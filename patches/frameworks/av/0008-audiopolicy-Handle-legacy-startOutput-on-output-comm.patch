From 3a727802be3e7b5911c55fbe6db6726e3074f6c9 Mon Sep 17 00:00:00 2001
From: Xuefer <xuefer@gmail.com>
Date: Tue, 29 Dec 2015 00:43:16 +0800
Subject: [PATCH 08/70] audiopolicy: Handle legacy startOutput on output
 command thread too

---
 .../audiopolicy/service/AudioPolicyService.cpp     | 29 +++++++
 .../service/AudioPolicyService.cpp.orig            | 91 +++++++++++++++++++++-
 services/audiopolicy/service/AudioPolicyService.h  | 14 ++++
 3 files changed, 133 insertions(+), 1 deletion(-)

diff --git a/services/audiopolicy/service/AudioPolicyService.cpp b/services/audiopolicy/service/AudioPolicyService.cpp
index 6e21215ab..c65609b4f 100644
--- a/services/audiopolicy/service/AudioPolicyService.cpp
+++ b/services/audiopolicy/service/AudioPolicyService.cpp
@@ -801,6 +801,19 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                             data->mVolume);
                     command->mStatus = AudioSystem::setVoiceVolume(data->mVolume);
                     }break;
+                case START_OUTPUT: {
+                    StartOutputData *data = (StartOutputData *)command->mParam.get();
+                    ALOGV("AudioCommandThread() processing start output %d",
+                            data->mIO);
+                    svc = mService.promote();
+                    if (svc == 0) {
+                        command->mStatus = UNKNOWN_ERROR;
+                        break;
+                    }
+                    mLock.unlock();
+                    command->mStatus = svc->doStartOutput(data->mIO, data->mStream, data->mSession);
+                    mLock.lock();
+                    }break;
                 case STOP_OUTPUT: {
                     StopOutputData *data = (StopOutputData *)command->mParam.get();
                     ALOGV("AudioCommandThread() processing stop output %d",
@@ -1069,6 +1082,22 @@ status_t AudioPolicyService::AudioCommandThread::voiceVolumeCommand(float volume
     return sendCommand(command, delayMs);
 }
 
+status_t AudioPolicyService::AudioCommandThread::startOutputCommand(audio_io_handle_t output,
+                                                                    audio_stream_type_t stream,
+                                                                    audio_session_t session)
+{
+    sp<AudioCommand> command = new AudioCommand();
+    command->mCommand = START_OUTPUT;
+    sp<StartOutputData> data = new StartOutputData();
+    data->mIO = output;
+    data->mStream = stream;
+    data->mSession = session;
+    command->mParam = data;
+    command->mWaitStatus = true;
+    ALOGV("AudioCommandThread() adding start output %d", output);
+    return sendCommand(command);
+}
+
 void AudioPolicyService::AudioCommandThread::stopOutputCommand(audio_io_handle_t output,
                                                                audio_stream_type_t stream,
                                                                audio_session_t session)
diff --git a/services/audiopolicy/service/AudioPolicyService.cpp.orig b/services/audiopolicy/service/AudioPolicyService.cpp.orig
index 6c54a5a29..6e21215ab 100644
--- a/services/audiopolicy/service/AudioPolicyService.cpp.orig
+++ b/services/audiopolicy/service/AudioPolicyService.cpp.orig
@@ -45,6 +45,11 @@
 
 #include <private/android_filesystem_config.h>
 
+#ifdef USE_LEGACY_AUDIO_POLICY
+#include <hardware/hardware.h>
+#include <hardware/audio_policy.h>
+#endif
+
 namespace android {
 
 static const char kDeadlockedString[] = "AudioPolicyService may be deadlocked\n";
@@ -57,6 +62,12 @@ static const nsecs_t kAudioCommandTimeoutNs = seconds(3); // 3 seconds
 
 static const String16 sManageAudioPolicyPermission("android.permission.MANAGE_AUDIO_POLICY");
 
+#ifdef USE_LEGACY_AUDIO_POLICY
+namespace {
+    extern struct audio_policy_service_ops aps_ops;
+};
+#endif
+
 // ----------------------------------------------------------------------------
 
 AudioPolicyService::AudioPolicyService()
@@ -77,8 +88,40 @@ void AudioPolicyService::onFirstRef()
         // start output activity command thread
         mOutputCommandThread = new AudioCommandThread(String8("ApmOutput"), this);
 
+#ifdef USE_LEGACY_AUDIO_POLICY
+        ALOGI("AudioPolicyService CSTOR in legacy mode");
+
+        /* instantiate the audio policy manager */
+        const struct hw_module_t *module;
+        int rc = hw_get_module(AUDIO_POLICY_HARDWARE_MODULE_ID, &module);
+        if (rc) {
+            return;
+        }
+        rc = audio_policy_dev_open(module, &mpAudioPolicyDev);
+        ALOGE_IF(rc, "couldn't open audio policy device (%s)", strerror(-rc));
+        if (rc) {
+            return;
+        }
+
+        rc = mpAudioPolicyDev->create_audio_policy(mpAudioPolicyDev, &aps_ops, this,
+                                                   &mpAudioPolicy);
+        ALOGE_IF(rc, "couldn't create audio policy (%s)", strerror(-rc));
+        if (rc) {
+            return;
+        }
+
+        rc = mpAudioPolicy->init_check(mpAudioPolicy);
+        ALOGE_IF(rc, "couldn't init_check the audio policy (%s)", strerror(-rc));
+        if (rc) {
+            return;
+        }
+        ALOGI("Loaded audio policy from %s (%s)", module->name, module->id);
+#else
+        ALOGI("AudioPolicyService CSTOR in new mode");
+
         mAudioPolicyClient = new AudioPolicyClient(this);
         mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);
+#endif
     }
     // load audio processing modules
     sp<AudioPolicyEffects>audioPolicyEffects = new AudioPolicyEffects(this);
@@ -97,8 +140,17 @@ AudioPolicyService::~AudioPolicyService()
     mAudioCommandThread->exit();
     mOutputCommandThread->exit();
 
+#ifdef USE_LEGACY_AUDIO_POLICY
+    if (mpAudioPolicy != NULL && mpAudioPolicyDev != NULL) {
+        mpAudioPolicyDev->destroy_audio_policy(mpAudioPolicyDev, mpAudioPolicy);
+    }
+    if (mpAudioPolicyDev != NULL) {
+        audio_policy_dev_close(mpAudioPolicyDev);
+    }
+#else
     destroyAudioPolicyManager(mAudioPolicyManager);
     delete mAudioPolicyClient;
+#endif
 
     mNotificationClients.clear();
     mAudioPolicyEffects.clear();
@@ -149,6 +201,7 @@ void AudioPolicyService::removeNotificationClient(uid_t uid)
         Mutex::Autolock _l(mNotificationClientsLock);
         mNotificationClients.removeItem(uid);
     }
+#ifndef USE_LEGACY_AUDIO_POLICY
     {
         Mutex::Autolock _l(mLock);
         if (mAudioPolicyManager) {
@@ -156,6 +209,7 @@ void AudioPolicyService::removeNotificationClient(uid_t uid)
             mAudioPolicyManager->releaseResourcesForUid(uid);
         }
     }
+#endif
 }
 
 void AudioPolicyService::onAudioPortListUpdate()
@@ -344,7 +398,11 @@ status_t AudioPolicyService::dumpInternals(int fd)
     char buffer[SIZE];
     String8 result;
 
+#ifdef USE_LEGACY_AUDIO_POLICY
+    snprintf(buffer, SIZE, "PolicyManager Interface: %p\n", mpAudioPolicy);
+#else
     snprintf(buffer, SIZE, "AudioPolicyManager: %p\n", mAudioPolicyManager);
+#endif
     result.append(buffer);
     snprintf(buffer, SIZE, "Command Thread: %p\n", mAudioCommandThread.get());
     result.append(buffer);
@@ -389,9 +447,15 @@ status_t AudioPolicyService::dump(int fd, const Vector<String16>& args __unused)
             mTonePlaybackThread->dump(fd);
         }
 
+#ifdef USE_LEGACY_AUDIO_POLICY
+        if (mpAudioPolicy) {
+            mpAudioPolicy->dump(mpAudioPolicy, fd);
+        }
+#else
         if (mAudioPolicyManager) {
             mAudioPolicyManager->dump(fd);
         }
+#endif
 
         if (locked) mLock.unlock();
     }
@@ -1464,4 +1528,29 @@ int aps_stop_tone(void *service);
 int aps_set_voice_volume(void *service, float volume, int delay_ms);
 };
 
-} // namespace android
+#ifdef USE_LEGACY_AUDIO_POLICY
+namespace {
+    struct audio_policy_service_ops aps_ops = {
+        .open_output           = aps_open_output,
+        .open_duplicate_output = aps_open_dup_output,
+        .close_output          = aps_close_output,
+        .suspend_output        = aps_suspend_output,
+        .restore_output        = aps_restore_output,
+        .open_input            = aps_open_input,
+        .close_input           = aps_close_input,
+        .set_stream_volume     = aps_set_stream_volume,
+        .invalidate_stream     = aps_invalidate_stream,
+        .set_parameters        = aps_set_parameters,
+        .get_parameters        = aps_get_parameters,
+        .start_tone            = aps_start_tone,
+        .stop_tone             = aps_stop_tone,
+        .set_voice_volume      = aps_set_voice_volume,
+        .move_effects          = aps_move_effects,
+        .load_hw_module        = aps_load_hw_module,
+        .open_output_on_module = aps_open_output_on_module,
+        .open_input_on_module  = aps_open_input_on_module,
+    };
+}; // namespace <unnamed>
+#endif
+
+}; // namespace android
diff --git a/services/audiopolicy/service/AudioPolicyService.h b/services/audiopolicy/service/AudioPolicyService.h
index 1ca43fd4e..349d1f5a6 100644
--- a/services/audiopolicy/service/AudioPolicyService.h
+++ b/services/audiopolicy/service/AudioPolicyService.h
@@ -222,6 +222,9 @@ public:
     virtual status_t listAudioSessions(audio_stream_type_t stream,
                                        Vector< sp<AudioSessionInfo>>& sessions);
 
+            status_t doStartOutput(audio_io_handle_t output,
+                                   audio_stream_type_t stream,
+                                   audio_session_t session);
             status_t doStopOutput(audio_io_handle_t output,
                                   audio_stream_type_t stream,
                                   audio_session_t session);
@@ -340,6 +343,7 @@ private:
             SET_VOLUME,
             SET_PARAMETERS,
             SET_VOICE_VOLUME,
+            START_OUTPUT,
             STOP_OUTPUT,
             RELEASE_OUTPUT,
             CREATE_AUDIO_PATCH,
@@ -370,6 +374,9 @@ private:
                     status_t    parametersCommand(audio_io_handle_t ioHandle,
                                             const char *keyValuePairs, int delayMs = 0);
                     status_t    voiceVolumeCommand(float volume, int delayMs = 0);
+                    status_t    startOutputCommand(audio_io_handle_t output,
+                                                   audio_stream_type_t stream,
+                                                   audio_session_t session);
                     void        stopOutputCommand(audio_io_handle_t output,
                                                   audio_stream_type_t stream,
                                                   audio_session_t session);
@@ -449,6 +456,13 @@ private:
             float mVolume;
         };
 
+        class StartOutputData : public AudioCommandData {
+        public:
+            audio_io_handle_t mIO;
+            audio_stream_type_t mStream;
+            audio_session_t mSession;
+        };
+
         class StopOutputData : public AudioCommandData {
         public:
             audio_io_handle_t mIO;
-- 
2.11.0

