From bcd1825b502498605b59fb6c4a847f0830241a68 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 17 Sep 2018 16:46:06 +0300
Subject: [PATCH 37/49] gui, sf: use dummy captureScreen / captureLayers

our mali blobs don't play nice with new changes to captureScreen / captureLayers

Change-Id: I573626f8be16fcee5f9c6fa08001a5cc50f41463
---
 libs/gui/ISurfaceComposer.cpp              | 15 +++++++++++++++
 services/surfaceflinger/SurfaceFlinger.cpp | 24 ++++++++++++++++--------
 2 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index e22bc708c..4224873d7 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -87,6 +87,7 @@ public:
         }
 
         data.writeUint32(static_cast<uint32_t>(displays.size()));
+
         for (const auto& d : displays) {
             d.write(data);
         }
@@ -548,6 +549,14 @@ IMPLEMENT_META_INTERFACE(SurfaceComposer, "android.ui.ISurfaceComposer");
 status_t BnSurfaceComposer::onTransact(
     uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
 {
+    ALOGE("%s: code = %d", __func__, code);
+    if (code == CAPTURE_LAYERS || code == CAPTURE_SCREEN) {
+       if (code == CAPTURE_LAYERS)
+           ALOGE("%s: CAPTURE_LAYERS, %d", __func__, CAPTURE_LAYERS);
+       if (code == CAPTURE_SCREEN)
+           ALOGE("%s: CAPTURE_SCREEN, %d", __func__, CAPTURE_SCREEN);
+       return  BAD_VALUE;
+    }
     switch(code) {
         case CREATE_CONNECTION: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
@@ -570,6 +579,7 @@ status_t BnSurfaceComposer::onTransact(
             if (count > data.dataSize()) {
                 return BAD_VALUE;
             }
+
             ComposerState s;
             Vector<ComposerState> state;
             state.setCapacity(count);
@@ -595,6 +605,7 @@ status_t BnSurfaceComposer::onTransact(
             }
 
             uint32_t stateFlags = data.readUint32();
+
             setTransactionState(state, displays, stateFlags);
             return NO_ERROR;
         }
@@ -604,6 +615,8 @@ status_t BnSurfaceComposer::onTransact(
             return NO_ERROR;
         }
         case CAPTURE_SCREEN: {
+            ALOGE("%s: CAPTURE_SCREEN: not supported!", __func__);
+            return NO_ERROR;
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
             sp<GraphicBuffer> outBuffer;
@@ -626,6 +639,8 @@ status_t BnSurfaceComposer::onTransact(
             return NO_ERROR;
         }
         case CAPTURE_LAYERS: {
+            ALOGE("%s: CAPTURE_LAYERS: not supported!", __func__);
+            return NO_ERROR;
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> layerHandleBinder = data.readStrongBinder();
             sp<GraphicBuffer> outBuffer;
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 87baf8c8a..3f41b11e4 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -4705,11 +4705,12 @@ private:
     const int mApi;
 };
 
-status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display, sp<GraphicBuffer>* outBuffer,
-                                       Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
-                                       int32_t minLayerZ, int32_t maxLayerZ,
-                                       bool useIdentityTransform,
-                                       ISurfaceComposer::Rotation rotation) {
+status_t SurfaceFlinger::captureScreen(const sp<IBinder>& /*display*/, sp<GraphicBuffer>* /*outBuffer*/,
+                                       Rect /*sourceCrop*/, uint32_t /*reqWidth*/, uint32_t /*reqHeight*/,
+                                       int32_t /*minLayerZ*/, int32_t /*maxLayerZ*/,
+                                       bool /*useIdentityTransform*/,
+                                       ISurfaceComposer::Rotation /*rotation*/) {
+#if 0
     ATRACE_CALL();
 
     if (CC_UNLIKELY(display == 0)) return BAD_VALUE;
@@ -4722,11 +4723,14 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display, sp<GraphicBuf
     auto traverseLayers = std::bind(std::mem_fn(&SurfaceFlinger::traverseLayersInDisplay), this,
                                     device, minLayerZ, maxLayerZ, std::placeholders::_1);
     return captureScreenCommon(renderArea, traverseLayers, outBuffer, useIdentityTransform);
+#endif
+    return NO_ERROR;
 }
 
-status_t SurfaceFlinger::captureLayers(const sp<IBinder>& layerHandleBinder,
-                                       sp<GraphicBuffer>* outBuffer, const Rect& sourceCrop,
-                                       float frameScale, bool childrenOnly) {
+status_t SurfaceFlinger::captureLayers(const sp<IBinder>& /*layerHandleBinder*/,
+                                       sp<GraphicBuffer>* /*outBuffer*/, const Rect& /*sourceCrop*/,
+                                       float /*frameScale*/, bool /*childrenOnly*/) {
+#if 0
     ATRACE_CALL();
 
     class LayerRenderArea : public RenderArea {
@@ -4836,8 +4840,11 @@ status_t SurfaceFlinger::captureLayers(const sp<IBinder>& layerHandleBinder,
         });
     };
     return captureScreenCommon(renderArea, traverseLayers, outBuffer, false);
+#endif
+    return NO_ERROR;
 }
 
+#if 0
 status_t SurfaceFlinger::captureScreenCommon(RenderArea& renderArea,
                                              TraverseLayersFunction traverseLayers,
                                              sp<GraphicBuffer>* outBuffer,
@@ -4912,6 +4919,7 @@ status_t SurfaceFlinger::captureScreenCommon(RenderArea& renderArea,
 
     return result;
 }
+#endif
 
 void SurfaceFlinger::renderScreenImplLocked(const RenderArea& renderArea,
                                             TraverseLayersFunction traverseLayers, bool yswap,
-- 
2.11.0

