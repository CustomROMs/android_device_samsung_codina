From 434c874df87e992310b9412446efdfdd7bd1a46d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sun, 2 Sep 2018 11:49:15 +0300
Subject: [PATCH 19/45] opengl: reset to lineage-15.1

Change-Id: I882e0733bc7f6f101a2ebefaec9caedecb989c31
---
 opengl/include/EGL/eglext.h                   |    2 +
 opengl/include/GLES/gl.h                      |    1 -
 opengl/include/GLES/glext.h                   |    3 +
 opengl/libagl/Android.mk                      |    2 -
 opengl/libagl/array.cpp                       |    4 +-
 opengl/libagl/egl.cpp                         |   35 +-
 opengl/libagl/light.cpp                       |    1 +
 opengl/libagl/matrix.cpp                      |   11 +
 opengl/libagl/primitives.cpp                  |    1 -
 opengl/libagl/texture.cpp                     |    6 +
 opengl/libs/Android.bp                        |   11 +-
 opengl/libs/EGL/Loader.cpp                    |   11 +-
 opengl/libs/EGL/eglApi.cpp                    |   20 +-
 opengl/libs/EGL/egl_display.cpp               |    4 -
 opengl/libs/EGL/egl_entries.in                |    2 +
 .../EGL_ANDROID_get_native_client_buffer.txt  |   15 +-
 opengl/specs/README                           |    3 +-
 opengl/tests/Android.bp                       |   19 -
 opengl/tests/Android.mk                       |   28 -
 opengl/tests/EGLTest/Android.bp               |   36 -
 opengl/tests/EGLTest/EGL_test.cpp             |  541 ------
 opengl/tests/EGLTest/egl_cache_test.cpp       |  111 --
 opengl/tests/angeles/Android.bp               |   27 -
 .../tests/angeles/MODULE_LICENSE_BSD_OR_LGPL  |    0
 opengl/tests/angeles/README.txt               |   77 -
 opengl/tests/angeles/app-linux.cpp            |  229 ---
 opengl/tests/angeles/app.h                    |   56 -
 opengl/tests/angeles/cams.h                   |   65 -
 opengl/tests/angeles/demo.c                   |  792 ---------
 opengl/tests/angeles/include/GLES/egl.h       |  229 ---
 opengl/tests/angeles/include/GLES/egltypes.h  |   20 -
 opengl/tests/angeles/include/GLES/gl.h        |  584 ------
 opengl/tests/angeles/license-BSD.txt          |   34 -
 opengl/tests/angeles/license-LGPL.txt         |  504 ------
 opengl/tests/angeles/license.txt              |   19 -
 opengl/tests/angeles/shapes.h                 |   59 -
 opengl/tests/configdump/Android.bp            |   18 -
 opengl/tests/configdump/configdump.cpp        |   91 -
 opengl/tests/fillrate/Android.bp              |   23 -
 opengl/tests/fillrate/fillrate.cpp            |  164 --
 opengl/tests/filter/Android.bp                |   25 -
 opengl/tests/filter/filter.cpp                |  196 ---
 opengl/tests/finish/Android.bp                |   25 -
 opengl/tests/finish/finish.cpp                |  226 ---
 opengl/tests/gl2_basic/Android.bp             |   25 -
 opengl/tests/gl2_basic/gl2_basic.cpp          |  364 ----
 opengl/tests/gl2_cameraeye/Android.mk         |   16 -
 .../tests/gl2_cameraeye/AndroidManifest.xml   |   36 -
 .../gl2_cameraeye/res/values/strings.xml      |   21 -
 .../android/gl2cameraeye/GL2CameraEye.java    |  508 ------
 opengl/tests/gl2_copyTexImage/Android.bp      |   24 -
 .../gl2_copyTexImage/gl2_copyTexImage.cpp     |  467 -----
 opengl/tests/gl2_java/Android.mk              |   19 -
 opengl/tests/gl2_java/AndroidManifest.xml     |   32 -
 opengl/tests/gl2_java/res/values/strings.xml  |   25 -
 .../com/android/gl2java/GL2JavaActivity.java  |   46 -
 .../src/com/android/gl2java/GL2JavaView.java  |  170 --
 opengl/tests/gl2_jni/Android.mk               |   49 -
 opengl/tests/gl2_jni/AndroidManifest.xml      |   31 -
 opengl/tests/gl2_jni/jni/gl_code.cpp          |  170 --
 opengl/tests/gl2_jni/res/values/strings.xml   |   25 -
 .../com/android/gl2jni/GL2JNIActivity.java    |   46 -
 .../src/com/android/gl2jni/GL2JNILib.java     |   33 -
 .../src/com/android/gl2jni/GL2JNIView.java    |  296 ----
 opengl/tests/gl2_yuvtex/Android.bp            |   26 -
 opengl/tests/gl2_yuvtex/gl2_yuvtex.cpp        |  427 -----
 opengl/tests/gl_basic/Android.bp              |   23 -
 opengl/tests/gl_basic/gl_basic.cpp            |  358 ----
 opengl/tests/gl_jni/Android.mk                |   52 -
 opengl/tests/gl_jni/AndroidManifest.xml       |   34 -
 opengl/tests/gl_jni/jni/gl_code.cpp           |  188 --
 opengl/tests/gl_jni/res/values/strings.xml    |   25 -
 .../src/com/android/gljni/GLJNIActivity.java  |   45 -
 .../src/com/android/gljni/GLJNILib.java       |   34 -
 .../src/com/android/gljni/GLJNIView.java      |   90 -
 opengl/tests/gl_perf/Android.bp               |   28 -
 opengl/tests/gl_perf/fill_common.cpp          |  298 ----
 opengl/tests/gl_perf/filltest.cpp             |   50 -
 opengl/tests/gl_perf/fragment_shaders.cpp     |  139 --
 opengl/tests/gl_perf/gl2_perf.cpp             |  129 --
 opengl/tests/gl_perfapp/Android.mk            |   52 -
 opengl/tests/gl_perfapp/AndroidManifest.xml   |   34 -
 opengl/tests/gl_perfapp/jni/gl_code.cpp       |  106 --
 .../tests/gl_perfapp/res/values/strings.xml   |   25 -
 .../com/android/glperf/GLPerfActivity.java    |   47 -
 .../src/com/android/glperf/GLPerfLib.java     |   33 -
 .../src/com/android/glperf/GLPerfView.java    |  296 ----
 opengl/tests/gl_yuvtex/Android.bp             |   25 -
 opengl/tests/gl_yuvtex/gl_yuvtex.cpp          |  333 ----
 opengl/tests/gldual/Android.mk                |   49 -
 opengl/tests/gldual/AndroidManifest.xml       |   31 -
 opengl/tests/gldual/jni/gl_code.cpp           |  170 --
 .../gldual/res/layout/gldual_activity.xml     |   30 -
 opengl/tests/gldual/res/values/strings.xml    |   25 -
 .../com/android/gldual/GLDualActivity.java    |   53 -
 .../src/com/android/gldual/GLDualGL2View.java |  299 ----
 .../src/com/android/gldual/GLDualLib.java     |   33 -
 .../com/android/gldual/TriangleRenderer.java  |  165 --
 opengl/tests/gralloc/Android.bp               |   18 -
 opengl/tests/gralloc/gralloc.cpp              |  110 --
 opengl/tests/hwc/Android.bp                   |  109 --
 opengl/tests/hwc/hwcColorEquiv.cpp            |  436 -----
 opengl/tests/hwc/hwcCommit.cpp                | 1558 -----------------
 opengl/tests/hwc/hwcRects.cpp                 |  575 ------
 opengl/tests/hwc/hwcStress.cpp                |  646 -------
 opengl/tests/hwc/hwcTestLib.cpp               | 1015 -----------
 opengl/tests/hwc/hwcTestLib.h                 |  131 --
 opengl/tests/lib/Android.bp                   |   38 -
 opengl/tests/lib/WindowSurface.cpp            |   86 -
 opengl/tests/lib/glTestLib.cpp                |  118 --
 opengl/tests/lib/include/EGLUtils.h           |  310 ----
 opengl/tests/lib/include/WindowSurface.h      |   49 -
 opengl/tests/lib/include/glTestLib.h          |   32 -
 opengl/tests/lighting1709/Android.mk          |   12 -
 opengl/tests/lighting1709/AndroidManifest.xml |   13 -
 .../android/lightingtest/ClearActivity.java   |  174 --
 opengl/tests/linetex/Android.mk               |   25 -
 opengl/tests/linetex/linetex.cpp              |  117 --
 opengl/tests/swapinterval/Android.mk          |   25 -
 opengl/tests/swapinterval/swapinterval.cpp    |  126 --
 opengl/tests/testFramerate/Android.mk         |   20 -
 .../tests/testFramerate/AndroidManifest.xml   |   33 -
 .../testFramerate/res/values/strings.xml      |   25 -
 .../testframerate/TestFramerateActivity.java  |   47 -
 .../testframerate/TestFramerateView.java      |   91 -
 opengl/tests/testLatency/Android.mk           |   20 -
 opengl/tests/testLatency/AndroidManifest.xml  |   33 -
 .../tests/testLatency/res/values/strings.xml  |   25 -
 .../testlatency/TestLatencyActivity.java      |   47 -
 .../android/testlatency/TestLatencyView.java  |  267 ---
 opengl/tests/testPauseResume/Android.mk       |   19 -
 .../tests/testPauseResume/AndroidManifest.xml |   34 -
 opengl/tests/testPauseResume/README           |   37 -
 .../testPauseResume/res/values/strings.xml    |   25 -
 .../src/com/android/test/TestActivity.java    |   64 -
 .../src/com/android/test/TestView.java        |   84 -
 opengl/tests/testViewport/Android.mk          |   22 -
 opengl/tests/testViewport/AndroidManifest.xml |   33 -
 opengl/tests/testViewport/README              |   28 -
 .../tests/testViewport/res/values/strings.xml |   25 -
 .../src/com/android/test/TestActivity.java    |   46 -
 .../src/com/android/test/TestView.java        |  262 ---
 opengl/tests/textures/Android.mk              |   26 -
 opengl/tests/textures/textures.cpp            |  115 --
 opengl/tests/tritex/Android.mk                |   25 -
 opengl/tests/tritex/tritex.cpp                |  274 ---
 opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp |    3 +-
 .../tools/glgen/stubs/egl/EGLExtcHeader.cpp   |    3 +-
 .../glgen/stubs/gles11/GLES10ExtcHeader.cpp   |    1 +
 .../glgen/stubs/gles11/GLES10cHeader.cpp      |    1 +
 .../glgen/stubs/gles11/GLES11ExtcHeader.cpp   |    1 +
 .../glgen/stubs/gles11/GLES11cHeader.cpp      |    1 +
 .../glgen/stubs/gles11/GLES20cHeader.cpp      |    1 +
 .../glgen/stubs/gles11/GLES30cHeader.cpp      |    1 +
 .../glgen/stubs/gles11/GLES31ExtcHeader.cpp   |    1 +
 .../glgen/stubs/gles11/GLES31cHeader.cpp      |    1 +
 .../glgen/stubs/gles11/GLES32cHeader.cpp      |    3 +-
 opengl/tools/glgen/stubs/gles11/common.cpp    |    2 +-
 opengl/tools/glgen/stubs/jsr239/GLCHeader.cpp |    3 +-
 159 files changed, 92 insertions(+), 17865 deletions(-)
 delete mode 100644 opengl/tests/Android.bp
 delete mode 100644 opengl/tests/Android.mk
 delete mode 100644 opengl/tests/EGLTest/Android.bp
 delete mode 100644 opengl/tests/EGLTest/EGL_test.cpp
 delete mode 100644 opengl/tests/EGLTest/egl_cache_test.cpp
 delete mode 100644 opengl/tests/angeles/Android.bp
 delete mode 100644 opengl/tests/angeles/MODULE_LICENSE_BSD_OR_LGPL
 delete mode 100644 opengl/tests/angeles/README.txt
 delete mode 100644 opengl/tests/angeles/app-linux.cpp
 delete mode 100644 opengl/tests/angeles/app.h
 delete mode 100644 opengl/tests/angeles/cams.h
 delete mode 100644 opengl/tests/angeles/demo.c
 delete mode 100644 opengl/tests/angeles/include/GLES/egl.h
 delete mode 100644 opengl/tests/angeles/include/GLES/egltypes.h
 delete mode 100644 opengl/tests/angeles/include/GLES/gl.h
 delete mode 100644 opengl/tests/angeles/license-BSD.txt
 delete mode 100644 opengl/tests/angeles/license-LGPL.txt
 delete mode 100644 opengl/tests/angeles/license.txt
 delete mode 100644 opengl/tests/angeles/shapes.h
 delete mode 100644 opengl/tests/configdump/Android.bp
 delete mode 100644 opengl/tests/configdump/configdump.cpp
 delete mode 100644 opengl/tests/fillrate/Android.bp
 delete mode 100644 opengl/tests/fillrate/fillrate.cpp
 delete mode 100644 opengl/tests/filter/Android.bp
 delete mode 100644 opengl/tests/filter/filter.cpp
 delete mode 100644 opengl/tests/finish/Android.bp
 delete mode 100644 opengl/tests/finish/finish.cpp
 delete mode 100644 opengl/tests/gl2_basic/Android.bp
 delete mode 100644 opengl/tests/gl2_basic/gl2_basic.cpp
 delete mode 100644 opengl/tests/gl2_cameraeye/Android.mk
 delete mode 100644 opengl/tests/gl2_cameraeye/AndroidManifest.xml
 delete mode 100644 opengl/tests/gl2_cameraeye/res/values/strings.xml
 delete mode 100644 opengl/tests/gl2_cameraeye/src/com/android/gl2cameraeye/GL2CameraEye.java
 delete mode 100644 opengl/tests/gl2_copyTexImage/Android.bp
 delete mode 100644 opengl/tests/gl2_copyTexImage/gl2_copyTexImage.cpp
 delete mode 100644 opengl/tests/gl2_java/Android.mk
 delete mode 100644 opengl/tests/gl2_java/AndroidManifest.xml
 delete mode 100644 opengl/tests/gl2_java/res/values/strings.xml
 delete mode 100644 opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaActivity.java
 delete mode 100644 opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaView.java
 delete mode 100644 opengl/tests/gl2_jni/Android.mk
 delete mode 100644 opengl/tests/gl2_jni/AndroidManifest.xml
 delete mode 100644 opengl/tests/gl2_jni/jni/gl_code.cpp
 delete mode 100644 opengl/tests/gl2_jni/res/values/strings.xml
 delete mode 100644 opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIActivity.java
 delete mode 100644 opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNILib.java
 delete mode 100644 opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIView.java
 delete mode 100644 opengl/tests/gl2_yuvtex/Android.bp
 delete mode 100644 opengl/tests/gl2_yuvtex/gl2_yuvtex.cpp
 delete mode 100644 opengl/tests/gl_basic/Android.bp
 delete mode 100644 opengl/tests/gl_basic/gl_basic.cpp
 delete mode 100644 opengl/tests/gl_jni/Android.mk
 delete mode 100644 opengl/tests/gl_jni/AndroidManifest.xml
 delete mode 100644 opengl/tests/gl_jni/jni/gl_code.cpp
 delete mode 100644 opengl/tests/gl_jni/res/values/strings.xml
 delete mode 100644 opengl/tests/gl_jni/src/com/android/gljni/GLJNIActivity.java
 delete mode 100644 opengl/tests/gl_jni/src/com/android/gljni/GLJNILib.java
 delete mode 100644 opengl/tests/gl_jni/src/com/android/gljni/GLJNIView.java
 delete mode 100644 opengl/tests/gl_perf/Android.bp
 delete mode 100644 opengl/tests/gl_perf/fill_common.cpp
 delete mode 100644 opengl/tests/gl_perf/filltest.cpp
 delete mode 100644 opengl/tests/gl_perf/fragment_shaders.cpp
 delete mode 100644 opengl/tests/gl_perf/gl2_perf.cpp
 delete mode 100644 opengl/tests/gl_perfapp/Android.mk
 delete mode 100644 opengl/tests/gl_perfapp/AndroidManifest.xml
 delete mode 100644 opengl/tests/gl_perfapp/jni/gl_code.cpp
 delete mode 100644 opengl/tests/gl_perfapp/res/values/strings.xml
 delete mode 100644 opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfActivity.java
 delete mode 100644 opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfLib.java
 delete mode 100644 opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfView.java
 delete mode 100644 opengl/tests/gl_yuvtex/Android.bp
 delete mode 100644 opengl/tests/gl_yuvtex/gl_yuvtex.cpp
 delete mode 100644 opengl/tests/gldual/Android.mk
 delete mode 100644 opengl/tests/gldual/AndroidManifest.xml
 delete mode 100644 opengl/tests/gldual/jni/gl_code.cpp
 delete mode 100644 opengl/tests/gldual/res/layout/gldual_activity.xml
 delete mode 100644 opengl/tests/gldual/res/values/strings.xml
 delete mode 100644 opengl/tests/gldual/src/com/android/gldual/GLDualActivity.java
 delete mode 100644 opengl/tests/gldual/src/com/android/gldual/GLDualGL2View.java
 delete mode 100644 opengl/tests/gldual/src/com/android/gldual/GLDualLib.java
 delete mode 100644 opengl/tests/gldual/src/com/android/gldual/TriangleRenderer.java
 delete mode 100644 opengl/tests/gralloc/Android.bp
 delete mode 100644 opengl/tests/gralloc/gralloc.cpp
 delete mode 100644 opengl/tests/hwc/Android.bp
 delete mode 100644 opengl/tests/hwc/hwcColorEquiv.cpp
 delete mode 100644 opengl/tests/hwc/hwcCommit.cpp
 delete mode 100644 opengl/tests/hwc/hwcRects.cpp
 delete mode 100644 opengl/tests/hwc/hwcStress.cpp
 delete mode 100644 opengl/tests/hwc/hwcTestLib.cpp
 delete mode 100644 opengl/tests/hwc/hwcTestLib.h
 delete mode 100644 opengl/tests/lib/Android.bp
 delete mode 100644 opengl/tests/lib/WindowSurface.cpp
 delete mode 100644 opengl/tests/lib/glTestLib.cpp
 delete mode 100644 opengl/tests/lib/include/EGLUtils.h
 delete mode 100644 opengl/tests/lib/include/WindowSurface.h
 delete mode 100644 opengl/tests/lib/include/glTestLib.h
 delete mode 100644 opengl/tests/lighting1709/Android.mk
 delete mode 100644 opengl/tests/lighting1709/AndroidManifest.xml
 delete mode 100644 opengl/tests/lighting1709/src/com/android/lightingtest/ClearActivity.java
 delete mode 100644 opengl/tests/linetex/Android.mk
 delete mode 100644 opengl/tests/linetex/linetex.cpp
 delete mode 100644 opengl/tests/swapinterval/Android.mk
 delete mode 100644 opengl/tests/swapinterval/swapinterval.cpp
 delete mode 100644 opengl/tests/testFramerate/Android.mk
 delete mode 100644 opengl/tests/testFramerate/AndroidManifest.xml
 delete mode 100644 opengl/tests/testFramerate/res/values/strings.xml
 delete mode 100644 opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateActivity.java
 delete mode 100644 opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateView.java
 delete mode 100644 opengl/tests/testLatency/Android.mk
 delete mode 100644 opengl/tests/testLatency/AndroidManifest.xml
 delete mode 100644 opengl/tests/testLatency/res/values/strings.xml
 delete mode 100644 opengl/tests/testLatency/src/com/android/testlatency/TestLatencyActivity.java
 delete mode 100644 opengl/tests/testLatency/src/com/android/testlatency/TestLatencyView.java
 delete mode 100644 opengl/tests/testPauseResume/Android.mk
 delete mode 100644 opengl/tests/testPauseResume/AndroidManifest.xml
 delete mode 100644 opengl/tests/testPauseResume/README
 delete mode 100644 opengl/tests/testPauseResume/res/values/strings.xml
 delete mode 100644 opengl/tests/testPauseResume/src/com/android/test/TestActivity.java
 delete mode 100644 opengl/tests/testPauseResume/src/com/android/test/TestView.java
 delete mode 100644 opengl/tests/testViewport/Android.mk
 delete mode 100644 opengl/tests/testViewport/AndroidManifest.xml
 delete mode 100644 opengl/tests/testViewport/README
 delete mode 100644 opengl/tests/testViewport/res/values/strings.xml
 delete mode 100644 opengl/tests/testViewport/src/com/android/test/TestActivity.java
 delete mode 100644 opengl/tests/testViewport/src/com/android/test/TestView.java
 delete mode 100644 opengl/tests/textures/Android.mk
 delete mode 100644 opengl/tests/textures/textures.cpp
 delete mode 100644 opengl/tests/tritex/Android.mk
 delete mode 100644 opengl/tests/tritex/tritex.cpp

diff --git a/opengl/include/EGL/eglext.h b/opengl/include/EGL/eglext.h
index 466768ae2c..fd7b0cf738 100644
--- a/opengl/include/EGL/eglext.h
+++ b/opengl/include/EGL/eglext.h
@@ -1266,6 +1266,7 @@ EGLAPI EGLBoolean EGLAPIENTRY eglGetSyncAttribNV (EGLSyncNV sync, EGLint attribu
 #endif /* KHRONOS_SUPPORT_INT64 */
 #endif /* EGL_NV_sync */
 
+#ifndef STE_HARDWARE
 #ifndef EGL_NV_system_time
 #define EGL_NV_system_time 1
 typedef khronos_utime_nanoseconds_t EGLuint64NV;
@@ -1278,6 +1279,7 @@ EGLAPI EGLuint64NV EGLAPIENTRY eglGetSystemTimeNV (void);
 #endif
 #endif /* KHRONOS_SUPPORT_INT64 */
 #endif /* EGL_NV_system_time */
+#endif
 
 #ifndef EGL_TIZEN_image_native_buffer
 #define EGL_TIZEN_image_native_buffer 1
diff --git a/opengl/include/GLES/gl.h b/opengl/include/GLES/gl.h
index 25033f2a39..36acff937f 100644
--- a/opengl/include/GLES/gl.h
+++ b/opengl/include/GLES/gl.h
@@ -51,7 +51,6 @@ extern "C" {
 #ifndef GL_VERSION_ES_CM_1_0
 #define GL_VERSION_ES_CM_1_0 1
 typedef void GLvoid;
-typedef char GLchar;
 typedef unsigned int GLenum;
 #include <KHR/khrplatform.h>
 typedef khronos_float_t GLfloat;
diff --git a/opengl/include/GLES/glext.h b/opengl/include/GLES/glext.h
index 1a150e34e8..b6fe620827 100644
--- a/opengl/include/GLES/glext.h
+++ b/opengl/include/GLES/glext.h
@@ -104,6 +104,7 @@ GL_API void GL_APIENTRY glBlendEquationOES (GLenum mode);
 
 #ifndef GL_OES_byte_coordinates
 #define GL_OES_byte_coordinates 1
+typedef khronos_int8_t GLbyte;
 #endif /* GL_OES_byte_coordinates */
 
 #ifndef GL_OES_compressed_ETC1_RGB8_sub_texture
@@ -127,6 +128,7 @@ GL_API void GL_APIENTRY glBlendEquationOES (GLenum mode);
 
 #ifndef GL_OES_draw_texture
 #define GL_OES_draw_texture 1
+typedef short GLshort;
 #define GL_TEXTURE_CROP_RECT_OES          0x8B9D
 typedef void (GL_APIENTRYP PFNGLDRAWTEXSOESPROC) (GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);
 typedef void (GL_APIENTRYP PFNGLDRAWTEXIOESPROC) (GLint x, GLint y, GLint z, GLint width, GLint height);
@@ -407,6 +409,7 @@ GL_API GLbitfield GL_APIENTRY glQueryMatrixxOES (GLfixed *mantissa, GLint *expon
 
 #ifndef GL_OES_single_precision
 #define GL_OES_single_precision 1
+typedef khronos_float_t GLclampf;
 typedef void (GL_APIENTRYP PFNGLCLEARDEPTHFOESPROC) (GLclampf depth);
 typedef void (GL_APIENTRYP PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat *equation);
 typedef void (GL_APIENTRYP PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
diff --git a/opengl/libagl/Android.mk b/opengl/libagl/Android.mk
index 15a12e458d..c7635e27c7 100644
--- a/opengl/libagl/Android.mk
+++ b/opengl/libagl/Android.mk
@@ -38,8 +38,6 @@ LOCAL_CFLAGS_mips += -fstrict-aliasing
 # The graphics code can generate division by zero
 LOCAL_CFLAGS_mips += -mno-check-zero-division
 
-LOCAL_CFLAGS += -Wall -Werror
-
 # we need to access the private Bionic header <bionic_tls.h>
 LOCAL_C_INCLUDES += bionic/libc/private
 
diff --git a/opengl/libagl/array.cpp b/opengl/libagl/array.cpp
index 2d36c6194e..54207fa212 100644
--- a/opengl/libagl/array.cpp
+++ b/opengl/libagl/array.cpp
@@ -136,6 +136,9 @@ void ogles_uninit_array(ogles_context_t* c)
 static void currentColor(ogles_context_t* c, GLfixed* v, const GLvoid*) {
     memcpy(v, c->current.color.v, sizeof(vec4_t));
 }
+static void currentColor_clamp(ogles_context_t* c, GLfixed* v, const GLvoid*) {
+    memcpy(v, c->currentColorClamped.v, sizeof(vec4_t));
+}
 static void currentNormal(ogles_context_t* c, GLfixed* v, const GLvoid*) {
     memcpy(v, c->currentNormal.v, sizeof(vec3_t));
 }
@@ -346,7 +349,6 @@ void vertex_cache_t::init()
 {
     // make sure the size of vertex_t allows cache-line alignment
     CTA<(sizeof(vertex_t) & 0x1F) == 0> assertAlignedSize;
-    (void)assertAlignedSize; // suppress unused warning.
 
     const int align = 32;
     const size_t s = VERTEX_BUFFER_SIZE + VERTEX_CACHE_SIZE;
diff --git a/opengl/libagl/egl.cpp b/opengl/libagl/egl.cpp
index be437054ce..99c0bcf5a9 100644
--- a/opengl/libagl/egl.cpp
+++ b/opengl/libagl/egl.cpp
@@ -81,9 +81,7 @@ namespace android {
 
 const unsigned int NUM_DISPLAYS = 1;
 
-#ifndef __ANDROID__
 static pthread_mutex_t gInitMutex = PTHREAD_MUTEX_INITIALIZER;
-#endif
 static pthread_mutex_t gErrorKeyMutex = PTHREAD_MUTEX_INITIALIZER;
 static pthread_key_t gEGLErrorKey = -1;
 #ifndef __ANDROID__
@@ -1716,11 +1714,41 @@ EGLBoolean eglQuerySurface( EGLDisplay dpy, EGLSurface eglSurface,
 }
 
 EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
-                            EGLContext /*share_list*/, const EGLint* /*attrib_list*/)
+                            EGLContext /*share_list*/, const EGLint* attrib_list)
 {
     if (egl_display_t::is_valid(dpy) == EGL_FALSE)
         return setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);
 
+    EGLint renderType = 0;
+    if (getConfigAttrib(dpy, config, EGL_RENDERABLE_TYPE, &renderType) == EGL_FALSE) {
+        return setError(EGL_BAD_CONFIG, EGL_NO_SURFACE);
+    }
+
+    EGLint major = 1;
+    if (attrib_list != NULL) {
+        for (EGLint i=0; attrib_list[i]!= EGL_NONE; i+=2) {
+            if (attrib_list[i] == EGL_CONTEXT_CLIENT_VERSION) {
+                major = attrib_list[i+1];
+                break;
+            }
+        }
+    }
+
+    switch (major) {
+        case 1:
+            if (!(renderType & EGL_OPENGL_ES_BIT)) {
+                return setError(EGL_BAD_MATCH, EGL_NO_SURFACE);
+            }
+            break;
+        case 2:
+            if (!(renderType & EGL_OPENGL_ES2_BIT)) {
+                return setError(EGL_BAD_MATCH, EGL_NO_SURFACE);
+            }
+            break;
+        default:
+            return setError(EGL_BAD_MATCH, EGL_NO_SURFACE);
+    }
+
     ogles_context_t* gl = ogles_init(sizeof(egl_context_t));
     if (!gl) return setError(EGL_BAD_ALLOC, EGL_NO_CONTEXT);
 
@@ -1778,6 +1806,7 @@ EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
         // if we're detaching, we need the current context
         current_ctx = (EGLContext)getGlThreadSpecific();
     } else {
+        egl_context_t* c = egl_context_t::context(ctx);
         egl_surface_t* d = (egl_surface_t*)draw;
         egl_surface_t* r = (egl_surface_t*)read;
         if ((d && d->ctx && d->ctx != ctx) ||
diff --git a/opengl/libagl/light.cpp b/opengl/libagl/light.cpp
index 216c725128..e7fe9d71a3 100644
--- a/opengl/libagl/light.cpp
+++ b/opengl/libagl/light.cpp
@@ -467,6 +467,7 @@ static void lightx(GLenum i, GLenum pname, GLfixed param, ogles_context_t* c)
     }
 
     light_t& light = c->lighting.lights[i-GL_LIGHT0];
+    const GLfixed kDegToRad = GLfixed((M_PI * gglIntToFixed(1)) / 180.0f);
     switch (pname) {
     case GL_SPOT_EXPONENT:
         if (GGLfixed(param) >= gglIntToFixed(128)) {
diff --git a/opengl/libagl/matrix.cpp b/opengl/libagl/matrix.cpp
index edd474d30c..034c857fa7 100644
--- a/opengl/libagl/matrix.cpp
+++ b/opengl/libagl/matrix.cpp
@@ -51,6 +51,7 @@ static const matrixx_t gIdentityx = {
 static void point2__nop(transform_t const*, vec4_t* c, vec4_t const* o);
 static void point3__nop(transform_t const*, vec4_t* c, vec4_t const* o);
 static void point4__nop(transform_t const*, vec4_t* c, vec4_t const* o);
+static void normal__nop(transform_t const*, vec4_t* c, vec4_t const* o);
 static void point2__generic(transform_t const*, vec4_t* c, vec4_t const* o);
 static void point3__generic(transform_t const*, vec4_t* c, vec4_t const* o);
 static void point4__generic(transform_t const*, vec4_t* c, vec4_t const* o);
@@ -523,6 +524,16 @@ void transform_state_t::update_mvp()
     }
 }
 
+static inline 
+GLfloat det22(GLfloat a, GLfloat b, GLfloat c, GLfloat d) {
+    return a*d - b*c;
+}
+
+static inline
+GLfloat ndet22(GLfloat a, GLfloat b, GLfloat c, GLfloat d) {
+    return b*c - a*d;
+}
+
 static __attribute__((noinline))
 void invert(GLfloat* inverse, const GLfloat* src)
 {
diff --git a/opengl/libagl/primitives.cpp b/opengl/libagl/primitives.cpp
index d3b19e8e6d..57a798deb3 100644
--- a/opengl/libagl/primitives.cpp
+++ b/opengl/libagl/primitives.cpp
@@ -241,7 +241,6 @@ void compute_iterators_t::initTriangle(
     m_dx20 = v0->window.x - v2->window.x;
     m_dy02 = v2->window.y - v0->window.y;
     m_area = m_dx01*m_dy02 + (-m_dy10)*m_dx20;
-    (void)m_reserved; // suppress unused warning
 }
 
 void compute_iterators_t::initLine(
diff --git a/opengl/libagl/texture.cpp b/opengl/libagl/texture.cpp
index aae8e058bf..3fe5ed0630 100644
--- a/opengl/libagl/texture.cpp
+++ b/opengl/libagl/texture.cpp
@@ -356,6 +356,10 @@ int createTextureSurface(ogles_context_t* c,
         GLenum format, GLenum type, GLsizei width, GLsizei height,
         GLenum compressedFormat = 0)
 {
+    // find out which texture is bound to the current unit
+    const int active = c->textures.active;
+    const GLuint name = c->textures.tmu[active].name;
+
     // convert the pixelformat to one we can handle
     const int32_t formatIdx = convertGLPixelFormat(format, type);
     if (formatIdx == 0) { // we don't know what to do with this
@@ -1188,6 +1192,7 @@ void glTexImage2D(
         const GGLFormat& pixelFormat(c->rasterizer.formats[formatIdx]);
         const int32_t align = c->textures.unpackAlignment-1;
         const int32_t bpr = ((width * pixelFormat.size) + align) & ~align;
+        const size_t size = bpr * height;
         const int32_t stride = bpr / pixelFormat.size;
 
         GGLSurface userSurface;
@@ -1271,6 +1276,7 @@ void glTexSubImage2D(
     const GGLFormat& pixelFormat(c->rasterizer.formats[formatIdx]);
     const int32_t align = c->textures.unpackAlignment-1;
     const int32_t bpr = ((width * pixelFormat.size) + align) & ~align;
+    const size_t size = bpr * height;
     const int32_t stride = bpr / pixelFormat.size;
     GGLSurface userSurface;
     userSurface.version = sizeof(userSurface);
diff --git a/opengl/libs/Android.bp b/opengl/libs/Android.bp
index 625ac3d9ae..d755c76fb1 100644
--- a/opengl/libs/Android.bp
+++ b/opengl/libs/Android.bp
@@ -3,7 +3,6 @@ cc_library {
     name: "libETC1",
     srcs: ["ETC1/etc1.cpp"],
     host_supported: true,
-    cflags: ["-Wall", "-Werror"],
 
     target: {
         android: {
@@ -17,7 +16,7 @@ cc_library {
             },
         },
         windows: {
-            enabled: true,
+            enabled: false,
         },
     },
 }
@@ -57,9 +56,6 @@ cc_defaults {
         "-DGL_GLEXT_PROTOTYPES",
         "-DEGL_EGLEXT_PROTOTYPES",
         "-fvisibility=hidden",
-        "-Wall",
-        "-Werror",
-        "-Wno-unused-variable",
     ],
     shared_libs: [
         // ***** DO NOT ADD NEW DEPENDENCIES HERE *****
@@ -91,11 +87,6 @@ cc_defaults {
     defaults: ["gl_libs_defaults"],
     cflags: [
         "-DLOG_TAG=\"libEGL\"",
-        "-Wall",
-        "-Werror",
-        "-Wno-error=deprecated-register",
-        "-Wno-error=unknown-attributes",
-        "-Wno-unused-variable",
     ],
     shared_libs: [
         // ***** DO NOT ADD NEW DEPENDENCIES HERE *****
diff --git a/opengl/libs/EGL/Loader.cpp b/opengl/libs/EGL/Loader.cpp
index 91a34558aa..86b50efccf 100644
--- a/opengl/libs/EGL/Loader.cpp
+++ b/opengl/libs/EGL/Loader.cpp
@@ -96,7 +96,6 @@ checkGlesEmulationStatus(void)
      * more additionnal emulation modes in the future.
      */
     char  prop[PROPERTY_VALUE_MAX];
-    int   result = -1;
 
     /* First, check for qemu=1 */
     property_get("ro.kernel.qemu",prop,"0");
@@ -338,14 +337,6 @@ static void* load_system_driver(const char* kind) {
                     result = std::string("/vendor/lib64/egl/lib") + kind + "_emulation.so";
 #else
                     result = std::string("/vendor/lib/egl/lib") + kind + "_emulation.so";
-#endif
-                    return result;
-                case 2:
-                    // Use guest side swiftshader library
-#if defined(__LP64__)
-                    result = std::string("/vendor/lib64/egl/lib") + kind + "_swiftshader.so";
-#else
-                    result = std::string("/vendor/lib/egl/lib") + kind + "_swiftshader.so";
 #endif
                     return result;
                 default:
@@ -397,7 +388,7 @@ static void* load_system_driver(const char* kind) {
         static bool find(std::string& result,
                 const std::string& pattern, const char* const search, bool exact) {
             if (exact) {
-                std::string absolutePath = std::string(search) + "/" + pattern + ".so";
+                std::string absolutePath = std::string(search) + "/" + pattern;
                 if (!access(absolutePath.c_str(), R_OK)) {
                     result = absolutePath;
                     return true;
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 3049f29ee0..59bb536458 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -163,11 +163,13 @@ static const extention_map_t sExtensionMap[] = {
     { "eglGetSyncAttribKHR",
             (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
 
+#ifndef STE_HARDWARE
     // EGL_NV_system_time
     { "eglGetSystemTimeFrequencyNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
     { "eglGetSystemTimeNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
+#endif
 
     // EGL_KHR_wait_sync
     { "eglWaitSyncKHR",
@@ -616,14 +618,12 @@ void getNativePixelFormat(EGLDisplay dpy, egl_connection_t* cnx, EGLConfig confi
     cnx->egl.eglGetConfigAttrib(dpy, config, EGL_COLOR_COMPONENT_TYPE_EXT, &componentType);
 
 #if WORKAROUND_BUG_10194508
-    int intFormat = (int)(format);
     if (!cnx->egl.eglGetConfigAttrib(dpy, config, EGL_NATIVE_VISUAL_ID,
-            &intFormat)) {
+            &format)) {
         ALOGE("eglGetConfigAttrib(EGL_NATIVE_VISUAL_ID) failed: %#x",
                 eglGetError());
         format = 0;
     }
-    format = (android_pixel_format)intFormat;
 #else
     EGLint a = 0;
     EGLint r, g, b;
@@ -686,16 +686,6 @@ EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
     if (dp) {
         EGLDisplay iDpy = dp->disp.dpy;
 
-        if (!window) {
-            return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-        }
-
-        int value = 0;
-        window->query(window, NATIVE_WINDOW_IS_VALID, &value);
-        if (!value) {
-            return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-        }
-
         int result = native_window_api_connect(window, NATIVE_WINDOW_API_EGL);
         if (result < 0) {
             ALOGE("eglCreateWindowSurface: native_window_api_connect (win=%p) "
@@ -748,7 +738,7 @@ EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
         anw->setSwapInterval(anw, 1);
 
         EGLSurface surface = cnx->egl.eglCreateWindowSurface(
-                iDpy, config, window, attrib_list);
+                iDpy, config, window, NULL);
         if (surface != EGL_NO_SURFACE) {
             egl_surface_t* s =
                     new egl_surface_t(dp.get(), config, window, surface, colorSpace, cnx);
@@ -2116,6 +2106,7 @@ EGLClientBuffer eglGetNativeClientBufferANDROID(const AHardwareBuffer *buffer) {
 // ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
+#ifndef STE_HARDWARE
 EGLuint64NV eglGetSystemTimeFrequencyNV()
 {
     clearError();
@@ -2151,6 +2142,7 @@ EGLuint64NV eglGetSystemTimeNV()
 
     return setErrorQuiet(EGL_BAD_DISPLAY, (EGLuint64NV)0);
 }
+#endif
 
 // ----------------------------------------------------------------------------
 // Partial update extension
diff --git a/opengl/libs/EGL/egl_display.cpp b/opengl/libs/EGL/egl_display.cpp
index 3c1edd148a..4e5833ab12 100644
--- a/opengl/libs/EGL/egl_display.cpp
+++ b/opengl/libs/EGL/egl_display.cpp
@@ -79,10 +79,6 @@ egl_display_t::~egl_display_t() {
 }
 
 egl_display_t* egl_display_t::get(EGLDisplay dpy) {
-    if (uintptr_t(dpy) == 0) {
-        return nullptr;
-    }
-
     uintptr_t index = uintptr_t(dpy)-1U;
     if (index >= NUM_DISPLAYS || !sDisplay[index].isValid()) {
         return nullptr;
diff --git a/opengl/libs/EGL/egl_entries.in b/opengl/libs/EGL/egl_entries.in
index b587a16203..43468cd14f 100644
--- a/opengl/libs/EGL/egl_entries.in
+++ b/opengl/libs/EGL/egl_entries.in
@@ -85,8 +85,10 @@ EGL_ENTRY(EGLClientBuffer, eglGetNativeClientBufferANDROID, const AHardwareBuffe
 
 /* NVIDIA extensions */
 
+#ifndef STE_HARDWARE
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeFrequencyNV, void)
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeNV, void)
+#endif
 
 /* IMG extensions */
 
diff --git a/opengl/specs/EGL_ANDROID_get_native_client_buffer.txt b/opengl/specs/EGL_ANDROID_get_native_client_buffer.txt
index 285bba46de..772b21a132 100644
--- a/opengl/specs/EGL_ANDROID_get_native_client_buffer.txt
+++ b/opengl/specs/EGL_ANDROID_get_native_client_buffer.txt
@@ -16,15 +16,15 @@ Contact
 
 Status
 
-    Complete
+    Draft
 
 Version
 
-    Version 3, October 11, 2017
+    Version 1.0, January 27, 2017
 
 Number
 
-    EGL Extension #123
+    EGL Extension #XXX
 
 Dependencies
 
@@ -43,11 +43,11 @@ Overview
 
 New Types
 
-    struct AHardwareBuffer
+struct AHardwareBuffer
 
 New Procedures and Functions
 
-    EGLClientBuffer eglGetNativeClientBufferANDROID(const struct AHardwareBuffer *buffer)
+EGLClientBuffer eglGetNativeClientBufferANDROID(const AHardwareBuffer *buffer)
 
 New Tokens
 
@@ -62,7 +62,7 @@ Changes to Chapter 3 of the EGL 1.2 Specification (EGL Functions and Errors)
    "The command
 
         EGLClientBuffer eglGetNativeClientBufferANDROID(
-                                const struct AHardwareBuffer *buffer)
+                                AHardwareBuffer *buffer)
 
     may be used to create an EGLClientBuffer from an AHardwareBuffer object.
     EGL implementations must guarantee that the lifetime of the returned
@@ -92,9 +92,6 @@ Issues
 
 Revision History
 
-#3 (Jesse Hall, October 11, 2017)
-    - Assigned extension number, fixed minor issues for publication
-
 #2 (Craig Donner, February 17, 2017)
     - Fix typographical errors.
 
diff --git a/opengl/specs/README b/opengl/specs/README
index fdafb1bffb..cba445389d 100644
--- a/opengl/specs/README
+++ b/opengl/specs/README
@@ -24,8 +24,7 @@ Khronos.
 0x314A               EGL_IMAGE_CROP_RIGHT_ANDROID (EGL_ANDROID_image_crop)
 0x314B               EGL_IMAGE_CROP_BOTTOM_ANDROID (EGL_ANDROID_image_crop)
 0x314C               EGL_FRONT_BUFFER_AUTO_REFRESH_ANDROID (EGL_ANDROID_front_buffer_auto_refresh)
-0x314D               EGL_GL_COLORSPACE_DEFAULT_EXT (EGL_EXT_image_gl_colorspace)
-0x314E - 0x314F      (unused)
+0x314D - 0x314F      (unused)
 
      Value                       Extension
 ================     ==================================
diff --git a/opengl/tests/Android.bp b/opengl/tests/Android.bp
deleted file mode 100644
index 639f351c69..0000000000
--- a/opengl/tests/Android.bp
+++ /dev/null
@@ -1,19 +0,0 @@
-
-subdirs = [
-    "angeles",
-    "configdump",
-    "EGLTest",
-    "fillrate",
-    "filter",
-    "finish",
-    "gl2_basic",
-    "gl2_copyTexImage",
-    "gl2_yuvtex",
-    "gl_basic",
-    "gl_perf",
-    "gl_yuvtex", // just renders magenta frame, broken?
-    "gralloc",
-    "hwc",
-    "lib",
-]
-
diff --git a/opengl/tests/Android.mk b/opengl/tests/Android.mk
deleted file mode 100644
index 134854a8b7..0000000000
--- a/opengl/tests/Android.mk
+++ /dev/null
@@ -1,28 +0,0 @@
-dirs := \
-	linetex \
-	swapinterval \
-	textures \
-	tritex \
-
-ifneq (,$(TARGET_BUILD_JAVA_SUPPORT_LEVEL))
-dirs += \
-	gl2_cameraeye \
-	gl2_java \
-	gl2_jni \
-	gldual \
-	gl_jni \
-	gl_perfapp \
-	lighting1709 \
-	testLatency \
-	testPauseResume \
-	testViewport \
-
-endif # JAVA_SUPPORT
-
-ifeq (platform,$(TARGET_BUILD_JAVA_SUPPORT_LEVEL))
-dirs += \
-	testFramerate
-
-endif # JAVA_SUPPORT platform
-
-include $(call all-named-subdir-makefiles, $(dirs))
diff --git a/opengl/tests/EGLTest/Android.bp b/opengl/tests/EGLTest/Android.bp
deleted file mode 100644
index f246077037..0000000000
--- a/opengl/tests/EGLTest/Android.bp
+++ /dev/null
@@ -1,36 +0,0 @@
-
-cc_test {
-
-    name: "EGL_test",
-
-    srcs: [
-        "egl_cache_test.cpp",
-        "EGL_test.cpp",
-    ],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    shared_libs: [
-        "android.hardware.configstore@1.0",
-        "android.hardware.configstore-utils",
-        "libEGL",
-        "libbase",
-        "libcutils",
-        "libbinder",
-        "libgui",
-        "libhidlbase",
-        "libhidltransport",
-        "liblog",
-        "libutils",
-    ],
-
-    include_dirs: [
-        "bionic/libc/private",
-        "frameworks/native/opengl/libs",
-        "frameworks/native/opengl/libs/EGL",
-    ],
-
-}
diff --git a/opengl/tests/EGLTest/EGL_test.cpp b/opengl/tests/EGLTest/EGL_test.cpp
deleted file mode 100644
index b67a053021..0000000000
--- a/opengl/tests/EGLTest/EGL_test.cpp
+++ /dev/null
@@ -1,541 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gtest/gtest.h>
-
-#include <android/hardware/configstore/1.0/ISurfaceFlingerConfigs.h>
-
-#include <configstore/Utils.h>
-#include <utils/String8.h>
-
-#include <EGL/egl.h>
-#include <gui/Surface.h>
-#include <gui/IConsumerListener.h>
-#include <gui/IProducerListener.h>
-#include <gui/IGraphicBufferConsumer.h>
-#include <gui/BufferQueue.h>
-
-bool hasEglExtension(EGLDisplay dpy, const char* extensionName) {
-    const char* exts = eglQueryString(dpy, EGL_EXTENSIONS);
-    size_t cropExtLen = strlen(extensionName);
-    size_t extsLen = strlen(exts);
-    bool equal = !strcmp(extensionName, exts);
-    android::String8 extString(extensionName);
-    android::String8 space(" ");
-    bool atStart = !strncmp(extString + space, exts, cropExtLen + 1);
-    bool atEnd = (cropExtLen + 1) < extsLen &&
-            !strcmp(space + extString, exts + extsLen - (cropExtLen + 1));
-    bool inMiddle = strstr(exts, space + extString + space);
-    return equal || atStart || atEnd || inMiddle;
-}
-
-namespace android {
-
-#define EGL_UNSIGNED_TRUE static_cast<EGLBoolean>(EGL_TRUE)
-
-// retrieve wide-color setting from configstore
-using namespace android::hardware::configstore;
-using namespace android::hardware::configstore::V1_0;
-
-static bool hasWideColorDisplay =
-        getBool<ISurfaceFlingerConfigs, &ISurfaceFlingerConfigs::hasWideColorDisplay>(false);
-
-class EGLTest : public ::testing::Test {
-protected:
-    EGLDisplay mEglDisplay;
-
-protected:
-    EGLTest() :
-            mEglDisplay(EGL_NO_DISPLAY) {
-    }
-
-    virtual void SetUp() {
-        mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        EGLint majorVersion;
-        EGLint minorVersion;
-        EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        RecordProperty("EglVersionMajor", majorVersion);
-        RecordProperty("EglVersionMajor", minorVersion);
-    }
-
-    virtual void TearDown() {
-        EGLBoolean success = eglTerminate(mEglDisplay);
-        ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    }
-};
-
-TEST_F(EGLTest, DISABLED_EGLConfigEightBitFirst) {
-
-    EGLint numConfigs;
-    EGLConfig config;
-    EGLBoolean success;
-    EGLint attrs[] = {
-            EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE,    EGL_OPENGL_ES2_BIT,
-            EGL_NONE
-    };
-
-    success = eglChooseConfig(mEglDisplay, attrs, &config, 1, &numConfigs);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_GE(numConfigs, 1);
-
-    EGLint components[3];
-
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_RED_SIZE, &components[0]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_GREEN_SIZE, &components[1]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_BLUE_SIZE, &components[2]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EXPECT_GE(components[0], 8);
-    EXPECT_GE(components[1], 8);
-    EXPECT_GE(components[2], 8);
-}
-
-TEST_F(EGLTest, EGLTerminateSucceedsWithRemainingObjects) {
-    EGLint numConfigs;
-    EGLConfig config;
-    EGLint attrs[] = {
-        EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE,    EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE,           8,
-        EGL_GREEN_SIZE,         8,
-        EGL_BLUE_SIZE,          8,
-        EGL_ALPHA_SIZE,         8,
-        EGL_NONE
-    };
-    EXPECT_TRUE(eglChooseConfig(mEglDisplay, attrs, &config, 1, &numConfigs));
-
-    struct DummyConsumer : public BnConsumerListener {
-        void onFrameAvailable(const BufferItem& /* item */) override {}
-        void onBuffersReleased() override {}
-        void onSidebandStreamChanged() override {}
-    };
-
-    // Create a EGLSurface
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    consumer->consumerConnect(new DummyConsumer, false);
-    sp<Surface> mSTC = new Surface(producer);
-    sp<ANativeWindow> mANW = mSTC;
-
-    EGLSurface eglSurface = eglCreateWindowSurface(mEglDisplay, config,
-                                mANW.get(), NULL);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_SURFACE, eglSurface) ;
-
-    // do not destroy eglSurface
-    // eglTerminate is called in the tear down and should destroy it for us
-}
-
-TEST_F(EGLTest, EGLConfigRGBA8888First) {
-
-    EGLint numConfigs;
-    EGLConfig config;
-    EGLBoolean success;
-    EGLint attrs[] = {
-            EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE,    EGL_OPENGL_ES2_BIT,
-            EGL_RED_SIZE,           8,
-            EGL_GREEN_SIZE,         8,
-            EGL_BLUE_SIZE,          8,
-            EGL_ALPHA_SIZE,         8,
-            EGL_NONE
-    };
-
-    success = eglChooseConfig(mEglDisplay, attrs, &config, 1, &numConfigs);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_GE(numConfigs, 1);
-
-    EGLint components[4];
-
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_RED_SIZE, &components[0]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_GREEN_SIZE, &components[1]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_BLUE_SIZE, &components[2]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_ALPHA_SIZE, &components[3]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EXPECT_GE(components[0], 8);
-    EXPECT_GE(components[1], 8);
-    EXPECT_GE(components[2], 8);
-    EXPECT_GE(components[3], 8);
-}
-
-TEST_F(EGLTest, EGLDisplayP3) {
-    EGLint numConfigs;
-    EGLConfig config;
-    EGLBoolean success;
-
-    if (!hasWideColorDisplay) {
-        // skip this test if device does not have wide-color display
-        std::cerr << "[          ] Device does not support wide-color, test skipped" << std::endl;
-        return;
-    }
-
-    // Test that display-p3 extensions exist
-    ASSERT_TRUE(hasEglExtension(mEglDisplay, "EGL_EXT_gl_colorspace_display_p3"));
-    ASSERT_TRUE(hasEglExtension(mEglDisplay, "EGL_EXT_gl_colorspace_display_p3_linear"));
-
-    // Use 8-bit to keep forcus on Display-P3 aspect
-    EGLint attrs[] = {
-            // clang-format off
-            EGL_SURFACE_TYPE,             EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE,          EGL_OPENGL_ES2_BIT,
-            EGL_SURFACE_TYPE,             EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
-            EGL_RED_SIZE,                 8,
-            EGL_GREEN_SIZE,               8,
-            EGL_BLUE_SIZE,                8,
-            EGL_ALPHA_SIZE,               8,
-            EGL_COLOR_COMPONENT_TYPE_EXT, EGL_COLOR_COMPONENT_TYPE_FIXED_EXT,
-            EGL_NONE,                     EGL_NONE
-            // clang-format on
-    };
-    success = eglChooseConfig(mEglDisplay, attrs, &config, 1, &numConfigs);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(1, numConfigs);
-
-    EGLint components[4];
-    EGLint value;
-    eglGetConfigAttrib(mEglDisplay, config, EGL_CONFIG_ID, &value);
-
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_RED_SIZE, &components[0]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_GREEN_SIZE, &components[1]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_BLUE_SIZE, &components[2]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_ALPHA_SIZE, &components[3]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EXPECT_EQ(components[0], 8);
-    EXPECT_EQ(components[1], 8);
-    EXPECT_EQ(components[2], 8);
-    EXPECT_EQ(components[3], 8);
-
-    struct DummyConsumer : public BnConsumerListener {
-        void onFrameAvailable(const BufferItem& /* item */) override {}
-        void onBuffersReleased() override {}
-        void onSidebandStreamChanged() override {}
-    };
-
-    // Create a EGLSurface
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    consumer->consumerConnect(new DummyConsumer, false);
-    sp<Surface> mSTC = new Surface(producer);
-    sp<ANativeWindow> mANW = mSTC;
-    EGLint winAttrs[] = {
-            // clang-format off
-            EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_DISPLAY_P3_EXT,
-            EGL_NONE,              EGL_NONE
-            // clang-format on
-    };
-
-    EGLSurface eglSurface = eglCreateWindowSurface(mEglDisplay, config, mANW.get(), winAttrs);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_SURFACE, eglSurface);
-
-    success = eglQuerySurface(mEglDisplay, eglSurface, EGL_GL_COLORSPACE_KHR, &value);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_GL_COLORSPACE_DISPLAY_P3_EXT, value);
-
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, eglSurface));
-}
-
-TEST_F(EGLTest, EGLDisplayP31010102) {
-    EGLint numConfigs;
-    EGLConfig config;
-    EGLBoolean success;
-
-    if (!hasWideColorDisplay) {
-        // skip this test if device does not have wide-color display
-        std::cerr << "[          ] Device does not support wide-color, test skipped" << std::endl;
-        return;
-    }
-
-    // Test that display-p3 extensions exist
-    ASSERT_TRUE(hasEglExtension(mEglDisplay, "EGL_EXT_gl_colorspace_display_p3"));
-    ASSERT_TRUE(hasEglExtension(mEglDisplay, "EGL_EXT_gl_colorspace_display_p3_linear"));
-
-    // Use 8-bit to keep forcus on Display-P3 aspect
-    EGLint attrs[] = {
-            // clang-format off
-            EGL_SURFACE_TYPE,             EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE,          EGL_OPENGL_ES2_BIT,
-            EGL_SURFACE_TYPE,             EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
-            EGL_RED_SIZE,                 10,
-            EGL_GREEN_SIZE,               10,
-            EGL_BLUE_SIZE,                10,
-            EGL_ALPHA_SIZE,               2,
-            EGL_COLOR_COMPONENT_TYPE_EXT, EGL_COLOR_COMPONENT_TYPE_FIXED_EXT,
-            EGL_NONE,                     EGL_NONE
-            // clang-format on
-    };
-    success = eglChooseConfig(mEglDisplay, attrs, &config, 1, &numConfigs);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(1, numConfigs);
-
-    EGLint components[4];
-    EGLint value;
-    eglGetConfigAttrib(mEglDisplay, config, EGL_CONFIG_ID, &value);
-
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_RED_SIZE, &components[0]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_GREEN_SIZE, &components[1]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_BLUE_SIZE, &components[2]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_ALPHA_SIZE, &components[3]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EXPECT_EQ(components[0], 10);
-    EXPECT_EQ(components[1], 10);
-    EXPECT_EQ(components[2], 10);
-    EXPECT_EQ(components[3], 2);
-
-    struct DummyConsumer : public BnConsumerListener {
-        void onFrameAvailable(const BufferItem& /* item */) override {}
-        void onBuffersReleased() override {}
-        void onSidebandStreamChanged() override {}
-    };
-
-    // Create a EGLSurface
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    consumer->consumerConnect(new DummyConsumer, false);
-    sp<Surface> mSTC = new Surface(producer);
-    sp<ANativeWindow> mANW = mSTC;
-    EGLint winAttrs[] = {
-            // clang-format off
-            EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_DISPLAY_P3_EXT,
-            EGL_NONE,              EGL_NONE
-            // clang-format on
-    };
-
-    EGLSurface eglSurface = eglCreateWindowSurface(mEglDisplay, config, mANW.get(), winAttrs);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_SURFACE, eglSurface);
-
-    success = eglQuerySurface(mEglDisplay, eglSurface, EGL_GL_COLORSPACE_KHR, &value);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_GL_COLORSPACE_DISPLAY_P3_EXT, value);
-
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, eglSurface));
-}
-
-TEST_F(EGLTest, EGLConfigFP16) {
-    EGLint numConfigs;
-    EGLConfig config;
-    EGLBoolean success;
-
-    if (!hasWideColorDisplay) {
-        // skip this test if device does not have wide-color display
-        std::cerr << "[          ] Device does not support wide-color, test skipped" << std::endl;
-        return;
-    }
-
-    ASSERT_TRUE(hasEglExtension(mEglDisplay, "EGL_EXT_pixel_format_float"));
-
-    EGLint attrs[] = {
-            // clang-format off
-            EGL_SURFACE_TYPE,             EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE,          EGL_OPENGL_ES2_BIT,
-            EGL_RED_SIZE,                 16,
-            EGL_GREEN_SIZE,               16,
-            EGL_BLUE_SIZE,                16,
-            EGL_ALPHA_SIZE,               16,
-            EGL_COLOR_COMPONENT_TYPE_EXT, EGL_COLOR_COMPONENT_TYPE_FLOAT_EXT,
-            EGL_NONE,                     EGL_NONE
-            // clang-format on
-    };
-    success = eglChooseConfig(mEglDisplay, attrs, &config, 1, &numConfigs);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(1, numConfigs);
-
-    EGLint components[4];
-
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_RED_SIZE, &components[0]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_GREEN_SIZE, &components[1]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_BLUE_SIZE, &components[2]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_ALPHA_SIZE, &components[3]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EXPECT_GE(components[0], 16);
-    EXPECT_GE(components[1], 16);
-    EXPECT_GE(components[2], 16);
-    EXPECT_GE(components[3], 16);
-
-    struct DummyConsumer : public BnConsumerListener {
-        void onFrameAvailable(const BufferItem& /* item */) override {}
-        void onBuffersReleased() override {}
-        void onSidebandStreamChanged() override {}
-    };
-
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    consumer->consumerConnect(new DummyConsumer, false);
-    sp<Surface> mSTC = new Surface(producer);
-    sp<ANativeWindow> mANW = mSTC;
-
-    EGLSurface eglSurface = eglCreateWindowSurface(mEglDisplay, config, mANW.get(), NULL);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_SURFACE, eglSurface);
-
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, eglSurface));
-}
-
-TEST_F(EGLTest, EGLNoConfigContext) {
-    if (!hasWideColorDisplay) {
-        // skip this test if device does not have wide-color display
-        std::cerr << "[          ] Device does not support wide-color, test skipped" << std::endl;
-        return;
-    }
-
-    ASSERT_TRUE(hasEglExtension(mEglDisplay, "EGL_KHR_no_config_context"));
-
-    struct DummyConsumer : public BnConsumerListener {
-        void onFrameAvailable(const BufferItem& /* item */) override {}
-        void onBuffersReleased() override {}
-        void onSidebandStreamChanged() override {}
-    };
-
-    std::vector<EGLint> contextAttributes;
-    contextAttributes.reserve(4);
-    contextAttributes.push_back(EGL_CONTEXT_CLIENT_VERSION);
-    contextAttributes.push_back(2);
-    contextAttributes.push_back(EGL_NONE);
-    contextAttributes.push_back(EGL_NONE);
-
-    EGLContext eglContext = eglCreateContext(mEglDisplay, EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
-                                             contextAttributes.data());
-    EXPECT_NE(EGL_NO_CONTEXT, eglContext);
-    EXPECT_EQ(EGL_SUCCESS, eglGetError());
-
-    if (eglContext != EGL_NO_CONTEXT) {
-        eglDestroyContext(mEglDisplay, eglContext);
-    }
-}
-
-// Emulate what a native application would do to create a
-// 10:10:10:2 surface.
-TEST_F(EGLTest, EGLConfig1010102) {
-    EGLint numConfigs;
-    EGLConfig config;
-    EGLBoolean success;
-
-    if (!hasWideColorDisplay) {
-        // skip this test if device does not have wide-color display
-        std::cerr << "[          ] Device does not support wide-color, test skipped" << std::endl;
-        return;
-    }
-
-    EGLint attrs[] = {
-            // clang-format off
-            EGL_SURFACE_TYPE,             EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE,          EGL_OPENGL_ES2_BIT,
-            EGL_SURFACE_TYPE,             EGL_WINDOW_BIT | EGL_PBUFFER_BIT,
-            EGL_RED_SIZE,                 10,
-            EGL_GREEN_SIZE,               10,
-            EGL_BLUE_SIZE,                10,
-            EGL_ALPHA_SIZE,               2,
-            EGL_COLOR_COMPONENT_TYPE_EXT, EGL_COLOR_COMPONENT_TYPE_FIXED_EXT,
-            EGL_NONE,                     EGL_NONE
-            // clang-format on
-    };
-    success = eglChooseConfig(mEglDisplay, attrs, &config, 1, &numConfigs);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(1, numConfigs);
-
-    EGLint components[4];
-    EGLint value;
-    eglGetConfigAttrib(mEglDisplay, config, EGL_CONFIG_ID, &value);
-
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_RED_SIZE, &components[0]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_GREEN_SIZE, &components[1]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_BLUE_SIZE, &components[2]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    success = eglGetConfigAttrib(mEglDisplay, config, EGL_ALPHA_SIZE, &components[3]);
-    ASSERT_EQ(EGL_UNSIGNED_TRUE, success);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EXPECT_EQ(components[0], 10);
-    EXPECT_EQ(components[1], 10);
-    EXPECT_EQ(components[2], 10);
-    EXPECT_EQ(components[3], 2);
-
-    struct DummyConsumer : public BnConsumerListener {
-        void onFrameAvailable(const BufferItem& /* item */) override {}
-        void onBuffersReleased() override {}
-        void onSidebandStreamChanged() override {}
-    };
-
-    // Create a EGLSurface
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    consumer->consumerConnect(new DummyConsumer, false);
-    sp<Surface> mSTC = new Surface(producer);
-    sp<ANativeWindow> mANW = mSTC;
-
-    EGLSurface eglSurface = eglCreateWindowSurface(mEglDisplay, config, mANW.get(), NULL);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_SURFACE, eglSurface);
-
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, eglSurface));
-}
-}
diff --git a/opengl/tests/EGLTest/egl_cache_test.cpp b/opengl/tests/EGLTest/egl_cache_test.cpp
deleted file mode 100644
index c974f63c13..0000000000
--- a/opengl/tests/EGLTest/egl_cache_test.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "EGL_test"
-//#define LOG_NDEBUG 0
-
-#include <gtest/gtest.h>
-
-#include <utils/Log.h>
-
-#include <android-base/test_utils.h>
-
-#include "egl_cache.h"
-#include "egl_display.h"
-
-#include <memory>
-
-namespace android {
-
-class EGLCacheTest : public ::testing::Test {
-protected:
-    virtual void SetUp() {
-        mCache = egl_cache_t::get();
-    }
-
-    virtual void TearDown() {
-        mCache->setCacheFilename("");
-        mCache->terminate();
-    }
-
-    egl_cache_t* mCache;
-};
-
-TEST_F(EGLCacheTest, UninitializedCacheAlwaysMisses) {
-    uint8_t buf[4] = { 0xee, 0xee, 0xee, 0xee };
-    mCache->setBlob("abcd", 4, "efgh", 4);
-    ASSERT_EQ(0, mCache->getBlob("abcd", 4, buf, 4));
-    ASSERT_EQ(0xee, buf[0]);
-    ASSERT_EQ(0xee, buf[1]);
-    ASSERT_EQ(0xee, buf[2]);
-    ASSERT_EQ(0xee, buf[3]);
-}
-
-TEST_F(EGLCacheTest, InitializedCacheAlwaysHits) {
-    uint8_t buf[4] = { 0xee, 0xee, 0xee, 0xee };
-    mCache->initialize(egl_display_t::get(EGL_DEFAULT_DISPLAY));
-    mCache->setBlob("abcd", 4, "efgh", 4);
-    ASSERT_EQ(4, mCache->getBlob("abcd", 4, buf, 4));
-    ASSERT_EQ('e', buf[0]);
-    ASSERT_EQ('f', buf[1]);
-    ASSERT_EQ('g', buf[2]);
-    ASSERT_EQ('h', buf[3]);
-}
-
-TEST_F(EGLCacheTest, TerminatedCacheAlwaysMisses) {
-    uint8_t buf[4] = { 0xee, 0xee, 0xee, 0xee };
-    mCache->initialize(egl_display_t::get(EGL_DEFAULT_DISPLAY));
-    mCache->setBlob("abcd", 4, "efgh", 4);
-    mCache->terminate();
-    ASSERT_EQ(0, mCache->getBlob("abcd", 4, buf, 4));
-    ASSERT_EQ(0xee, buf[0]);
-    ASSERT_EQ(0xee, buf[1]);
-    ASSERT_EQ(0xee, buf[2]);
-    ASSERT_EQ(0xee, buf[3]);
-}
-
-class EGLCacheSerializationTest : public EGLCacheTest {
-
-protected:
-
-    virtual void SetUp() {
-        EGLCacheTest::SetUp();
-        mTempFile.reset(new TemporaryFile());
-    }
-
-    virtual void TearDown() {
-        mTempFile.reset(nullptr);
-        EGLCacheTest::TearDown();
-    }
-
-    std::unique_ptr<TemporaryFile> mTempFile;
-};
-
-TEST_F(EGLCacheSerializationTest, ReinitializedCacheContainsValues) {
-    uint8_t buf[4] = { 0xee, 0xee, 0xee, 0xee };
-    mCache->setCacheFilename(&mTempFile->path[0]);
-    mCache->initialize(egl_display_t::get(EGL_DEFAULT_DISPLAY));
-    mCache->setBlob("abcd", 4, "efgh", 4);
-    mCache->terminate();
-    mCache->initialize(egl_display_t::get(EGL_DEFAULT_DISPLAY));
-    ASSERT_EQ(4, mCache->getBlob("abcd", 4, buf, 4));
-    ASSERT_EQ('e', buf[0]);
-    ASSERT_EQ('f', buf[1]);
-    ASSERT_EQ('g', buf[2]);
-    ASSERT_EQ('h', buf[3]);
-}
-
-}
diff --git a/opengl/tests/angeles/Android.bp b/opengl/tests/angeles/Android.bp
deleted file mode 100644
index 5c398a6323..0000000000
--- a/opengl/tests/angeles/Android.bp
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2006 The Android Open Source Project
-
-cc_test {
-    name: "angeles",
-
-    srcs: [
-        "app-linux.cpp",
-        "demo.c",
-    ],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    gtest: false,
-
-    shared_libs: [
-        "libEGL",
-        "libGLESv1_CM",
-        "libui",
-        "libgui",
-        "libutils",
-    ],
-
-    static_libs: ["libglTest"],
-}
diff --git a/opengl/tests/angeles/MODULE_LICENSE_BSD_OR_LGPL b/opengl/tests/angeles/MODULE_LICENSE_BSD_OR_LGPL
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/opengl/tests/angeles/README.txt b/opengl/tests/angeles/README.txt
deleted file mode 100644
index 38b8a4a74d..0000000000
--- a/opengl/tests/angeles/README.txt
+++ /dev/null
@@ -1,77 +0,0 @@
-------------------------------------------------------------------------
-San Angeles Observation OpenGL ES version example
-Copyright 2004-2005 Jetro Lauha
-Web: http://iki.fi/jetro/
-See file license.txt for licensing information.
-------------------------------------------------------------------------
-
-This is an OpenGL ES port of the small self-running demonstration
-called "San Angeles Observation", which was first presented in the
-Assembly'2004 event. It won the first place in the 4 KB intro
-competition category.
-
-The demonstration features a sightseeing of a futuristic city
-having many different kind of buildings and items. Everything is
-flat shaded with three different lights.
-
-The original version was made for desktop with OpenGL. It was
-naturally heavily size optimized in order to fit it in the size
-limit. For this OpenGL ES version example much of the code is
-cleaned up and the sound is removed. Also detail level is lowered,
-although it still contains over 60000 faces.
-
-The Win32 (2000/XP) binary package of original version is
-available from this address: http://jet.ro/files/angeles.zip
-
-First version of this OpenGL ES port was submitted to the Khronos
-OpenGL ES Coding Challenge held in 2004-2005.
-
-As a code example, this source shows the following:
-  * How to create a minimal and portable ad hoc framework
-    for small testing/demonstration programs. This framework
-    compiles for both desktop and PocketPC Win32 environment,
-    and a separate source is included for Linux with X11.
-  * How to dynamically find and use the OpenGL ES DLL or
-    shared object, so that the library is not needed at
-    the compile/link stage.
-  * How to use the basic features of OpenGL ES 1.0/1.1
-    Common Lite, such as vertex arrays, color arrays and
-    lighting.
-  * How to create a self contained small demonstration
-    application with objects generated using procedural
-    algorithms.
-
-As the original version was optimized for size instead of
-performance, that holds true for this OpenGL ES version as
-well. Thus the performance could be significantly increased,
-for example by changing the code to use glDrawElements
-instead of glDrawArrays. The code uses only OpenGL ES 1.0
-Common Lite -level function calls without any extensions.
-
-The reference OpenGL ES implementations used for this application:
-  * Hybrid's OpenGL ES API Implementation (Gerbera) version 2.0.4
-    Prebuilt Win32 PC executable: SanOGLES-Gerbera.exe
-  * PowerVR MBX SDK, OpenGL ES Windows PC Emulation version 1.04.14.0170
-    Prebuilt Win32 PC executable: SanOGLES-PVRSDK.exe
-
-Note that DISABLE_IMPORTGL preprocessor macro can be used
-to specify not to use dynamic runtime binding of the library.
-You also need to define preprocessor macro PVRSDK to compile
-the source with PowerVR OpenGL ES SDK.
-
-The demo application is briefly tested with a few other OpenGL ES
-implementations as well (e.g. Vincent, GLESonGL on Linux, Dell
-Axim X50v). Most of these other implementations rendered the demo
-erroneously in some aspect. This may indicate that the demo source
-could still have some work to do with compatibility and correct
-API usage, although the non-conforming implementations are most
-probably unfinished as well.
-
-Thanks and Acknowledgements:
-
-* Toni Lnnberg (!Cube) created the music for original version, which
-  is not featured in this OpenGL ES port.
-* Sara Kapli (st Rana) for additional camera work.
-* Paul Bourke for information about the supershapes.
-
-------------------------------------------------------------------------
diff --git a/opengl/tests/angeles/app-linux.cpp b/opengl/tests/angeles/app-linux.cpp
deleted file mode 100644
index 9d2c98ff8a..0000000000
--- a/opengl/tests/angeles/app-linux.cpp
+++ /dev/null
@@ -1,229 +0,0 @@
-/* San Angeles Observation OpenGL ES version example
- * Copyright 2004-2005 Jetro Lauha
- * All rights reserved.
- * Web: http://iki.fi/jetro/
- *
- * This source is free software; you can redistribute it and/or
- * modify it under the terms of EITHER:
- *   (1) The GNU Lesser General Public License as published by the Free
- *       Software Foundation; either version 2.1 of the License, or (at
- *       your option) any later version. The text of the GNU Lesser
- *       General Public License is included with this source in the
- *       file LICENSE-LGPL.txt.
- *   (2) The BSD-style license that is included with this source in
- *       the file LICENSE-BSD.txt.
- *
- * This source is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
- * LICENSE-LGPL.txt and LICENSE-BSD.txt for more details.
- *
- * $Id: app-linux.c,v 1.4 2005/02/08 18:42:48 tonic Exp $
- * $Revision: 1.4 $
- *
- * Parts of this source file is based on test/example code from
- * GLESonGL implementation by David Blythe. Here is copy of the
- * license notice from that source:
- *
- * Copyright (C) 2003  David Blythe   All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * DAVID BLYTHE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
- * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <sys/time.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-
-#include <EGLUtils.h>
-#include <WindowSurface.h>
-
-using namespace android;
-
-#include "app.h"
-
-
-int gAppAlive = 1;
-
-static int sWindowWidth = WINDOW_DEFAULT_WIDTH;
-static int sWindowHeight = WINDOW_DEFAULT_HEIGHT;
-static EGLDisplay sEglDisplay = EGL_NO_DISPLAY;
-static EGLContext sEglContext = EGL_NO_CONTEXT;
-static EGLSurface sEglSurface = EGL_NO_SURFACE;
-
-const char *egl_strerror(unsigned err)
-{
-    switch(err){
-        case EGL_SUCCESS: return "SUCCESS";
-        case EGL_NOT_INITIALIZED: return "NOT INITIALIZED";
-        case EGL_BAD_ACCESS: return "BAD ACCESS";
-        case EGL_BAD_ALLOC: return "BAD ALLOC";
-        case EGL_BAD_ATTRIBUTE: return "BAD_ATTRIBUTE";
-        case EGL_BAD_CONFIG: return "BAD CONFIG";
-        case EGL_BAD_CONTEXT: return "BAD CONTEXT";
-        case EGL_BAD_CURRENT_SURFACE: return "BAD CURRENT SURFACE";
-        case EGL_BAD_DISPLAY: return "BAD DISPLAY";
-        case EGL_BAD_MATCH: return "BAD MATCH";
-        case EGL_BAD_NATIVE_PIXMAP: return "BAD NATIVE PIXMAP";
-        case EGL_BAD_NATIVE_WINDOW: return "BAD NATIVE WINDOW";
-        case EGL_BAD_PARAMETER: return "BAD PARAMETER";
-        case EGL_BAD_SURFACE: return "BAD_SURFACE";
-        //    case EGL_CONTEXT_LOST: return "CONTEXT LOST";
-        default: return "UNKNOWN";
-    }
-}
-
-void egl_error(const char *name)
-{
-    unsigned err = eglGetError();
-    if(err != EGL_SUCCESS) {
-        fprintf(stderr,"%s(): egl error 0x%x (%s)\n", 
-                name, err, egl_strerror(err));
-    }
-}
-
-static void checkGLErrors()
-{
-    GLenum error = glGetError();
-    if (error != GL_NO_ERROR)
-        fprintf(stderr, "GL Error: 0x%04x\n", (int)error);
-}
-
-
-static void checkEGLErrors()
-{
-    EGLint error = eglGetError();
-    // GLESonGL seems to be returning 0 when there is no errors?
-    if (error && error != EGL_SUCCESS)
-        fprintf(stderr, "EGL Error: 0x%04x\n", (int)error);
-}
-
-static int initGraphics(EGLint samples, const WindowSurface& windowSurface)
-{
-    EGLint configAttribs[] = {
-            EGL_DEPTH_SIZE, 16,
-            EGL_SAMPLE_BUFFERS, samples ? 1 : 0,
-                    EGL_SAMPLES, samples,
-                    EGL_NONE
-    };
-
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EGLContext context;
-    EGLConfig config;
-    EGLSurface surface;
-    EGLDisplay dpy;
-
-    EGLNativeWindowType window = windowSurface.getSurface();
-
-    dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    eglInitialize(dpy, &majorVersion, &minorVersion);
-
-    status_t err = EGLUtils::selectConfigForNativeWindow(
-            dpy, configAttribs, window, &config);
-    if (err) {
-        fprintf(stderr, "couldn't find an EGLConfig matching the screen format\n");
-        return 0;
-    }
-
-    surface = eglCreateWindowSurface(dpy, config, window, NULL);
-    egl_error("eglCreateWindowSurface");
-
-    fprintf(stderr,"surface = %p\n", surface);
-
-    context = eglCreateContext(dpy, config, NULL, NULL);
-    egl_error("eglCreateContext");
-    fprintf(stderr,"context = %p\n", context);
-
-    eglMakeCurrent(dpy, surface, surface, context);
-    egl_error("eglMakeCurrent");
-
-    eglQuerySurface(dpy, surface, EGL_WIDTH, &sWindowWidth);
-    eglQuerySurface(dpy, surface, EGL_HEIGHT, &sWindowHeight);
-
-    sEglDisplay = dpy;
-    sEglSurface = surface;
-    sEglContext = context;
-
-    if (samples == 0) {
-        // GL_MULTISAMPLE is enabled by default
-        glDisable(GL_MULTISAMPLE);
-    }
-
-    return EGL_TRUE;
-}
-
-
-static void deinitGraphics()
-{
-    eglMakeCurrent(sEglDisplay, NULL, NULL, NULL);
-    eglDestroyContext(sEglDisplay, sEglContext);
-    eglDestroySurface(sEglDisplay, sEglSurface);
-    eglTerminate(sEglDisplay);
-}
-
-
-int main(int argc, char *argv[])
-{
-    unsigned samples = 0;
-    printf("usage: %s [samples]\n", argv[0]);
-    if (argc == 2) {
-        samples = atoi( argv[1] );
-        printf("Multisample enabled: GL_SAMPLES = %u\n", samples);
-    }
-
-    WindowSurface windowSurface;
-    if (!initGraphics(samples, windowSurface))
-    {
-        fprintf(stderr, "Graphics initialization failed.\n");
-        return EXIT_FAILURE;
-    }
-
-    appInit();
-
-    struct timeval timeTemp;
-    int frameCount = 0;
-    gettimeofday(&timeTemp, NULL);
-    double totalTime = timeTemp.tv_usec/1000000.0 + timeTemp.tv_sec;
-
-    while (gAppAlive)
-    {
-        struct timeval timeNow;
-
-        gettimeofday(&timeNow, NULL);
-        appRender(timeNow.tv_sec * 1000 + timeNow.tv_usec / 1000,
-                sWindowWidth, sWindowHeight);
-        checkGLErrors();
-        eglSwapBuffers(sEglDisplay, sEglSurface);
-        checkEGLErrors();
-        frameCount++;
-    }
-
-    gettimeofday(&timeTemp, NULL);
-
-    appDeinit();
-    deinitGraphics();
-
-    totalTime = (timeTemp.tv_usec/1000000.0 + timeTemp.tv_sec) - totalTime;
-    printf("totalTime=%f s, frameCount=%d, %.2f fps\n",
-            totalTime, frameCount, frameCount/totalTime);
-
-    return EXIT_SUCCESS;
-}
diff --git a/opengl/tests/angeles/app.h b/opengl/tests/angeles/app.h
deleted file mode 100644
index 70ebd35be1..0000000000
--- a/opengl/tests/angeles/app.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* San Angeles Observation OpenGL ES version example
- * Copyright 2004-2005 Jetro Lauha
- * All rights reserved.
- * Web: http://iki.fi/jetro/
- *
- * This source is free software; you can redistribute it and/or
- * modify it under the terms of EITHER:
- *   (1) The GNU Lesser General Public License as published by the Free
- *       Software Foundation; either version 2.1 of the License, or (at
- *       your option) any later version. The text of the GNU Lesser
- *       General Public License is included with this source in the
- *       file LICENSE-LGPL.txt.
- *   (2) The BSD-style license that is included with this source in
- *       the file LICENSE-BSD.txt.
- *
- * This source is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
- * LICENSE-LGPL.txt and LICENSE-BSD.txt for more details.
- *
- * $Id: app.h,v 1.14 2005/02/06 21:13:54 tonic Exp $
- * $Revision: 1.14 $
- */
-
-#ifndef APP_H_INCLUDED
-#define APP_H_INCLUDED
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define WINDOW_DEFAULT_WIDTH    640
-#define WINDOW_DEFAULT_HEIGHT   480
-
-#define WINDOW_BPP              16
-
-
-// The simple framework expects the application code to define these functions.
-extern void appInit();
-extern void appDeinit();
-extern void appRender(long tick, int width, int height);
-
-/* Value is non-zero when application is alive, and 0 when it is closing.
- * Defined by the application framework.
- */
-extern int gAppAlive;
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif // !APP_H_INCLUDED
diff --git a/opengl/tests/angeles/cams.h b/opengl/tests/angeles/cams.h
deleted file mode 100644
index 2b1acb3c35..0000000000
--- a/opengl/tests/angeles/cams.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* San Angeles Observation OpenGL ES version example
- * Copyright 2004-2005 Jetro Lauha
- * All rights reserved.
- * Web: http://iki.fi/jetro/
- *
- * This source is free software; you can redistribute it and/or
- * modify it under the terms of EITHER:
- *   (1) The GNU Lesser General Public License as published by the Free
- *       Software Foundation; either version 2.1 of the License, or (at
- *       your option) any later version. The text of the GNU Lesser
- *       General Public License is included with this source in the
- *       file LICENSE-LGPL.txt.
- *   (2) The BSD-style license that is included with this source in
- *       the file LICENSE-BSD.txt.
- *
- * This source is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
- * LICENSE-LGPL.txt and LICENSE-BSD.txt for more details.
- *
- * $Id: cams.h,v 1.7 2005/01/31 22:15:15 tonic Exp $
- * $Revision: 1.7 $
- */
-
-#ifndef CAMS_H_INCLUDED
-#define CAMS_H_INCLUDED
-
-
-/* Length in milliseconds of one camera track base unit.
- * The value originates from the music synchronization.
- */
-#define CAMTRACK_LEN    5442
-
-
-// Camera track definition for one camera trucking shot.
-typedef struct
-{
-    /* Five parameters of src[5] and dest[5]:
-     * eyeX, eyeY, eyeZ, viewAngle, viewHeightOffs
-     */
-    short src[5], dest[5];
-    unsigned char dist;     // if >0, cam rotates around eye xy on dist * 0.1
-    unsigned char len;      // length multiplier
-} CAMTRACK;
-
-static CAMTRACK sCamTracks[] =
-{
-    { { 4500, 2700, 100, 70, -30 }, { 50, 50, -90, -100, 0 }, 20, 1 },
-    { { -1448, 4294, 25, 363, 0 }, { -136, 202, 125, -98, 100 }, 0, 1 },
-    { { 1437, 4930, 200, -275, -20 }, { 1684, 0, 0, 9, 0 }, 0, 1 },
-    { { 1800, 3609, 200, 0, 675 }, { 0, 0, 0, 300, 0 }, 0, 1 },
-    { { 923, 996, 50, 2336, -80 }, { 0, -20, -50, 0, 170 }, 0, 1 },
-    { { -1663, -43, 600, 2170, 0 }, { 20, 0, -600, 0, 100 }, 0, 1 },
-    { { 1049, -1420, 175, 2111, -17 }, { 0, 0, 0, -334, 0 }, 0, 2 },
-    { { 0, 0, 50, 300, 25 }, { 0, 0, 0, 300, 0 }, 70, 2 },
-    { { -473, -953, 3500, -353, -350 }, { 0, 0, -2800, 0, 0 }, 0, 2 },
-    { { 191, 1938, 35, 1139, -17 }, { 1205, -2909, 0, 0, 0 }, 0, 2 },
-    { { -1449, -2700, 150, 0, 0 }, { 0, 2000, 0, 0, 0 }, 0, 2 },
-    { { 5273, 4992, 650, 373, -50 }, { -4598, -3072, 0, 0, 0 }, 0, 2 },
-    { { 3223, -3282, 1075, -393, -25 }, { 1649, -1649, 0, 0, 0 }, 0, 2 }
-};
-#define CAMTRACK_COUNT (sizeof(camTracks) / sizeof(camTracks[0]))
-
-
-#endif // !CAMS_H_INCLUDED
diff --git a/opengl/tests/angeles/demo.c b/opengl/tests/angeles/demo.c
deleted file mode 100644
index 30c3202bd4..0000000000
--- a/opengl/tests/angeles/demo.c
+++ /dev/null
@@ -1,792 +0,0 @@
-/* San Angeles Observation OpenGL ES version example
- * Copyright 2004-2005 Jetro Lauha
- * All rights reserved.
- * Web: http://iki.fi/jetro/
- *
- * This source is free software; you can redistribute it and/or
- * modify it under the terms of EITHER:
- *   (1) The GNU Lesser General Public License as published by the Free
- *       Software Foundation; either version 2.1 of the License, or (at
- *       your option) any later version. The text of the GNU Lesser
- *       General Public License is included with this source in the
- *       file LICENSE-LGPL.txt.
- *   (2) The BSD-style license that is included with this source in
- *       the file LICENSE-BSD.txt.
- *
- * This source is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
- * LICENSE-LGPL.txt and LICENSE-BSD.txt for more details.
- *
- * $Id: demo.c,v 1.10 2005/02/08 20:54:39 tonic Exp $
- * $Revision: 1.10 $
- */
-
-#include <stdlib.h>
-#include <math.h>
-#include <float.h>
-#include <assert.h>
-
-#include <GLES/gl.h>
-
-#include "app.h"
-#include "shapes.h"
-#include "cams.h"
-
-
-// Total run length is 20 * camera track base unit length (see cams.h).
-#define RUN_LENGTH  (20 * CAMTRACK_LEN)
-#undef PI
-#define PI 3.1415926535897932f
-#define RANDOM_UINT_MAX 65535
-
-
-static unsigned long sRandomSeed = 0;
-
-static void seedRandom(unsigned long seed)
-{
-    sRandomSeed = seed;
-}
-
-static unsigned long randomUInt()
-{
-    sRandomSeed = sRandomSeed * 0x343fd + 0x269ec3;
-    return sRandomSeed >> 16;
-}
-
-
-// Capped conversion from float to fixed.
-static long floatToFixed(float value)
-{
-    if (value < -32768) value = -32768;
-    if (value > 32767) value = 32767;
-    return (long)(value * 65536);
-}
-
-#define FIXED(value) floatToFixed(value)
-
-
-// Definition of one GL object in this demo.
-typedef struct {
-    /* Vertex array and color array are enabled for all objects, so their
-     * pointers must always be valid and non-NULL. Normal array is not
-     * used by the ground plane, so when its pointer is NULL then normal
-     * array usage is disabled.
-     *
-     * Vertex array is supposed to use GL_FIXED datatype and stride 0
-     * (i.e. tightly packed array). Color array is supposed to have 4
-     * components per color with GL_UNSIGNED_BYTE datatype and stride 0.
-     * Normal array is supposed to use GL_FIXED datatype and stride 0.
-     */
-    GLfixed *vertexArray;
-    GLubyte *colorArray;
-    GLfixed *normalArray;
-    GLint vertexComponents;
-    GLsizei count;
-} GLOBJECT;
-
-
-static long sStartTick = 0;
-static long sTick = 0;
-
-static int sCurrentCamTrack = 0;
-static long sCurrentCamTrackStartTick = 0;
-static long sNextCamTrackStartTick = 0x7fffffff;
-
-static GLOBJECT *sSuperShapeObjects[SUPERSHAPE_COUNT] = { NULL };
-static GLOBJECT *sGroundPlane = NULL;
-
-
-typedef struct {
-    float x, y, z;
-} VECTOR3;
-
-
-static void freeGLObject(GLOBJECT *object)
-{
-    if (object == NULL)
-        return;
-    free(object->normalArray);
-    free(object->colorArray);
-    free(object->vertexArray);
-    free(object);
-}
-
-
-static GLOBJECT * newGLObject(long vertices, int vertexComponents,
-                              int useNormalArray)
-{
-    GLOBJECT *result;
-    result = (GLOBJECT *)malloc(sizeof(GLOBJECT));
-    if (result == NULL)
-        return NULL;
-    result->count = vertices;
-    result->vertexComponents = vertexComponents;
-    result->vertexArray = (GLfixed *)malloc(vertices * vertexComponents *
-                                            sizeof(GLfixed));
-    result->colorArray = (GLubyte *)malloc(vertices * 4 * sizeof(GLubyte));
-    if (useNormalArray)
-    {
-        result->normalArray = (GLfixed *)malloc(vertices * 3 *
-                                                sizeof(GLfixed));
-    }
-    else
-        result->normalArray = NULL;
-    if (result->vertexArray == NULL ||
-        result->colorArray == NULL ||
-        (useNormalArray && result->normalArray == NULL))
-    {
-        freeGLObject(result);
-        return NULL;
-    }
-    return result;
-}
-
-
-static void drawGLObject(GLOBJECT *object)
-{
-    assert(object != NULL);
-
-    glVertexPointer(object->vertexComponents, GL_FIXED,
-                    0, object->vertexArray);
-    glColorPointer(4, GL_UNSIGNED_BYTE, 0, object->colorArray);
-
-    // Already done in initialization:
-    //glEnableClientState(GL_VERTEX_ARRAY);
-    //glEnableClientState(GL_COLOR_ARRAY);
-
-    if (object->normalArray)
-    {
-        glNormalPointer(GL_FIXED, 0, object->normalArray);
-        glEnableClientState(GL_NORMAL_ARRAY);
-    }
-    else
-        glDisableClientState(GL_NORMAL_ARRAY);
-    glDrawArrays(GL_TRIANGLES, 0, object->count);
-}
-
-
-static void vector3Sub(VECTOR3 *dest, VECTOR3 *v1, VECTOR3 *v2)
-{
-    dest->x = v1->x - v2->x;
-    dest->y = v1->y - v2->y;
-    dest->z = v1->z - v2->z;
-}
-
-
-static void superShapeMap(VECTOR3 *point, float r1, float r2, float t, float p)
-{
-    // sphere-mapping of supershape parameters
-    point->x = (float)(cos(t) * cos(p) / r1 / r2);
-    point->y = (float)(sin(t) * cos(p) / r1 / r2);
-    point->z = (float)(sin(p) / r2);
-}
-
-
-static float ssFunc(const float t, const float *p)
-{
-    return (float)(pow(pow(fabs(cos(p[0] * t / 4)) / p[1], p[4]) +
-                       pow(fabs(sin(p[0] * t / 4)) / p[2], p[5]), 1 / p[3]));
-}
-
-
-// Creates and returns a supershape object.
-// Based on Paul Bourke's POV-Ray implementation.
-// http://astronomy.swin.edu.au/~pbourke/povray/supershape/
-static GLOBJECT * createSuperShape(const float *params)
-{
-    const int resol1 = (int)params[SUPERSHAPE_PARAMS - 3];
-    const int resol2 = (int)params[SUPERSHAPE_PARAMS - 2];
-    // latitude 0 to pi/2 for no mirrored bottom
-    // (latitudeBegin==0 for -pi/2 to pi/2 originally)
-    const int latitudeBegin = resol2 / 4;
-    const int latitudeEnd = resol2 / 2;    // non-inclusive
-    const int longitudeCount = resol1;
-    const int latitudeCount = latitudeEnd - latitudeBegin;
-    const long triangleCount = longitudeCount * latitudeCount * 2;
-    const long vertices = triangleCount * 3;
-    GLOBJECT *result;
-    float baseColor[3];
-    int a, longitude, latitude;
-    long currentVertex, currentQuad;
-
-    result = newGLObject(vertices, 3, 1);
-    if (result == NULL)
-        return NULL;
-
-    for (a = 0; a < 3; ++a)
-        baseColor[a] = ((randomUInt() % 155) + 100) / 255.f;
-
-    currentQuad = 0;
-    currentVertex = 0;
-
-    // longitude -pi to pi
-    for (longitude = 0; longitude < longitudeCount; ++longitude)
-    {
-
-        // latitude 0 to pi/2
-        for (latitude = latitudeBegin; latitude < latitudeEnd; ++latitude)
-        {
-            float t1 = -PI + longitude * 2 * PI / resol1;
-            float t2 = -PI + (longitude + 1) * 2 * PI / resol1;
-            float p1 = -PI / 2 + latitude * 2 * PI / resol2;
-            float p2 = -PI / 2 + (latitude + 1) * 2 * PI / resol2;
-            float r0, r1, r2, r3;
-
-            r0 = ssFunc(t1, params);
-            r1 = ssFunc(p1, &params[6]);
-            r2 = ssFunc(t2, params);
-            r3 = ssFunc(p2, &params[6]);
-
-            if (r0 != 0 && r1 != 0 && r2 != 0 && r3 != 0)
-            {
-                VECTOR3 pa, pb, pc, pd;
-                VECTOR3 v1, v2, n;
-                float ca;
-                int i;
-                //float lenSq, invLenSq;
-
-                superShapeMap(&pa, r0, r1, t1, p1);
-                superShapeMap(&pb, r2, r1, t2, p1);
-                superShapeMap(&pc, r2, r3, t2, p2);
-                superShapeMap(&pd, r0, r3, t1, p2);
-
-                // kludge to set lower edge of the object to fixed level
-                if (latitude == latitudeBegin + 1)
-                    pa.z = pb.z = 0;
-
-                vector3Sub(&v1, &pb, &pa);
-                vector3Sub(&v2, &pd, &pa);
-
-                // Calculate normal with cross product.
-                /*   i    j    k      i    j
-                 * v1.x v1.y v1.z | v1.x v1.y
-                 * v2.x v2.y v2.z | v2.x v2.y
-                 */
-
-                n.x = v1.y * v2.z - v1.z * v2.y;
-                n.y = v1.z * v2.x - v1.x * v2.z;
-                n.z = v1.x * v2.y - v1.y * v2.x;
-
-                /* Pre-normalization of the normals is disabled here because
-                 * they will be normalized anyway later due to automatic
-                 * normalization (GL_NORMALIZE). It is enabled because the
-                 * objects are scaled with glScale.
-                 */
-                /*
-                lenSq = n.x * n.x + n.y * n.y + n.z * n.z;
-                invLenSq = (float)(1 / sqrt(lenSq));
-                n.x *= invLenSq;
-                n.y *= invLenSq;
-                n.z *= invLenSq;
-                */
-
-                ca = pa.z + 0.5f;
-
-                for (i = currentVertex * 3;
-                     i < (currentVertex + 6) * 3;
-                     i += 3)
-                {
-                    result->normalArray[i] = FIXED(n.x);
-                    result->normalArray[i + 1] = FIXED(n.y);
-                    result->normalArray[i + 2] = FIXED(n.z);
-                }
-                for (i = currentVertex * 4;
-                     i < (currentVertex + 6) * 4;
-                     i += 4)
-                {
-                    int a, color[3];
-                    for (a = 0; a < 3; ++a)
-                    {
-                        color[a] = (int)(ca * baseColor[a] * 255);
-                        if (color[a] > 255) color[a] = 255;
-                    }
-                    result->colorArray[i] = (GLubyte)color[0];
-                    result->colorArray[i + 1] = (GLubyte)color[1];
-                    result->colorArray[i + 2] = (GLubyte)color[2];
-                    result->colorArray[i + 3] = 0;
-                }
-                result->vertexArray[currentVertex * 3] = FIXED(pa.x);
-                result->vertexArray[currentVertex * 3 + 1] = FIXED(pa.y);
-                result->vertexArray[currentVertex * 3 + 2] = FIXED(pa.z);
-                ++currentVertex;
-                result->vertexArray[currentVertex * 3] = FIXED(pb.x);
-                result->vertexArray[currentVertex * 3 + 1] = FIXED(pb.y);
-                result->vertexArray[currentVertex * 3 + 2] = FIXED(pb.z);
-                ++currentVertex;
-                result->vertexArray[currentVertex * 3] = FIXED(pd.x);
-                result->vertexArray[currentVertex * 3 + 1] = FIXED(pd.y);
-                result->vertexArray[currentVertex * 3 + 2] = FIXED(pd.z);
-                ++currentVertex;
-                result->vertexArray[currentVertex * 3] = FIXED(pb.x);
-                result->vertexArray[currentVertex * 3 + 1] = FIXED(pb.y);
-                result->vertexArray[currentVertex * 3 + 2] = FIXED(pb.z);
-                ++currentVertex;
-                result->vertexArray[currentVertex * 3] = FIXED(pc.x);
-                result->vertexArray[currentVertex * 3 + 1] = FIXED(pc.y);
-                result->vertexArray[currentVertex * 3 + 2] = FIXED(pc.z);
-                ++currentVertex;
-                result->vertexArray[currentVertex * 3] = FIXED(pd.x);
-                result->vertexArray[currentVertex * 3 + 1] = FIXED(pd.y);
-                result->vertexArray[currentVertex * 3 + 2] = FIXED(pd.z);
-                ++currentVertex;
-            } // r0 && r1 && r2 && r3
-            ++currentQuad;
-        } // latitude
-    } // longitude
-
-    // Set number of vertices in object to the actual amount created.
-    result->count = currentVertex;
-
-    return result;
-}
-
-
-static GLOBJECT * createGroundPlane()
-{
-    const int scale = 4;
-    const int yBegin = -15, yEnd = 15;    // ends are non-inclusive
-    const int xBegin = -15, xEnd = 15;
-    const long triangleCount = (yEnd - yBegin) * (xEnd - xBegin) * 2;
-    const long vertices = triangleCount * 3;
-    GLOBJECT *result;
-    int x, y;
-    long currentVertex, currentQuad;
-
-    result = newGLObject(vertices, 2, 0);
-    if (result == NULL)
-        return NULL;
-
-    currentQuad = 0;
-    currentVertex = 0;
-
-    for (y = yBegin; y < yEnd; ++y)
-    {
-        for (x = xBegin; x < xEnd; ++x)
-        {
-            GLubyte color;
-            int i, a;
-            color = (GLubyte)((randomUInt() & 0x5f) + 81);  // 101 1111
-            for (i = currentVertex * 4; i < (currentVertex + 6) * 4; i += 4)
-            {
-                result->colorArray[i] = color;
-                result->colorArray[i + 1] = color;
-                result->colorArray[i + 2] = color;
-                result->colorArray[i + 3] = 0;
-            }
-
-            // Axis bits for quad triangles:
-            // x: 011100 (0x1c), y: 110001 (0x31)  (clockwise)
-            // x: 001110 (0x0e), y: 100011 (0x23)  (counter-clockwise)
-            for (a = 0; a < 6; ++a)
-            {
-                const int xm = x + ((0x1c >> a) & 1);
-                const int ym = y + ((0x31 >> a) & 1);
-                const float m = (float)(cos(xm * 2) * sin(ym * 4) * 0.75f);
-                result->vertexArray[currentVertex * 2] =
-                    FIXED(xm * scale + m);
-                result->vertexArray[currentVertex * 2 + 1] =
-                    FIXED(ym * scale + m);
-                ++currentVertex;
-            }
-            ++currentQuad;
-        }
-    }
-    return result;
-}
-
-
-static void drawGroundPlane()
-{
-    glDisable(GL_CULL_FACE);
-    glDisable(GL_DEPTH_TEST);
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_ZERO, GL_SRC_COLOR);
-    glDisable(GL_LIGHTING);
-
-    drawGLObject(sGroundPlane);
-
-    glEnable(GL_LIGHTING);
-    glDisable(GL_BLEND);
-    glEnable(GL_DEPTH_TEST);
-}
-
-
-static void drawFadeQuad()
-{
-    static const GLfixed quadVertices[] = {
-        -0x10000, -0x10000,
-         0x10000, -0x10000,
-        -0x10000,  0x10000,
-         0x10000, -0x10000,
-         0x10000,  0x10000,
-        -0x10000,  0x10000
-    };
-
-    const int beginFade = sTick - sCurrentCamTrackStartTick;
-    const int endFade = sNextCamTrackStartTick - sTick;
-    const int minFade = beginFade < endFade ? beginFade : endFade;
-
-    if (minFade < 1024)
-    {
-        const GLfixed fadeColor = minFade << 6;
-        glColor4x(fadeColor, fadeColor, fadeColor, 0);
-
-        glDisable(GL_DEPTH_TEST);
-        glEnable(GL_BLEND);
-        glBlendFunc(GL_ZERO, GL_SRC_COLOR);
-        glDisable(GL_LIGHTING);
-
-        glMatrixMode(GL_MODELVIEW);
-        glLoadIdentity();
-
-        glMatrixMode(GL_PROJECTION);
-        glLoadIdentity();
-
-        glDisableClientState(GL_COLOR_ARRAY);
-        glDisableClientState(GL_NORMAL_ARRAY);
-        glVertexPointer(2, GL_FIXED, 0, quadVertices);
-        glDrawArrays(GL_TRIANGLES, 0, 6);
-
-        glEnableClientState(GL_COLOR_ARRAY);
-
-        glMatrixMode(GL_MODELVIEW);
-
-        glEnable(GL_LIGHTING);
-        glDisable(GL_BLEND);
-        glEnable(GL_DEPTH_TEST);
-    }
-}
-
-
-// Called from the app framework.
-void appInit()
-{
-    unsigned int a;
-
-    glEnable(GL_NORMALIZE);
-    glEnable(GL_DEPTH_TEST);
-    glDisable(GL_CULL_FACE);
-    glShadeModel(GL_FLAT);
-
-    glEnable(GL_LIGHTING);
-    glEnable(GL_LIGHT0);
-    glEnable(GL_LIGHT1);
-    glEnable(GL_LIGHT2);
-
-    glEnableClientState(GL_VERTEX_ARRAY);
-    glEnableClientState(GL_COLOR_ARRAY);
-
-    seedRandom(15);
-
-    for (a = 0; a < SUPERSHAPE_COUNT; ++a)
-    {
-        sSuperShapeObjects[a] = createSuperShape(sSuperShapeParams[a]);
-        assert(sSuperShapeObjects[a] != NULL);
-    }
-    sGroundPlane = createGroundPlane();
-    assert(sGroundPlane != NULL);
-}
-
-
-// Called from the app framework.
-void appDeinit()
-{
-    unsigned int a;
-    for (a = 0; a < SUPERSHAPE_COUNT; ++a)
-        freeGLObject(sSuperShapeObjects[a]);
-    freeGLObject(sGroundPlane);
-}
-
-
-static void gluPerspective(GLfloat fovy, GLfloat aspect,
-                           GLfloat zNear, GLfloat zFar)
-{
-    GLfloat xmin, xmax, ymin, ymax;
-
-    ymax = zNear * (GLfloat)tan(fovy * PI / 360);
-    ymin = -ymax;
-    xmin = ymin * aspect;
-    xmax = ymax * aspect;
-
-    glFrustumx((GLfixed)(xmin * 65536), (GLfixed)(xmax * 65536),
-               (GLfixed)(ymin * 65536), (GLfixed)(ymax * 65536),
-               (GLfixed)(zNear * 65536), (GLfixed)(zFar * 65536));
-}
-
-
-static void prepareFrame(int width, int height)
-{
-    glViewport(0, 0, width, height);
-
-    glClearColorx((GLfixed)(0.1f * 65536),
-                  (GLfixed)(0.2f * 65536),
-                  (GLfixed)(0.3f * 65536), 0x10000);
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    gluPerspective(45, (float)width / height, 0.5f, 150);
-
-    glMatrixMode(GL_MODELVIEW);
-
-    glLoadIdentity();
-}
-
-
-static void configureLightAndMaterial()
-{
-    static GLfixed light0Position[] = { -0x40000, 0x10000, 0x10000, 0 };
-    static GLfixed light0Diffuse[] = { 0x10000, 0x6666, 0, 0x10000 };
-    static GLfixed light1Position[] = { 0x10000, -0x20000, -0x10000, 0 };
-    static GLfixed light1Diffuse[] = { 0x11eb, 0x23d7, 0x5999, 0x10000 };
-    static GLfixed light2Position[] = { -0x10000, 0, -0x40000, 0 };
-    static GLfixed light2Diffuse[] = { 0x11eb, 0x2b85, 0x23d7, 0x10000 };
-    static GLfixed materialSpecular[] = { 0x10000, 0x10000, 0x10000, 0x10000 };
-
-    glLightxv(GL_LIGHT0, GL_POSITION, light0Position);
-    glLightxv(GL_LIGHT0, GL_DIFFUSE, light0Diffuse);
-    glLightxv(GL_LIGHT1, GL_POSITION, light1Position);
-    glLightxv(GL_LIGHT1, GL_DIFFUSE, light1Diffuse);
-    glLightxv(GL_LIGHT2, GL_POSITION, light2Position);
-    glLightxv(GL_LIGHT2, GL_DIFFUSE, light2Diffuse);
-    glMaterialxv(GL_FRONT_AND_BACK, GL_SPECULAR, materialSpecular);
-
-    glMaterialx(GL_FRONT_AND_BACK, GL_SHININESS, 60 << 16);
-    glEnable(GL_COLOR_MATERIAL);
-}
-
-
-static void drawModels(float zScale)
-{
-    const int translationScale = 9;
-    int x, y;
-
-    seedRandom(9);
-
-    glScalex(1 << 16, 1 << 16, (GLfixed)(zScale * 65536));
-
-    for (y = -5; y <= 5; ++y)
-    {
-        for (x = -5; x <= 5; ++x)
-        {
-            float buildingScale;
-            GLfixed fixedScale;
-
-            int curShape = randomUInt() % SUPERSHAPE_COUNT;
-            buildingScale = sSuperShapeParams[curShape][SUPERSHAPE_PARAMS - 1];
-            fixedScale = (GLfixed)(buildingScale * 65536);
-
-            glPushMatrix();
-            glTranslatex((x * translationScale) * 65536,
-                         (y * translationScale) * 65536,
-                         0);
-            glRotatex((GLfixed)((randomUInt() % 360) << 16), 0, 0, 1 << 16);
-            glScalex(fixedScale, fixedScale, fixedScale);
-
-            drawGLObject(sSuperShapeObjects[curShape]);
-            glPopMatrix();
-        }
-    }
-
-    for (x = -2; x <= 2; ++x)
-    {
-        const int shipScale100 = translationScale * 500;
-        const int offs100 = x * shipScale100 + (sTick % shipScale100);
-        float offs = offs100 * 0.01f;
-        GLfixed fixedOffs = (GLfixed)(offs * 65536);
-        glPushMatrix();
-        glTranslatex(fixedOffs, -4 * 65536, 2 << 16);
-        drawGLObject(sSuperShapeObjects[SUPERSHAPE_COUNT - 1]);
-        glPopMatrix();
-        glPushMatrix();
-        glTranslatex(-4 * 65536, fixedOffs, 4 << 16);
-        glRotatex(90 << 16, 0, 0, 1 << 16);
-        drawGLObject(sSuperShapeObjects[SUPERSHAPE_COUNT - 1]);
-        glPopMatrix();
-    }
-}
-
-
-/* Following gluLookAt implementation is adapted from the
- * Mesa 3D Graphics library. http://www.mesa3d.org
- */
-static void gluLookAt(GLfloat eyex, GLfloat eyey, GLfloat eyez,
-	              GLfloat centerx, GLfloat centery, GLfloat centerz,
-	              GLfloat upx, GLfloat upy, GLfloat upz)
-{
-    GLfloat m[16];
-    GLfloat x[3], y[3], z[3];
-    GLfloat mag;
-
-    /* Make rotation matrix */
-
-    /* Z vector */
-    z[0] = eyex - centerx;
-    z[1] = eyey - centery;
-    z[2] = eyez - centerz;
-    mag = (float)sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);
-    if (mag) {			/* mpichler, 19950515 */
-        z[0] /= mag;
-        z[1] /= mag;
-        z[2] /= mag;
-    }
-
-    /* Y vector */
-    y[0] = upx;
-    y[1] = upy;
-    y[2] = upz;
-
-    /* X vector = Y cross Z */
-    x[0] = y[1] * z[2] - y[2] * z[1];
-    x[1] = -y[0] * z[2] + y[2] * z[0];
-    x[2] = y[0] * z[1] - y[1] * z[0];
-
-    /* Recompute Y = Z cross X */
-    y[0] = z[1] * x[2] - z[2] * x[1];
-    y[1] = -z[0] * x[2] + z[2] * x[0];
-    y[2] = z[0] * x[1] - z[1] * x[0];
-
-    /* mpichler, 19950515 */
-    /* cross product gives area of parallelogram, which is < 1.0 for
-     * non-perpendicular unit-length vectors; so normalize x, y here
-     */
-
-    mag = (float)sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
-    if (mag) {
-        x[0] /= mag;
-        x[1] /= mag;
-        x[2] /= mag;
-    }
-
-    mag = (float)sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);
-    if (mag) {
-        y[0] /= mag;
-        y[1] /= mag;
-        y[2] /= mag;
-    }
-
-#define M(row,col)  m[(col)*4+(row)]
-    M(0, 0) = x[0];
-    M(0, 1) = x[1];
-    M(0, 2) = x[2];
-    M(0, 3) = 0.0;
-    M(1, 0) = y[0];
-    M(1, 1) = y[1];
-    M(1, 2) = y[2];
-    M(1, 3) = 0.0;
-    M(2, 0) = z[0];
-    M(2, 1) = z[1];
-    M(2, 2) = z[2];
-    M(2, 3) = 0.0;
-    M(3, 0) = 0.0;
-    M(3, 1) = 0.0;
-    M(3, 2) = 0.0;
-    M(3, 3) = 1.0;
-#undef M
-    {
-        int a;
-        GLfixed fixedM[16];
-        for (a = 0; a < 16; ++a)
-            fixedM[a] = (GLfixed)(m[a] * 65536);
-        glMultMatrixx(fixedM);
-    }
-
-    /* Translate Eye to Origin */
-    glTranslatex((GLfixed)(-eyex * 65536),
-                 (GLfixed)(-eyey * 65536),
-                 (GLfixed)(-eyez * 65536));
-}
-
-
-static void camTrack()
-{
-    float lerp[5];
-    float eX, eY, eZ, cX, cY, cZ;
-    float trackPos;
-    CAMTRACK *cam;
-    long currentCamTick;
-    int a;
-
-    if (sNextCamTrackStartTick <= sTick)
-    {
-        ++sCurrentCamTrack;
-        sCurrentCamTrackStartTick = sNextCamTrackStartTick;
-    }
-    sNextCamTrackStartTick = sCurrentCamTrackStartTick +
-                             sCamTracks[sCurrentCamTrack].len * CAMTRACK_LEN;
-
-    cam = &sCamTracks[sCurrentCamTrack];
-    currentCamTick = sTick - sCurrentCamTrackStartTick;
-    trackPos = (float)currentCamTick / (CAMTRACK_LEN * cam->len);
-
-    for (a = 0; a < 5; ++a)
-        lerp[a] = (cam->src[a] + cam->dest[a] * trackPos) * 0.01f;
-
-    if (cam->dist)
-    {
-        float dist = cam->dist * 0.1f;
-        cX = lerp[0];
-        cY = lerp[1];
-        cZ = lerp[2];
-        eX = cX - (float)cos(lerp[3]) * dist;
-        eY = cY - (float)sin(lerp[3]) * dist;
-        eZ = cZ - lerp[4];
-    }
-    else
-    {
-        eX = lerp[0];
-        eY = lerp[1];
-        eZ = lerp[2];
-        cX = eX + (float)cos(lerp[3]);
-        cY = eY + (float)sin(lerp[3]);
-        cZ = eZ + lerp[4];
-    }
-    gluLookAt(eX, eY, eZ, cX, cY, cZ, 0, 0, 1);
-}
-
-
-// Called from the app framework.
-/* The tick is current time in milliseconds, width and height
- * are the image dimensions to be rendered.
- */
-void appRender(long tick, int width, int height)
-{
-    if (sStartTick == 0)
-        sStartTick = tick;
-    if (!gAppAlive)
-        return;
-
-    // Actual tick value is "blurred" a little bit.
-    sTick = (sTick + tick - sStartTick) >> 1;
-
-    // Terminate application after running through the demonstration once.
-    if (sTick >= RUN_LENGTH)
-    {
-        gAppAlive = 0;
-        return;
-    }
-
-    // Prepare OpenGL ES for rendering of the frame.
-    prepareFrame(width, height);
-
-    // Update the camera position and set the lookat.
-    camTrack();
-
-    // Configure environment.
-    configureLightAndMaterial();
-
-    // Draw the reflection by drawing models with negated Z-axis.
-    glPushMatrix();
-    drawModels(-1);
-    glPopMatrix();
-
-    // Blend the ground plane to the window.
-    drawGroundPlane();
-
-    // Draw all the models normally.
-    drawModels(1);
-
-    // Draw fade quad over whole window (when changing cameras).
-    drawFadeQuad();
-}
diff --git a/opengl/tests/angeles/include/GLES/egl.h b/opengl/tests/angeles/include/GLES/egl.h
deleted file mode 100644
index cdf8410833..0000000000
--- a/opengl/tests/angeles/include/GLES/egl.h
+++ /dev/null
@@ -1,229 +0,0 @@
-#ifndef __egl_h_
-#define __egl_h_
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.0 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-**
-** http://oss.sgi.com/projects/FreeB
-**
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-**
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2004 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-**
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-*/
-
-#include <GLES/gl.h>
-#include <GLES/egltypes.h>
-
-/*
-** egltypes.h is platform dependent. It defines:
-**
-**     - EGL types and resources
-**     - Native types
-**     - EGL and native handle values
-**
-** EGL types and resources are to be typedef'ed with appropriate platform
-** dependent resource handle types. EGLint must be an integer of at least
-** 32-bit.
-**
-** NativeDisplayType, NativeWindowType and NativePixmapType are to be
-** replaced with corresponding types of the native window system in egl.h.
-**
-** EGL and native handle values must match their types.
-**
-** Example egltypes.h:
-*/
-
-#if 0
-
-#include <sys/types.h>
-#include <native_window_system.h>
-
-/*
-** Types and resources
-*/
-typedef int EGLBoolean;
-typedef int32_t EGLint;
-typedef void *EGLDisplay;
-typedef void *EGLConfig;
-typedef void *EGLSurface;
-typedef void *EGLContext;
-
-/*
-** EGL and native handle values
-*/
-#define EGL_DEFAULT_DISPLAY ((NativeDisplayType)0)
-#define EGL_NO_CONTEXT ((EGLContext)0)
-#define EGL_NO_DISPLAY ((EGLDisplay)0)
-#define EGL_NO_SURFACE ((EGLSurface)0)
-
-#endif
-
-/*
-** Versioning and extensions
-*/
-#define EGL_VERSION_1_0		       1
-
-/*
-** Boolean
-*/
-#define EGL_FALSE		       0
-#define EGL_TRUE		       1
-
-/*
-** Errors
-*/
-#define EGL_SUCCESS		       0x3000
-#define EGL_NOT_INITIALIZED	       0x3001
-#define EGL_BAD_ACCESS		       0x3002
-#define EGL_BAD_ALLOC		       0x3003
-#define EGL_BAD_ATTRIBUTE	       0x3004
-#define EGL_BAD_CONFIG		       0x3005
-#define EGL_BAD_CONTEXT		       0x3006
-#define EGL_BAD_CURRENT_SURFACE        0x3007
-#define EGL_BAD_DISPLAY		       0x3008
-#define EGL_BAD_MATCH		       0x3009
-#define EGL_BAD_NATIVE_PIXMAP	       0x300A
-#define EGL_BAD_NATIVE_WINDOW	       0x300B
-#define EGL_BAD_PARAMETER	       0x300C
-#define EGL_BAD_SURFACE		       0x300D
-/* 0x300E - 0x301F reserved for additional errors. */
-
-/*
-** Config attributes
-*/
-#define EGL_BUFFER_SIZE		       0x3020
-#define EGL_ALPHA_SIZE		       0x3021
-#define EGL_BLUE_SIZE		       0x3022
-#define EGL_GREEN_SIZE		       0x3023
-#define EGL_RED_SIZE		       0x3024
-#define EGL_DEPTH_SIZE		       0x3025
-#define EGL_STENCIL_SIZE	       0x3026
-#define EGL_CONFIG_CAVEAT	       0x3027
-#define EGL_CONFIG_ID		       0x3028
-#define EGL_LEVEL		       0x3029
-#define EGL_MAX_PBUFFER_HEIGHT	       0x302A
-#define EGL_MAX_PBUFFER_PIXELS	       0x302B
-#define EGL_MAX_PBUFFER_WIDTH	       0x302C
-#define EGL_NATIVE_RENDERABLE	       0x302D
-#define EGL_NATIVE_VISUAL_ID	       0x302E
-#define EGL_NATIVE_VISUAL_TYPE	       0x302F
-/*#define EGL_PRESERVED_RESOURCES	 0x3030*/
-#define EGL_SAMPLES		       0x3031
-#define EGL_SAMPLE_BUFFERS	       0x3032
-#define EGL_SURFACE_TYPE	       0x3033
-#define EGL_TRANSPARENT_TYPE	       0x3034
-#define EGL_TRANSPARENT_BLUE_VALUE     0x3035
-#define EGL_TRANSPARENT_GREEN_VALUE    0x3036
-#define EGL_TRANSPARENT_RED_VALUE      0x3037
-
-/*
-** Config attribute and value
-*/
-#define EGL_NONE		       0x3038
-/* 0x3039 - 0x304F reserved for additional config attributes. */
-
-/*
-** Config values
-*/
-#define EGL_DONT_CARE		       ((EGLint) -1)
-#define EGL_PBUFFER_BIT		       0x01
-#define EGL_PIXMAP_BIT		       0x02
-#define EGL_WINDOW_BIT		       0x04
-#define EGL_SLOW_CONFIG		       0x3050
-#define EGL_NON_CONFORMANT_CONFIG      0x3051
-#define EGL_TRANSPARENT_RGB	       0x3052
-
-/*
-** String names
-*/
-#define EGL_VENDOR		       0x3053
-#define EGL_VERSION		       0x3054
-#define EGL_EXTENSIONS		       0x3055
-
-/*
-** Surface attributes
-*/
-#define EGL_HEIGHT		       0x3056
-#define EGL_WIDTH		       0x3057
-#define EGL_LARGEST_PBUFFER	       0x3058
-
-/*
-** Current surfaces
-*/
-#define EGL_DRAW		       0x3059
-#define EGL_READ		       0x305A
-
-/*
-** Engines
-*/
-#define EGL_CORE_NATIVE_ENGINE	       0x305B
-
-/* 0x305C-0x3FFFF reserved for future use */
-
-/*
-** Functions
-*/
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-GLAPI EGLint APIENTRY eglGetError (void);
-
-GLAPI EGLDisplay APIENTRY eglGetDisplay (NativeDisplayType display);
-GLAPI EGLBoolean APIENTRY eglInitialize (EGLDisplay dpy, EGLint *major, EGLint *minor);
-GLAPI EGLBoolean APIENTRY eglTerminate (EGLDisplay dpy);
-GLAPI const char * APIENTRY eglQueryString (EGLDisplay dpy, EGLint name);
-GLAPI void (* APIENTRY eglGetProcAddress (const char *procname))();
-
-GLAPI EGLBoolean APIENTRY eglGetConfigs (EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config);
-GLAPI EGLBoolean APIENTRY eglChooseConfig (EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config);
-GLAPI EGLBoolean APIENTRY eglGetConfigAttrib (EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value);
-
-GLAPI EGLSurface APIENTRY eglCreateWindowSurface (EGLDisplay dpy, EGLConfig config, NativeWindowType window, const EGLint *attrib_list);
-GLAPI EGLSurface APIENTRY eglCreatePixmapSurface (EGLDisplay dpy, EGLConfig config, NativePixmapType pixmap, const EGLint *attrib_list);
-GLAPI EGLSurface APIENTRY eglCreatePbufferSurface (EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list);
-GLAPI EGLBoolean APIENTRY eglDestroySurface (EGLDisplay dpy, EGLSurface surface);
-GLAPI EGLBoolean APIENTRY eglQuerySurface (EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value);
-
-GLAPI EGLContext APIENTRY eglCreateContext (EGLDisplay dpy, EGLConfig config, EGLContext share_list, const EGLint *attrib_list);
-GLAPI EGLBoolean APIENTRY eglDestroyContext (EGLDisplay dpy, EGLContext ctx);
-GLAPI EGLBoolean APIENTRY eglMakeCurrent (EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
-GLAPI EGLContext APIENTRY eglGetCurrentContext (void);
-GLAPI EGLSurface APIENTRY eglGetCurrentSurface (EGLint readdraw);
-GLAPI EGLDisplay APIENTRY eglGetCurrentDisplay (void);
-GLAPI EGLBoolean APIENTRY eglQueryContext (EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value);
-
-GLAPI EGLBoolean APIENTRY eglWaitGL (void);
-GLAPI EGLBoolean APIENTRY eglWaitNative (EGLint engine);
-GLAPI EGLBoolean APIENTRY eglSwapBuffers (EGLDisplay dpy, EGLSurface draw);
-GLAPI EGLBoolean APIENTRY eglCopyBuffers (EGLDisplay dpy, EGLSurface surface, NativePixmapType target);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ___egl_h_ */
diff --git a/opengl/tests/angeles/include/GLES/egltypes.h b/opengl/tests/angeles/include/GLES/egltypes.h
deleted file mode 100644
index 9db36c9876..0000000000
--- a/opengl/tests/angeles/include/GLES/egltypes.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
-** Types and resources
-*/
-typedef int EGLBoolean;
-typedef long EGLint;
-typedef void *EGLDisplay;
-typedef void *EGLConfig;
-typedef void *EGLSurface;
-typedef void *EGLContext;
-typedef void *NativeDisplayType;
-typedef void *NativeWindowType;
-typedef void *NativePixmapType;
-
-/*
-** EGL and native handle values
-*/
-#define EGL_DEFAULT_DISPLAY ((NativeDisplayType)0)
-#define EGL_NO_CONTEXT ((EGLContext)0)
-#define EGL_NO_DISPLAY ((EGLDisplay)0)
-#define EGL_NO_SURFACE ((EGLSurface)0)
diff --git a/opengl/tests/angeles/include/GLES/gl.h b/opengl/tests/angeles/include/GLES/gl.h
deleted file mode 100644
index 415482228d..0000000000
--- a/opengl/tests/angeles/include/GLES/gl.h
+++ /dev/null
@@ -1,584 +0,0 @@
-#ifndef __gl_h_
-#define __gl_h_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-** License Applicability. Except to the extent portions of this file are
-** made subject to an alternative license as permitted in the SGI Free
-** Software License B, Version 1.0 (the "License"), the contents of this
-** file are subject only to the provisions of the License. You may not use
-** this file except in compliance with the License. You may obtain a copy
-** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
-** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
-** 
-** http://oss.sgi.com/projects/FreeB
-** 
-** Note that, as provided in the License, the Software is distributed on an
-** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
-** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
-** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
-** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
-** 
-** Original Code. The Original Code is: OpenGL Sample Implementation,
-** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
-** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
-** Copyright in any portions created by third parties is as indicated
-** elsewhere herein. All Rights Reserved.
-** 
-** Additional Notice Provisions: The application programming interfaces
-** established by SGI in conjunction with the Original Code are The
-** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
-** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
-** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
-** Window System(R) (Version 1.3), released October 19, 1998. This software
-** was created using the OpenGL(R) version 1.2.1 Sample Implementation
-** published by SGI, but has not been independently verified as being
-** compliant with the OpenGL(R) version 1.2.1 Specification.
-*/
-
-#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__)
-#define WIN32_LEAN_AND_MEAN 1
-#include <windows.h>
-#endif
-
-#ifndef APIENTRY
-#define APIENTRY
-#endif
-#ifndef GLAPI
-#define GLAPI extern
-#endif
-
-typedef unsigned int GLenum;
-typedef unsigned char GLboolean;
-typedef unsigned int GLbitfield;
-typedef signed char GLbyte;
-typedef short GLshort;
-typedef int GLint;
-typedef int GLsizei;
-typedef unsigned char GLubyte;
-typedef unsigned short GLushort;
-typedef unsigned int GLuint;
-typedef float GLfloat;
-typedef float GLclampf;
-typedef void GLvoid;
-typedef int GLintptrARB;
-typedef int GLsizeiptrARB;
-typedef int GLfixed;
-typedef int GLclampx;
-/* Internal convenience typedefs */
-typedef void (*_GLfuncptr)();
-
-/*************************************************************/
-
-/* Extensions */
-#define GL_OES_VERSION_1_0                1
-#define GL_OES_read_format                1
-#define GL_OES_compressed_paletted_texture 1
-
-/* ClearBufferMask */
-#define GL_DEPTH_BUFFER_BIT               0x00000100
-#define GL_STENCIL_BUFFER_BIT             0x00000400
-#define GL_COLOR_BUFFER_BIT               0x00004000
-
-/* Boolean */
-#define GL_FALSE                          0
-#define GL_TRUE                           1
-
-/* BeginMode */
-#define GL_POINTS                         0x0000
-#define GL_LINES                          0x0001
-#define GL_LINE_LOOP                      0x0002
-#define GL_LINE_STRIP                     0x0003
-#define GL_TRIANGLES                      0x0004
-#define GL_TRIANGLE_STRIP                 0x0005
-#define GL_TRIANGLE_FAN                   0x0006
-
-/* AlphaFunction */
-#define GL_NEVER                          0x0200
-#define GL_LESS                           0x0201
-#define GL_EQUAL                          0x0202
-#define GL_LEQUAL                         0x0203
-#define GL_GREATER                        0x0204
-#define GL_NOTEQUAL                       0x0205
-#define GL_GEQUAL                         0x0206
-#define GL_ALWAYS                         0x0207
-
-/* BlendingFactorDest */
-#define GL_ZERO                           0
-#define GL_ONE                            1
-#define GL_SRC_COLOR                      0x0300
-#define GL_ONE_MINUS_SRC_COLOR            0x0301
-#define GL_SRC_ALPHA                      0x0302
-#define GL_ONE_MINUS_SRC_ALPHA            0x0303
-#define GL_DST_ALPHA                      0x0304
-#define GL_ONE_MINUS_DST_ALPHA            0x0305
-
-/* BlendingFactorSrc */
-/*      GL_ZERO */
-/*      GL_ONE */
-#define GL_DST_COLOR                      0x0306
-#define GL_ONE_MINUS_DST_COLOR            0x0307
-#define GL_SRC_ALPHA_SATURATE             0x0308
-/*      GL_SRC_ALPHA */
-/*      GL_ONE_MINUS_SRC_ALPHA */
-/*      GL_DST_ALPHA */
-/*      GL_ONE_MINUS_DST_ALPHA */
-
-/* ColorMaterialFace */
-/*      GL_FRONT_AND_BACK */
-
-/* ColorMaterialParameter */
-/*      GL_AMBIENT_AND_DIFFUSE */
-
-/* ColorPointerType */
-/*      GL_UNSIGNED_BYTE */
-/*      GL_FLOAT */
-/*      GL_FIXED */
-
-/* CullFaceMode */
-#define GL_FRONT                          0x0404
-#define GL_BACK                           0x0405
-#define GL_FRONT_AND_BACK                 0x0408
-
-/* DepthFunction */
-/*      GL_NEVER */
-/*      GL_LESS */
-/*      GL_EQUAL */
-/*      GL_LEQUAL */
-/*      GL_GREATER */
-/*      GL_NOTEQUAL */
-/*      GL_GEQUAL */
-/*      GL_ALWAYS */
-
-/* EnableCap */
-#define GL_FOG                            0x0B60
-#define GL_LIGHTING                       0x0B50
-#define GL_TEXTURE_2D                     0x0DE1
-#define GL_CULL_FACE                      0x0B44
-#define GL_ALPHA_TEST                     0x0BC0
-#define GL_BLEND                          0x0BE2
-#define GL_COLOR_LOGIC_OP                 0x0BF2
-#define GL_DITHER                         0x0BD0
-#define GL_STENCIL_TEST                   0x0B90
-#define GL_DEPTH_TEST                     0x0B71
-/*      GL_LIGHT0 */
-/*      GL_LIGHT1 */
-/*      GL_LIGHT2 */
-/*      GL_LIGHT3 */
-/*      GL_LIGHT4 */
-/*      GL_LIGHT5 */
-/*      GL_LIGHT6 */
-/*      GL_LIGHT7 */
-#define GL_POINT_SMOOTH                   0x0B10
-#define GL_LINE_SMOOTH                    0x0B20
-#define GL_SCISSOR_TEST                   0x0C11
-#define GL_COLOR_MATERIAL                 0x0B57
-#define GL_NORMALIZE                      0x0BA1
-#define GL_RESCALE_NORMAL                 0x803A
-#define GL_POLYGON_OFFSET_FILL            0x8037
-#define GL_VERTEX_ARRAY                   0x8074
-#define GL_NORMAL_ARRAY                   0x8075
-#define GL_COLOR_ARRAY                    0x8076
-#define GL_TEXTURE_COORD_ARRAY            0x8078
-#define GL_MULTISAMPLE                    0x809D
-#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
-#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
-#define GL_SAMPLE_COVERAGE                0x80A0
-
-/* ErrorCode */
-#define GL_NO_ERROR                       0
-#define GL_INVALID_ENUM                   0x0500
-#define GL_INVALID_VALUE                  0x0501
-#define GL_INVALID_OPERATION              0x0502
-#define GL_STACK_OVERFLOW                 0x0503
-#define GL_STACK_UNDERFLOW                0x0504
-#define GL_OUT_OF_MEMORY                  0x0505
-
-/* FogMode */
-/*      GL_LINEAR */
-#define GL_EXP                            0x0800
-#define GL_EXP2                           0x0801
-
-/* FogParameter */
-#define GL_FOG_DENSITY                    0x0B62
-#define GL_FOG_START                      0x0B63
-#define GL_FOG_END                        0x0B64
-#define GL_FOG_MODE                       0x0B65
-#define GL_FOG_COLOR                      0x0B66
-
-/* FrontFaceDirection */
-#define GL_CW                             0x0900
-#define GL_CCW                            0x0901
-
-/* GetPName */
-#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
-#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
-#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
-#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
-#define GL_IMPLEMENTATION_COLOR_READ_TYPE_OES 0x8B9A
-#define GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES 0x8B9B
-#define GL_MAX_LIGHTS                     0x0D31
-#define GL_MAX_TEXTURE_SIZE               0x0D33
-#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
-#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
-#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
-#define GL_MAX_VIEWPORT_DIMS              0x0D3A
-#define GL_MAX_ELEMENTS_VERTICES          0x80E8
-#define GL_MAX_ELEMENTS_INDICES           0x80E9
-#define GL_MAX_TEXTURE_UNITS              0x84E2
-#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
-#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
-#define GL_SUBPIXEL_BITS                  0x0D50
-#define GL_RED_BITS                       0x0D52
-#define GL_GREEN_BITS                     0x0D53
-#define GL_BLUE_BITS                      0x0D54
-#define GL_ALPHA_BITS                     0x0D55
-#define GL_DEPTH_BITS                     0x0D56
-#define GL_STENCIL_BITS                   0x0D57
-
-/* HintMode */
-#define GL_DONT_CARE                      0x1100
-#define GL_FASTEST                        0x1101
-#define GL_NICEST                         0x1102
-
-/* HintTarget */
-#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
-#define GL_POINT_SMOOTH_HINT              0x0C51
-#define GL_LINE_SMOOTH_HINT               0x0C52
-#define GL_POLYGON_SMOOTH_HINT            0x0C53
-#define GL_FOG_HINT                       0x0C54
-
-/* LightModelParameter */
-#define GL_LIGHT_MODEL_AMBIENT            0x0B53
-#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
-
-/* LightParameter */
-#define GL_AMBIENT                        0x1200
-#define GL_DIFFUSE                        0x1201
-#define GL_SPECULAR                       0x1202
-#define GL_POSITION                       0x1203
-#define GL_SPOT_DIRECTION                 0x1204
-#define GL_SPOT_EXPONENT                  0x1205
-#define GL_SPOT_CUTOFF                    0x1206
-#define GL_CONSTANT_ATTENUATION           0x1207
-#define GL_LINEAR_ATTENUATION             0x1208
-#define GL_QUADRATIC_ATTENUATION          0x1209
-
-/* DataType */
-#define GL_BYTE                           0x1400
-#define GL_UNSIGNED_BYTE                  0x1401
-#define GL_SHORT                          0x1402
-#define GL_UNSIGNED_SHORT                 0x1403
-#define GL_FLOAT                          0x1406
-#define GL_FIXED                          0x140C
-
-/* LogicOp */
-#define GL_CLEAR                          0x1500
-#define GL_AND                            0x1501
-#define GL_AND_REVERSE                    0x1502
-#define GL_COPY                           0x1503
-#define GL_AND_INVERTED                   0x1504
-#define GL_NOOP                           0x1505
-#define GL_XOR                            0x1506
-#define GL_OR                             0x1507
-#define GL_NOR                            0x1508
-#define GL_EQUIV                          0x1509
-#define GL_INVERT                         0x150A
-#define GL_OR_REVERSE                     0x150B
-#define GL_COPY_INVERTED                  0x150C
-#define GL_OR_INVERTED                    0x150D
-#define GL_NAND                           0x150E
-#define GL_SET                            0x150F
-
-/* MaterialFace */
-/*      GL_FRONT_AND_BACK */
-
-/* MaterialParameter */
-#define GL_EMISSION                       0x1600
-#define GL_SHININESS                      0x1601
-#define GL_AMBIENT_AND_DIFFUSE            0x1602
-/*      GL_AMBIENT */
-/*      GL_DIFFUSE */
-/*      GL_SPECULAR */
-
-/* MatrixMode */
-#define GL_MODELVIEW                      0x1700
-#define GL_PROJECTION                     0x1701
-#define GL_TEXTURE                        0x1702
-
-/* NormalPointerType */
-/*      GL_BYTE */
-/*      GL_SHORT */
-/*      GL_FLOAT */
-/*      GL_FIXED */
-
-/* PixelFormat */
-#define GL_ALPHA                          0x1906
-#define GL_RGB                            0x1907
-#define GL_RGBA                           0x1908
-#define GL_LUMINANCE                      0x1909
-#define GL_LUMINANCE_ALPHA                0x190A
-
-/* PixelStoreParameter */
-#define GL_UNPACK_ALIGNMENT               0x0CF5
-#define GL_PACK_ALIGNMENT                 0x0D05
-
-/* PixelType */
-/*      GL_UNSIGNED_BYTE */
-#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
-#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
-#define GL_UNSIGNED_SHORT_5_6_5           0x8363
-
-/* ShadingModel */
-#define GL_FLAT                           0x1D00
-#define GL_SMOOTH                         0x1D01
-
-/* StencilFunction */
-/*      GL_NEVER */
-/*      GL_LESS */
-/*      GL_EQUAL */
-/*      GL_LEQUAL */
-/*      GL_GREATER */
-/*      GL_NOTEQUAL */
-/*      GL_GEQUAL */
-/*      GL_ALWAYS */
-
-/* StencilOp */
-/*      GL_ZERO */
-#define GL_KEEP                           0x1E00
-#define GL_REPLACE                        0x1E01
-#define GL_INCR                           0x1E02
-#define GL_DECR                           0x1E03
-/*      GL_INVERT */
-
-/* StringName */
-#define GL_VENDOR                         0x1F00
-#define GL_RENDERER                       0x1F01
-#define GL_VERSION                        0x1F02
-#define GL_EXTENSIONS                     0x1F03
-
-/* TexCoordPointerType */
-/*      GL_SHORT */
-/*      GL_FLOAT */
-/*      GL_FIXED */
-/*      GL_BYTE */
-
-/* TextureEnvMode */
-#define GL_MODULATE                       0x2100
-#define GL_DECAL                          0x2101
-/*      GL_BLEND */
-#define GL_ADD                            0x0104
-/*      GL_REPLACE */
-
-/* TextureEnvParameter */
-#define GL_TEXTURE_ENV_MODE               0x2200
-#define GL_TEXTURE_ENV_COLOR              0x2201
-
-/* TextureEnvTarget */
-#define GL_TEXTURE_ENV                    0x2300
-
-/* TextureMagFilter */
-#define GL_NEAREST                        0x2600
-#define GL_LINEAR                         0x2601
-
-/* TextureMinFilter */
-/*      GL_NEAREST */
-/*      GL_LINEAR */
-#define GL_NEAREST_MIPMAP_NEAREST         0x2700
-#define GL_LINEAR_MIPMAP_NEAREST          0x2701
-#define GL_NEAREST_MIPMAP_LINEAR          0x2702
-#define GL_LINEAR_MIPMAP_LINEAR           0x2703
-
-/* TextureParameterName */
-#define GL_TEXTURE_MAG_FILTER             0x2800
-#define GL_TEXTURE_MIN_FILTER             0x2801
-#define GL_TEXTURE_WRAP_S                 0x2802
-#define GL_TEXTURE_WRAP_T                 0x2803
-
-/* TextureTarget */
-/*      GL_TEXTURE_2D */
-
-/* TextureUnit */
-#define GL_TEXTURE0                       0x84C0
-#define GL_TEXTURE1                       0x84C1
-#define GL_TEXTURE2                       0x84C2
-#define GL_TEXTURE3                       0x84C3
-#define GL_TEXTURE4                       0x84C4
-#define GL_TEXTURE5                       0x84C5
-#define GL_TEXTURE6                       0x84C6
-#define GL_TEXTURE7                       0x84C7
-#define GL_TEXTURE8                       0x84C8
-#define GL_TEXTURE9                       0x84C9
-#define GL_TEXTURE10                      0x84CA
-#define GL_TEXTURE11                      0x84CB
-#define GL_TEXTURE12                      0x84CC
-#define GL_TEXTURE13                      0x84CD
-#define GL_TEXTURE14                      0x84CE
-#define GL_TEXTURE15                      0x84CF
-#define GL_TEXTURE16                      0x84D0
-#define GL_TEXTURE17                      0x84D1
-#define GL_TEXTURE18                      0x84D2
-#define GL_TEXTURE19                      0x84D3
-#define GL_TEXTURE20                      0x84D4
-#define GL_TEXTURE21                      0x84D5
-#define GL_TEXTURE22                      0x84D6
-#define GL_TEXTURE23                      0x84D7
-#define GL_TEXTURE24                      0x84D8
-#define GL_TEXTURE25                      0x84D9
-#define GL_TEXTURE26                      0x84DA
-#define GL_TEXTURE27                      0x84DB
-#define GL_TEXTURE28                      0x84DC
-#define GL_TEXTURE29                      0x84DD
-#define GL_TEXTURE30                      0x84DE
-#define GL_TEXTURE31                      0x84DF
-
-/* TextureWrapMode */
-#define GL_REPEAT                         0x2901
-#define GL_CLAMP_TO_EDGE                  0x812F
-
-/* PixelInternalFormat */
-#define GL_PALETTE4_RGB8_OES              0x8B90
-#define GL_PALETTE4_RGBA8_OES             0x8B91
-#define GL_PALETTE4_R5_G6_B5_OES          0x8B92
-#define GL_PALETTE4_RGBA4_OES             0x8B93
-#define GL_PALETTE4_RGB5_A1_OES           0x8B94
-#define GL_PALETTE8_RGB8_OES              0x8B95
-#define GL_PALETTE8_RGBA8_OES             0x8B96
-#define GL_PALETTE8_R5_G6_B5_OES          0x8B97
-#define GL_PALETTE8_RGBA4_OES             0x8B98
-#define GL_PALETTE8_RGB5_A1_OES           0x8B99
-
-/* VertexPointerType */
-/*      GL_SHORT */
-/*      GL_FLOAT */
-/*      GL_FIXED */
-/*      GL_BYTE */
-
-/* LightName */
-#define GL_LIGHT0                         0x4000
-#define GL_LIGHT1                         0x4001
-#define GL_LIGHT2                         0x4002
-#define GL_LIGHT3                         0x4003
-#define GL_LIGHT4                         0x4004
-#define GL_LIGHT5                         0x4005
-#define GL_LIGHT6                         0x4006
-#define GL_LIGHT7                         0x4007
-
-
-/*************************************************************/
-
-GLAPI void APIENTRY glActiveTexture (GLenum texture);
-GLAPI void APIENTRY glAlphaFunc (GLenum func, GLclampf ref);
-GLAPI void APIENTRY glAlphaFuncx (GLenum func, GLclampx ref);
-GLAPI void APIENTRY glBindTexture (GLenum target, GLuint texture);
-GLAPI void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
-GLAPI void APIENTRY glClear (GLbitfield mask);
-GLAPI void APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
-GLAPI void APIENTRY glClearColorx (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
-GLAPI void APIENTRY glClearDepthf (GLclampf depth);
-GLAPI void APIENTRY glClearDepthx (GLclampx depth);
-GLAPI void APIENTRY glClearStencil (GLint s);
-GLAPI void APIENTRY glClientActiveTexture (GLenum texture);
-GLAPI void APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
-GLAPI void APIENTRY glColor4x (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
-GLAPI void APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
-GLAPI void APIENTRY glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
-GLAPI void APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
-GLAPI void APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
-GLAPI void APIENTRY glCullFace (GLenum mode);
-GLAPI void APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
-GLAPI void APIENTRY glDepthFunc (GLenum func);
-GLAPI void APIENTRY glDepthMask (GLboolean flag);
-GLAPI void APIENTRY glDepthRangef (GLclampf zNear, GLclampf zFar);
-GLAPI void APIENTRY glDepthRangex (GLclampx zNear, GLclampx zFar);
-GLAPI void APIENTRY glDisable (GLenum cap);
-GLAPI void APIENTRY glDisableClientState (GLenum array);
-GLAPI void APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
-GLAPI void APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
-GLAPI void APIENTRY glEnable (GLenum cap);
-GLAPI void APIENTRY glEnableClientState (GLenum array);
-GLAPI void APIENTRY glFinish (void);
-GLAPI void APIENTRY glFlush (void);
-GLAPI void APIENTRY glFogf (GLenum pname, GLfloat param);
-GLAPI void APIENTRY glFogfv (GLenum pname, const GLfloat *params);
-GLAPI void APIENTRY glFogx (GLenum pname, GLfixed param);
-GLAPI void APIENTRY glFogxv (GLenum pname, const GLfixed *params);
-GLAPI void APIENTRY glFrontFace (GLenum mode);
-GLAPI void APIENTRY glFrustumf (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
-GLAPI void APIENTRY glFrustumx (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
-GLAPI void APIENTRY glGenTextures (GLsizei n, GLuint *textures);
-GLAPI GLenum APIENTRY glGetError (void);
-GLAPI void APIENTRY glGetIntegerv (GLenum pname, GLint *params);
-GLAPI const GLubyte * APIENTRY glGetString (GLenum name);
-GLAPI void APIENTRY glHint (GLenum target, GLenum mode);
-GLAPI void APIENTRY glLightModelf (GLenum pname, GLfloat param);
-GLAPI void APIENTRY glLightModelfv (GLenum pname, const GLfloat *params);
-GLAPI void APIENTRY glLightModelx (GLenum pname, GLfixed param);
-GLAPI void APIENTRY glLightModelxv (GLenum pname, const GLfixed *params);
-GLAPI void APIENTRY glLightf (GLenum light, GLenum pname, GLfloat param);
-GLAPI void APIENTRY glLightfv (GLenum light, GLenum pname, const GLfloat *params);
-GLAPI void APIENTRY glLightx (GLenum light, GLenum pname, GLfixed param);
-GLAPI void APIENTRY glLightxv (GLenum light, GLenum pname, const GLfixed *params);
-GLAPI void APIENTRY glLineWidth (GLfloat width);
-GLAPI void APIENTRY glLineWidthx (GLfixed width);
-GLAPI void APIENTRY glLoadIdentity (void);
-GLAPI void APIENTRY glLoadMatrixf (const GLfloat *m);
-GLAPI void APIENTRY glLoadMatrixx (const GLfixed *m);
-GLAPI void APIENTRY glLogicOp (GLenum opcode);
-GLAPI void APIENTRY glMaterialf (GLenum face, GLenum pname, GLfloat param);
-GLAPI void APIENTRY glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
-GLAPI void APIENTRY glMaterialx (GLenum face, GLenum pname, GLfixed param);
-GLAPI void APIENTRY glMaterialxv (GLenum face, GLenum pname, const GLfixed *params);
-GLAPI void APIENTRY glMatrixMode (GLenum mode);
-GLAPI void APIENTRY glMultMatrixf (const GLfloat *m);
-GLAPI void APIENTRY glMultMatrixx (const GLfixed *m);
-GLAPI void APIENTRY glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
-GLAPI void APIENTRY glMultiTexCoord4x (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
-GLAPI void APIENTRY glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
-GLAPI void APIENTRY glNormal3x (GLfixed nx, GLfixed ny, GLfixed nz);
-GLAPI void APIENTRY glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
-GLAPI void APIENTRY glOrthof (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
-GLAPI void APIENTRY glOrthox (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
-GLAPI void APIENTRY glPixelStorei (GLenum pname, GLint param);
-GLAPI void APIENTRY glPointSize (GLfloat size);
-GLAPI void APIENTRY glPointSizex (GLfixed size);
-GLAPI void APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
-GLAPI void APIENTRY glPolygonOffsetx (GLfixed factor, GLfixed units);
-GLAPI void APIENTRY glPopMatrix (void);
-GLAPI void APIENTRY glPushMatrix (void);
-GLAPI void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
-GLAPI void APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
-GLAPI void APIENTRY glRotatex (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
-GLAPI void APIENTRY glSampleCoverage (GLclampf value, GLboolean invert);
-GLAPI void APIENTRY glSampleCoveragex (GLclampx value, GLboolean invert);
-GLAPI void APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z);
-GLAPI void APIENTRY glScalex (GLfixed x, GLfixed y, GLfixed z);
-GLAPI void APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
-GLAPI void APIENTRY glShadeModel (GLenum mode);
-GLAPI void APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
-GLAPI void APIENTRY glStencilMask (GLuint mask);
-GLAPI void APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
-GLAPI void APIENTRY glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
-GLAPI void APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param);
-GLAPI void APIENTRY glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
-GLAPI void APIENTRY glTexEnvx (GLenum target, GLenum pname, GLfixed param);
-GLAPI void APIENTRY glTexEnvxv (GLenum target, GLenum pname, const GLfixed *params);
-GLAPI void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
-GLAPI void APIENTRY glTexParameterx (GLenum target, GLenum pname, GLfixed param);
-GLAPI void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z);
-GLAPI void APIENTRY glTranslatex (GLfixed x, GLfixed y, GLfixed z);
-GLAPI void APIENTRY glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
-GLAPI void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __gl_h_ */
diff --git a/opengl/tests/angeles/license-BSD.txt b/opengl/tests/angeles/license-BSD.txt
deleted file mode 100644
index 8924e3ca28..0000000000
--- a/opengl/tests/angeles/license-BSD.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-This is the BSD-style license for the "San Angeles Observation"
-OpenGL ES version example source code
----------------------------------------------------------------
-
-San Angeles Observation OpenGL ES version example
-Copyright (c) 2004-2005, Jetro Lauha
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-    * Neither the name of the software product's copyright owner nor
-      the names of its contributors may be used to endorse or promote
-      products derived from this software without specific prior written
-      permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
-TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/opengl/tests/angeles/license-LGPL.txt b/opengl/tests/angeles/license-LGPL.txt
deleted file mode 100644
index b1e3f5a263..0000000000
--- a/opengl/tests/angeles/license-LGPL.txt
+++ /dev/null
@@ -1,504 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
-
diff --git a/opengl/tests/angeles/license.txt b/opengl/tests/angeles/license.txt
deleted file mode 100644
index 620841e82e..0000000000
--- a/opengl/tests/angeles/license.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-San Angeles Observation OpenGL ES version example
-Copyright 2004-2005 Jetro Lauha
-All rights reserved.
-Web: http://iki.fi/jetro/
-
-This source is free software; you can redistribute it and/or
-modify it under the terms of EITHER:
-  (1) The GNU Lesser General Public License as published by the Free
-      Software Foundation; either version 2.1 of the License, or (at
-      your option) any later version. The text of the GNU Lesser
-      General Public License is included with this source in the
-      file LICENSE-LGPL.txt.
-  (2) The BSD-style license that is included with this source in
-      the file LICENSE-BSD.txt.
-
-This source is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
-LICENSE-LGPL.txt and LICENSE-BSD.txt for more details.
diff --git a/opengl/tests/angeles/shapes.h b/opengl/tests/angeles/shapes.h
deleted file mode 100644
index 25ffae8ce4..0000000000
--- a/opengl/tests/angeles/shapes.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* San Angeles Observation OpenGL ES version example
- * Copyright 2004-2005 Jetro Lauha
- * All rights reserved.
- * Web: http://iki.fi/jetro/
- *
- * This source is free software; you can redistribute it and/or
- * modify it under the terms of EITHER:
- *   (1) The GNU Lesser General Public License as published by the Free
- *       Software Foundation; either version 2.1 of the License, or (at
- *       your option) any later version. The text of the GNU Lesser
- *       General Public License is included with this source in the
- *       file LICENSE-LGPL.txt.
- *   (2) The BSD-style license that is included with this source in
- *       the file LICENSE-BSD.txt.
- *
- * This source is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files
- * LICENSE-LGPL.txt and LICENSE-BSD.txt for more details.
- *
- * $Id: shapes.h,v 1.6 2005/01/31 22:15:30 tonic Exp $
- * $Revision: 1.6 $
- */
-
-#ifndef SHAPES_H_INCLUDED
-#define SHAPES_H_INCLUDED
-
-
-#define SUPERSHAPE_PARAMS 15
-
-static const float sSuperShapeParams[][SUPERSHAPE_PARAMS] =
-{
-    // m  a     b     n1      n2     n3     m     a     b     n1     n2      n3   res1 res2 scale  (org.res1,res2)
-    { 10, 1,    2,    90,      1,   -45,    8,    1,    1,    -1,     1,  -0.4f,   20,  30, 2 }, // 40, 60
-    { 10, 1,    2,    90,      1,   -45,    4,    1,    1,    10,     1,  -0.4f,   20,  20, 4 }, // 40, 40
-    { 10, 1,    2,    60,      1,   -10,    4,    1,    1,    -1,    -2,  -0.4f,   41,  41, 1 }, // 82, 82
-    {  6, 1,    1,    60,      1,   -70,    8,    1,    1,  0.4f,     3,  0.25f,   20,  20, 1 }, // 40, 40
-    {  4, 1,    1,    30,      1,    20,   12,    1,    1,  0.4f,     3,  0.25f,   10,  30, 1 }, // 20, 60
-    {  8, 1,    1,    30,      1,    -4,    8,    2,    1,    -1,     5,   0.5f,   25,  26, 1 }, // 60, 60
-    { 13, 1,    1,    30,      1,    -4,   13,    1,    1,     1,     5,      1,   30,  30, 6 }, // 60, 60
-    { 10, 1, 1.1f, -0.5f,   0.1f,    70,   60,    1,    1,   -90,     0, -0.25f,   20,  60, 8 }, // 60, 180
-    {  7, 1,    1,    20,  -0.3f, -3.5f,    6,    1,    1,    -1,  4.5f,   0.5f,   10,  20, 4 }, // 60, 80
-    {  4, 1,    1,    10,     10,    10,    4,    1,    1,    10,    10,     10,   10,  20, 1 }, // 20, 40
-    {  4, 1,    1,     1,      1,     1,    4,    1,    1,     1,     1,      1,   10,  10, 2 }, // 10, 10
-    {  1, 1,    1,    38, -0.25f,    19,    4,    1,    1,    10,    10,     10,   10,  15, 2 }, // 20, 40
-    {  2, 1,    1,  0.7f,   0.3f,  0.2f,    3,    1,    1,   100,   100,    100,   10,  25, 2 }, // 20, 50
-    {  6, 1,    1,     1,      1,     1,    3,    1,    1,     1,     1,      1,   30,  30, 2 }, // 60, 60
-    {  3, 1,    1,     1,      1,     1,    6,    1,    1,     2,     1,      1,   10,  20, 2 }, // 20, 40
-    {  6, 1,    1,     6,   5.5f,   100,    6,    1,    1,    25,    10,     10,   30,  20, 2 }, // 60, 40
-    {  3, 1,    1,  0.5f,   1.7f,  1.7f,    2,    1,    1,    10,    10,     10,   20,  20, 2 }, // 40, 40
-    {  5, 1,    1,  0.1f,   1.7f,  1.7f,    1,    1,    1,  0.3f,  0.5f,   0.5f,   20,  20, 4 }, // 40, 40
-    {  2, 1,    1,     6,   5.5f,   100,    6,    1,    1,     4,    10,     10,   10,  22, 1 }, // 40, 40
-    {  6, 1,    1,    -1,     70,  0.1f,    9,    1, 0.5f,   -98, 0.05f,    -45,   20,  30, 4 }, // 60, 91
-    {  6, 1,    1,    -1,     90, -0.1f,    7,    1,    1,    90,  1.3f,     34,   13,  16, 1 }, // 32, 60
-};
-#define SUPERSHAPE_COUNT (sizeof(sSuperShapeParams) / sizeof(sSuperShapeParams[0]))
-
-
-#endif // !SHAPES_H_INCLUDED
diff --git a/opengl/tests/configdump/Android.bp b/opengl/tests/configdump/Android.bp
deleted file mode 100644
index ee96797030..0000000000
--- a/opengl/tests/configdump/Android.bp
+++ /dev/null
@@ -1,18 +0,0 @@
-cc_test {
-    name: "test-opengl-configdump",
-
-    gtest: false,
-
-    srcs: ["configdump.cpp"],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv1_CM",
-    ],
-}
diff --git a/opengl/tests/configdump/configdump.cpp b/opengl/tests/configdump/configdump.cpp
deleted file mode 100644
index a4bb8791ea..0000000000
--- a/opengl/tests/configdump/configdump.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-** Copyright 2010, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-
-#define ATTRIBUTE(_attr) { _attr, #_attr }
-
-struct Attribute {
-    EGLint attribute;
-    char const* name;
-};
-
-// clang-format off
-Attribute attributes[] = {
-        ATTRIBUTE( EGL_BUFFER_SIZE ),
-        ATTRIBUTE( EGL_ALPHA_SIZE ),
-        ATTRIBUTE( EGL_BLUE_SIZE ),
-        ATTRIBUTE( EGL_GREEN_SIZE ),
-        ATTRIBUTE( EGL_RED_SIZE ),
-        ATTRIBUTE( EGL_DEPTH_SIZE ),
-        ATTRIBUTE( EGL_STENCIL_SIZE ),
-        ATTRIBUTE( EGL_CONFIG_CAVEAT ),
-        ATTRIBUTE( EGL_CONFIG_ID ),
-        ATTRIBUTE( EGL_LEVEL ),
-        ATTRIBUTE( EGL_MAX_PBUFFER_HEIGHT ),
-        ATTRIBUTE( EGL_MAX_PBUFFER_WIDTH ),
-        ATTRIBUTE( EGL_MAX_PBUFFER_PIXELS ),
-        ATTRIBUTE( EGL_NATIVE_RENDERABLE ),
-        ATTRIBUTE( EGL_NATIVE_VISUAL_ID ),
-        ATTRIBUTE( EGL_NATIVE_VISUAL_TYPE ),
-        ATTRIBUTE( EGL_SAMPLES ),
-        ATTRIBUTE( EGL_SAMPLE_BUFFERS ),
-        ATTRIBUTE( EGL_SURFACE_TYPE ),
-        ATTRIBUTE( EGL_TRANSPARENT_TYPE ),
-        ATTRIBUTE( EGL_TRANSPARENT_BLUE_VALUE ),
-        ATTRIBUTE( EGL_TRANSPARENT_GREEN_VALUE ),
-        ATTRIBUTE( EGL_TRANSPARENT_RED_VALUE ),
-        ATTRIBUTE( EGL_BIND_TO_TEXTURE_RGB ),
-        ATTRIBUTE( EGL_BIND_TO_TEXTURE_RGBA ),
-        ATTRIBUTE( EGL_MIN_SWAP_INTERVAL ),
-        ATTRIBUTE( EGL_MAX_SWAP_INTERVAL ),
-        ATTRIBUTE( EGL_LUMINANCE_SIZE ),
-        ATTRIBUTE( EGL_ALPHA_MASK_SIZE ),
-        ATTRIBUTE( EGL_COLOR_BUFFER_TYPE ),
-        ATTRIBUTE( EGL_RENDERABLE_TYPE ),
-        ATTRIBUTE( EGL_MATCH_NATIVE_PIXMAP ),
-        ATTRIBUTE( EGL_CONFORMANT ),
-        ATTRIBUTE( EGL_COLOR_COMPONENT_TYPE_EXT ),
-};
-// clang-format on
-
-int main(int /*argc*/, char** /*argv*/) {
-    EGLConfig* configs;
-    EGLint n;
-
-    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    eglInitialize(dpy, 0, 0);
-    eglGetConfigs(dpy, NULL, 0, &n);
-    configs = new EGLConfig[n];
-    eglGetConfigs(dpy, configs, n, &n);
-
-    for (EGLint i=0 ; i<n ; i++) {
-        printf("EGLConfig[%d]\n", i);
-        for (unsigned attr = 0 ; attr<sizeof(attributes)/sizeof(Attribute) ; attr++) {
-            EGLint value;
-            eglGetConfigAttrib(dpy, configs[i], attributes[attr].attribute, &value);
-            printf("\t%-32s: %10d (0x%08x)\n", attributes[attr].name, value, value);
-        }
-    }
-
-    delete [] configs;
-    eglTerminate(dpy);
-    return 0;
-}
diff --git a/opengl/tests/fillrate/Android.bp b/opengl/tests/fillrate/Android.bp
deleted file mode 100644
index 689cee42d5..0000000000
--- a/opengl/tests/fillrate/Android.bp
+++ /dev/null
@@ -1,23 +0,0 @@
-cc_test {
-    name: "test-opengl-fillrate",
-
-    srcs: ["fillrate.cpp"],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "libutils",
-        "libEGL",
-        "libGLESv1_CM",
-        "libui",
-        "libgui",
-    ],
-
-    static_libs: ["libglTest"],
-}
diff --git a/opengl/tests/fillrate/fillrate.cpp b/opengl/tests/fillrate/fillrate.cpp
deleted file mode 100644
index f0220693d1..0000000000
--- a/opengl/tests/fillrate/fillrate.cpp
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License"); 
-** you may not use this file except in compliance with the License. 
-** You may obtain a copy of the License at 
-**
-**     http://www.apache.org/licenses/LICENSE-2.0 
-**
-** Unless required by applicable law or agreed to in writing, software 
-** distributed under the License is distributed on an "AS IS" BASIS, 
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-** See the License for the specific language governing permissions and 
-** limitations under the License.
-*/
-
-#define LOG_TAG "fillrate"
-
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <utils/StopWatch.h>
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    EGLint configAttribs[] = {
-         EGL_DEPTH_SIZE, 0,
-         EGL_NONE
-     };
-     
-     EGLint majorVersion;
-     EGLint minorVersion;
-     EGLContext context;
-     EGLConfig config;
-     EGLSurface surface;
-     EGLint w, h;
-     EGLDisplay dpy;
-
-     WindowSurface windowSurface;
-     EGLNativeWindowType window = windowSurface.getSurface();
-     
-     dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-     eglInitialize(dpy, &majorVersion, &minorVersion);
-          
-     status_t err = EGLUtils::selectConfigForNativeWindow(
-             dpy, configAttribs, window, &config);
-     if (err) {
-         fprintf(stderr, "couldn't find an EGLConfig matching the screen format\n");
-         return 0;
-     }
-
-     surface = eglCreateWindowSurface(dpy, config, window, NULL);
-     context = eglCreateContext(dpy, config, NULL, NULL);
-     eglMakeCurrent(dpy, surface, surface, context);   
-     eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-     eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-     
-     printf("w=%d, h=%d\n", w, h);
-     
-     glBindTexture(GL_TEXTURE_2D, 0);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-     glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-     glDisable(GL_DITHER);
-     glEnable(GL_BLEND);
-     glEnable(GL_TEXTURE_2D);
-     glColor4f(1,1,1,1);
-
-     uint32_t* t32 = (uint32_t*)malloc(512*512*4); 
-     for (int y=0 ; y<512 ; y++) {
-         for (int x=0 ; x<512 ; x++) {
-             int u = x-256;
-             int v = y-256;
-             if (u*u+v*v < 256*256) {
-                 t32[x+y*512] = 0x10FFFFFF;
-             } else {
-                 t32[x+y*512] = 0x20FF0000;
-             }
-         }
-     }
-
-     const GLfloat fh = h;
-     const GLfloat fw = w;
-     const GLfloat vertices[4][2] = {
-             { 0,   0  },
-             { 0,   fh },
-             { fw,  fh },
-             { fw,  0  }
-     };
-
-     const GLfloat texCoords[4][2] = {
-             { 0,  0 },
-             { 0,  1 },
-             { 1,  1 },
-             { 1,  0 }
-     };
-
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 512, 512, 0, GL_RGBA, GL_UNSIGNED_BYTE, t32);
-
-     glViewport(0, 0, w, h);
-     glMatrixMode(GL_PROJECTION);
-     glLoadIdentity();
-     glOrthof(0, w, 0, h, 0, 1);
-
-     glEnableClientState(GL_VERTEX_ARRAY);
-     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-     glVertexPointer(2, GL_FLOAT, 0, vertices);
-     glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
-
-     eglSwapInterval(dpy, 1);
-
-     glClearColor(1,0,0,0);
-     glClear(GL_COLOR_BUFFER_BIT);
-     glDrawArrays(GL_TRIANGLE_FAN, 0, 4); 
-     eglSwapBuffers(dpy, surface);
-     
-
-     nsecs_t times[32];
-
-     for (int c=1 ; c<32 ; c++) {
-         glClear(GL_COLOR_BUFFER_BIT);
-         for (int i=0 ; i<c ; i++) {
-             glDrawArrays(GL_TRIANGLE_FAN, 0, 4); 
-         }
-         eglSwapBuffers(dpy, surface);
-     }
-
-
-     //     for (int c=31 ; c>=1 ; c--) {
-     int j=0;
-     for (int c=1 ; c<32 ; c++) {
-         glClear(GL_COLOR_BUFFER_BIT);
-         nsecs_t now = systemTime();
-         for (int i=0 ; i<c ; i++) {
-             glDrawArrays(GL_TRIANGLE_FAN, 0, 4); 
-         }
-         eglSwapBuffers(dpy, surface);
-         nsecs_t t = systemTime() - now;
-         times[j++] = t;
-     }
-
-     for (int c=1, j=0 ; c<32 ; c++, j++) {
-         nsecs_t t = times[j];
-         printf("%lld\t%d\t%f\n", (long long)t, c, (double(t)/c)/1000000.0);
-     }
-
-
-       
-     eglTerminate(dpy);
-     
-     return 0;
-}
diff --git a/opengl/tests/filter/Android.bp b/opengl/tests/filter/Android.bp
deleted file mode 100644
index 23241e1116..0000000000
--- a/opengl/tests/filter/Android.bp
+++ /dev/null
@@ -1,25 +0,0 @@
-cc_test {
-    name: "test-opengl-filter",
-
-    srcs: ["filter.cpp"],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv1_CM",
-        "libui",
-        "libgui",
-        "libutils",
-    ],
-
-    static_libs: ["libglTest"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-Wall",
-        "-Werror",
-    ],
-
-}
diff --git a/opengl/tests/filter/filter.cpp b/opengl/tests/filter/filter.cpp
deleted file mode 100644
index 49778a0685..0000000000
--- a/opengl/tests/filter/filter.cpp
+++ /dev/null
@@ -1,196 +0,0 @@
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-#define USE_DRAW_TEXTURE 1
-
-int main(int argc, char** argv)
-{
-    if (argc!=2 && argc!=3) {
-        printf("usage: %s <0-6> [pbuffer]\n", argv[0]);
-        return 0;
-    }
-    
-    const int test = atoi(argv[1]);
-    int usePbuffer = argc==3 && !strcmp(argv[2], "pbuffer");
-    EGLint s_configAttribs[] = {
-         EGL_SURFACE_TYPE, EGL_PBUFFER_BIT|EGL_WINDOW_BIT,
-         EGL_RED_SIZE,       5,
-         EGL_GREEN_SIZE,     6,
-         EGL_BLUE_SIZE,      5,
-         EGL_NONE
-     };
-     
-     EGLint numConfigs = -1;
-     EGLint majorVersion;
-     EGLint minorVersion;
-     EGLConfig config;
-     EGLContext context;
-     EGLSurface surface;
-     EGLint w, h;
-     
-     EGLDisplay dpy;
-
-     EGLNativeWindowType window = 0;
-     WindowSurface* windowSurface = NULL;
-     if (!usePbuffer) {
-         windowSurface = new WindowSurface();
-         window = windowSurface->getSurface();
-     }
-     
-     dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-     eglInitialize(dpy, &majorVersion, &minorVersion);
-     if (!usePbuffer) {
-         EGLUtils::selectConfigForNativeWindow(
-                 dpy, s_configAttribs, window, &config);
-         surface = eglCreateWindowSurface(dpy, config, window, NULL);
-     } else {
-         printf("using pbuffer\n");
-         eglChooseConfig(dpy, s_configAttribs, &config, 1, &numConfigs);
-         EGLint attribs[] = { EGL_WIDTH, 320, EGL_HEIGHT, 480, EGL_NONE };
-         surface = eglCreatePbufferSurface(dpy, config, attribs);
-         if (surface == EGL_NO_SURFACE) {
-             printf("eglCreatePbufferSurface error %x\n", eglGetError());
-         }
-     }
-     context = eglCreateContext(dpy, config, NULL, NULL);
-     eglMakeCurrent(dpy, surface, surface, context);   
-     eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-     eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-     GLint dim = w<h ? w : h;
-
-     glViewport(0, 0, w, h);
-     glMatrixMode(GL_PROJECTION);
-     glLoadIdentity();
-     glOrthof(0, w, 0, h, 0, 1);
-
-     glClearColor(0,0,0,0);
-     glClear(GL_COLOR_BUFFER_BIT);
-
-     GLint crop[4] = { 0, 4, 4, -4 };
-     glBindTexture(GL_TEXTURE_2D, 0);
-     glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-     glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-     glEnable(GL_TEXTURE_2D);
-     glColor4f(1,1,1,1);
-
-     // packing is always 4
-     uint8_t t8[]  = { 
-             0x00, 0x55, 0x00, 0x55, 
-             0xAA, 0xFF, 0xAA, 0xFF,
-             0x00, 0x55, 0x00, 0x55, 
-             0xAA, 0xFF, 0xAA, 0xFF  };
-
-     uint16_t t16[]  = { 
-             0x0000, 0x5555, 0x0000, 0x5555, 
-             0xAAAA, 0xFFFF, 0xAAAA, 0xFFFF,
-             0x0000, 0x5555, 0x0000, 0x5555, 
-             0xAAAA, 0xFFFF, 0xAAAA, 0xFFFF  };
-
-     uint16_t t5551[]  = { 
-             0x0000, 0xFFFF, 0x0000, 0xFFFF, 
-             0xFFFF, 0x0000, 0xFFFF, 0x0000,
-             0x0000, 0xFFFF, 0x0000, 0xFFFF, 
-             0xFFFF, 0x0000, 0xFFFF, 0x0000  };
-
-     uint32_t t32[]  = { 
-             0xFF000000, 0xFF0000FF, 0xFF00FF00, 0xFFFF0000, 
-             0xFF00FF00, 0xFFFF0000, 0xFF000000, 0xFF0000FF, 
-             0xFF00FFFF, 0xFF00FF00, 0x00FF00FF, 0xFFFFFF00, 
-             0xFF000000, 0xFFFF00FF, 0xFF00FFFF, 0xFFFFFFFF
-     };
-
-     switch(test) 
-     {
-     case 1:
-         glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE,
-                 4, 4, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, t8);
-         break;
-     case 2:
-         glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB,
-                 4, 4, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, t16);
-         break;
-     case 3:
-         glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
-                 4, 4, 0, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4, t16);
-         break;
-     case 4:
-         glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA,
-                 4, 4, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, t16);
-         break;
-     case 5:
-         glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
-                 4, 4, 0, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1, t5551);
-         break;
-     case 6:
-         glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
-                 4, 4, 0, GL_RGBA, GL_UNSIGNED_BYTE, t32);
-         break;
-     }
-
-     //glDrawTexiOES(0, 0, 0, dim, dim);
-     
-#if !USE_DRAW_TEXTURE || !GL_OES_draw_texture
-     const GLfloat fdim = dim;
-     const GLfloat vertices[4][2] = {
-             { 0,     0    },
-             { 0,     fdim },
-             { fdim,  fdim },
-             { fdim,  0    }
-     };
-
-     const GLfloat texCoords[4][2] = {
-             { 0,  0 },
-             { 0,  1 },
-             { 1,  1 },
-             { 1,  0 }
-     };
-#endif
-     
-     if (!usePbuffer) {
-         eglSwapBuffers(dpy, surface);
-     }
-     
-     glMatrixMode(GL_MODELVIEW);
-     glScissor(0,dim,dim,h-dim);
-     glDisable(GL_SCISSOR_TEST);
-     
-     for (int y=0 ; y<dim ; y++) {
-         //glDisable(GL_SCISSOR_TEST);
-         glClear(GL_COLOR_BUFFER_BIT);
-
-         //glEnable(GL_SCISSOR_TEST);
-
-#if USE_DRAW_TEXTURE && GL_OES_draw_texture
-         glDrawTexiOES(0, y, 1, dim, dim);
-#else
-         glLoadIdentity();
-         glTranslatef(0, y, 0);
-         glEnableClientState(GL_VERTEX_ARRAY);
-         glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-         glVertexPointer(2, GL_FLOAT, 0, vertices);
-         glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
-         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-#endif
-
-         if (!usePbuffer) {
-             eglSwapBuffers(dpy, surface);
-         } else {
-             glFinish();
-         }
-     }
-
-     eglTerminate(dpy);
-     delete windowSurface;
-     return 0;
-}
diff --git a/opengl/tests/finish/Android.bp b/opengl/tests/finish/Android.bp
deleted file mode 100644
index be20851e8f..0000000000
--- a/opengl/tests/finish/Android.bp
+++ /dev/null
@@ -1,25 +0,0 @@
-cc_test {
-    name: "test-opengl-finish",
-
-    srcs: ["finish.cpp"],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "libutils",
-        "libEGL",
-        "libGLESv1_CM",
-        "libui",
-        "libgui",
-    ],
-
-    static_libs: ["libglTest"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-Wall",
-        "-Werror",
-    ],
-
-}
diff --git a/opengl/tests/finish/finish.cpp b/opengl/tests/finish/finish.cpp
deleted file mode 100644
index 63ea82223b..0000000000
--- a/opengl/tests/finish/finish.cpp
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sched.h>
-#include <sys/resource.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <utils/Timers.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    EGLint configAttribs[] = {
-         EGL_DEPTH_SIZE, 0,
-         EGL_NONE
-     };
-     
-     EGLint majorVersion;
-     EGLint minorVersion;
-     EGLContext context;
-     EGLConfig config;
-     EGLSurface surface;
-     EGLint w, h;
-     EGLDisplay dpy;
-
-     WindowSurface windowSurface;
-     EGLNativeWindowType window = windowSurface.getSurface();
-     
-     dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-     eglInitialize(dpy, &majorVersion, &minorVersion);
-          
-     status_t err = EGLUtils::selectConfigForNativeWindow(
-             dpy, configAttribs, window, &config);
-     if (err) {
-         fprintf(stderr, "couldn't find an EGLConfig matching the screen format\n");
-         return 0;
-     }
-
-     surface = eglCreateWindowSurface(dpy, config, window, NULL);
-     context = eglCreateContext(dpy, config, NULL, NULL);
-     eglMakeCurrent(dpy, surface, surface, context);   
-     eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-     eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-
-     glBindTexture(GL_TEXTURE_2D, 0);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-     glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-     glEnable(GL_TEXTURE_2D);
-     glColor4f(1,1,1,1);
-     glDisable(GL_DITHER);
-     glShadeModel(GL_FLAT);
-
-     long long now, t;
-     int i;
-
-     char* texels = (char*)malloc(512*512*2);
-     memset(texels,0xFF,512*512*2);
-     
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB,
-             512, 512, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, texels);
-
-     char* dst = (char*)malloc(320*480*2);
-     memset(dst, 0, 320*480*2);
-     printf("307200 bytes memcpy\n");
-     for (i=0 ; i<4 ; i++) {
-         now = systemTime();
-         memcpy(dst, texels, 320*480*2);
-         t = systemTime();
-         printf("memcpy() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-     }
-     free(dst);
-
-     free(texels);
-
-     setpriority(PRIO_PROCESS, 0, -20);
-     
-     printf("512x512 unmodified texture, 512x512 blit:\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         GLint crop[4] = { 0, 512, 512, -512 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 512, 512);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-         eglSwapBuffers(dpy, surface);
-     }
-     
-     printf("512x512 unmodified texture, 1x1 blit:\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         GLint crop[4] = { 0, 1, 1, -1 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 1, 1);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-         eglSwapBuffers(dpy, surface);
-     }
-     
-     printf("512x512 unmodified texture, 512x512 blit (x2):\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         GLint crop[4] = { 0, 512, 512, -512 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 512, 512);
-         glDrawTexiOES(0, 0, 0, 512, 512);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-         eglSwapBuffers(dpy, surface);
-     }
-
-     printf("512x512 unmodified texture, 1x1 blit (x2):\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         GLint crop[4] = { 0, 1, 1, -1 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 1, 1);
-         glDrawTexiOES(0, 0, 0, 1, 1);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-         eglSwapBuffers(dpy, surface);
-     }
-
-     
-     printf("512x512 (1x1 texel MODIFIED texture), 512x512 blit:\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         uint16_t green = 0x7E0;
-         GLint crop[4] = { 0, 512, 512, -512 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 1, 1, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, &green);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 512, 512);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-         eglSwapBuffers(dpy, surface);
-     }
-
-
-     int16_t texel = 0xF800;
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB,
-             1, 1, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, &texel);
-
-     printf("1x1 unmodified texture, 1x1 blit:\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         GLint crop[4] = { 0, 1, 1, -1 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 1, 1);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         eglSwapBuffers(dpy, surface);
-     }
-
-     printf("1x1 unmodified texture, 512x512 blit:\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         GLint crop[4] = { 0, 1, 1, -1 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 512, 512);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-         eglSwapBuffers(dpy, surface);
-     }
-
-     printf("1x1 (1x1 texel MODIFIED texture), 512x512 blit:\n");
-     glClear(GL_COLOR_BUFFER_BIT);
-     for (i=0 ; i<4 ; i++) {
-         uint16_t green = 0x7E0;
-         GLint crop[4] = { 0, 1, 1, -1 };
-         glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-         glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 1, 1, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, &green);
-         now = systemTime();
-         glDrawTexiOES(0, 0, 0, 1, 1);
-         glFinish();
-         t = systemTime();
-         printf("glFinish() time = %llu us\n", (t-now)/1000);
-         fflush(stdout);
-         eglSwapBuffers(dpy, surface);
-     }
-
-     return 0;
-}
diff --git a/opengl/tests/gl2_basic/Android.bp b/opengl/tests/gl2_basic/Android.bp
deleted file mode 100644
index f4538adb54..0000000000
--- a/opengl/tests/gl2_basic/Android.bp
+++ /dev/null
@@ -1,25 +0,0 @@
-cc_test {
-    name: "test-opengl-gl2_basic",
-
-    srcs: ["gl2_basic.cpp"],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv2",
-        "libui",
-        "libgui",
-        "libutils",
-    ],
-
-    static_libs: ["libglTest"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-Wall",
-        "-Werror",
-    ],
-
-}
diff --git a/opengl/tests/gl2_basic/gl2_basic.cpp b/opengl/tests/gl2_basic/gl2_basic.cpp
deleted file mode 100644
index 13f6fba92e..0000000000
--- a/opengl/tests/gl2_basic/gl2_basic.cpp
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sched.h>
-#include <sys/resource.h>
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <utils/Timers.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-extern "C" EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name);
-
-static void printGLString(const char *name, GLenum s) {
-    // fprintf(stderr, "printGLString %s, %d\n", name, s);
-    const char *v = (const char *) glGetString(s);
-    // int error = glGetError();
-    // fprintf(stderr, "glGetError() = %d, result of glGetString = %x\n", error,
-    //        (unsigned int) v);
-    // if ((v < (const char*) 0) || (v > (const char*) 0x10000))
-    //    fprintf(stderr, "GL %s = %s\n", name, v);
-    // else
-    //    fprintf(stderr, "GL %s = (null) 0x%08x\n", name, (unsigned int) v);
-    fprintf(stderr, "GL %s = %s\n", name, v);
-}
-
-static void printEGLString(EGLDisplay dpy, const char *name, GLenum s) {
-    const char *v = (const char *) eglQueryString(dpy, s);
-    const char* va = (const char*)eglQueryStringImplementationANDROID(dpy, s);
-    fprintf(stderr, "GL %s = %s\nImplementationANDROID: %s\n", name, v, va);
-}
-
-static void checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE) {
-    if (returnVal != EGL_TRUE) {
-        fprintf(stderr, "%s() returned %d\n", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        fprintf(stderr, "after %s() eglError %s (0x%x)\n", op, EGLUtils::strerror(error),
-                error);
-    }
-}
-
-static void checkGlError(const char* op) {
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        fprintf(stderr, "after %s() glError (0x%x)\n", op, error);
-    }
-}
-
-static const char gVertexShader[] = "attribute vec4 vPosition;\n"
-    "void main() {\n"
-    "  gl_Position = vPosition;\n"
-    "}\n";
-
-static const char gFragmentShader[] = "precision mediump float;\n"
-    "void main() {\n"
-    "  gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
-    "}\n";
-
-GLuint loadShader(GLenum shaderType, const char* pSource) {
-    GLuint shader = glCreateShader(shaderType);
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        glCompileShader(shader);
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    fprintf(stderr, "Could not compile shader %d:\n%s\n",
-                            shaderType, buf);
-                    free(buf);
-                }
-                glDeleteShader(shader);
-                shader = 0;
-            }
-        }
-    }
-    return shader;
-}
-
-GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {
-    GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
-    if (!vertexShader) {
-        return 0;
-    }
-
-    GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);
-    if (!pixelShader) {
-        return 0;
-    }
-
-    GLuint program = glCreateProgram();
-    if (program) {
-        glAttachShader(program, vertexShader);
-        checkGlError("glAttachShader");
-        glAttachShader(program, pixelShader);
-        checkGlError("glAttachShader");
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    fprintf(stderr, "Could not link program:\n%s\n", buf);
-                    free(buf);
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    return program;
-}
-
-GLuint gProgram;
-GLuint gvPositionHandle;
-
-bool setupGraphics(int w, int h) {
-    gProgram = createProgram(gVertexShader, gFragmentShader);
-    if (!gProgram) {
-        return false;
-    }
-    gvPositionHandle = glGetAttribLocation(gProgram, "vPosition");
-    checkGlError("glGetAttribLocation");
-    fprintf(stderr, "glGetAttribLocation(\"vPosition\") = %d\n",
-            gvPositionHandle);
-
-    glViewport(0, 0, w, h);
-    checkGlError("glViewport");
-    return true;
-}
-
-const GLfloat gTriangleVertices[] = { 0.0f, 0.5f, -0.5f, -0.5f,
-        0.5f, -0.5f };
-
-void renderFrame() {
-    glClearColor(0.0f, 0.0f, 1.0f, 1.0f);
-    checkGlError("glClearColor");
-    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    checkGlError("glClear");
-
-    glUseProgram(gProgram);
-    checkGlError("glUseProgram");
-
-    glVertexAttribPointer(gvPositionHandle, 2, GL_FLOAT, GL_FALSE, 0, gTriangleVertices);
-    checkGlError("glVertexAttribPointer");
-    glEnableVertexAttribArray(gvPositionHandle);
-    checkGlError("glEnableVertexAttribArray");
-    glDrawArrays(GL_TRIANGLES, 0, 3);
-    checkGlError("glDrawArrays");
-}
-
-void printEGLConfiguration(EGLDisplay dpy, EGLConfig config) {
-
-#define X(VAL) {VAL, #VAL}
-    struct {EGLint attribute; const char* name;} names[] = {
-    X(EGL_BUFFER_SIZE),
-    X(EGL_ALPHA_SIZE),
-    X(EGL_BLUE_SIZE),
-    X(EGL_GREEN_SIZE),
-    X(EGL_RED_SIZE),
-    X(EGL_DEPTH_SIZE),
-    X(EGL_STENCIL_SIZE),
-    X(EGL_CONFIG_CAVEAT),
-    X(EGL_CONFIG_ID),
-    X(EGL_LEVEL),
-    X(EGL_MAX_PBUFFER_HEIGHT),
-    X(EGL_MAX_PBUFFER_PIXELS),
-    X(EGL_MAX_PBUFFER_WIDTH),
-    X(EGL_NATIVE_RENDERABLE),
-    X(EGL_NATIVE_VISUAL_ID),
-    X(EGL_NATIVE_VISUAL_TYPE),
-    X(EGL_SAMPLES),
-    X(EGL_SAMPLE_BUFFERS),
-    X(EGL_SURFACE_TYPE),
-    X(EGL_TRANSPARENT_TYPE),
-    X(EGL_TRANSPARENT_RED_VALUE),
-    X(EGL_TRANSPARENT_GREEN_VALUE),
-    X(EGL_TRANSPARENT_BLUE_VALUE),
-    X(EGL_BIND_TO_TEXTURE_RGB),
-    X(EGL_BIND_TO_TEXTURE_RGBA),
-    X(EGL_MIN_SWAP_INTERVAL),
-    X(EGL_MAX_SWAP_INTERVAL),
-    X(EGL_LUMINANCE_SIZE),
-    X(EGL_ALPHA_MASK_SIZE),
-    X(EGL_COLOR_BUFFER_TYPE),
-    X(EGL_RENDERABLE_TYPE),
-    X(EGL_CONFORMANT),
-   };
-#undef X
-
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute, &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            printf(" %s: ", names[j].name);
-            printf("%d (0x%x)", value, value);
-        }
-    }
-    printf("\n");
-}
-
-int printEGLConfigurations(EGLDisplay dpy) {
-    EGLint numConfig = 0;
-    EGLint returnVal = eglGetConfigs(dpy, NULL, 0, &numConfig);
-    checkEglError("eglGetConfigs", returnVal);
-    if (!returnVal) {
-        return false;
-    }
-
-    printf("Number of EGL configuration: %d\n", numConfig);
-
-    EGLConfig* configs = (EGLConfig*) malloc(sizeof(EGLConfig) * numConfig);
-    if (! configs) {
-        printf("Could not allocate configs.\n");
-        return false;
-    }
-
-    returnVal = eglGetConfigs(dpy, configs, numConfig, &numConfig);
-    checkEglError("eglGetConfigs", returnVal);
-    if (!returnVal) {
-        free(configs);
-        return false;
-    }
-
-    for(int i = 0; i < numConfig; i++) {
-        printf("Configuration %d\n", i);
-        printEGLConfiguration(dpy, configs[i]);
-    }
-
-    free(configs);
-    return true;
-}
-
-int main(int /*argc*/, char** /*argv*/) {
-    EGLBoolean returnValue;
-    EGLConfig myConfig = {0};
-
-    EGLint context_attribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
-    EGLint s_configAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL_NONE };
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EGLContext context;
-    EGLSurface surface;
-    EGLint w, h;
-
-    EGLDisplay dpy;
-
-    checkEglError("<init>");
-    dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    checkEglError("eglGetDisplay");
-    if (dpy == EGL_NO_DISPLAY) {
-        printf("eglGetDisplay returned EGL_NO_DISPLAY.\n");
-        return 0;
-    }
-
-    returnValue = eglInitialize(dpy, &majorVersion, &minorVersion);
-    checkEglError("eglInitialize", returnValue);
-    fprintf(stderr, "EGL version %d.%d\n", majorVersion, minorVersion);
-    if (returnValue != EGL_TRUE) {
-        printf("eglInitialize failed\n");
-        return 0;
-    }
-
-    if (!printEGLConfigurations(dpy)) {
-        printf("printEGLConfigurations failed\n");
-        return 0;
-    }
-
-    checkEglError("printEGLConfigurations");
-
-    WindowSurface windowSurface;
-    EGLNativeWindowType window = windowSurface.getSurface();
-    returnValue = EGLUtils::selectConfigForNativeWindow(dpy, s_configAttribs, window, &myConfig);
-    if (returnValue) {
-        printf("EGLUtils::selectConfigForNativeWindow() returned %d", returnValue);
-        return 0;
-    }
-
-    checkEglError("EGLUtils::selectConfigForNativeWindow");
-
-    printf("Chose this configuration:\n");
-    printEGLConfiguration(dpy, myConfig);
-
-    surface = eglCreateWindowSurface(dpy, myConfig, window, NULL);
-    checkEglError("eglCreateWindowSurface");
-    if (surface == EGL_NO_SURFACE) {
-        printf("gelCreateWindowSurface failed.\n");
-        return 0;
-    }
-
-    context = eglCreateContext(dpy, myConfig, EGL_NO_CONTEXT, context_attribs);
-    checkEglError("eglCreateContext");
-    if (context == EGL_NO_CONTEXT) {
-        printf("eglCreateContext failed\n");
-        return 0;
-    }
-    returnValue = eglMakeCurrent(dpy, surface, surface, context);
-    checkEglError("eglMakeCurrent", returnValue);
-    if (returnValue != EGL_TRUE) {
-        return 0;
-    }
-    eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-    checkEglError("eglQuerySurface");
-    eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-    checkEglError("eglQuerySurface");
-
-    fprintf(stderr, "Window dimensions: %d x %d\n", w, h);
-
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-    printEGLString(dpy, "EGL Extensions", EGL_EXTENSIONS);
-
-    if(!setupGraphics(w, h)) {
-        fprintf(stderr, "Could not set up graphics.\n");
-        return 0;
-    }
-
-    for (;;) {
-        renderFrame();
-        eglSwapBuffers(dpy, surface);
-        checkEglError("eglSwapBuffers");
-    }
-
-    return 0;
-}
diff --git a/opengl/tests/gl2_cameraeye/Android.mk b/opengl/tests/gl2_cameraeye/Android.mk
deleted file mode 100644
index 4a43a9e2ff..0000000000
--- a/opengl/tests/gl2_cameraeye/Android.mk
+++ /dev/null
@@ -1,16 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-# Only compile source java files in this apk.
-LOCAL_SRC_FILES := $(call all-java-files-under, src)
-
-LOCAL_PACKAGE_NAME := GL2CameraEye
-
-LOCAL_SDK_VERSION := current
-
-include $(BUILD_PACKAGE)
-
-# Use the following include to make our test apk.
-include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/opengl/tests/gl2_cameraeye/AndroidManifest.xml b/opengl/tests/gl2_cameraeye/AndroidManifest.xml
deleted file mode 100644
index c53f7be0b0..0000000000
--- a/opengl/tests/gl2_cameraeye/AndroidManifest.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2011 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-  
-          http://www.apache.org/licenses/LICENSE-2.0
-  
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- Declare the contents of this Android application.  The namespace
-     attribute brings in the Android platform namespace, and the package
-     supplies a unique name for the application.  When writing your
-     own application, the package name must be changed from "com.example.*"
-     to come from a domain that you own or have control over. -->
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.gl2cameraeye">
-    <uses-permission android:name="android.permission.CAMERA" />
-    <uses-feature android:name="android.hardware.camera" />
-    <uses-feature android:name="android.hardware.camera.autofocus" />
-    <uses-feature android:glEsVersion="0x00020000" />
-    <application android:label="@string/gl2cameraeye_name">
-        <activity android:name="GL2CameraEye">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN"/>
-                <category android:name="android.intent.category.LAUNCHER"/>
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/gl2_cameraeye/res/values/strings.xml b/opengl/tests/gl2_cameraeye/res/values/strings.xml
deleted file mode 100644
index 386b930303..0000000000
--- a/opengl/tests/gl2_cameraeye/res/values/strings.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2007 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-  
-          http://www.apache.org/licenses/LICENSE-2.0
-  
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<resources>
-
-    <string name="gl2cameraeye_name">GL2CameraEye</string>
-
-</resources>
diff --git a/opengl/tests/gl2_cameraeye/src/com/android/gl2cameraeye/GL2CameraEye.java b/opengl/tests/gl2_cameraeye/src/com/android/gl2cameraeye/GL2CameraEye.java
deleted file mode 100644
index 561e4c50f0..0000000000
--- a/opengl/tests/gl2_cameraeye/src/com/android/gl2cameraeye/GL2CameraEye.java
+++ /dev/null
@@ -1,508 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gl2cameraeye;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.app.Activity;
-import android.content.pm.ActivityInfo;
-import android.os.Bundle;
-import android.view.MotionEvent;
-import android.content.Context;
-import android.util.Log;
-
-import android.opengl.GLES20;
-import android.opengl.GLSurfaceView;
-import android.opengl.GLUtils;
-import android.opengl.Matrix;
-
-import android.graphics.SurfaceTexture;
-
-import android.hardware.Camera;
-import android.hardware.SensorManager;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.Sensor;
-
-public class GL2CameraEye extends Activity {
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mGLView = new CamGLSurfaceView(this);
-        setContentView(mGLView);
-        setRequestedOrientation (ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        mGLView.onPause();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mGLView.onResume();
-    }
-
-    private GLSurfaceView mGLView;
-}
-
-class CamGLSurfaceView extends GLSurfaceView implements SensorEventListener {
-    public CamGLSurfaceView(Context context) {
-        super(context);
-        setEGLContextClientVersion(2);
-        mRenderer = new CamRenderer(context);
-        setRenderer(mRenderer);
-
-        mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);
-        mAcceleration = mSensorManager.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION);
-    }
-
-    public boolean onTouchEvent(final MotionEvent event) {
-        queueEvent(new Runnable(){
-                public void run() {
-                mRenderer.setPosition(event.getX() / getWidth(),
-                                      event.getY() / getHeight());
-            }});
-        return true;
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mCamera.stopPreview();
-        mCamera.release();
-
-        mSensorManager.unregisterListener(this);
-    }
-
-    @Override
-    public void onResume() {
-        mCamera = Camera.open();
-        Camera.Parameters p = mCamera.getParameters();
-        // No changes to default camera parameters
-        mCamera.setParameters(p);
-
-        queueEvent(new Runnable(){
-                public void run() {
-                    mRenderer.setCamera(mCamera);
-                }});
-
-        mSensorManager.registerListener(this, mAcceleration, SensorManager.SENSOR_DELAY_GAME);
-        super.onResume();
-    }
-
-    public void onSensorChanged(SensorEvent event) {
-        if (event.sensor.getType() == Sensor.TYPE_LINEAR_ACCELERATION) {
-            final float[] accelerationVector = event.values;
-            queueEvent(new Runnable(){
-                    public void run() {
-                        mRenderer.setAcceleration(accelerationVector);
-                    }});
-        }
-    }
-
-    public void onAccuracyChanged(Sensor sensor, int accuracy) {
-        // Ignoring sensor accuracy changes.
-    }
-
-    CamRenderer mRenderer;
-    Camera mCamera;
-
-    SensorManager mSensorManager;
-    Sensor mAcceleration;
-}
-
-class CamRenderer implements GLSurfaceView.Renderer, SurfaceTexture.OnFrameAvailableListener {
-
-    public CamRenderer(Context context) {
-        mContext = context;
-
-        mTriangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length
-                * FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();
-        mTriangleVertices.put(mTriangleVerticesData).position(0);
-
-        Matrix.setIdentityM(mSTMatrix, 0);
-        Matrix.setIdentityM(mMMatrix, 0);
-
-        float[] defaultAcceleration = {0.f,0.f,0.f};
-        setAcceleration(defaultAcceleration);
-        mPos[0] = 0.f;
-        mPos[1] = 0.f;
-        mPos[2] = 0.f;
-        mVel[0] = 0.f;
-        mVel[1] = 0.f;
-        mVel[2] = 0.f;
-
-    }
-
-    /* The following set methods are not synchronized, so should only
-     * be called within the rendering thread context. Use GLSurfaceView.queueEvent for safe access.
-     */
-    public void setPosition(float x, float y) {
-        /* Map from screen (0,0)-(1,1) to scene coordinates */
-        mPos[0] = (x*2-1)*mRatio;
-        mPos[1] = (-y)*2+1;
-        mPos[2] = 0.f;
-        mVel[0] = 0;
-        mVel[1] = 0;
-        mVel[2] = 0;
-    }
-
-    public void setCamera(Camera camera) {
-        mCamera = camera;
-        Camera.Size previewSize = camera.getParameters().getPreviewSize();
-        mCameraRatio = (float)previewSize.width/previewSize.height;
-    }
-
-    public void setAcceleration(float[] accelerationVector) {
-        mGForce[0] = accelerationVector[0];
-        mGForce[1] = accelerationVector[1];
-        mGForce[2] = accelerationVector[2];
-    }
-
-    public void onDrawFrame(GL10 glUnused) {
-        synchronized(this) {
-            if (updateSurface) {
-                mSurface.updateTexImage();
-
-                mSurface.getTransformMatrix(mSTMatrix);
-                long timestamp = mSurface.getTimestamp();
-                doPhysics(timestamp);
-
-                updateSurface = false;
-            }
-        }
-
-        // Ignore the passed-in GL10 interface, and use the GLES20
-        // class's static methods instead.
-        GLES20.glClear( GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
-        GLES20.glUseProgram(mProgram);
-        checkGlError("glUseProgram");
-
-        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
-        GLES20.glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureID);
-
-        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);
-        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false,
-                TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices);
-        checkGlError("glVertexAttribPointer maPosition");
-        GLES20.glEnableVertexAttribArray(maPositionHandle);
-        checkGlError("glEnableVertexAttribArray maPositionHandle");
-
-        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);
-        GLES20.glVertexAttribPointer(maTextureHandle, 3, GLES20.GL_FLOAT, false,
-                TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices);
-        checkGlError("glVertexAttribPointer maTextureHandle");
-        GLES20.glEnableVertexAttribArray(maTextureHandle);
-        checkGlError("glEnableVertexAttribArray maTextureHandle");
-
-        Matrix.multiplyMM(mMVPMatrix, 0, mVMatrix, 0, mMMatrix, 0);
-        Matrix.multiplyMM(mMVPMatrix, 0, mProjMatrix, 0, mMVPMatrix, 0);
-
-        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0);
-        GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0);
-        GLES20.glUniform1f(muCRatioHandle, mCameraRatio);
-
-        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
-        checkGlError("glDrawArrays");
-    }
-
-    public void onSurfaceChanged(GL10 glUnused, int width, int height) {
-        // Ignore the passed-in GL10 interface, and use the GLES20
-        // class's static methods instead.
-        GLES20.glViewport(0, 0, width, height);
-        mRatio = (float) width / height;
-        Matrix.frustumM(mProjMatrix, 0, -mRatio, mRatio, -1, 1, 3, 7);
-    }
-
-    public void onSurfaceCreated(GL10 glUnused, EGLConfig config) {
-        // Ignore the passed-in GL10 interface, and use the GLES20
-        // class's static methods instead.
-
-        /* Set up alpha blending and an Android background color */
-        GLES20.glEnable(GLES20.GL_BLEND);
-        GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA);
-        GLES20.glClearColor(0.643f, 0.776f, 0.223f, 1.0f);
-
-        /* Set up shaders and handles to their variables */
-        mProgram = createProgram(mVertexShader, mFragmentShader);
-        if (mProgram == 0) {
-            return;
-        }
-        maPositionHandle = GLES20.glGetAttribLocation(mProgram, "aPosition");
-        checkGlError("glGetAttribLocation aPosition");
-        if (maPositionHandle == -1) {
-            throw new RuntimeException("Could not get attrib location for aPosition");
-        }
-        maTextureHandle = GLES20.glGetAttribLocation(mProgram, "aTextureCoord");
-        checkGlError("glGetAttribLocation aTextureCoord");
-        if (maTextureHandle == -1) {
-            throw new RuntimeException("Could not get attrib location for aTextureCoord");
-        }
-
-        muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix");
-        checkGlError("glGetUniformLocation uMVPMatrix");
-        if (muMVPMatrixHandle == -1) {
-            throw new RuntimeException("Could not get attrib location for uMVPMatrix");
-        }
-
-        muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uSTMatrix");
-        checkGlError("glGetUniformLocation uSTMatrix");
-        if (muMVPMatrixHandle == -1) {
-            throw new RuntimeException("Could not get attrib location for uSTMatrix");
-        }
-
-        muCRatioHandle = GLES20.glGetUniformLocation(mProgram, "uCRatio");
-        checkGlError("glGetUniformLocation uCRatio");
-        if (muMVPMatrixHandle == -1) {
-            throw new RuntimeException("Could not get attrib location for uCRatio");
-        }
-
-        /*
-         * Create our texture. This has to be done each time the
-         * surface is created.
-         */
-
-        int[] textures = new int[1];
-        GLES20.glGenTextures(1, textures, 0);
-
-        mTextureID = textures[0];
-        GLES20.glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureID);
-        checkGlError("glBindTexture mTextureID");
-
-        // Can't do mipmapping with camera source
-        GLES20.glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER,
-                GLES20.GL_NEAREST);
-        GLES20.glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER,
-                GLES20.GL_LINEAR);
-        // Clamp to edge is the only option
-        GLES20.glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S,
-                GLES20.GL_CLAMP_TO_EDGE);
-        GLES20.glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T,
-                GLES20.GL_CLAMP_TO_EDGE);
-        checkGlError("glTexParameteri mTextureID");
-
-        /*
-         * Create the SurfaceTexture that will feed this textureID, and pass it to the camera
-         */
-
-        mSurface = new SurfaceTexture(mTextureID);
-        mSurface.setOnFrameAvailableListener(this);
-        try {
-            mCamera.setPreviewTexture(mSurface);
-        } catch (IOException t) {
-            Log.e(TAG, "Cannot set preview texture target!");
-        }
-
-        /* Start the camera */
-        mCamera.startPreview();
-
-        Matrix.setLookAtM(mVMatrix, 0, 0, 0, 5f, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
-
-        mLastTime = 0;
-
-        synchronized(this) {
-            updateSurface = false;
-        }
-    }
-
-    synchronized public void onFrameAvailable(SurfaceTexture surface) {
-        /* For simplicity, SurfaceTexture calls here when it has new
-         * data available.  Call may come in from some random thread,
-         * so let's be safe and use synchronize. No OpenGL calls can be done here.
-         */
-        updateSurface = true;
-    }
-
-    private void doPhysics(long timestamp) {
-        /*
-         * Move the camera surface around based on some simple spring physics with drag
-         */
-
-        if (mLastTime == 0)
-            mLastTime = timestamp;
-
-        float deltaT = (timestamp - mLastTime)/1000000000.f; // To seconds
-
-        float springStrength = 20.f;
-        float frictionCoeff = 10.f;
-        float mass = 10.f;
-        float gMultiplier = 4.f;
-        /* Only update physics every 30 ms */
-        if (deltaT > 0.030f) {
-            mLastTime = timestamp;
-
-            float[] totalForce = new float[3];
-            totalForce[0] = -mPos[0] * springStrength - mVel[0]*frictionCoeff + gMultiplier*mGForce[0]*mass;
-            totalForce[1] = -mPos[1] * springStrength - mVel[1]*frictionCoeff + gMultiplier*mGForce[1]*mass;
-            totalForce[2] = -mPos[2] * springStrength - mVel[2]*frictionCoeff + gMultiplier*mGForce[2]*mass;
-
-            float[] accel = new float[3];
-            accel[0] = totalForce[0]/mass;
-            accel[1] = totalForce[1]/mass;
-            accel[2] = totalForce[2]/mass;
-
-            /* Not a very accurate integrator */
-            mVel[0] = mVel[0] + accel[0]*deltaT;
-            mVel[1] = mVel[1] + accel[1]*deltaT;
-            mVel[2] = mVel[2] + accel[2]*deltaT;
-
-            mPos[0] = mPos[0] + mVel[0]*deltaT;
-            mPos[1] = mPos[1] + mVel[1]*deltaT;
-            mPos[2] = mPos[2] + mVel[2]*deltaT;
-
-            Matrix.setIdentityM(mMMatrix, 0);
-            Matrix.translateM(mMMatrix, 0, mPos[0], mPos[1], mPos[2]);
-        }
-
-    }
-
-    private int loadShader(int shaderType, String source) {
-        int shader = GLES20.glCreateShader(shaderType);
-        if (shader != 0) {
-            GLES20.glShaderSource(shader, source);
-            GLES20.glCompileShader(shader);
-            int[] compiled = new int[1];
-            GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0);
-            if (compiled[0] == 0) {
-                Log.e(TAG, "Could not compile shader " + shaderType + ":");
-                Log.e(TAG, GLES20.glGetShaderInfoLog(shader));
-                GLES20.glDeleteShader(shader);
-                shader = 0;
-            }
-        }
-        return shader;
-    }
-
-    private int createProgram(String vertexSource, String fragmentSource) {
-        int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);
-        if (vertexShader == 0) {
-            return 0;
-        }
-        int pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);
-        if (pixelShader == 0) {
-            return 0;
-        }
-
-        int program = GLES20.glCreateProgram();
-        if (program != 0) {
-            GLES20.glAttachShader(program, vertexShader);
-            checkGlError("glAttachShader");
-            GLES20.glAttachShader(program, pixelShader);
-            checkGlError("glAttachShader");
-            GLES20.glLinkProgram(program);
-            int[] linkStatus = new int[1];
-            GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0);
-            if (linkStatus[0] != GLES20.GL_TRUE) {
-                Log.e(TAG, "Could not link program: ");
-                Log.e(TAG, GLES20.glGetProgramInfoLog(program));
-                GLES20.glDeleteProgram(program);
-                program = 0;
-            }
-        }
-        return program;
-    }
-
-    private void checkGlError(String op) {
-        int error;
-        while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
-            Log.e(TAG, op + ": glError " + error);
-            throw new RuntimeException(op + ": glError " + error);
-        }
-    }
-
-    private static final int FLOAT_SIZE_BYTES = 4;
-    private static final int TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES;
-    private static final int TRIANGLE_VERTICES_DATA_POS_OFFSET = 0;
-    private static final int TRIANGLE_VERTICES_DATA_UV_OFFSET = 3;
-    private final float[] mTriangleVerticesData = {
-        // X, Y, Z, U, V
-        -1.0f, -1.0f, 0, 0.f, 0.f,
-        1.0f, -1.0f, 0, 1.f, 0.f,
-        -1.0f,  1.0f, 0, 0.f, 1.f,
-        1.0f,   1.0f, 0, 1.f, 1.f,
-    };
-
-    private FloatBuffer mTriangleVertices;
-
-    private final String mVertexShader =
-        "uniform mat4 uMVPMatrix;\n" +
-        "uniform mat4 uSTMatrix;\n" +
-        "uniform float uCRatio;\n" +
-        "attribute vec4 aPosition;\n" +
-        "attribute vec4 aTextureCoord;\n" +
-        "varying vec2 vTextureCoord;\n" +
-        "varying vec2 vTextureNormCoord;\n" +
-        "void main() {\n" +
-        "  vec4 scaledPos = aPosition;\n" +
-        "  scaledPos.x = scaledPos.x * uCRatio;\n" +
-        "  gl_Position = uMVPMatrix * scaledPos;\n" +
-        "  vTextureCoord = (uSTMatrix * aTextureCoord).xy;\n" +
-        "  vTextureNormCoord = aTextureCoord.xy;\n" +
-        "}\n";
-
-    private final String mFragmentShader =
-        "#extension GL_OES_EGL_image_external : require\n" +
-        "precision mediump float;\n" +
-        "varying vec2 vTextureCoord;\n" +
-        "varying vec2 vTextureNormCoord;\n" +
-        "uniform samplerExternalOES sTexture;\n" +
-        "void main() {\n" +
-        "  gl_FragColor = texture2D(sTexture, vTextureCoord);\n" +
-        "  gl_FragColor.a = 1.0-min(length(vTextureNormCoord-0.5)*2.0,1.0);\n" +
-        "}\n";
-
-    private float[] mMVPMatrix = new float[16];
-    private float[] mProjMatrix = new float[16];
-    private float[] mMMatrix = new float[16];
-    private float[] mVMatrix = new float[16];
-    private float[] mSTMatrix = new float[16];
-
-    private int mProgram;
-    private int mTextureID;
-    private int muMVPMatrixHandle;
-    private int muSTMatrixHandle;
-    private int muCRatioHandle;
-    private int maPositionHandle;
-    private int maTextureHandle;
-
-    private float mRatio = 1.0f;
-    private float mCameraRatio = 1.0f;
-    private float[] mVel = new float[3];
-    private float[] mPos = new float[3];
-    private float[] mGForce = new float[3];
-
-    private long mLastTime;
-
-    private SurfaceTexture mSurface;
-    private Camera mCamera;
-    private boolean updateSurface = false;
-
-    private Context mContext;
-    private static String TAG = "CamRenderer";
-
-    // Magic key
-    private static int GL_TEXTURE_EXTERNAL_OES = 0x8D65;
-}
diff --git a/opengl/tests/gl2_copyTexImage/Android.bp b/opengl/tests/gl2_copyTexImage/Android.bp
deleted file mode 100644
index 87fa7ea37d..0000000000
--- a/opengl/tests/gl2_copyTexImage/Android.bp
+++ /dev/null
@@ -1,24 +0,0 @@
-cc_test {
-    name: "test-opengl-gl2_copyTexImage",
-
-    srcs: ["gl2_copyTexImage.cpp"],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv2",
-        "libui",
-        "libgui",
-        "libutils",
-    ],
-
-    static_libs: ["libglTest"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-Wall",
-        "-Werror",
-    ],
-}
diff --git a/opengl/tests/gl2_copyTexImage/gl2_copyTexImage.cpp b/opengl/tests/gl2_copyTexImage/gl2_copyTexImage.cpp
deleted file mode 100644
index ada98aa0c0..0000000000
--- a/opengl/tests/gl2_copyTexImage/gl2_copyTexImage.cpp
+++ /dev/null
@@ -1,467 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sched.h>
-#include <sys/resource.h>
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <utils/Timers.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-static void printGLString(const char *name, GLenum s) {
-    // fprintf(stderr, "printGLString %s, %d\n", name, s);
-    const char *v = (const char *) glGetString(s);
-    // int error = glGetError();
-    // fprintf(stderr, "glGetError() = %d, result of glGetString = %x\n", error,
-    //        (unsigned int) v);
-    // if ((v < (const char*) 0) || (v > (const char*) 0x10000))
-    //    fprintf(stderr, "GL %s = %s\n", name, v);
-    // else
-    //    fprintf(stderr, "GL %s = (null) 0x%08x\n", name, (unsigned int) v);
-    fprintf(stderr, "GL %s = %s\n", name, v);
-}
-
-static void checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE) {
-    if (returnVal != EGL_TRUE) {
-        fprintf(stderr, "%s() returned %d\n", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        fprintf(stderr, "after %s() eglError %s (0x%x)\n", op, EGLUtils::strerror(error),
-                error);
-    }
-}
-
-static void checkGlError(const char* op) {
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        fprintf(stderr, "after %s() glError (0x%x)\n", op, error);
-    }
-}
-
-static const char gVertexShader[] = "attribute vec4 vPosition;\n"
-    "void main() {\n"
-    "  gl_Position = vPosition;\n"
-    "}\n";
-
-static const char gFragmentShader[] = "precision mediump float;\n"
-    "void main() {\n"
-    "  gl_FragColor = vec4(0.0, 1.0, 0.0, 0.5);\n"
-    "}\n";
-
-GLuint loadShader(GLenum shaderType, const char* pSource) {
-    GLuint shader = glCreateShader(shaderType);
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        glCompileShader(shader);
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    fprintf(stderr, "Could not compile shader %d:\n%s\n",
-                            shaderType, buf);
-                    free(buf);
-                }
-                glDeleteShader(shader);
-                shader = 0;
-            }
-        }
-    }
-    return shader;
-}
-
-GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {
-    GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
-    if (!vertexShader) {
-        return 0;
-    }
-
-    GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);
-    if (!pixelShader) {
-        return 0;
-    }
-
-    GLuint program = glCreateProgram();
-    if (program) {
-        glAttachShader(program, vertexShader);
-        checkGlError("glAttachShader");
-        glAttachShader(program, pixelShader);
-        checkGlError("glAttachShader");
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    fprintf(stderr, "Could not link program:\n%s\n", buf);
-                    free(buf);
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    return program;
-}
-
-GLuint gProgram;
-GLuint gTextureProgram;
-GLuint gvPositionHandle;
-GLuint gvTexturePositionHandle;
-GLuint gvTextureTexCoordsHandle;
-GLuint gvTextureSamplerHandle;
-GLuint gFbo;
-GLuint gTexture;
-GLuint gBufferTexture;
-
-static const char gSimpleVS[] =
-    "attribute vec4 position;\n"
-    "attribute vec2 texCoords;\n"
-    "varying vec2 outTexCoords;\n"
-    "\nvoid main(void) {\n"
-    "    outTexCoords = texCoords;\n"
-    "    gl_Position = position;\n"
-    "}\n\n";
-static const char gSimpleFS[] =
-    "precision mediump float;\n\n"
-    "varying vec2 outTexCoords;\n"
-    "uniform sampler2D texture;\n"
-    "\nvoid main(void) {\n"
-    "    gl_FragColor = texture2D(texture, outTexCoords);\n"
-    "}\n\n";
-
-bool setupGraphics(int w, int h) {
-    gProgram = createProgram(gVertexShader, gFragmentShader);
-    if (!gProgram) {
-        return false;
-    }
-    gvPositionHandle = glGetAttribLocation(gProgram, "vPosition");
-    checkGlError("glGetAttribLocation");
-    fprintf(stderr, "glGetAttribLocation(\"vPosition\") = %d\n", gvPositionHandle);
-
-    gTextureProgram = createProgram(gSimpleVS, gSimpleFS);
-    if (!gTextureProgram) {
-        return false;
-    }
-    gvTexturePositionHandle = glGetAttribLocation(gTextureProgram, "position");
-    checkGlError("glGetAttribLocation");
-    gvTextureTexCoordsHandle = glGetAttribLocation(gTextureProgram, "texCoords");
-    checkGlError("glGetAttribLocation");
-    gvTextureSamplerHandle = glGetUniformLocation(gTextureProgram, "texture");
-    checkGlError("glGetAttribLocation");
-
-    glActiveTexture(GL_TEXTURE0);
-
-    glGenTextures(1, &gTexture);
-    glBindTexture(GL_TEXTURE_2D, gTexture);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-
-    glGenTextures(1, &gBufferTexture);
-    glBindTexture(GL_TEXTURE_2D, gBufferTexture);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-
-    glGenFramebuffers(1, &gFbo);
-    glBindFramebuffer(GL_FRAMEBUFFER, gFbo);
-    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gTexture, 0);
-
-    glBindFramebuffer(GL_FRAMEBUFFER, 0);
-
-    glViewport(0, 0, w, h);
-    checkGlError("glViewport");
-    return true;
-}
-
-const GLfloat gTriangleVertices[] = { 0.0f, 0.5f, -0.5f, -0.5f,
-        0.5f, -0.5f };
-
-const GLint FLOAT_SIZE_BYTES = 4;
-const GLint TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES;
-const GLfloat gTriangleVerticesData[] = {
-    // X, Y, Z, U, V
-    -1.0f, -1.0f, 0, 0.f, 0.f,
-    1.0f, -1.0f, 0, 1.f, 0.f,
-    -1.0f,  1.0f, 0, 0.f, 1.f,
-    1.0f,   1.0f, 0, 1.f, 1.f,
-};
-
-void renderFrame(GLint w, GLint h) {
-    glClearColor(1.0f, 0.0f, 0.0f, 1.0f);
-    checkGlError("glClearColor");
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    checkGlError("glClear");
-
-    // Bind FBO and draw into it
-    glBindFramebuffer(GL_FRAMEBUFFER, gFbo);
-    checkGlError("glBindFramebuffer");
-
-    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
-    checkGlError("glClearColor");
-    glClear(GL_COLOR_BUFFER_BIT);
-    checkGlError("glClear");
-
-    glUseProgram(gProgram);
-    checkGlError("glUseProgram");
-
-    glVertexAttribPointer(gvPositionHandle, 2, GL_FLOAT, GL_FALSE, 0, gTriangleVertices);
-    checkGlError("glVertexAttribPointer");
-    glEnableVertexAttribArray(gvPositionHandle);
-    checkGlError("glEnableVertexAttribArray");
-    glDrawArrays(GL_TRIANGLES, 0, 3);
-    checkGlError("glDrawArrays");
-
-    // Copy content of FBO into a texture
-    glBindTexture(GL_TEXTURE_2D, gBufferTexture);
-    glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, w / 2, h / 2);
-    checkGlError("glCopyTexSubImage2D");
-
-    // Back to the display
-    glBindFramebuffer(GL_FRAMEBUFFER, 0);
-    checkGlError("glBindFramebuffer");
-
-    // Draw copied content on the screen
-    glUseProgram(gTextureProgram);
-    checkGlError("glUseProgram");
-
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
-
-    glVertexAttribPointer(gvTexturePositionHandle, 3, GL_FLOAT, GL_FALSE,
-            TRIANGLE_VERTICES_DATA_STRIDE_BYTES, gTriangleVerticesData);
-    checkGlError("glVertexAttribPointer");
-    glVertexAttribPointer(gvTextureTexCoordsHandle, 2, GL_FLOAT, GL_FALSE,
-            TRIANGLE_VERTICES_DATA_STRIDE_BYTES, &gTriangleVerticesData[3]);
-    checkGlError("glVertexAttribPointer");
-    glEnableVertexAttribArray(gvTexturePositionHandle);
-    glEnableVertexAttribArray(gvTextureTexCoordsHandle);
-    checkGlError("glEnableVertexAttribArray");
-    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-    checkGlError("glDrawArrays");
-}
-
-void printEGLConfiguration(EGLDisplay dpy, EGLConfig config) {
-
-#define X(VAL) {VAL, #VAL}
-    struct {EGLint attribute; const char* name;} names[] = {
-    X(EGL_BUFFER_SIZE),
-    X(EGL_ALPHA_SIZE),
-    X(EGL_BLUE_SIZE),
-    X(EGL_GREEN_SIZE),
-    X(EGL_RED_SIZE),
-    X(EGL_DEPTH_SIZE),
-    X(EGL_STENCIL_SIZE),
-    X(EGL_CONFIG_CAVEAT),
-    X(EGL_CONFIG_ID),
-    X(EGL_LEVEL),
-    X(EGL_MAX_PBUFFER_HEIGHT),
-    X(EGL_MAX_PBUFFER_PIXELS),
-    X(EGL_MAX_PBUFFER_WIDTH),
-    X(EGL_NATIVE_RENDERABLE),
-    X(EGL_NATIVE_VISUAL_ID),
-    X(EGL_NATIVE_VISUAL_TYPE),
-    X(EGL_SAMPLES),
-    X(EGL_SAMPLE_BUFFERS),
-    X(EGL_SURFACE_TYPE),
-    X(EGL_TRANSPARENT_TYPE),
-    X(EGL_TRANSPARENT_RED_VALUE),
-    X(EGL_TRANSPARENT_GREEN_VALUE),
-    X(EGL_TRANSPARENT_BLUE_VALUE),
-    X(EGL_BIND_TO_TEXTURE_RGB),
-    X(EGL_BIND_TO_TEXTURE_RGBA),
-    X(EGL_MIN_SWAP_INTERVAL),
-    X(EGL_MAX_SWAP_INTERVAL),
-    X(EGL_LUMINANCE_SIZE),
-    X(EGL_ALPHA_MASK_SIZE),
-    X(EGL_COLOR_BUFFER_TYPE),
-    X(EGL_RENDERABLE_TYPE),
-    X(EGL_CONFORMANT),
-   };
-#undef X
-
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute, &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            printf(" %s: ", names[j].name);
-            printf("%d (0x%x)", value, value);
-        }
-    }
-    printf("\n");
-}
-
-int printEGLConfigurations(EGLDisplay dpy) {
-    EGLint numConfig = 0;
-    EGLint returnVal = eglGetConfigs(dpy, NULL, 0, &numConfig);
-    checkEglError("eglGetConfigs", returnVal);
-    if (!returnVal) {
-        return false;
-    }
-
-    printf("Number of EGL configuration: %d\n", numConfig);
-
-    EGLConfig* configs = (EGLConfig*) malloc(sizeof(EGLConfig) * numConfig);
-    if (! configs) {
-        printf("Could not allocate configs.\n");
-        return false;
-    }
-
-    returnVal = eglGetConfigs(dpy, configs, numConfig, &numConfig);
-    checkEglError("eglGetConfigs", returnVal);
-    if (!returnVal) {
-        free(configs);
-        return false;
-    }
-
-    for(int i = 0; i < numConfig; i++) {
-        printf("Configuration %d\n", i);
-        printEGLConfiguration(dpy, configs[i]);
-    }
-
-    free(configs);
-    return true;
-}
-
-int main(int /*argc*/, char** /*argv*/) {
-    EGLBoolean returnValue;
-    EGLConfig myConfig = {0};
-
-    EGLint context_attribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
-    EGLint s_configAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL_RED_SIZE, 8,
-            EGL_GREEN_SIZE, 8,
-            EGL_BLUE_SIZE, 8,
-            EGL_ALPHA_SIZE, 8,
-            EGL_NONE };
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EGLContext context;
-    EGLSurface surface;
-    EGLint w, h;
-
-    EGLDisplay dpy;
-
-    checkEglError("<init>");
-    dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    checkEglError("eglGetDisplay");
-    if (dpy == EGL_NO_DISPLAY) {
-        printf("eglGetDisplay returned EGL_NO_DISPLAY.\n");
-        return 0;
-    }
-
-    returnValue = eglInitialize(dpy, &majorVersion, &minorVersion);
-    checkEglError("eglInitialize", returnValue);
-    fprintf(stderr, "EGL version %d.%d\n", majorVersion, minorVersion);
-    if (returnValue != EGL_TRUE) {
-        printf("eglInitialize failed\n");
-        return 0;
-    }
-
-    if (!printEGLConfigurations(dpy)) {
-        printf("printEGLConfigurations failed\n");
-        return 0;
-    }
-
-    checkEglError("printEGLConfigurations");
-
-    WindowSurface windowSurface;
-    EGLNativeWindowType window = windowSurface.getSurface();
-    EGLint numConfigs = -1, n = 0;
-    eglChooseConfig(dpy, s_configAttribs, 0, 0, &numConfigs);
-    if (numConfigs) {
-        EGLConfig* const configs = new EGLConfig[numConfigs];
-        eglChooseConfig(dpy, s_configAttribs, configs, numConfigs, &n);
-        myConfig = configs[0];
-        delete[] configs;
-    }
-
-    checkEglError("EGLUtils::selectConfigForNativeWindow");
-
-    printf("Chose this configuration:\n");
-    printEGLConfiguration(dpy, myConfig);
-
-    surface = eglCreateWindowSurface(dpy, myConfig, window, NULL);
-    checkEglError("eglCreateWindowSurface");
-    if (surface == EGL_NO_SURFACE) {
-        printf("gelCreateWindowSurface failed.\n");
-        return 0;
-    }
-
-    context = eglCreateContext(dpy, myConfig, EGL_NO_CONTEXT, context_attribs);
-    checkEglError("eglCreateContext");
-    if (context == EGL_NO_CONTEXT) {
-        printf("eglCreateContext failed\n");
-        return 0;
-    }
-    returnValue = eglMakeCurrent(dpy, surface, surface, context);
-    checkEglError("eglMakeCurrent", returnValue);
-    if (returnValue != EGL_TRUE) {
-        return 0;
-    }
-    eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-    checkEglError("eglQuerySurface");
-    eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-    checkEglError("eglQuerySurface");
-
-    fprintf(stderr, "Window dimensions: %d x %d\n", w, h);
-
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-
-    if(!setupGraphics(w, h)) {
-        fprintf(stderr, "Could not set up graphics.\n");
-        return 0;
-    }
-
-    for (;;) {
-        renderFrame(w, h);
-        eglSwapBuffers(dpy, surface);
-        checkEglError("eglSwapBuffers");
-    }
-
-    return 0;
-}
diff --git a/opengl/tests/gl2_java/Android.mk b/opengl/tests/gl2_java/Android.mk
deleted file mode 100644
index 71aa5a05f1..0000000000
--- a/opengl/tests/gl2_java/Android.mk
+++ /dev/null
@@ -1,19 +0,0 @@
-#########################################################################
-# OpenGL ES 2.0 Java sample
-#########################################################################
-
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := GL2Java
-LOCAL_SDK_VERSION := current
-
-include $(BUILD_PACKAGE)
diff --git a/opengl/tests/gl2_java/AndroidManifest.xml b/opengl/tests/gl2_java/AndroidManifest.xml
deleted file mode 100644
index 8bb6840a16..0000000000
--- a/opengl/tests/gl2_java/AndroidManifest.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.gl2java">
-    <uses-feature android:glEsVersion="0x00020000" />
-    <application
-            android:label="@string/gl2java_activity">
-        <activity android:name="GL2JavaActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-            	android:launchMode="singleTask"
-            	android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/gl2_java/res/values/strings.xml b/opengl/tests/gl2_java/res/values/strings.xml
deleted file mode 100644
index 06bd23c972..0000000000
--- a/opengl/tests/gl2_java/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="gl2java_activity">GL2Java</string>
-
-</resources>
-
diff --git a/opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaActivity.java b/opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaActivity.java
deleted file mode 100644
index 37654fbd57..0000000000
--- a/opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaActivity.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gl2java;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.WindowManager;
-
-import java.io.File;
-
-
-public class GL2JavaActivity extends Activity {
-
-    GL2JavaView mView;
-
-    @Override protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        mView = new GL2JavaView(getApplication());
-	setContentView(mView);
-    }
-
-    @Override protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaView.java b/opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaView.java
deleted file mode 100644
index 7f2bfd3e34..0000000000
--- a/opengl/tests/gl2_java/src/com/android/gl2java/GL2JavaView.java
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gl2java;
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.opengl.GLES20;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class GL2JavaView extends GLSurfaceView {
-    private static String TAG = "GL2JavaView";
-
-    public GL2JavaView(Context context) {
-        super(context);
-        setEGLContextClientVersion(2);
-        setRenderer(new Renderer());
-    }
-
-    private static class Renderer implements GLSurfaceView.Renderer {
-
-        public Renderer() {
-            mTriangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length * 4)
-                .order(ByteOrder.nativeOrder()).asFloatBuffer();
-            mTriangleVertices.put(mTriangleVerticesData).position(0);
-        }
-
-        public void onDrawFrame(GL10 gl) {
-            GLES20.glClearColor(0.0f, 0.0f, 1.0f, 1.0f);
-            GLES20.glClear( GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
-            GLES20.glUseProgram(mProgram);
-            checkGlError("glUseProgram");
-
-            GLES20.glVertexAttribPointer(mvPositionHandle, 2, GLES20.GL_FLOAT, false, 0, mTriangleVertices);
-            checkGlError("glVertexAttribPointer");
-            GLES20.glEnableVertexAttribArray(mvPositionHandle);
-            checkGlError("glEnableVertexAttribArray");
-            GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);
-            checkGlError("glDrawArrays");
-
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            GLES20.glViewport(0, 0, width, height);
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            mProgram = createProgram(mVertexShader, mFragmentShader);
-            if (mProgram == 0) {
-                return;
-            }
-            mvPositionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition");
-            checkGlError("glGetAttribLocation");
-            if (mvPositionHandle == -1) {
-                throw new RuntimeException("Could not get attrib location for vPosition");
-            }
-        }
-
-        private int loadShader(int shaderType, String source) {
-            int shader = GLES20.glCreateShader(shaderType);
-            if (shader != 0) {
-                GLES20.glShaderSource(shader, source);
-                GLES20.glCompileShader(shader);
-                int[] compiled = new int[1];
-                GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0);
-                if (compiled[0] == 0) {
-                    Log.e(TAG, "Could not compile shader " + shaderType + ":");
-                    Log.e(TAG, GLES20.glGetShaderInfoLog(shader));
-                    GLES20.glDeleteShader(shader);
-                    shader = 0;
-                }
-            }
-            return shader;
-        }
-
-        private int createProgram(String vertexSource, String fragmentSource) {
-            int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);
-            if (vertexShader == 0) {
-                return 0;
-            }
-
-            int pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);
-            if (pixelShader == 0) {
-                return 0;
-            }
-
-            int program = GLES20.glCreateProgram();
-            if (program != 0) {
-                GLES20.glAttachShader(program, vertexShader);
-                checkGlError("glAttachShader");
-                GLES20.glAttachShader(program, pixelShader);
-                checkGlError("glAttachShader");
-                GLES20.glLinkProgram(program);
-                int[] linkStatus = new int[1];
-                GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0);
-                if (linkStatus[0] != GLES20.GL_TRUE) {
-                    Log.e(TAG, "Could not link program: ");
-                    Log.e(TAG, GLES20.glGetProgramInfoLog(program));
-                    GLES20.glDeleteProgram(program);
-                    program = 0;
-                }
-            }
-            return program;
-        }
-
-        private void checkGlError(String op) {
-            int error;
-            while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
-                Log.e(TAG, op + ": glError " + error);
-                throw new RuntimeException(op + ": glError " + error);
-            }
-        }
-
-        private final float[] mTriangleVerticesData = { 0.0f, 0.5f, -0.5f, -0.5f,
-                0.5f, -0.5f };
-
-        private FloatBuffer mTriangleVertices;
-
-        private final String mVertexShader = "attribute vec4 vPosition;\n"
-            + "void main() {\n"
-            + "  gl_Position = vPosition;\n"
-            + "}\n";
-
-        private final String mFragmentShader = "precision mediump float;\n"
-            + "void main() {\n"
-            + "  gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
-            + "}\n";
-
-        private int mProgram;
-        private int mvPositionHandle;
-
-    }
-}
-
diff --git a/opengl/tests/gl2_jni/Android.mk b/opengl/tests/gl2_jni/Android.mk
deleted file mode 100644
index b0081c2244..0000000000
--- a/opengl/tests/gl2_jni/Android.mk
+++ /dev/null
@@ -1,49 +0,0 @@
-#########################################################################
-# OpenGL ES JNI sample
-# This makefile builds both an activity and a shared library.
-#########################################################################
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := GL2JNI
-LOCAL_SDK_VERSION := current
-
-LOCAL_JNI_SHARED_LIBRARIES := libgl2jni
-
-include $(BUILD_PACKAGE)
-
-#########################################################################
-# Build JNI Shared Library
-#########################################################################
-
-LOCAL_PATH:= $(LOCAL_PATH)/jni
-
-include $(CLEAR_VARS)
-
-# Optional tag would mean it doesn't get installed by default
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -Werror -Wno-error=unused-parameter
-
-LOCAL_SRC_FILES:= \
-  gl_code.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-	liblog \
-	libEGL \
-	libGLESv2
-
-LOCAL_MODULE := libgl2jni
-
-LOCAL_SDK_VERSION := current
-
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/opengl/tests/gl2_jni/AndroidManifest.xml b/opengl/tests/gl2_jni/AndroidManifest.xml
deleted file mode 100644
index 1827e5f377..0000000000
--- a/opengl/tests/gl2_jni/AndroidManifest.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.gl2jni">
-    <application
-            android:label="@string/gl2jni_activity">
-        <activity android:name="GL2JNIActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-            	android:launchMode="singleTask"
-            	android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/gl2_jni/jni/gl_code.cpp b/opengl/tests/gl2_jni/jni/gl_code.cpp
deleted file mode 100644
index 9b22c6cfd5..0000000000
--- a/opengl/tests/gl2_jni/jni/gl_code.cpp
+++ /dev/null
@@ -1,170 +0,0 @@
-// OpenGL ES 2.0 code
-
-#include <jni.h>
-#define LOG_TAG "GL2JNI gl_code.cpp"
-#include <android/log.h>
-
-#define ALOG(priority, tag, ...) ((void)__android_log_print(ANDROID_##priority, tag, __VA_ARGS__))
-
-#define ALOGI(...) ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__)
-#define ALOGE(...) ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__)
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-static void printGLString(const char *name, GLenum s) {
-    const char *v = (const char *) glGetString(s);
-    ALOGI("GL %s = %s\n", name, v);
-}
-
-static void checkGlError(const char* op) {
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        ALOGI("after %s() glError (0x%x)\n", op, error);
-    }
-}
-
-static const char gVertexShader[] = "attribute vec4 vPosition;\n"
-    "void main() {\n"
-    "  gl_Position = vPosition;\n"
-    "}\n";
-
-static const char gFragmentShader[] = "precision mediump float;\n"
-    "void main() {\n"
-    "  gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
-    "}\n";
-
-GLuint loadShader(GLenum shaderType, const char* pSource) {
-    GLuint shader = glCreateShader(shaderType);
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        glCompileShader(shader);
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    ALOGE("Could not compile shader %d:\n%s\n",
-                            shaderType, buf);
-                    free(buf);
-                }
-                glDeleteShader(shader);
-                shader = 0;
-            }
-        }
-    }
-    return shader;
-}
-
-GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {
-    GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
-    if (!vertexShader) {
-        return 0;
-    }
-
-    GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);
-    if (!pixelShader) {
-        return 0;
-    }
-
-    GLuint program = glCreateProgram();
-    if (program) {
-        glAttachShader(program, vertexShader);
-        checkGlError("glAttachShader");
-        glAttachShader(program, pixelShader);
-        checkGlError("glAttachShader");
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    ALOGE("Could not link program:\n%s\n", buf);
-                    free(buf);
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    return program;
-}
-
-GLuint gProgram;
-GLuint gvPositionHandle;
-
-bool setupGraphics(int w, int h) {
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-
-    ALOGI("setupGraphics(%d, %d)", w, h);
-    gProgram = createProgram(gVertexShader, gFragmentShader);
-    if (!gProgram) {
-        ALOGE("Could not create program.");
-        return false;
-    }
-    gvPositionHandle = glGetAttribLocation(gProgram, "vPosition");
-    checkGlError("glGetAttribLocation");
-    ALOGI("glGetAttribLocation(\"vPosition\") = %d\n",
-            gvPositionHandle);
-
-    glViewport(0, 0, w, h);
-    checkGlError("glViewport");
-    return true;
-}
-
-const GLfloat gTriangleVertices[] = { 0.0f, 0.5f, -0.5f, -0.5f,
-        0.5f, -0.5f };
-
-void renderFrame() {
-    static float grey;
-    grey += 0.01f;
-    if (grey > 1.0f) {
-        grey = 0.0f;
-    }
-    glClearColor(grey, grey, grey, 1.0f);
-    checkGlError("glClearColor");
-    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    checkGlError("glClear");
-
-    glUseProgram(gProgram);
-    checkGlError("glUseProgram");
-
-    glVertexAttribPointer(gvPositionHandle, 2, GL_FLOAT, GL_FALSE, 0, gTriangleVertices);
-    checkGlError("glVertexAttribPointer");
-    glEnableVertexAttribArray(gvPositionHandle);
-    checkGlError("glEnableVertexAttribArray");
-    glDrawArrays(GL_TRIANGLES, 0, 3);
-    checkGlError("glDrawArrays");
-}
-
-extern "C" {
-    JNIEXPORT void JNICALL Java_com_android_gl2jni_GL2JNILib_init(JNIEnv * env, jobject obj,  jint width, jint height);
-    JNIEXPORT void JNICALL Java_com_android_gl2jni_GL2JNILib_step(JNIEnv * env, jobject obj);
-};
-
-JNIEXPORT void JNICALL Java_com_android_gl2jni_GL2JNILib_init(JNIEnv * /*env*/, jobject /*obj*/,  jint width, jint height)
-{
-    setupGraphics(width, height);
-}
-
-JNIEXPORT void JNICALL Java_com_android_gl2jni_GL2JNILib_step(JNIEnv * /*env*/, jobject /*obj*/)
-{
-    renderFrame();
-}
-
diff --git a/opengl/tests/gl2_jni/res/values/strings.xml b/opengl/tests/gl2_jni/res/values/strings.xml
deleted file mode 100644
index a29c74b25d..0000000000
--- a/opengl/tests/gl2_jni/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="gl2jni_activity">GL2JNI</string>
-
-</resources>
-
diff --git a/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIActivity.java b/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIActivity.java
deleted file mode 100644
index c366a2cbc3..0000000000
--- a/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIActivity.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gl2jni;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.WindowManager;
-
-import java.io.File;
-
-
-public class GL2JNIActivity extends Activity {
-
-    GL2JNIView mView;
-
-    @Override protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        mView = new GL2JNIView(getApplication());
-	setContentView(mView);
-    }
-
-    @Override protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNILib.java b/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNILib.java
deleted file mode 100644
index 040a984804..0000000000
--- a/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNILib.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gl2jni;
-
-// Wrapper for native library
-
-public class GL2JNILib {
-
-     static {
-         System.loadLibrary("gl2jni");
-     }
-
-    /**
-     * @param width the current view width
-     * @param height the current view height
-     */
-     public static native void init(int width, int height);
-     public static native void step();
-}
diff --git a/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIView.java b/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIView.java
deleted file mode 100644
index 72b1dfb9bb..0000000000
--- a/opengl/tests/gl2_jni/src/com/android/gl2jni/GL2JNIView.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gl2jni;
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class GL2JNIView extends GLSurfaceView {
-    private static String TAG = "GL2JNIView";
-
-    public GL2JNIView(Context context) {
-        super(context);
-        init(false, 0, 0);
-    }
-
-    public GL2JNIView(Context context, boolean translucent, int depth, int stencil) {
-        super(context);
-        init(translucent, depth, stencil);
-    }
-
-    private void init(boolean translucent, int depth, int stencil) {
-        setEGLContextFactory(new ContextFactory());
-        setEGLConfigChooser( translucent ?
-              new ConfigChooser(8,8,8,8, depth, stencil) :
-              new ConfigChooser(5,6,5,0, depth, stencil));
-        setRenderer(new Renderer());
-    }
-
-    private static class ContextFactory implements GLSurfaceView.EGLContextFactory {
-        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
-            Log.w(TAG, "creating OpenGL ES 2.0 context");
-            checkEglError("Before eglCreateContext", egl);
-            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };
-            EGLContext context = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, attrib_list);
-            checkEglError("After eglCreateContext", egl);
-            return context;
-        }
-
-        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
-            egl.eglDestroyContext(display, context);
-        }
-    }
-
-    private static void checkEglError(String prompt, EGL10 egl) {
-        int error;
-        while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {
-            Log.e(TAG, String.format("%s: EGL error: 0x%x", prompt, error));
-        }
-    }
-
-    private static class ConfigChooser implements GLSurfaceView.EGLConfigChooser {
-        private static int EGL_OPENGL_ES2_BIT = 4;
-        private static int[] s_configAttribs2 =
-        {
-            EGL10.EGL_RED_SIZE, 4,
-            EGL10.EGL_GREEN_SIZE, 4,
-            EGL10.EGL_BLUE_SIZE, 4,
-            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL10.EGL_NONE
-        };
-
-        public ConfigChooser(int r, int g, int b, int a, int depth, int stencil) {
-            mRedSize = r;
-            mGreenSize = g;
-            mBlueSize = b;
-            mAlphaSize = a;
-            mDepthSize = depth;
-            mStencilSize = stencil;
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-
-            int[] num_config = new int[1];
-            egl.eglChooseConfig(display, s_configAttribs2, null, 0, num_config);
-
-            int numConfigs = num_config[0];
-
-            if (numConfigs <= 0) {
-                throw new IllegalArgumentException("No configs match configSpec");
-            }
-            EGLConfig[] configs = new EGLConfig[numConfigs];
-            egl.eglChooseConfig(display, s_configAttribs2, configs, numConfigs, num_config);
-            // printConfigs(egl, display, configs);
-            return chooseConfig(egl, display, configs);
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs) {
-            EGLConfig closestConfig = null;
-            int closestDistance = 1000;
-            for(EGLConfig config : configs) {
-                int d = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_DEPTH_SIZE, 0);
-                int s = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_STENCIL_SIZE, 0);
-                if (d >= mDepthSize && s>= mStencilSize) {
-                    int r = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_RED_SIZE, 0);
-                    int g = findConfigAttrib(egl, display, config,
-                             EGL10.EGL_GREEN_SIZE, 0);
-                    int b = findConfigAttrib(egl, display, config,
-                              EGL10.EGL_BLUE_SIZE, 0);
-                    int a = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_ALPHA_SIZE, 0);
-                    int distance = Math.abs(r - mRedSize)
-                                + Math.abs(g - mGreenSize)
-                                + Math.abs(b - mBlueSize)
-                                + Math.abs(a - mAlphaSize);
-                    if (distance < closestDistance) {
-                        closestDistance = distance;
-                        closestConfig = config;
-                    }
-                }
-            }
-            return closestConfig;
-        }
-
-        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-                EGLConfig config, int attribute, int defaultValue) {
-
-            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-                return mValue[0];
-            }
-            return defaultValue;
-        }
-
-        private void printConfigs(EGL10 egl, EGLDisplay display,
-            EGLConfig[] configs) {
-            int numConfigs = configs.length;
-            Log.w(TAG, String.format("%d configurations", numConfigs));
-            for (int i = 0; i < numConfigs; i++) {
-                Log.w(TAG, String.format("Configuration %d:\n", i));
-                printConfig(egl, display, configs[i]);
-            }
-        }
-
-        private void printConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig config) {
-            int[] attributes = {
-                    EGL10.EGL_BUFFER_SIZE,
-                    EGL10.EGL_ALPHA_SIZE,
-                    EGL10.EGL_BLUE_SIZE,
-                    EGL10.EGL_GREEN_SIZE,
-                    EGL10.EGL_RED_SIZE,
-                    EGL10.EGL_DEPTH_SIZE,
-                    EGL10.EGL_STENCIL_SIZE,
-                    EGL10.EGL_CONFIG_CAVEAT,
-                    EGL10.EGL_CONFIG_ID,
-                    EGL10.EGL_LEVEL,
-                    EGL10.EGL_MAX_PBUFFER_HEIGHT,
-                    EGL10.EGL_MAX_PBUFFER_PIXELS,
-                    EGL10.EGL_MAX_PBUFFER_WIDTH,
-                    EGL10.EGL_NATIVE_RENDERABLE,
-                    EGL10.EGL_NATIVE_VISUAL_ID,
-                    EGL10.EGL_NATIVE_VISUAL_TYPE,
-                    0x3030, // EGL10.EGL_PRESERVED_RESOURCES,
-                    EGL10.EGL_SAMPLES,
-                    EGL10.EGL_SAMPLE_BUFFERS,
-                    EGL10.EGL_SURFACE_TYPE,
-                    EGL10.EGL_TRANSPARENT_TYPE,
-                    EGL10.EGL_TRANSPARENT_RED_VALUE,
-                    EGL10.EGL_TRANSPARENT_GREEN_VALUE,
-                    EGL10.EGL_TRANSPARENT_BLUE_VALUE,
-                    0x3039, // EGL10.EGL_BIND_TO_TEXTURE_RGB,
-                    0x303A, // EGL10.EGL_BIND_TO_TEXTURE_RGBA,
-                    0x303B, // EGL10.EGL_MIN_SWAP_INTERVAL,
-                    0x303C, // EGL10.EGL_MAX_SWAP_INTERVAL,
-                    EGL10.EGL_LUMINANCE_SIZE,
-                    EGL10.EGL_ALPHA_MASK_SIZE,
-                    EGL10.EGL_COLOR_BUFFER_TYPE,
-                    EGL10.EGL_RENDERABLE_TYPE,
-                    0x3042 // EGL10.EGL_CONFORMANT
-            };
-            String[] names = {
-                    "EGL_BUFFER_SIZE",
-                    "EGL_ALPHA_SIZE",
-                    "EGL_BLUE_SIZE",
-                    "EGL_GREEN_SIZE",
-                    "EGL_RED_SIZE",
-                    "EGL_DEPTH_SIZE",
-                    "EGL_STENCIL_SIZE",
-                    "EGL_CONFIG_CAVEAT",
-                    "EGL_CONFIG_ID",
-                    "EGL_LEVEL",
-                    "EGL_MAX_PBUFFER_HEIGHT",
-                    "EGL_MAX_PBUFFER_PIXELS",
-                    "EGL_MAX_PBUFFER_WIDTH",
-                    "EGL_NATIVE_RENDERABLE",
-                    "EGL_NATIVE_VISUAL_ID",
-                    "EGL_NATIVE_VISUAL_TYPE",
-                    "EGL_PRESERVED_RESOURCES",
-                    "EGL_SAMPLES",
-                    "EGL_SAMPLE_BUFFERS",
-                    "EGL_SURFACE_TYPE",
-                    "EGL_TRANSPARENT_TYPE",
-                    "EGL_TRANSPARENT_RED_VALUE",
-                    "EGL_TRANSPARENT_GREEN_VALUE",
-                    "EGL_TRANSPARENT_BLUE_VALUE",
-                    "EGL_BIND_TO_TEXTURE_RGB",
-                    "EGL_BIND_TO_TEXTURE_RGBA",
-                    "EGL_MIN_SWAP_INTERVAL",
-                    "EGL_MAX_SWAP_INTERVAL",
-                    "EGL_LUMINANCE_SIZE",
-                    "EGL_ALPHA_MASK_SIZE",
-                    "EGL_COLOR_BUFFER_TYPE",
-                    "EGL_RENDERABLE_TYPE",
-                    "EGL_CONFORMANT"
-            };
-            int[] value = new int[1];
-            for (int i = 0; i < attributes.length; i++) {
-                int attribute = attributes[i];
-                String name = names[i];
-                if ( egl.eglGetConfigAttrib(display, config, attribute, value)) {
-                    Log.w(TAG, String.format("  %s: %d\n", name, value[0]));
-                } else {
-                    // Log.w(TAG, String.format("  %s: failed\n", name));
-                    while (egl.eglGetError() != EGL10.EGL_SUCCESS);
-                }
-            }
-        }
-
-        // Subclasses can adjust these values:
-        protected int mRedSize;
-        protected int mGreenSize;
-        protected int mBlueSize;
-        protected int mAlphaSize;
-        protected int mDepthSize;
-        protected int mStencilSize;
-        private int[] mValue = new int[1];
-    }
-
-    private static class Renderer implements GLSurfaceView.Renderer {
-        public void onDrawFrame(GL10 gl) {
-            GL2JNILib.step();
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            GL2JNILib.init(width, height);
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            // Do nothing.
-        }
-    }
-}
-
diff --git a/opengl/tests/gl2_yuvtex/Android.bp b/opengl/tests/gl2_yuvtex/Android.bp
deleted file mode 100644
index b64d94d320..0000000000
--- a/opengl/tests/gl2_yuvtex/Android.bp
+++ /dev/null
@@ -1,26 +0,0 @@
-cc_test {
-    name: "test-opengl-gl2_yuvtex",
-
-    srcs: ["gl2_yuvtex.cpp"],
-
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv2",
-        "libutils",
-        "libui",
-        "libgui",
-        "libutils",
-    ],
-
-    gtest: false,
-
-    static_libs: ["libglTest"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-DEGL_EGLEXT_PROTOTYPES",
-        "-Wall",
-        "-Werror",
-    ],
-}
diff --git a/opengl/tests/gl2_yuvtex/gl2_yuvtex.cpp b/opengl/tests/gl2_yuvtex/gl2_yuvtex.cpp
deleted file mode 100644
index 850a615ee1..0000000000
--- a/opengl/tests/gl2_yuvtex/gl2_yuvtex.cpp
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sched.h>
-#include <sys/resource.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <utils/Timers.h>
-
-#include <WindowSurface.h>
-#include <ui/GraphicBuffer.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-static void printGLString(const char *name, GLenum s) {
-    // fprintf(stderr, "printGLString %s, %d\n", name, s);
-    const char *v = (const char *) glGetString(s);
-    // int error = glGetError();
-    // fprintf(stderr, "glGetError() = %d, result of glGetString = %x\n", error,
-    //        (unsigned int) v);
-    // if ((v < (const char*) 0) || (v > (const char*) 0x10000))
-    //    fprintf(stderr, "GL %s = %s\n", name, v);
-    // else
-    //    fprintf(stderr, "GL %s = (null) 0x%08x\n", name, (unsigned int) v);
-    fprintf(stderr, "GL %s = %s\n", name, v);
-}
-
-static void checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE) {
-    if (returnVal != EGL_TRUE) {
-        fprintf(stderr, "%s() returned %d\n", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        fprintf(stderr, "after %s() eglError %s (0x%x)\n", op, EGLUtils::strerror(error),
-                error);
-    }
-}
-
-static void checkGlError(const char* op) {
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        fprintf(stderr, "after %s() glError (0x%x)\n", op, error);
-    }
-}
-
-static const char gVertexShader[] = "attribute vec4 vPosition;\n"
-    "varying vec2 yuvTexCoords;\n"
-    "void main() {\n"
-    "  yuvTexCoords = vPosition.xy + vec2(0.5, 0.5);\n"
-    "  gl_Position = vPosition;\n"
-    "}\n";
-
-static const char gFragmentShader[] = "#extension GL_OES_EGL_image_external : require\n"
-    "precision mediump float;\n"
-    "uniform samplerExternalOES yuvTexSampler;\n"
-    "varying vec2 yuvTexCoords;\n"
-    "void main() {\n"
-    "  gl_FragColor = texture2D(yuvTexSampler, yuvTexCoords);\n"
-    "}\n";
-
-GLuint loadShader(GLenum shaderType, const char* pSource) {
-    GLuint shader = glCreateShader(shaderType);
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        glCompileShader(shader);
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    fprintf(stderr, "Could not compile shader %d:\n%s\n",
-                            shaderType, buf);
-                    free(buf);
-                }
-            } else {
-                fprintf(stderr, "Guessing at GL_INFO_LOG_LENGTH size\n");
-                char* buf = (char*) malloc(0x1000);
-                if (buf) {
-                    glGetShaderInfoLog(shader, 0x1000, NULL, buf);
-                    fprintf(stderr, "Could not compile shader %d:\n%s\n",
-                            shaderType, buf);
-                    free(buf);
-                }
-            }
-            glDeleteShader(shader);
-            shader = 0;
-        }
-    }
-    return shader;
-}
-
-GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {
-    GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
-    if (!vertexShader) {
-        return 0;
-    }
-
-    GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);
-    if (!pixelShader) {
-        return 0;
-    }
-
-    GLuint program = glCreateProgram();
-    if (program) {
-        glAttachShader(program, vertexShader);
-        checkGlError("glAttachShader");
-        glAttachShader(program, pixelShader);
-        checkGlError("glAttachShader");
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    fprintf(stderr, "Could not link program:\n%s\n", buf);
-                    free(buf);
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    return program;
-}
-
-GLuint gProgram;
-GLint gvPositionHandle;
-GLint gYuvTexSamplerHandle;
-
-bool setupGraphics(int w, int h) {
-    gProgram = createProgram(gVertexShader, gFragmentShader);
-    if (!gProgram) {
-        return false;
-    }
-    gvPositionHandle = glGetAttribLocation(gProgram, "vPosition");
-    checkGlError("glGetAttribLocation");
-    fprintf(stderr, "glGetAttribLocation(\"vPosition\") = %d\n",
-            gvPositionHandle);
-    gYuvTexSamplerHandle = glGetUniformLocation(gProgram, "yuvTexSampler");
-    checkGlError("glGetUniformLocation");
-    fprintf(stderr, "glGetUniformLocation(\"yuvTexSampler\") = %d\n",
-            gYuvTexSamplerHandle);
-
-    glViewport(0, 0, w, h);
-    checkGlError("glViewport");
-    return true;
-}
-
-int align(int x, int a) {
-    return (x + (a-1)) & (~(a-1));
-}
-
-const int yuvTexWidth = 608;
-const int yuvTexHeight = 480;
-const int yuvTexUsage = GraphicBuffer::USAGE_HW_TEXTURE |
-        GraphicBuffer::USAGE_SW_WRITE_RARELY;
-const int yuvTexFormat = HAL_PIXEL_FORMAT_YV12;
-const int yuvTexOffsetY = 0;
-const bool yuvTexSameUV = false;
-static sp<GraphicBuffer> yuvTexBuffer;
-static GLuint yuvTex;
-
-bool setupYuvTexSurface(EGLDisplay dpy, EGLContext /*context*/) {
-    int blockWidth = yuvTexWidth > 16 ? yuvTexWidth / 16 : 1;
-    int blockHeight = yuvTexHeight > 16 ? yuvTexHeight / 16 : 1;
-    yuvTexBuffer = new GraphicBuffer(yuvTexWidth, yuvTexHeight, yuvTexFormat,
-            yuvTexUsage);
-    int yuvTexStrideY = yuvTexBuffer->getStride();
-    int yuvTexOffsetV = yuvTexStrideY * yuvTexHeight;
-    int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf;
-    int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * yuvTexHeight/2;
-    int yuvTexStrideU = yuvTexStrideV;
-    char* buf = NULL;
-    status_t err = yuvTexBuffer->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&buf));
-    if (err != 0) {
-        fprintf(stderr, "yuvTexBuffer->lock(...) failed: %d\n", err);
-        return false;
-    }
-    for (int x = 0; x < yuvTexWidth; x++) {
-        for (int y = 0; y < yuvTexHeight; y++) {
-            int parityX = (x / blockWidth) & 1;
-            int parityY = (y / blockHeight) & 1;
-            unsigned char intensity = (parityX ^ parityY) ? 63 : 191;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = intensity;
-            if (x < yuvTexWidth / 2 && y < yuvTexHeight / 2) {
-                buf[yuvTexOffsetU + (y * yuvTexStrideU) + x] = intensity;
-                if (yuvTexSameUV) {
-                    buf[yuvTexOffsetV + (y * yuvTexStrideV) + x] = intensity;
-                } else if (x < yuvTexWidth / 4 && y < yuvTexHeight / 4) {
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 1] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 1] = intensity;
-                }
-            }
-        }
-    }
-
-    err = yuvTexBuffer->unlock();
-    if (err != 0) {
-        fprintf(stderr, "yuvTexBuffer->unlock() failed: %d\n", err);
-        return false;
-    }
-
-    EGLClientBuffer clientBuffer = (EGLClientBuffer)yuvTexBuffer->getNativeBuffer();
-    EGLImageKHR img = eglCreateImageKHR(dpy, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_ANDROID,
-            clientBuffer, 0);
-    checkEglError("eglCreateImageKHR");
-    if (img == EGL_NO_IMAGE_KHR) {
-        return false;
-    }
-
-    glGenTextures(1, &yuvTex);
-    checkGlError("glGenTextures");
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, yuvTex);
-    checkGlError("glBindTexture");
-    glEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);
-    checkGlError("glEGLImageTargetTexture2DOES");
-
-    return true;
-}
-
-const GLfloat gTriangleVertices[] = {
-    -0.5f, 0.5f,
-    -0.5f, -0.5f,
-    0.5f, -0.5f,
-    0.5f, 0.5f,
-};
-
-void renderFrame() {
-    glClearColor(0.0f, 0.0f, 1.0f, 1.0f);
-    checkGlError("glClearColor");
-    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    checkGlError("glClear");
-
-    glUseProgram(gProgram);
-    checkGlError("glUseProgram");
-
-    glVertexAttribPointer(gvPositionHandle, 2, GL_FLOAT, GL_FALSE, 0, gTriangleVertices);
-    checkGlError("glVertexAttribPointer");
-    glEnableVertexAttribArray(gvPositionHandle);
-    checkGlError("glEnableVertexAttribArray");
-
-    glUniform1i(gYuvTexSamplerHandle, 0);
-    checkGlError("glUniform1i");
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, yuvTex);
-    checkGlError("glBindTexture");
-
-    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-    checkGlError("glDrawArrays");
-}
-
-void printEGLConfiguration(EGLDisplay dpy, EGLConfig config) {
-
-#define X(VAL) {VAL, #VAL}
-    struct {EGLint attribute; const char* name;} names[] = {
-    X(EGL_BUFFER_SIZE),
-    X(EGL_ALPHA_SIZE),
-    X(EGL_BLUE_SIZE),
-    X(EGL_GREEN_SIZE),
-    X(EGL_RED_SIZE),
-    X(EGL_DEPTH_SIZE),
-    X(EGL_STENCIL_SIZE),
-    X(EGL_CONFIG_CAVEAT),
-    X(EGL_CONFIG_ID),
-    X(EGL_LEVEL),
-    X(EGL_MAX_PBUFFER_HEIGHT),
-    X(EGL_MAX_PBUFFER_PIXELS),
-    X(EGL_MAX_PBUFFER_WIDTH),
-    X(EGL_NATIVE_RENDERABLE),
-    X(EGL_NATIVE_VISUAL_ID),
-    X(EGL_NATIVE_VISUAL_TYPE),
-    X(EGL_SAMPLES),
-    X(EGL_SAMPLE_BUFFERS),
-    X(EGL_SURFACE_TYPE),
-    X(EGL_TRANSPARENT_TYPE),
-    X(EGL_TRANSPARENT_RED_VALUE),
-    X(EGL_TRANSPARENT_GREEN_VALUE),
-    X(EGL_TRANSPARENT_BLUE_VALUE),
-    X(EGL_BIND_TO_TEXTURE_RGB),
-    X(EGL_BIND_TO_TEXTURE_RGBA),
-    X(EGL_MIN_SWAP_INTERVAL),
-    X(EGL_MAX_SWAP_INTERVAL),
-    X(EGL_LUMINANCE_SIZE),
-    X(EGL_ALPHA_MASK_SIZE),
-    X(EGL_COLOR_BUFFER_TYPE),
-    X(EGL_RENDERABLE_TYPE),
-    X(EGL_CONFORMANT),
-   };
-#undef X
-
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute, &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            printf(" %s: ", names[j].name);
-            printf("%d (0x%x)", value, value);
-        }
-    }
-    printf("\n");
-}
-
-int main(int /*argc*/, char** /*argv*/) {
-    EGLBoolean returnValue;
-    EGLConfig myConfig = {0};
-
-    EGLint context_attribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
-    EGLint s_configAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL_NONE };
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EGLContext context;
-    EGLSurface surface;
-    EGLint w, h;
-
-    EGLDisplay dpy;
-
-    checkEglError("<init>");
-    dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    checkEglError("eglGetDisplay");
-    if (dpy == EGL_NO_DISPLAY) {
-        printf("eglGetDisplay returned EGL_NO_DISPLAY.\n");
-        return 0;
-    }
-
-    returnValue = eglInitialize(dpy, &majorVersion, &minorVersion);
-    checkEglError("eglInitialize", returnValue);
-    fprintf(stderr, "EGL version %d.%d\n", majorVersion, minorVersion);
-    if (returnValue != EGL_TRUE) {
-        printf("eglInitialize failed\n");
-        return 0;
-    }
-
-    WindowSurface windowSurface;
-    EGLNativeWindowType window = windowSurface.getSurface();
-    returnValue = EGLUtils::selectConfigForNativeWindow(dpy, s_configAttribs, window, &myConfig);
-    if (returnValue) {
-        printf("EGLUtils::selectConfigForNativeWindow() returned %d", returnValue);
-        return 1;
-    }
-
-    checkEglError("EGLUtils::selectConfigForNativeWindow");
-
-    printf("Chose this configuration:\n");
-    printEGLConfiguration(dpy, myConfig);
-
-    surface = eglCreateWindowSurface(dpy, myConfig, window, NULL);
-    checkEglError("eglCreateWindowSurface");
-    if (surface == EGL_NO_SURFACE) {
-        printf("gelCreateWindowSurface failed.\n");
-        return 1;
-    }
-
-    context = eglCreateContext(dpy, myConfig, EGL_NO_CONTEXT, context_attribs);
-    checkEglError("eglCreateContext");
-    if (context == EGL_NO_CONTEXT) {
-        printf("eglCreateContext failed\n");
-        return 1;
-    }
-    returnValue = eglMakeCurrent(dpy, surface, surface, context);
-    checkEglError("eglMakeCurrent", returnValue);
-    if (returnValue != EGL_TRUE) {
-        return 1;
-    }
-    eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-    checkEglError("eglQuerySurface");
-    eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-    checkEglError("eglQuerySurface");
-
-    fprintf(stderr, "Window dimensions: %d x %d\n", w, h);
-
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-
-    if(!setupYuvTexSurface(dpy, context)) {
-        fprintf(stderr, "Could not set up texture surface.\n");
-        return 1;
-    }
-
-    if(!setupGraphics(w, h)) {
-        fprintf(stderr, "Could not set up graphics.\n");
-        return 1;
-    }
-
-    for (;;) {
-        renderFrame();
-        eglSwapBuffers(dpy, surface);
-        checkEglError("eglSwapBuffers");
-    }
-
-    return 0;
-}
diff --git a/opengl/tests/gl_basic/Android.bp b/opengl/tests/gl_basic/Android.bp
deleted file mode 100644
index 5eed17e876..0000000000
--- a/opengl/tests/gl_basic/Android.bp
+++ /dev/null
@@ -1,23 +0,0 @@
-cc_test {
-    name: "test-opengl-gl_basic",
-
-    srcs: ["gl_basic.cpp"],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv1_CM",
-        "libui",
-        "libgui",
-        "libutils",
-    ],
-
-    static_libs: ["libglTest"],
-}
diff --git a/opengl/tests/gl_basic/gl_basic.cpp b/opengl/tests/gl_basic/gl_basic.cpp
deleted file mode 100644
index a675c7c5bd..0000000000
--- a/opengl/tests/gl_basic/gl_basic.cpp
+++ /dev/null
@@ -1,358 +0,0 @@
-// Simple OpenGL ES 1.x application showing how to initialize and draw something.
-
-#include <EGL/egl.h>
-
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-#include <stdio.h>
-
-#include <stdlib.h>
-#include <math.h>
-
-using namespace android;
-
-EGLDisplay eglDisplay;
-EGLSurface eglSurface;
-EGLContext eglContext;
-GLuint texture;
-
-#define FIXED_ONE 0x10000
-#define ITERATIONS 50
-
-int init_gl_surface(const WindowSurface& windowSurface);
-void free_gl_surface(void);
-void init_scene(void);
-void render();
-void create_texture(void);
-int readTimer(void);
-
-static void printGLString(const char *name, GLenum s) {
-    const char *v = (const char *) glGetString(s);
-    fprintf(stderr, "GL %s = %s\n", name, v);
-}
-
-static void gluLookAt(float eyeX, float eyeY, float eyeZ,
-        float centerX, float centerY, float centerZ, float upX, float upY,
-        float upZ)
-{
-    // See the OpenGL GLUT documentation for gluLookAt for a description
-    // of the algorithm. We implement it in a straightforward way:
-
-    float fx = centerX - eyeX;
-    float fy = centerY - eyeY;
-    float fz = centerZ - eyeZ;
-
-    // Normalize f
-    float rlf = 1.0f / sqrtf(fx*fx + fy*fy + fz*fz);
-    fx *= rlf;
-    fy *= rlf;
-    fz *= rlf;
-
-    // Normalize up
-    float rlup = 1.0f / sqrtf(upX*upX + upY*upY + upZ*upZ);
-    upX *= rlup;
-    upY *= rlup;
-    upZ *= rlup;
-
-    // compute s = f x up (x means "cross product")
-
-    float sx = fy * upZ - fz * upY;
-    float sy = fz * upX - fx * upZ;
-    float sz = fx * upY - fy * upX;
-
-    // compute u = s x f
-    float ux = sy * fz - sz * fy;
-    float uy = sz * fx - sx * fz;
-    float uz = sx * fy - sy * fx;
-
-    float m[16] ;
-    m[0] = sx;
-    m[1] = ux;
-    m[2] = -fx;
-    m[3] = 0.0f;
-
-    m[4] = sy;
-    m[5] = uy;
-    m[6] = -fy;
-    m[7] = 0.0f;
-
-    m[8] = sz;
-    m[9] = uz;
-    m[10] = -fz;
-    m[11] = 0.0f;
-
-    m[12] = 0.0f;
-    m[13] = 0.0f;
-    m[14] = 0.0f;
-    m[15] = 1.0f;
-
-    glMultMatrixf(m);
-    glTranslatef(-eyeX, -eyeY, -eyeZ);
-}
-
-void printEGLConfiguration(EGLDisplay dpy, EGLConfig config) {
-
-#define X(VAL) {VAL, #VAL}
-    struct {EGLint attribute; const char* name;} names[] = {
-    X(EGL_BUFFER_SIZE),
-    X(EGL_ALPHA_SIZE),
-    X(EGL_BLUE_SIZE),
-    X(EGL_GREEN_SIZE),
-    X(EGL_RED_SIZE),
-    X(EGL_DEPTH_SIZE),
-    X(EGL_STENCIL_SIZE),
-    X(EGL_CONFIG_CAVEAT),
-    X(EGL_CONFIG_ID),
-    X(EGL_LEVEL),
-    X(EGL_MAX_PBUFFER_HEIGHT),
-    X(EGL_MAX_PBUFFER_PIXELS),
-    X(EGL_MAX_PBUFFER_WIDTH),
-    X(EGL_NATIVE_RENDERABLE),
-    X(EGL_NATIVE_VISUAL_ID),
-    X(EGL_NATIVE_VISUAL_TYPE),
-    X(EGL_SAMPLES),
-    X(EGL_SAMPLE_BUFFERS),
-    X(EGL_SURFACE_TYPE),
-    X(EGL_TRANSPARENT_TYPE),
-    X(EGL_TRANSPARENT_RED_VALUE),
-    X(EGL_TRANSPARENT_GREEN_VALUE),
-    X(EGL_TRANSPARENT_BLUE_VALUE),
-    X(EGL_BIND_TO_TEXTURE_RGB),
-    X(EGL_BIND_TO_TEXTURE_RGBA),
-    X(EGL_MIN_SWAP_INTERVAL),
-    X(EGL_MAX_SWAP_INTERVAL),
-    X(EGL_LUMINANCE_SIZE),
-    X(EGL_ALPHA_MASK_SIZE),
-    X(EGL_COLOR_BUFFER_TYPE),
-    X(EGL_RENDERABLE_TYPE),
-    X(EGL_CONFORMANT),
-   };
-#undef X
-
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute, &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            printf(" %s: ", names[j].name);
-            printf("%d (0x%x)", value, value);
-        }
-    }
-    printf("\n");
-}
-
-static void checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE) {
-    if (returnVal != EGL_TRUE) {
-        fprintf(stderr, "%s() returned %d\n", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        fprintf(stderr, "after %s() eglError %s (0x%x)\n", op, EGLUtils::strerror(error),
-                error);
-    }
-}
-
-int printEGLConfigurations(EGLDisplay dpy) {
-    EGLint numConfig = 0;
-    EGLint returnVal = eglGetConfigs(dpy, NULL, 0, &numConfig);
-    checkEglError("eglGetConfigs", returnVal);
-    if (!returnVal) {
-        return false;
-    }
-
-    printf("Number of EGL configurations: %d\n", numConfig);
-
-    EGLConfig* configs = (EGLConfig*) malloc(sizeof(EGLConfig) * numConfig);
-    if (! configs) {
-        printf("Could not allocate configs.\n");
-        return false;
-    }
-
-    returnVal = eglGetConfigs(dpy, configs, numConfig, &numConfig);
-    checkEglError("eglGetConfigs", returnVal);
-    if (!returnVal) {
-        free(configs);
-        return false;
-    }
-
-    for(int i = 0; i < numConfig; i++) {
-        printf("Configuration %d\n", i);
-        printEGLConfiguration(dpy, configs[i]);
-    }
-
-    free(configs);
-    return true;
-}
-
-int main(int /*argc*/, char **/*argv*/)
-{
-    printf("Initializing EGL...\n");
-    WindowSurface windowSurface;
-    if(!init_gl_surface(windowSurface))
-    {
-        printf("GL initialisation failed - exiting\n");
-        return 0;
-    }
-    init_scene();
-    create_texture();
-    printf("Running...\n");
-    while(true) {
-        render();
-    }
-    free_gl_surface();
-    return 0;
-}
-
-int init_gl_surface(const WindowSurface& windowSurface)
-{
-    EGLConfig myConfig = {0};
-    EGLint attrib[] =
-    {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_NONE
-    };
-
-    if ( (eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY)) == EGL_NO_DISPLAY )
-    {
-        printf("eglGetDisplay failed\n");
-        return 0;
-    }
-    
-    if ( eglInitialize(eglDisplay, NULL, NULL) != EGL_TRUE )
-    {
-        printf("eglInitialize failed\n");
-        return 0;
-    }
-
-    if (! printEGLConfigurations(eglDisplay)) {
-        printf("printEGLConfigurations failed.\n");
-        return 0;
-    }
-
-    EGLNativeWindowType window = windowSurface.getSurface();
-    EGLUtils::selectConfigForNativeWindow(eglDisplay, attrib, window, &myConfig);
-
-    if ( (eglSurface = eglCreateWindowSurface(eglDisplay, myConfig,
-            window, 0)) == EGL_NO_SURFACE )
-    {
-        printf("eglCreateWindowSurface failed\n");
-        return 0;
-    }
-
-    if ( (eglContext = eglCreateContext(eglDisplay, myConfig, 0, 0)) == EGL_NO_CONTEXT )
-    {
-        printf("eglCreateContext failed\n");
-        return 0;
-    }
-
-    if ( eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext) != EGL_TRUE )
-    {
-        printf("eglMakeCurrent failed\n");
-        return 0;
-    }
-    
-    int w, h;
-
-    eglQuerySurface(eglDisplay, eglSurface, EGL_WIDTH, &w);
-    checkEglError("eglQuerySurface");
-    eglQuerySurface(eglDisplay, eglSurface, EGL_HEIGHT, &h);
-    checkEglError("eglQuerySurface");
-    
-    fprintf(stderr, "Window dimensions: %d x %d\n", w, h);
-
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-
-    return 1;
-}
-
-void free_gl_surface(void)
-{
-    if (eglDisplay != EGL_NO_DISPLAY)
-    {
-        eglMakeCurrent( EGL_NO_DISPLAY, EGL_NO_SURFACE,
-                EGL_NO_SURFACE, EGL_NO_CONTEXT );
-        eglDestroyContext( eglDisplay, eglContext );
-        eglDestroySurface( eglDisplay, eglSurface );
-        eglTerminate( eglDisplay );
-        eglDisplay = EGL_NO_DISPLAY;
-    }
-}
-
-void init_scene(void)
-{
-    glDisable(GL_DITHER);
-    glEnable(GL_CULL_FACE);
-    float ratio = 320.0f / 480.0f;
-    glViewport(0, 0, 320, 480);
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
-    gluLookAt(
-            0, 0, 3,  // eye
-            0, 0, 0,  // center
-            0, 1, 0); // up
-    glEnable(GL_TEXTURE_2D);
-    glEnableClientState(GL_VERTEX_ARRAY);
-    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-}
-
-void create_texture(void)
-{
-    const unsigned int on = 0xff0000ff;
-    const unsigned int off = 0xffffffff;
-    const unsigned int pixels[] =
-    {
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-    };
-
-    glGenTextures(1, &texture);
-    glBindTexture(GL_TEXTURE_2D, texture);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-}
-
-void render()
-{
-    const GLfloat vertices[] = {
-            -1,  -1,  0,
-             1,  -1,  0,
-             1,   1,  0,
-            -1,   1,  0
-    };
-
-    const GLfixed texCoords[] = {
-            0,            0,
-            FIXED_ONE,    0,
-            FIXED_ONE,    FIXED_ONE,
-            0,            FIXED_ONE
-    };
-
-    const GLushort indices[] = { 0, 1, 2,  0, 2, 3 };
-
-    glVertexPointer(3, GL_FLOAT, 0, vertices);
-    glTexCoordPointer(2, GL_FIXED, 0, texCoords);
-    glClearColor(1.0, 1.0, 1.0, 1.0);
-    int nelem = sizeof(indices)/sizeof(indices[0]);
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    glDrawElements(GL_TRIANGLES, nelem, GL_UNSIGNED_SHORT, indices);
-    eglSwapBuffers(eglDisplay, eglSurface);
-}
diff --git a/opengl/tests/gl_jni/Android.mk b/opengl/tests/gl_jni/Android.mk
deleted file mode 100644
index d64dfcf2bf..0000000000
--- a/opengl/tests/gl_jni/Android.mk
+++ /dev/null
@@ -1,52 +0,0 @@
-#########################################################################
-# OpenGL ES JNI sample
-# This makefile builds both an activity and a shared library.
-#########################################################################
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := GLJNI
-LOCAL_SDK_VERSION := current
-
-LOCAL_JNI_SHARED_LIBRARIES := libgljni
-
-include $(BUILD_PACKAGE)
-
-#########################################################################
-# Build JNI Shared Library
-#########################################################################
-
-LOCAL_PATH:= $(LOCAL_PATH)/jni
-
-include $(CLEAR_VARS)
-
-# Optional tag would mean it doesn't get installed by default
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -Werror -Wno-error=unused-parameter
-
-LOCAL_SRC_FILES:= \
-  gl_code.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-	liblog \
-	libEGL \
-	libGLESv1_CM
-
-LOCAL_MODULE := libgljni
-
-LOCAL_SDK_VERSION := current
-
-LOCAL_ARM_MODE := arm
-
-
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/opengl/tests/gl_jni/AndroidManifest.xml b/opengl/tests/gl_jni/AndroidManifest.xml
deleted file mode 100644
index 5d0ec966f4..0000000000
--- a/opengl/tests/gl_jni/AndroidManifest.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.gljni">
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <application
-            android:label="@string/gljni_activity">
-        <activity android:name="GLJNIActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-            	android:launchMode="singleTask"
-            	android:screenOrientation="landscape"
-            	android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/gl_jni/jni/gl_code.cpp b/opengl/tests/gl_jni/jni/gl_code.cpp
deleted file mode 100644
index 88f3228c62..0000000000
--- a/opengl/tests/gl_jni/jni/gl_code.cpp
+++ /dev/null
@@ -1,188 +0,0 @@
-// OpenGL ES 1.0 code
-
-#include <jni.h>
-#define LOG_TAG "GLJNI gl_code.cpp"
-#include <android/log.h>
-
-#define ALOG(priority, tag, ...) ((void)__android_log_print(ANDROID_##priority, tag, __VA_ARGS__))
-
-#define ALOGI(...) ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__)
-#define ALOGE(...) ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__)
-
-#include <GLES/gl.h>
-
-#include <stdio.h>
-
-#include <stdlib.h>
-#include <math.h>
-
-GLuint texture;
-GLfloat background;
-
-#define FIXED_ONE 0x10000
-
-static void printGLString(const char *name, GLenum s) {
-    const char *v = (const char *) glGetString(s);
-    ALOGI("GL %s = %s\n", name, v);
-}
-
-static void gluLookAt(float eyeX, float eyeY, float eyeZ,
-        float centerX, float centerY, float centerZ, float upX, float upY,
-        float upZ)
-{
-    // See the OpenGL GLUT documentation for gluLookAt for a description
-    // of the algorithm. We implement it in a straightforward way:
-
-    float fx = centerX - eyeX;
-    float fy = centerY - eyeY;
-    float fz = centerZ - eyeZ;
-
-    // Normalize f
-    float rlf = 1.0f / sqrtf(fx*fx + fy*fy + fz*fz);
-    fx *= rlf;
-    fy *= rlf;
-    fz *= rlf;
-
-    // Normalize up
-    float rlup = 1.0f / sqrtf(upX*upX + upY*upY + upZ*upZ);
-    upX *= rlup;
-    upY *= rlup;
-    upZ *= rlup;
-
-    // compute s = f x up (x means "cross product")
-
-    float sx = fy * upZ - fz * upY;
-    float sy = fz * upX - fx * upZ;
-    float sz = fx * upY - fy * upX;
-
-    // compute u = s x f
-    float ux = sy * fz - sz * fy;
-    float uy = sz * fx - sx * fz;
-    float uz = sx * fy - sy * fx;
-
-    float m[16] ;
-    m[0] = sx;
-    m[1] = ux;
-    m[2] = -fx;
-    m[3] = 0.0f;
-
-    m[4] = sy;
-    m[5] = uy;
-    m[6] = -fy;
-    m[7] = 0.0f;
-
-    m[8] = sz;
-    m[9] = uz;
-    m[10] = -fz;
-    m[11] = 0.0f;
-
-    m[12] = 0.0f;
-    m[13] = 0.0f;
-    m[14] = 0.0f;
-    m[15] = 1.0f;
-
-    glMultMatrixf(m);
-    glTranslatef(-eyeX, -eyeY, -eyeZ);
-}
-
-void init_scene(int width, int height)
-{
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-
-    glDisable(GL_DITHER);
-    glEnable(GL_CULL_FACE);
-
-    float ratio = width / height;
-    glViewport(0, 0, width, height);
-
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-
-    glMatrixMode(GL_MODELVIEW);
-
-    glLoadIdentity();
-    gluLookAt(
-            0, 0, 3,  // eye
-            0, 0, 0,  // center
-            0, 1, 0); // up
-
-    glEnable(GL_TEXTURE_2D);
-    glEnableClientState(GL_VERTEX_ARRAY);
-    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-}
-
-void create_texture()
-{
-    const unsigned int on = 0xff0000ff;
-    const unsigned int off = 0xffffffff;
-    const unsigned int pixels[] =
-    {
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-    };
-
-    glGenTextures(1, &texture);
-    glBindTexture(GL_TEXTURE_2D, texture);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-}
-
-extern "C" {
-    JNIEXPORT void JNICALL Java_com_android_gljni_GLJNILib_init(JNIEnv * env, jobject obj,  jint width, jint height);
-    JNIEXPORT void JNICALL Java_com_android_gljni_GLJNILib_step(JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_gljni_GLJNILib_changeBackground(JNIEnv * env, jobject obj);
-};
-
-JNIEXPORT void JNICALL Java_com_android_gljni_GLJNILib_init(JNIEnv * /*env*/, jobject /*obj*/,  jint width, jint height)
-{
-    init_scene(width, height);
-    create_texture();
-}
-
-JNIEXPORT void JNICALL Java_com_android_gljni_GLJNILib_step(JNIEnv * /*env*/, jobject /*obj*/)
-{
-    const GLfloat vertices[] = {
-            -1,  -1,  0,
-             1,  -1,  0,
-             1,   1,  0,
-            -1,   1,  0
-    };
-
-    const GLfixed texCoords[] = {
-            0,            0,
-            FIXED_ONE,    0,
-            FIXED_ONE,    FIXED_ONE,
-            0,            FIXED_ONE
-    };
-
-    const GLushort quadIndices[] = { 0, 1, 2,  0, 2, 3 };
-    glVertexPointer(3, GL_FLOAT, 0, vertices);
-    glTexCoordPointer(2, GL_FIXED, 0, texCoords);
-
-    int nelem = sizeof(quadIndices)/sizeof(quadIndices[0]);
-    static float grey;
-    grey += 0.01f;
-    if (grey > 1.0f) {
-        grey = 0.0f;
-    }
-    glClearColor(background, grey, grey, 1.0f);
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    glDrawElements(GL_TRIANGLES, nelem, GL_UNSIGNED_SHORT, quadIndices);
-}
-
-JNIEXPORT void JNICALL Java_com_android_gljni_GLJNILib_changeBackground(JNIEnv * /*env*/, jobject /*obj*/)
-{
-    background = 1.0f - background;
-}
diff --git a/opengl/tests/gl_jni/res/values/strings.xml b/opengl/tests/gl_jni/res/values/strings.xml
deleted file mode 100644
index aee9fa03ae..0000000000
--- a/opengl/tests/gl_jni/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="gljni_activity">GLJNI</string>
-
-</resources>
-
diff --git a/opengl/tests/gl_jni/src/com/android/gljni/GLJNIActivity.java b/opengl/tests/gl_jni/src/com/android/gljni/GLJNIActivity.java
deleted file mode 100644
index c6f53134f9..0000000000
--- a/opengl/tests/gl_jni/src/com/android/gljni/GLJNIActivity.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gljni;
-
-import android.app.Activity;
-import android.os.Bundle;
-
-public class GLJNIActivity extends Activity {
-
-    GLJNIView mView;
-
-    @Override
-    protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        mView = new GLJNIView(getApplication());
-	    mView.setFocusableInTouchMode(true);
-	    setContentView(mView);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/gl_jni/src/com/android/gljni/GLJNILib.java b/opengl/tests/gl_jni/src/com/android/gljni/GLJNILib.java
deleted file mode 100644
index f56d2af95b..0000000000
--- a/opengl/tests/gl_jni/src/com/android/gljni/GLJNILib.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gljni;
-
-// Wrapper for native library
-
-public class GLJNILib {
-
-     static {
-         System.loadLibrary("gljni");
-     }
-
-    /**
-     * @param width the current view width
-     * @param height the current view height
-     */
-     public static native void init(int width, int height);
-     public static native void step();
-     public static native void changeBackground();
-}
diff --git a/opengl/tests/gl_jni/src/com/android/gljni/GLJNIView.java b/opengl/tests/gl_jni/src/com/android/gljni/GLJNIView.java
deleted file mode 100644
index 9a2c8c4548..0000000000
--- a/opengl/tests/gl_jni/src/com/android/gljni/GLJNIView.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gljni;
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class GLJNIView extends GLSurfaceView {
-    GLJNIView(Context context) {
-        super(context);
-        init();
-    }
-
-    public GLJNIView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    private void init() {
-        setRenderer(new Renderer());
-    }
-
-    private class Renderer implements GLSurfaceView.Renderer {
-        private static final String TAG = "Renderer";
-        public void onDrawFrame(GL10 gl) {
-            GLJNILib.step();
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            GLJNILib.init(width, height);
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            // Do nothing.
-        }
-    }
-    
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        GLJNILib.changeBackground();
-        return true;
-    }
-}
-
diff --git a/opengl/tests/gl_perf/Android.bp b/opengl/tests/gl_perf/Android.bp
deleted file mode 100644
index 25a317c3e3..0000000000
--- a/opengl/tests/gl_perf/Android.bp
+++ /dev/null
@@ -1,28 +0,0 @@
-cc_test {
-    name: "test-opengl-gl2_perf",
-
-    srcs: [
-        "gl2_perf.cpp",
-        "filltest.cpp",
-    ],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "liblog",
-        "libEGL",
-        "libGLESv2",
-        "libui",
-        "libgui",
-        "libutils",
-    ],
-
-    static_libs: ["libglTest"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-Wall",
-        "-Werror",
-    ],
-}
diff --git a/opengl/tests/gl_perf/fill_common.cpp b/opengl/tests/gl_perf/fill_common.cpp
deleted file mode 100644
index fefedc0939..0000000000
--- a/opengl/tests/gl_perf/fill_common.cpp
+++ /dev/null
@@ -1,298 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "fragment_shaders.cpp"
-
-FILE * fOut = NULL;
-void ptSwap();
-
-static char gCurrentTestName[1024];
-static uint32_t gWidth = 0;
-static uint32_t gHeight = 0;
-
-static void checkGlError(const char* op) {
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        ALOGE("after %s() glError (0x%x)\n", op, error);
-    }
-}
-
-GLuint loadShader(GLenum shaderType, const char* pSource) {
-    GLuint shader = glCreateShader(shaderType);
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        glCompileShader(shader);
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    ALOGE("Could not compile shader %d:\n%s\n", shaderType, buf);
-                    free(buf);
-                }
-                glDeleteShader(shader);
-                shader = 0;
-            }
-        }
-    }
-    return shader;
-}
-
-enum {
-    A_POS,
-    A_COLOR,
-    A_TEX0,
-    A_TEX1
-};
-
-GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {
-    GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
-    if (!vertexShader) {
-        return 0;
-    }
-
-    GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);
-    if (!pixelShader) {
-        return 0;
-    }
-
-    GLuint program = glCreateProgram();
-    if (program) {
-        glAttachShader(program, vertexShader);
-        checkGlError("glAttachShader v");
-        glAttachShader(program, pixelShader);
-        checkGlError("glAttachShader p");
-
-        glBindAttribLocation(program, A_POS, "a_pos");
-        glBindAttribLocation(program, A_COLOR, "a_color");
-        glBindAttribLocation(program, A_TEX0, "a_tex0");
-        glBindAttribLocation(program, A_TEX1, "a_tex1");
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    ALOGE("Could not link program:\n%s\n", buf);
-                    free(buf);
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    checkGlError("createProgram");
-    glUseProgram(program);
-    return program;
-}
-
-uint64_t getTime() {
-    struct timespec t;
-    clock_gettime(CLOCK_MONOTONIC, &t);
-    return t.tv_nsec + ((uint64_t)t.tv_sec * 1000 * 1000 * 1000);
-}
-
-uint64_t gTime;
-void startTimer() {
-    gTime = getTime();
-}
-
-
-static void endTimer(int count) {
-    uint64_t t2 = getTime();
-    double delta = ((double)(t2 - gTime)) / 1000000000;
-    double pixels = (gWidth * gHeight) * count;
-    double mpps = pixels / delta / 1000000;
-    double dc60 = ((double)count) / delta / 60;
-
-    if (fOut) {
-        fprintf(fOut, "%s, %f, %f\r\n", gCurrentTestName, mpps, dc60);
-        fflush(fOut);
-    } else {
-        printf("%s, %f, %f\n", gCurrentTestName, mpps, dc60);
-    }
-    ALOGI("%s, %f, %f\r\n", gCurrentTestName, mpps, dc60);
-}
-
-
-static const char gVertexShader[] =
-    "attribute vec4 a_pos;\n"
-    "attribute vec4 a_color;\n"
-    "attribute vec2 a_tex0;\n"
-    "attribute vec2 a_tex1;\n"
-    "varying vec4 v_color;\n"
-    "varying vec2 v_tex0;\n"
-    "varying vec2 v_tex1;\n"
-    "uniform vec2 u_texOff;\n"
-
-    "void main() {\n"
-    "    v_color = a_color;\n"
-    "    v_tex0 = a_tex0;\n"
-    "    v_tex1 = a_tex1;\n"
-    "    v_tex0.x += u_texOff.x;\n"
-    "    v_tex1.y += u_texOff.y;\n"
-    "    gl_Position = a_pos;\n"
-    "}\n";
-
-static void setupVA() {
-    static const float vtx[] = {
-        -1.0f,-1.0f,
-         1.0f,-1.0f,
-        -1.0f, 1.0f,
-         1.0f, 1.0f };
-    static const float color[] = {
-        1.0f,0.0f,1.0f,1.0f,
-        0.0f,0.0f,1.0f,1.0f,
-        1.0f,1.0f,0.0f,1.0f,
-        1.0f,1.0f,1.0f,1.0f };
-    static const float tex0[] = {
-        0.0f,0.0f,
-        1.0f,0.0f,
-        0.0f,1.0f,
-        1.0f,1.0f };
-    static const float tex1[] = {
-        1.0f,0.0f,
-        1.0f,1.0f,
-        0.0f,1.0f,
-        0.0f,0.0f };
-
-    glEnableVertexAttribArray(A_POS);
-    glEnableVertexAttribArray(A_COLOR);
-    glEnableVertexAttribArray(A_TEX0);
-    glEnableVertexAttribArray(A_TEX1);
-
-    glVertexAttribPointer(A_POS, 2, GL_FLOAT, false, 8, vtx);
-    glVertexAttribPointer(A_COLOR, 4, GL_FLOAT, false, 16, color);
-    glVertexAttribPointer(A_TEX0, 2, GL_FLOAT, false, 8, tex0);
-    glVertexAttribPointer(A_TEX1, 2, GL_FLOAT, false, 8, tex1);
-}
-
-static void randUniform(int pgm, const char *var) {
-    GLint loc = glGetUniformLocation(pgm, var);
-    if (loc >= 0) {
-        float x = ((float)rand()) / RAND_MAX;
-        float y = ((float)rand()) / RAND_MAX;
-        float z = ((float)rand()) / RAND_MAX;
-        float w = ((float)rand()) / RAND_MAX;
-        glUniform4f(loc, x, y, z, w);
-    }
-}
-
-static void doLoop(bool warmup, int pgm, uint32_t passCount) {
-    if (warmup) {
-        glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-        ptSwap();
-        glFinish();
-        return;
-    }
-
-    startTimer();
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    for (uint32_t ct=0; ct < passCount; ct++) {
-        GLint loc = glGetUniformLocation(pgm, "u_texOff");
-        glUniform2f(loc, ((float)ct) / passCount, ((float)ct) / 2.f / passCount);
-
-        randUniform(pgm, "u_color");
-        randUniform(pgm, "u_0");
-        randUniform(pgm, "u_1");
-        randUniform(pgm, "u_2");
-        randUniform(pgm, "u_3");
-        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
-    }
-    ptSwap();
-    glFinish();
-    endTimer(passCount);
-}
-
-
-static uint32_t rgb(uint32_t r, uint32_t g, uint32_t b)
-{
-    uint32_t ret = 0xff000000;
-    ret |= r & 0xff;
-    ret |= (g & 0xff) << 8;
-    ret |= (b & 0xff) << 16;
-    return ret;
-}
-
-void genTextures() {
-    uint32_t *m = (uint32_t *)malloc(1024*1024*4);
-    for (int y=0; y < 1024; y++){
-        for (int x=0; x < 1024; x++){
-            m[y*1024 + x] = rgb(x, (((x+y) & 0xff) == 0x7f) * 0xff, y);
-        }
-    }
-    glBindTexture(GL_TEXTURE_2D, 1);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1024, 1024, 0, GL_RGBA, GL_UNSIGNED_BYTE, m);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-
-    for (int y=0; y < 16; y++){
-        for (int x=0; x < 16; x++){
-            m[y*16 + x] = rgb(x << 4, (((x+y) & 0xf) == 0x7) * 0xff, y << 4);
-        }
-    }
-    glBindTexture(GL_TEXTURE_2D, 2);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 16, 16, 0, GL_RGBA, GL_UNSIGNED_BYTE, m);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-    free(m);
-}
-
-static void doSingleTest(uint32_t pgmNum, int tex) {
-    const char *pgmTxt = gFragmentTests[pgmNum]->txt;
-    int pgm = createProgram(gVertexShader, pgmTxt);
-    if (!pgm) {
-        printf("error running test\n");
-        return;
-    }
-    GLint loc = glGetUniformLocation(pgm, "u_tex0");
-    if (loc >= 0) glUniform1i(loc, 0);
-    loc = glGetUniformLocation(pgm, "u_tex1");
-    if (loc >= 0) glUniform1i(loc, 1);
-
-
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_2D, tex);
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_2D, tex);
-    glActiveTexture(GL_TEXTURE0);
-
-    glBlendFunc(GL_ONE, GL_ONE);
-    glDisable(GL_BLEND);
-    //sprintf(str2, "%i, %i, %i, %i, %i, 0",
-            //useVarColor, texCount, modulateFirstTex, extraMath, tex0);
-    //doLoop(true, pgm, w, h, str2);
-    //doLoop(false, pgm, w, h, str2);
-
-    glEnable(GL_BLEND);
-    sprintf(gCurrentTestName, "%s, %i, %i, 1", gFragmentTests[pgmNum]->name, pgmNum, tex);
-    doLoop(true, pgm, 100);
-    doLoop(false, pgm, 100);
-}
-
diff --git a/opengl/tests/gl_perf/filltest.cpp b/opengl/tests/gl_perf/filltest.cpp
deleted file mode 100644
index 4135c6252f..0000000000
--- a/opengl/tests/gl_perf/filltest.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sched.h>
-#include <sys/resource.h>
-#include <string.h>
-
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-#include <utils/Timers.h>
-#include <EGL/egl.h>
-#include <utils/Log.h>
-
-#include "fill_common.cpp"
-
-
-bool doTest(uint32_t w, uint32_t h) {
-    gWidth = w;
-    gHeight = h;
-    setupVA();
-    genTextures();
-
-    printf("\nvarColor, texCount, modulate, extraMath, texSize, blend, Mpps, DC60\n");
-
-    for (uint32_t num = 0; num < gFragmentTestCount; num++) {
-        doSingleTest(num, 2);
-        if (gFragmentTests[num]->texCount) {
-            doSingleTest(num, 1);
-        }
-    }
-
-    exit(0);
-    return true;
-}
diff --git a/opengl/tests/gl_perf/fragment_shaders.cpp b/opengl/tests/gl_perf/fragment_shaders.cpp
deleted file mode 100644
index 79d5ead3fd..0000000000
--- a/opengl/tests/gl_perf/fragment_shaders.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-
-typedef struct FragmentTestRec {
-	const char * name;
-	uint32_t texCount;
-	const char * txt;
-} FragmentTest;
-
-static FragmentTest fpFill = {
-	"Solid color", 0,
-
-    "precision mediump float;\n"
-    "uniform vec4 u_color;\n"
-    "void main() {\n"
-    "  gl_FragColor = u_color;\n"
-    "}\n"
-};
-
-static FragmentTest fpGradient = {
-	"Solid gradient", 0,
-
-    "precision mediump float;\n"
-    "varying lowp vec4 v_color;\n"
-    "void main() {\n"
-    "  gl_FragColor = v_color;\n"
-    "}\n"
-};
-
-static FragmentTest fpCopyTex = {
-	"Texture copy", 1,
-
-    "precision mediump float;\n"
-    "varying vec2 v_tex0;\n"
-    "uniform sampler2D u_tex0;\n"
-    "void main() {\n"
-    "  gl_FragColor = texture2D(u_tex0, v_tex0);\n"
-    "}\n"
-};
-
-static FragmentTest fpCopyTexGamma = {
-	"Texture copy with gamma", 1,
-
-    "precision mediump float;\n"
-    "varying vec2 v_tex0;\n"
-    "uniform sampler2D u_tex0;\n"
-    "void main() {\n"
-    "  vec4 t = texture2D(u_tex0, v_tex0);\n"
-    "  t.rgb = pow(t.rgb, vec3(1.4, 1.4, 1.4));\n"
-    "  gl_FragColor = t;\n"
-    "}\n"
-};
-
-static FragmentTest fpTexSpec = {
-	"Texture spec", 1,
-
-    "precision mediump float;\n"
-    "varying vec2 v_tex0;\n"
-    "uniform sampler2D u_tex0;\n"
-    "void main() {\n"
-    "  vec4 t = texture2D(u_tex0, v_tex0);\n"
-    "  float simSpec = dot(gl_FragCoord.xyz, gl_FragCoord.xyz);\n"
-    "  simSpec = pow(clamp(simSpec, 0.1, 1.0), 40.0);\n"
-    "  gl_FragColor = t + vec4(simSpec, simSpec, simSpec, simSpec);\n"
-    "}\n"
-};
-
-static FragmentTest fpDepTex = {
-	"Dependent Lookup", 1,
-
-    "precision mediump float;\n"
-    "varying vec2 v_tex0;\n"
-    "uniform sampler2D u_tex0;\n"
-    "void main() {\n"
-    "  vec4 t = texture2D(u_tex0, v_tex0);\n"
-    "  t += texture2D(u_tex0, t.xy);\n"
-    "  gl_FragColor = t;\n"
-    "}\n"
-};
-
-static FragmentTest fpModulateConstantTex = {
-	"Texture modulate constant", 1,
-
-    "precision mediump float;\n"
-    "varying vec2 v_tex0;\n"
-    "uniform sampler2D u_tex0;\n"
-    "uniform vec4 u_color;\n"
-
-    "void main() {\n"
-    "  lowp vec4 c = texture2D(u_tex0, v_tex0);\n"
-	"  c *= u_color;\n"
-    "  gl_FragColor = c;\n"
-    "}\n"
-};
-
-static FragmentTest fpModulateVaryingTex = {
-	"Texture modulate gradient", 1,
-
-    "precision mediump float;\n"
-    "varying vec2 v_tex0;\n"
-    "varying lowp vec4 v_color;\n"
-    "uniform sampler2D u_tex0;\n"
-
-    "void main() {\n"
-    "  lowp vec4 c = texture2D(u_tex0, v_tex0);\n"
-	"  c *= v_color;\n"
-    "  gl_FragColor = c;\n"
-    "}\n"
-};
-
-static FragmentTest fpModulateVaryingConstantTex = {
-	"Texture modulate gradient constant", 1,
-
-    "precision mediump float;\n"
-    "varying vec2 v_tex0;\n"
-    "varying lowp vec4 v_color;\n"
-    "uniform sampler2D u_tex0;\n"
-    "uniform vec4 u_color;\n"
-
-    "void main() {\n"
-    "  lowp vec4 c = texture2D(u_tex0, v_tex0);\n"
-	"  c *= v_color;\n"
-	"  c *= u_color;\n"
-    "  gl_FragColor = c;\n"
-    "}\n"
-};
-
-static FragmentTest *gFragmentTests[] = {
-	&fpFill,
-	&fpGradient,
-	&fpCopyTex,
-	&fpCopyTexGamma,
-   &fpTexSpec,
-   &fpDepTex,
-	&fpModulateConstantTex,
-	&fpModulateVaryingTex,
-	&fpModulateVaryingConstantTex,
-
-};
-
-static const size_t gFragmentTestCount = sizeof(gFragmentTests) / sizeof(gFragmentTests[0]);
diff --git a/opengl/tests/gl_perf/gl2_perf.cpp b/opengl/tests/gl_perf/gl2_perf.cpp
deleted file mode 100644
index 047db20864..0000000000
--- a/opengl/tests/gl_perf/gl2_perf.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sched.h>
-#include <sys/resource.h>
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <utils/Timers.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-
-static void checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE) {
-    if (returnVal != EGL_TRUE) {
-        fprintf(stderr, "%s() returned %d\n", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        fprintf(stderr, "after %s() eglError %s (0x%x)\n", op, EGLUtils::strerror(error),
-                error);
-    }
-}
-
-bool doTest(uint32_t w, uint32_t h);
-
-static EGLDisplay dpy;
-static EGLSurface surface;
-
-int main(int /*argc*/, char** /*argv*/) {
-    EGLBoolean returnValue;
-    EGLConfig myConfig = {0};
-
-    EGLint context_attribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
-    EGLint s_configAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL_NONE };
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EGLContext context;
-    EGLint w, h;
-
-
-    checkEglError("<init>");
-    dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    checkEglError("eglGetDisplay");
-    if (dpy == EGL_NO_DISPLAY) {
-        printf("eglGetDisplay returned EGL_NO_DISPLAY.\n");
-        return 0;
-    }
-
-    returnValue = eglInitialize(dpy, &majorVersion, &minorVersion);
-    checkEglError("eglInitialize", returnValue);
-    if (returnValue != EGL_TRUE) {
-        printf("eglInitialize failed\n");
-        return 0;
-    }
-
-    WindowSurface windowSurface;
-    EGLNativeWindowType window = windowSurface.getSurface();
-    returnValue = EGLUtils::selectConfigForNativeWindow(dpy, s_configAttribs, window, &myConfig);
-    if (returnValue) {
-        printf("EGLUtils::selectConfigForNativeWindow() returned %d", returnValue);
-        return 0;
-    }
-
-    checkEglError("EGLUtils::selectConfigForNativeWindow");
-
-    surface = eglCreateWindowSurface(dpy, myConfig, window, NULL);
-    checkEglError("eglCreateWindowSurface");
-    if (surface == EGL_NO_SURFACE) {
-        printf("gelCreateWindowSurface failed.\n");
-        return 0;
-    }
-
-    context = eglCreateContext(dpy, myConfig, EGL_NO_CONTEXT, context_attribs);
-    checkEglError("eglCreateContext");
-    if (context == EGL_NO_CONTEXT) {
-        printf("eglCreateContext failed\n");
-        return 0;
-    }
-    returnValue = eglMakeCurrent(dpy, surface, surface, context);
-    checkEglError("eglMakeCurrent", returnValue);
-    if (returnValue != EGL_TRUE) {
-        return 0;
-    }
-    eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-    checkEglError("eglQuerySurface");
-    eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-    checkEglError("eglQuerySurface");
-
-    glViewport(0, 0, w, h);
-
-    for (;;) {
-        doTest(w, h);
-        eglSwapBuffers(dpy, surface);
-        checkEglError("eglSwapBuffers");
-    }
-
-    return 0;
-}
-
-void ptSwap() {
-    eglSwapBuffers(dpy, surface);
-}
-
diff --git a/opengl/tests/gl_perfapp/Android.mk b/opengl/tests/gl_perfapp/Android.mk
deleted file mode 100644
index 3f411ea962..0000000000
--- a/opengl/tests/gl_perfapp/Android.mk
+++ /dev/null
@@ -1,52 +0,0 @@
-#########################################################################
-# OpenGL ES Perf App
-# This makefile builds both an activity and a shared library.
-#########################################################################
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := GLPerf
-
-LOCAL_JNI_SHARED_LIBRARIES := libglperf
-
-# Run on Eclair
-LOCAL_SDK_VERSION := 7
-
-include $(BUILD_PACKAGE)
-
-#########################################################################
-# Build JNI Shared Library
-#########################################################################
-
-LOCAL_PATH:= $(LOCAL_PATH)/jni
-
-include $(CLEAR_VARS)
-
-# Optional tag would mean it doesn't get installed by default
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -Werror -Wno-error=unused-parameter
-
-LOCAL_SRC_FILES:= \
-  gl_code.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-	liblog \
-	libEGL \
-	libGLESv2
-
-LOCAL_SDK_VERSION := current
-
-LOCAL_MODULE := libglperf
-
-
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/opengl/tests/gl_perfapp/AndroidManifest.xml b/opengl/tests/gl_perfapp/AndroidManifest.xml
deleted file mode 100644
index ee4bd9800e..0000000000
--- a/opengl/tests/gl_perfapp/AndroidManifest.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.glperf"
-    android:versionName="1.0.0" android:versionCode="10000" >
-    <uses-sdk android:targetSdkVersion="7" android:minSdkVersion="7" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <application
-            android:label="@string/glperf_activity">
-        <activity android:name="GLPerfActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-            	android:launchMode="singleTask"
-            	android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/gl_perfapp/jni/gl_code.cpp b/opengl/tests/gl_perfapp/jni/gl_code.cpp
deleted file mode 100644
index bd1fd83184..0000000000
--- a/opengl/tests/gl_perfapp/jni/gl_code.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-// OpenGL ES 2.0 code
-
-#include <jni.h>
-#define LOG_TAG "GLPerf gl_code.cpp"
-#include <android/log.h>
-
-#define ALOG(priority, tag, ...) ((void)__android_log_print(ANDROID_##priority, tag, __VA_ARGS__))
-
-#define ALOGI(...) ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__)
-#define ALOGE(...) ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__)
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <time.h>
-
-#include "../../gl_perf/fill_common.cpp"
-
-
-//////////////////////////
-
-// Width and height of the screen
-
-uint32_t w;
-uint32_t h;
-
-// The stateClock starts at zero and increments by 1 every time we draw a frame. It is used to control which phase of the test we are in.
-
-int stateClock;
-bool done;
-
-// Saves the parameters of the test (so we can print them out when we finish the timing.)
-
-
-int pgm;
-
-void ptSwap() {
-}
-
-void doTest() {
-    uint32_t testNum = stateClock >> 2;
-    int texSize = ((stateClock >> 1) & 0x1) + 1;
-
-    if (testNum >= gFragmentTestCount) {
-       ALOGI("done\n");
-       if (fOut) {
-           fclose(fOut);
-           fOut = NULL;
-       }
-       done = true;
-       return;
-    }
-
-    // ALOGI("doTest %d %d %d\n", texCount, extraMath, testSubState);
-
-//        for (uint32_t num = 0; num < gFragmentTestCount; num++) {
-    doSingleTest(testNum, texSize);
-}
-
-extern "C" {
-    JNIEXPORT void JNICALL Java_com_android_glperf_GLPerfLib_init(JNIEnv * env, jobject obj,  jint width, jint height);
-    JNIEXPORT void JNICALL Java_com_android_glperf_GLPerfLib_step(JNIEnv * env, jobject obj);
-};
-
-JNIEXPORT void JNICALL Java_com_android_glperf_GLPerfLib_init(JNIEnv * /*env*/, jobject /*obj*/,  jint width, jint height)
-{
-    gWidth = width;
-    gHeight = height;
-    if (!done) {
-            stateClock = 0;
-            done = false;
-            setupVA();
-            genTextures();
-            const char* fileName = "/sdcard/glperf.csv";
-            if (fOut != NULL) {
-                 ALOGI("Closing partially written output.n");
-                 fclose(fOut);
-                 fOut = NULL;
-            }
-            ALOGI("Writing to: %s\n",fileName);
-            fOut = fopen(fileName, "w");
-            if (fOut == NULL) {
-                ALOGE("Could not open: %s\n", fileName);
-            }
-
-            ALOGI("\nvarColor, texCount, modulate, extraMath, texSize, blend, Mpps, DC60\n");
-            if (fOut) fprintf(fOut,"varColor, texCount, modulate, extraMath, texSize, blend, Mpps, DC60\r\n");
-    }
-}
-
-JNIEXPORT void JNICALL Java_com_android_glperf_GLPerfLib_step(JNIEnv * /*env*/, jobject /*obj*/)
-{
-    if (! done) {
-        if (stateClock > 0 && ((stateClock & 1) == 0)) {
-            //endTimer(100);
-        }
-        doTest();
-        stateClock++;
-    } else {
-            glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    }
-}
diff --git a/opengl/tests/gl_perfapp/res/values/strings.xml b/opengl/tests/gl_perfapp/res/values/strings.xml
deleted file mode 100644
index 52cd961841..0000000000
--- a/opengl/tests/gl_perfapp/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="glperf_activity">GLPerf</string>
-
-</resources>
-
diff --git a/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfActivity.java b/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfActivity.java
deleted file mode 100644
index e3f3abf029..0000000000
--- a/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfActivity.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.glperf;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.WindowManager;
-
-import java.io.File;
-
-
-public class GLPerfActivity extends Activity {
-
-    GLPerfView mView;
-
-    @Override protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-	getWindow().setFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-        mView = new GLPerfView(getApplication());
-	setContentView(mView);
-    }
-
-    @Override protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfLib.java b/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfLib.java
deleted file mode 100644
index 89a0e54d4c..0000000000
--- a/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfLib.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.glperf;
-
-// Wrapper for native library
-
-public class GLPerfLib {
-
-     static {
-         System.loadLibrary("glperf");
-     }
-
-    /**
-     * @param width the current view width
-     * @param height the current view height
-     */
-     public static native void init(int width, int height);
-     public static native void step();
-}
diff --git a/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfView.java b/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfView.java
deleted file mode 100644
index 4ce4a4d3ed..0000000000
--- a/opengl/tests/gl_perfapp/src/com/android/glperf/GLPerfView.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.glperf;
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class GLPerfView extends GLSurfaceView {
-    private static String TAG = "GLPerfView";
-
-    public GLPerfView(Context context) {
-        super(context);
-        init(false, 0, 0);
-    }
-
-    public GLPerfView(Context context, boolean translucent, int depth, int stencil) {
-        super(context);
-        init(translucent, depth, stencil);
-    }
-
-    private void init(boolean translucent, int depth, int stencil) {
-        setEGLContextFactory(new ContextFactory());
-        setEGLConfigChooser( translucent ?
-              new ConfigChooser(8,8,8,8, depth, stencil) :
-              new ConfigChooser(5,6,5,0, depth, stencil));
-        setRenderer(new Renderer());
-    }
-
-    private static class ContextFactory implements GLSurfaceView.EGLContextFactory {
-        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
-            Log.w(TAG, "creating OpenGL ES 2.0 context");
-            checkEglError("Before eglCreateContext", egl);
-            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };
-            EGLContext context = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, attrib_list);
-            checkEglError("After eglCreateContext", egl);
-            return context;
-        }
-
-        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
-            egl.eglDestroyContext(display, context);
-        }
-    }
-
-    private static void checkEglError(String prompt, EGL10 egl) {
-        int error;
-        while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {
-            Log.e(TAG, String.format("%s: EGL error: 0x%x", prompt, error));
-        }
-    }
-
-    private static class ConfigChooser implements GLSurfaceView.EGLConfigChooser {
-        private static int EGL_OPENGL_ES2_BIT = 4;
-        private static int[] s_configAttribs2 =
-        {
-            EGL10.EGL_RED_SIZE, 4,
-            EGL10.EGL_GREEN_SIZE, 4,
-            EGL10.EGL_BLUE_SIZE, 4,
-            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL10.EGL_NONE
-        };
-
-        public ConfigChooser(int r, int g, int b, int a, int depth, int stencil) {
-            mRedSize = r;
-            mGreenSize = g;
-            mBlueSize = b;
-            mAlphaSize = a;
-            mDepthSize = depth;
-            mStencilSize = stencil;
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-
-            int[] num_config = new int[1];
-            egl.eglChooseConfig(display, s_configAttribs2, null, 0, num_config);
-
-            int numConfigs = num_config[0];
-
-            if (numConfigs <= 0) {
-                throw new IllegalArgumentException("No configs match configSpec");
-            }
-            EGLConfig[] configs = new EGLConfig[numConfigs];
-            egl.eglChooseConfig(display, s_configAttribs2, configs, numConfigs, num_config);
-            // printConfigs(egl, display, configs);
-            return chooseConfig(egl, display, configs);
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs) {
-            EGLConfig closestConfig = null;
-            int closestDistance = 1000;
-            for(EGLConfig config : configs) {
-                int d = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_DEPTH_SIZE, 0);
-                int s = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_STENCIL_SIZE, 0);
-                if (d >= mDepthSize && s>= mStencilSize) {
-                    int r = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_RED_SIZE, 0);
-                    int g = findConfigAttrib(egl, display, config,
-                             EGL10.EGL_GREEN_SIZE, 0);
-                    int b = findConfigAttrib(egl, display, config,
-                              EGL10.EGL_BLUE_SIZE, 0);
-                    int a = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_ALPHA_SIZE, 0);
-                    int distance = Math.abs(r - mRedSize)
-                                + Math.abs(g - mGreenSize)
-                                + Math.abs(b - mBlueSize)
-                                + Math.abs(a - mAlphaSize);
-                    if (distance < closestDistance) {
-                        closestDistance = distance;
-                        closestConfig = config;
-                    }
-                }
-            }
-            return closestConfig;
-        }
-
-        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-                EGLConfig config, int attribute, int defaultValue) {
-
-            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-                return mValue[0];
-            }
-            return defaultValue;
-        }
-
-        private void printConfigs(EGL10 egl, EGLDisplay display,
-            EGLConfig[] configs) {
-            int numConfigs = configs.length;
-            Log.w(TAG, String.format("%d configurations", numConfigs));
-            for (int i = 0; i < numConfigs; i++) {
-                Log.w(TAG, String.format("Configuration %d:\n", i));
-                printConfig(egl, display, configs[i]);
-            }
-        }
-
-        private void printConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig config) {
-            int[] attributes = {
-                    EGL10.EGL_BUFFER_SIZE,
-                    EGL10.EGL_ALPHA_SIZE,
-                    EGL10.EGL_BLUE_SIZE,
-                    EGL10.EGL_GREEN_SIZE,
-                    EGL10.EGL_RED_SIZE,
-                    EGL10.EGL_DEPTH_SIZE,
-                    EGL10.EGL_STENCIL_SIZE,
-                    EGL10.EGL_CONFIG_CAVEAT,
-                    EGL10.EGL_CONFIG_ID,
-                    EGL10.EGL_LEVEL,
-                    EGL10.EGL_MAX_PBUFFER_HEIGHT,
-                    EGL10.EGL_MAX_PBUFFER_PIXELS,
-                    EGL10.EGL_MAX_PBUFFER_WIDTH,
-                    EGL10.EGL_NATIVE_RENDERABLE,
-                    EGL10.EGL_NATIVE_VISUAL_ID,
-                    EGL10.EGL_NATIVE_VISUAL_TYPE,
-                    0x3030, // EGL10.EGL_PRESERVED_RESOURCES,
-                    EGL10.EGL_SAMPLES,
-                    EGL10.EGL_SAMPLE_BUFFERS,
-                    EGL10.EGL_SURFACE_TYPE,
-                    EGL10.EGL_TRANSPARENT_TYPE,
-                    EGL10.EGL_TRANSPARENT_RED_VALUE,
-                    EGL10.EGL_TRANSPARENT_GREEN_VALUE,
-                    EGL10.EGL_TRANSPARENT_BLUE_VALUE,
-                    0x3039, // EGL10.EGL_BIND_TO_TEXTURE_RGB,
-                    0x303A, // EGL10.EGL_BIND_TO_TEXTURE_RGBA,
-                    0x303B, // EGL10.EGL_MIN_SWAP_INTERVAL,
-                    0x303C, // EGL10.EGL_MAX_SWAP_INTERVAL,
-                    EGL10.EGL_LUMINANCE_SIZE,
-                    EGL10.EGL_ALPHA_MASK_SIZE,
-                    EGL10.EGL_COLOR_BUFFER_TYPE,
-                    EGL10.EGL_RENDERABLE_TYPE,
-                    0x3042 // EGL10.EGL_CONFORMANT
-            };
-            String[] names = {
-                    "EGL_BUFFER_SIZE",
-                    "EGL_ALPHA_SIZE",
-                    "EGL_BLUE_SIZE",
-                    "EGL_GREEN_SIZE",
-                    "EGL_RED_SIZE",
-                    "EGL_DEPTH_SIZE",
-                    "EGL_STENCIL_SIZE",
-                    "EGL_CONFIG_CAVEAT",
-                    "EGL_CONFIG_ID",
-                    "EGL_LEVEL",
-                    "EGL_MAX_PBUFFER_HEIGHT",
-                    "EGL_MAX_PBUFFER_PIXELS",
-                    "EGL_MAX_PBUFFER_WIDTH",
-                    "EGL_NATIVE_RENDERABLE",
-                    "EGL_NATIVE_VISUAL_ID",
-                    "EGL_NATIVE_VISUAL_TYPE",
-                    "EGL_PRESERVED_RESOURCES",
-                    "EGL_SAMPLES",
-                    "EGL_SAMPLE_BUFFERS",
-                    "EGL_SURFACE_TYPE",
-                    "EGL_TRANSPARENT_TYPE",
-                    "EGL_TRANSPARENT_RED_VALUE",
-                    "EGL_TRANSPARENT_GREEN_VALUE",
-                    "EGL_TRANSPARENT_BLUE_VALUE",
-                    "EGL_BIND_TO_TEXTURE_RGB",
-                    "EGL_BIND_TO_TEXTURE_RGBA",
-                    "EGL_MIN_SWAP_INTERVAL",
-                    "EGL_MAX_SWAP_INTERVAL",
-                    "EGL_LUMINANCE_SIZE",
-                    "EGL_ALPHA_MASK_SIZE",
-                    "EGL_COLOR_BUFFER_TYPE",
-                    "EGL_RENDERABLE_TYPE",
-                    "EGL_CONFORMANT"
-            };
-            int[] value = new int[1];
-            for (int i = 0; i < attributes.length; i++) {
-                int attribute = attributes[i];
-                String name = names[i];
-                if ( egl.eglGetConfigAttrib(display, config, attribute, value)) {
-                    Log.w(TAG, String.format("  %s: %d\n", name, value[0]));
-                } else {
-                    // Log.w(TAG, String.format("  %s: failed\n", name));
-                    while (egl.eglGetError() != EGL10.EGL_SUCCESS);
-                }
-            }
-        }
-
-        // Subclasses can adjust these values:
-        protected int mRedSize;
-        protected int mGreenSize;
-        protected int mBlueSize;
-        protected int mAlphaSize;
-        protected int mDepthSize;
-        protected int mStencilSize;
-        private int[] mValue = new int[1];
-    }
-
-    private static class Renderer implements GLSurfaceView.Renderer {
-        public void onDrawFrame(GL10 gl) {
-            GLPerfLib.step();
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            GLPerfLib.init(width, height);
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            // Do nothing.
-        }
-    }
-}
-
diff --git a/opengl/tests/gl_yuvtex/Android.bp b/opengl/tests/gl_yuvtex/Android.bp
deleted file mode 100644
index 9b4924ab82..0000000000
--- a/opengl/tests/gl_yuvtex/Android.bp
+++ /dev/null
@@ -1,25 +0,0 @@
-cc_test {
-    name: "test-opengl-gl_yuvtex",
-
-    srcs: ["gl_yuvtex.cpp"],
-
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv1_CM",
-        "libutils",
-        "libui",
-        "libgui",
-    ],
-
-    gtest: false,
-
-    static_libs: ["libglTest"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-DEGL_EGLEXT_PROTOTYPES",
-        "-Wall",
-        "-Werror",
-    ],
-}
diff --git a/opengl/tests/gl_yuvtex/gl_yuvtex.cpp b/opengl/tests/gl_yuvtex/gl_yuvtex.cpp
deleted file mode 100644
index 2c9640bfef..0000000000
--- a/opengl/tests/gl_yuvtex/gl_yuvtex.cpp
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sched.h>
-#include <sys/resource.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <utils/Timers.h>
-
-#include <WindowSurface.h>
-#include <ui/GraphicBuffer.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-static void printGLString(const char *name, GLenum s) {
-    // fprintf(stderr, "printGLString %s, %d\n", name, s);
-    const char *v = (const char *) glGetString(s);
-    // int error = glGetError();
-    // fprintf(stderr, "glGetError() = %d, result of glGetString = %x\n", error,
-    //        (unsigned int) v);
-    // if ((v < (const char*) 0) || (v > (const char*) 0x10000))
-    //    fprintf(stderr, "GL %s = %s\n", name, v);
-    // else
-    //    fprintf(stderr, "GL %s = (null) 0x%08x\n", name, (unsigned int) v);
-    fprintf(stderr, "GL %s = %s\n", name, v);
-}
-
-static void checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE) {
-    if (returnVal != EGL_TRUE) {
-        fprintf(stderr, "%s() returned %d\n", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        fprintf(stderr, "after %s() eglError %s (0x%x)\n", op, EGLUtils::strerror(error),
-                error);
-    }
-}
-
-static void checkGlError(const char* op) {
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        fprintf(stderr, "after %s() glError (0x%x)\n", op, error);
-    }
-}
-
-bool setupGraphics(int w, int h) {
-    glViewport(0, 0, w, h);
-    checkGlError("glViewport");
-    return true;
-}
-
-int align(int x, int a) {
-    return (x + (a-1)) & (~(a-1));
-}
-
-const int yuvTexWidth = 600;
-const int yuvTexHeight = 480;
-const int yuvTexUsage = GraphicBuffer::USAGE_HW_TEXTURE |
-        GraphicBuffer::USAGE_SW_WRITE_RARELY;
-const int yuvTexFormat = HAL_PIXEL_FORMAT_YV12;
-const int yuvTexOffsetY = 0;
-const int yuvTexStrideY = (yuvTexWidth + 0xf) & ~0xf;
-const int yuvTexOffsetV = yuvTexStrideY * yuvTexHeight;
-const int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf; 
-const int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * yuvTexHeight/2;
-const int yuvTexStrideU = yuvTexStrideV;
-const bool yuvTexSameUV = false;
-static sp<GraphicBuffer> yuvTexBuffer;
-static GLuint yuvTex;
-
-static bool setupYuvTexSurface(EGLDisplay dpy) {
-    int blockWidth = yuvTexWidth > 16 ? yuvTexWidth / 16 : 1;
-    int blockHeight = yuvTexHeight > 16 ? yuvTexHeight / 16 : 1;
-    yuvTexBuffer = new GraphicBuffer(yuvTexWidth, yuvTexHeight, yuvTexFormat,
-            yuvTexUsage);
-    char* buf = NULL;
-    status_t err = yuvTexBuffer->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&buf));
-    if (err != 0) {
-        fprintf(stderr, "yuvTexBuffer->lock(...) failed: %d\n", err);
-        return false;
-    }
-    for (int x = 0; x < yuvTexWidth; x++) {
-        for (int y = 0; y < yuvTexHeight; y++) {
-            int parityX = (x / blockWidth) & 1;
-            int parityY = (y / blockHeight) & 1;
-            unsigned char intensity = (parityX ^ parityY) ? 63 : 191;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = intensity;
-            if (x < yuvTexWidth / 2 && y < yuvTexHeight / 2) {
-                buf[yuvTexOffsetU + (y * yuvTexStrideU) + x] = intensity;
-                if (yuvTexSameUV) {
-                    buf[yuvTexOffsetV + (y * yuvTexStrideV) + x] = intensity;
-                } else if (x < yuvTexWidth / 4 && y < yuvTexHeight / 4) {
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 1] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 1] = intensity;
-                }
-            }
-        }
-    }
-
-    err = yuvTexBuffer->unlock();
-    if (err != 0) {
-        fprintf(stderr, "yuvTexBuffer->unlock() failed: %d\n", err);
-        return false;
-    }
-
-    EGLClientBuffer clientBuffer = (EGLClientBuffer)yuvTexBuffer->getNativeBuffer();
-    EGLImageKHR img = eglCreateImageKHR(dpy, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_ANDROID,
-            clientBuffer, 0);
-    checkEglError("eglCreateImageKHR");
-    if (img == EGL_NO_IMAGE_KHR) {
-        return false;
-    }
-
-    glGenTextures(1, &yuvTex);
-    checkGlError("glGenTextures");
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, yuvTex);
-    checkGlError("glBindTexture");
-    glEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);
-    checkGlError("glEGLImageTargetTexture2DOES");
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-    checkGlError("glTexParameteri");
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    checkGlError("glTexParameteri");
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-    checkGlError("glTexEnvx");
-
-    GLint crop[4] = { 0, 0, yuvTexWidth, yuvTexHeight };
-    glTexParameteriv(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_CROP_RECT_OES, crop);
-    checkGlError("glTexParameteriv");
-
-    return true;
-}
-
-void renderFrame(int w, int h) {
-    glClearColor(0.0f, 0.0f, 1.0f, 1.0f);
-    checkGlError("glClearColor");
-    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    checkGlError("glClear");
-    
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, yuvTex);
-    checkGlError("glBindTexture");
-    glEnable(GL_TEXTURE_EXTERNAL_OES);
-    checkGlError("glEnable");
-
-    glDrawTexiOES(0, 0, 0, w, h);
-    checkGlError("glDrawTexiOES");
-}
-
-void printEGLConfiguration(EGLDisplay dpy, EGLConfig config) {
-
-#define X(VAL) {VAL, #VAL}
-    struct {EGLint attribute; const char* name;} names[] = {
-    X(EGL_BUFFER_SIZE),
-    X(EGL_ALPHA_SIZE),
-    X(EGL_BLUE_SIZE),
-    X(EGL_GREEN_SIZE),
-    X(EGL_RED_SIZE),
-    X(EGL_DEPTH_SIZE),
-    X(EGL_STENCIL_SIZE),
-    X(EGL_CONFIG_CAVEAT),
-    X(EGL_CONFIG_ID),
-    X(EGL_LEVEL),
-    X(EGL_MAX_PBUFFER_HEIGHT),
-    X(EGL_MAX_PBUFFER_PIXELS),
-    X(EGL_MAX_PBUFFER_WIDTH),
-    X(EGL_NATIVE_RENDERABLE),
-    X(EGL_NATIVE_VISUAL_ID),
-    X(EGL_NATIVE_VISUAL_TYPE),
-    X(EGL_SAMPLES),
-    X(EGL_SAMPLE_BUFFERS),
-    X(EGL_SURFACE_TYPE),
-    X(EGL_TRANSPARENT_TYPE),
-    X(EGL_TRANSPARENT_RED_VALUE),
-    X(EGL_TRANSPARENT_GREEN_VALUE),
-    X(EGL_TRANSPARENT_BLUE_VALUE),
-    X(EGL_BIND_TO_TEXTURE_RGB),
-    X(EGL_BIND_TO_TEXTURE_RGBA),
-    X(EGL_MIN_SWAP_INTERVAL),
-    X(EGL_MAX_SWAP_INTERVAL),
-    X(EGL_LUMINANCE_SIZE),
-    X(EGL_ALPHA_MASK_SIZE),
-    X(EGL_COLOR_BUFFER_TYPE),
-    X(EGL_RENDERABLE_TYPE),
-    X(EGL_CONFORMANT),
-   };
-#undef X
-
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute, &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            printf(" %s: ", names[j].name);
-            printf("%d (0x%x)", value, value);
-        }
-    }
-    printf("\n");
-}
-
-int main(int /*argc*/, char** /*argv*/) {
-    EGLBoolean returnValue;
-    EGLConfig myConfig = {0};
-
-    EGLint context_attribs[] = { EGL_CONTEXT_CLIENT_VERSION, 1, EGL_NONE };
-    EGLint s_configAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES_BIT,
-            EGL_NONE };
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EGLContext context;
-    EGLSurface surface;
-    EGLint w, h;
-
-    EGLDisplay dpy;
-
-    checkEglError("<init>");
-    dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    checkEglError("eglGetDisplay");
-    if (dpy == EGL_NO_DISPLAY) {
-        printf("eglGetDisplay returned EGL_NO_DISPLAY.\n");
-        return 0;
-    }
-
-    returnValue = eglInitialize(dpy, &majorVersion, &minorVersion);
-    checkEglError("eglInitialize", returnValue);
-    fprintf(stderr, "EGL version %d.%d\n", majorVersion, minorVersion);
-    if (returnValue != EGL_TRUE) {
-        printf("eglInitialize failed\n");
-        return 0;
-    }
-
-    WindowSurface windowSurface;
-    EGLNativeWindowType window = windowSurface.getSurface();
-    returnValue = EGLUtils::selectConfigForNativeWindow(dpy, s_configAttribs, window, &myConfig);
-    if (returnValue) {
-        printf("EGLUtils::selectConfigForNativeWindow() returned %d", returnValue);
-        return 1;
-    }
-
-    checkEglError("EGLUtils::selectConfigForNativeWindow");
-
-    printf("Chose this configuration:\n");
-    printEGLConfiguration(dpy, myConfig);
-
-    surface = eglCreateWindowSurface(dpy, myConfig, window, NULL);
-    checkEglError("eglCreateWindowSurface");
-    if (surface == EGL_NO_SURFACE) {
-        printf("gelCreateWindowSurface failed.\n");
-        return 1;
-    }
-
-    context = eglCreateContext(dpy, myConfig, EGL_NO_CONTEXT, context_attribs);
-    checkEglError("eglCreateContext");
-    if (context == EGL_NO_CONTEXT) {
-        printf("eglCreateContext failed\n");
-        return 1;
-    }
-    returnValue = eglMakeCurrent(dpy, surface, surface, context);
-    checkEglError("eglMakeCurrent", returnValue);
-    if (returnValue != EGL_TRUE) {
-        return 1;
-    }
-    eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-    checkEglError("eglQuerySurface");
-    eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-    checkEglError("eglQuerySurface");
-
-    fprintf(stderr, "Window dimensions: %d x %d\n", w, h);
-
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-
-    if(!setupYuvTexSurface(dpy)) {
-        fprintf(stderr, "Could not set up texture surface.\n");
-        return 1;
-    }
-
-    if(!setupGraphics(w, h)) {
-        fprintf(stderr, "Could not set up graphics.\n");
-        return 1;
-    }
-
-    for (;;) {
-        static int dir = -1;
-
-        renderFrame(w, h);
-        eglSwapBuffers(dpy, surface);
-        checkEglError("eglSwapBuffers");
-
-        if (w <= 10 || h <= 10)
-        {
-            dir = -dir;
-        }
-
-        if (w >= 1300 || h >= 900)
-        {
-            dir = -dir;
-        }
-
-
-        w += dir;
-        h += dir;
-    }
-
-    return 0;
-}
diff --git a/opengl/tests/gldual/Android.mk b/opengl/tests/gldual/Android.mk
deleted file mode 100644
index 5bdc0a8f3f..0000000000
--- a/opengl/tests/gldual/Android.mk
+++ /dev/null
@@ -1,49 +0,0 @@
-#########################################################################
-# OpenGL ES JNI sample
-# This makefile builds both an activity and a shared library.
-#########################################################################
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := GLDual
-LOCAL_SDK_VERSION := current
-
-LOCAL_JNI_SHARED_LIBRARIES := libgldualjni
-
-include $(BUILD_PACKAGE)
-
-#########################################################################
-# Build JNI Shared Library
-#########################################################################
-
-LOCAL_PATH:= $(LOCAL_PATH)/jni
-
-include $(CLEAR_VARS)
-
-# Optional tag would mean it doesn't get installed by default
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -Werror -Wno-error=unused-parameter
-
-LOCAL_SRC_FILES:= \
-  gl_code.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-	liblog \
-	libEGL \
-	libGLESv2
-
-LOCAL_MODULE := libgldualjni
-
-LOCAL_SDK_VERSION := current
-
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/opengl/tests/gldual/AndroidManifest.xml b/opengl/tests/gldual/AndroidManifest.xml
deleted file mode 100644
index a36f4f715e..0000000000
--- a/opengl/tests/gldual/AndroidManifest.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.gldual">
-    <application
-            android:label="@string/gldual_activity">
-        <activity android:name="GLDualActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-            	android:launchMode="singleTask"
-            	android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/gldual/jni/gl_code.cpp b/opengl/tests/gldual/jni/gl_code.cpp
deleted file mode 100644
index 4e44976c92..0000000000
--- a/opengl/tests/gldual/jni/gl_code.cpp
+++ /dev/null
@@ -1,170 +0,0 @@
-// OpenGL ES 2.0 code
-
-#include <jni.h>
-#define LOG_TAG "GL2JNI gl_code.cpp"
-#include <android/log.h>
-
-#define ALOG(priority, tag, ...) ((void)__android_log_print(ANDROID_##priority, tag, __VA_ARGS__))
-
-#define ALOGI(...) ALOG(LOG_INFO, LOG_TAG, __VA_ARGS__)
-#define ALOGE(...) ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__)
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-static void printGLString(const char *name, GLenum s) {
-    const char *v = (const char *) glGetString(s);
-    ALOGI("GL %s = %s\n", name, v);
-}
-
-static void checkGlError(const char* op) {
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        ALOGI("after %s() glError (0x%x)\n", op, error);
-    }
-}
-
-static const char gVertexShader[] = "attribute vec4 vPosition;\n"
-    "void main() {\n"
-    "  gl_Position = vPosition;\n"
-    "}\n";
-
-static const char gFragmentShader[] = "precision mediump float;\n"
-    "void main() {\n"
-    "  gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
-    "}\n";
-
-GLuint loadShader(GLenum shaderType, const char* pSource) {
-    GLuint shader = glCreateShader(shaderType);
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        glCompileShader(shader);
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    ALOGE("Could not compile shader %d:\n%s\n",
-                            shaderType, buf);
-                    free(buf);
-                }
-                glDeleteShader(shader);
-                shader = 0;
-            }
-        }
-    }
-    return shader;
-}
-
-GLuint createProgram(const char* pVertexSource, const char* pFragmentSource) {
-    GLuint vertexShader = loadShader(GL_VERTEX_SHADER, pVertexSource);
-    if (!vertexShader) {
-        return 0;
-    }
-
-    GLuint pixelShader = loadShader(GL_FRAGMENT_SHADER, pFragmentSource);
-    if (!pixelShader) {
-        return 0;
-    }
-
-    GLuint program = glCreateProgram();
-    if (program) {
-        glAttachShader(program, vertexShader);
-        checkGlError("glAttachShader");
-        glAttachShader(program, pixelShader);
-        checkGlError("glAttachShader");
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    ALOGE("Could not link program:\n%s\n", buf);
-                    free(buf);
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    return program;
-}
-
-GLuint gProgram;
-GLuint gvPositionHandle;
-
-bool setupGraphics(int w, int h) {
-    printGLString("Version", GL_VERSION);
-    printGLString("Vendor", GL_VENDOR);
-    printGLString("Renderer", GL_RENDERER);
-    printGLString("Extensions", GL_EXTENSIONS);
-
-    ALOGI("setupGraphics(%d, %d)", w, h);
-    gProgram = createProgram(gVertexShader, gFragmentShader);
-    if (!gProgram) {
-        ALOGE("Could not create program.");
-        return false;
-    }
-    gvPositionHandle = glGetAttribLocation(gProgram, "vPosition");
-    checkGlError("glGetAttribLocation");
-    ALOGI("glGetAttribLocation(\"vPosition\") = %d\n",
-            gvPositionHandle);
-
-    glViewport(0, 0, w, h);
-    checkGlError("glViewport");
-    return true;
-}
-
-const GLfloat gTriangleVertices[] = { 0.0f, 0.5f, -0.5f, -0.5f,
-        0.5f, -0.5f };
-
-void renderFrame() {
-    static float grey;
-    grey += 0.01f;
-    if (grey > 1.0f) {
-        grey = 0.0f;
-    }
-    glClearColor(grey, grey, grey, 1.0f);
-    checkGlError("glClearColor");
-    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    checkGlError("glClear");
-
-    glUseProgram(gProgram);
-    checkGlError("glUseProgram");
-
-    glVertexAttribPointer(gvPositionHandle, 2, GL_FLOAT, GL_FALSE, 0, gTriangleVertices);
-    checkGlError("glVertexAttribPointer");
-    glEnableVertexAttribArray(gvPositionHandle);
-    checkGlError("glEnableVertexAttribArray");
-    glDrawArrays(GL_TRIANGLES, 0, 3);
-    checkGlError("glDrawArrays");
-}
-
-extern "C" {
-    JNIEXPORT void JNICALL Java_com_android_gldual_GLDualLib_init(JNIEnv * env, jobject obj, jint width, jint height);
-    JNIEXPORT void JNICALL Java_com_android_gldual_GLDualLib_step(JNIEnv * env, jobject obj);
-};
-
-JNIEXPORT void JNICALL Java_com_android_gldual_GLDualLib_init(JNIEnv * /*env*/, jobject /*obj*/, jint width, jint height)
-{
-    setupGraphics(width, height);
-}
-
-JNIEXPORT void JNICALL Java_com_android_gldual_GLDualLib_step(JNIEnv * /*env*/, jobject /*obj*/)
-{
-    renderFrame();
-}
-
diff --git a/opengl/tests/gldual/res/layout/gldual_activity.xml b/opengl/tests/gldual/res/layout/gldual_activity.xml
deleted file mode 100644
index d75acbcb3e..0000000000
--- a/opengl/tests/gldual/res/layout/gldual_activity.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2007 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-  
-          http://www.apache.org/licenses/LICENSE-2.0
-  
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/text"
-
-    android:orientation="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-  <android.opengl.GLSurfaceView android:id="@+id/gl1"
-	android:layout_width="match_parent"
-	    android:layout_height="0dip"
-	    android:layout_weight="1" />
-  <com.android.gldual.GLDualGL2View android:id="@+id/gl2"
-	android:layout_width="match_parent"
-            android:layout_height="0dip"
-            android:layout_weight="1" />
-</LinearLayout>
diff --git a/opengl/tests/gldual/res/values/strings.xml b/opengl/tests/gldual/res/values/strings.xml
deleted file mode 100644
index b1f535da87..0000000000
--- a/opengl/tests/gldual/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="gldual_activity">GLDual</string>
-
-</resources>
-
diff --git a/opengl/tests/gldual/src/com/android/gldual/GLDualActivity.java b/opengl/tests/gldual/src/com/android/gldual/GLDualActivity.java
deleted file mode 100644
index 9d88f64882..0000000000
--- a/opengl/tests/gldual/src/com/android/gldual/GLDualActivity.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gldual;
-
-import android.app.Activity;
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.LinearLayout;
-
-
-public class GLDualActivity extends Activity {
-
-    GLSurfaceView mGLView;
-    GLDualGL2View mGL2View;
-
-    @Override protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        View root = getLayoutInflater().inflate(R.layout.gldual_activity, null);
-        mGLView = (GLSurfaceView) root.findViewById(R.id.gl1);
-        mGLView.setEGLConfigChooser(5,6,5,0,0,0);
-        mGLView.setRenderer(new TriangleRenderer());
-        mGL2View = (GLDualGL2View) root.findViewById(R.id.gl2);
-        setContentView(root);
-    }
-
-    @Override protected void onPause() {
-        super.onPause();
-        mGLView.onPause();
-        mGL2View.onPause();
-    }
-
-    @Override protected void onResume() {
-        super.onResume();
-        mGLView.onResume();
-        mGL2View.onResume();
-    }
-}
diff --git a/opengl/tests/gldual/src/com/android/gldual/GLDualGL2View.java b/opengl/tests/gldual/src/com/android/gldual/GLDualGL2View.java
deleted file mode 100644
index 8f5e347ea8..0000000000
--- a/opengl/tests/gldual/src/com/android/gldual/GLDualGL2View.java
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gldual;
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class GLDualGL2View extends GLSurfaceView {
-    private static String TAG = "GLDualGL2View";
-
-    public GLDualGL2View(Context context) {
-        super(context);
-        init(false, 0, 0);
-    }
-
-    public GLDualGL2View(Context context, AttributeSet set) {
-        super(context, set);
-        init(false, 0, 0);
-    }
-
-    public GLDualGL2View(Context context, boolean translucent, int depth, int stencil) {
-        super(context);
-        init(translucent, depth, stencil);
-    }
-
-    private void init(boolean translucent, int depth, int stencil) {
-        setEGLContextFactory(new ContextFactory());
-        setEGLConfigChooser( translucent ?
-              new ConfigChooser(8,8,8,8, depth, stencil) :
-              new ConfigChooser(5,6,5,0, depth, stencil));
-        setRenderer(new Renderer());
-    }
-
-    private static class ContextFactory implements GLSurfaceView.EGLContextFactory {
-        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
-        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
-            Log.w(TAG, "creating OpenGL ES 2.0 context");
-            checkEglError("Before eglCreateContext", egl);
-            int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };
-            EGLContext context = egl.eglCreateContext(display, eglConfig, EGL10.EGL_NO_CONTEXT, attrib_list);
-            checkEglError("After eglCreateContext", egl);
-            return context;
-        }
-
-        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
-            egl.eglDestroyContext(display, context);
-        }
-    }
-
-    private static void checkEglError(String prompt, EGL10 egl) {
-        int error;
-        while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {
-            Log.e(TAG, String.format("%s: EGL error: 0x%x", prompt, error));
-        }
-    }
-
-    private static class ConfigChooser implements GLSurfaceView.EGLConfigChooser {
-        private static int EGL_OPENGL_ES2_BIT = 4;
-        private static int[] s_configAttribs2 =
-        {
-            EGL10.EGL_RED_SIZE, 4,
-            EGL10.EGL_GREEN_SIZE, 4,
-            EGL10.EGL_BLUE_SIZE, 4,
-            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-            EGL10.EGL_NONE
-        };
-
-        public ConfigChooser(int r, int g, int b, int a, int depth, int stencil) {
-            mRedSize = r;
-            mGreenSize = g;
-            mBlueSize = b;
-            mAlphaSize = a;
-            mDepthSize = depth;
-            mStencilSize = stencil;
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
-
-            int[] num_config = new int[1];
-            egl.eglChooseConfig(display, s_configAttribs2, null, 0, num_config);
-
-            int numConfigs = num_config[0];
-
-            if (numConfigs <= 0) {
-                throw new IllegalArgumentException("No configs match configSpec");
-            }
-            EGLConfig[] configs = new EGLConfig[numConfigs];
-            egl.eglChooseConfig(display, s_configAttribs2, configs, numConfigs, num_config);
-            // printConfigs(egl, display, configs);
-            return chooseConfig(egl, display, configs);
-        }
-
-        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig[] configs) {
-            EGLConfig closestConfig = null;
-            int closestDistance = 1000;
-            for(EGLConfig config : configs) {
-                int d = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_DEPTH_SIZE, 0);
-                int s = findConfigAttrib(egl, display, config,
-                        EGL10.EGL_STENCIL_SIZE, 0);
-                if (d >= mDepthSize && s>= mStencilSize) {
-                    int r = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_RED_SIZE, 0);
-                    int g = findConfigAttrib(egl, display, config,
-                             EGL10.EGL_GREEN_SIZE, 0);
-                    int b = findConfigAttrib(egl, display, config,
-                              EGL10.EGL_BLUE_SIZE, 0);
-                    int a = findConfigAttrib(egl, display, config,
-                            EGL10.EGL_ALPHA_SIZE, 0);
-                    int distance = Math.abs(r - mRedSize)
-                                + Math.abs(g - mGreenSize)
-                                + Math.abs(b - mBlueSize)
-                                + Math.abs(a - mAlphaSize);
-                    if (distance < closestDistance) {
-                        closestDistance = distance;
-                        closestConfig = config;
-                    }
-                }
-            }
-            return closestConfig;
-        }
-
-        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
-                EGLConfig config, int attribute, int defaultValue) {
-
-            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
-                return mValue[0];
-            }
-            return defaultValue;
-        }
-
-        private void printConfigs(EGL10 egl, EGLDisplay display,
-            EGLConfig[] configs) {
-            int numConfigs = configs.length;
-            Log.w(TAG, String.format("%d configurations", numConfigs));
-            for (int i = 0; i < numConfigs; i++) {
-                Log.w(TAG, String.format("Configuration %d:\n", i));
-                printConfig(egl, display, configs[i]);
-            }
-        }
-
-        private void printConfig(EGL10 egl, EGLDisplay display,
-                EGLConfig config) {
-            int[] attributes = {
-                    EGL10.EGL_BUFFER_SIZE,
-                    EGL10.EGL_ALPHA_SIZE,
-                    EGL10.EGL_BLUE_SIZE,
-                    EGL10.EGL_GREEN_SIZE,
-                    EGL10.EGL_RED_SIZE,
-                    EGL10.EGL_DEPTH_SIZE,
-                    EGL10.EGL_STENCIL_SIZE,
-                    EGL10.EGL_CONFIG_CAVEAT,
-                    EGL10.EGL_CONFIG_ID,
-                    EGL10.EGL_LEVEL,
-                    EGL10.EGL_MAX_PBUFFER_HEIGHT,
-                    EGL10.EGL_MAX_PBUFFER_PIXELS,
-                    EGL10.EGL_MAX_PBUFFER_WIDTH,
-                    EGL10.EGL_NATIVE_RENDERABLE,
-                    EGL10.EGL_NATIVE_VISUAL_ID,
-                    EGL10.EGL_NATIVE_VISUAL_TYPE,
-                    0x3030, // EGL10.EGL_PRESERVED_RESOURCES,
-                    EGL10.EGL_SAMPLES,
-                    EGL10.EGL_SAMPLE_BUFFERS,
-                    EGL10.EGL_SURFACE_TYPE,
-                    EGL10.EGL_TRANSPARENT_TYPE,
-                    EGL10.EGL_TRANSPARENT_RED_VALUE,
-                    EGL10.EGL_TRANSPARENT_GREEN_VALUE,
-                    EGL10.EGL_TRANSPARENT_BLUE_VALUE,
-                    0x3039, // EGL10.EGL_BIND_TO_TEXTURE_RGB,
-                    0x303A, // EGL10.EGL_BIND_TO_TEXTURE_RGBA,
-                    0x303B, // EGL10.EGL_MIN_SWAP_INTERVAL,
-                    0x303C, // EGL10.EGL_MAX_SWAP_INTERVAL,
-                    EGL10.EGL_LUMINANCE_SIZE,
-                    EGL10.EGL_ALPHA_MASK_SIZE,
-                    EGL10.EGL_COLOR_BUFFER_TYPE,
-                    EGL10.EGL_RENDERABLE_TYPE,
-                    0x3042 // EGL10.EGL_CONFORMANT
-            };
-            String[] names = {
-                    "EGL_BUFFER_SIZE",
-                    "EGL_ALPHA_SIZE",
-                    "EGL_BLUE_SIZE",
-                    "EGL_GREEN_SIZE",
-                    "EGL_RED_SIZE",
-                    "EGL_DEPTH_SIZE",
-                    "EGL_STENCIL_SIZE",
-                    "EGL_CONFIG_CAVEAT",
-                    "EGL_CONFIG_ID",
-                    "EGL_LEVEL",
-                    "EGL_MAX_PBUFFER_HEIGHT",
-                    "EGL_MAX_PBUFFER_PIXELS",
-                    "EGL_MAX_PBUFFER_WIDTH",
-                    "EGL_NATIVE_RENDERABLE",
-                    "EGL_NATIVE_VISUAL_ID",
-                    "EGL_NATIVE_VISUAL_TYPE",
-                    "EGL_PRESERVED_RESOURCES",
-                    "EGL_SAMPLES",
-                    "EGL_SAMPLE_BUFFERS",
-                    "EGL_SURFACE_TYPE",
-                    "EGL_TRANSPARENT_TYPE",
-                    "EGL_TRANSPARENT_RED_VALUE",
-                    "EGL_TRANSPARENT_GREEN_VALUE",
-                    "EGL_TRANSPARENT_BLUE_VALUE",
-                    "EGL_BIND_TO_TEXTURE_RGB",
-                    "EGL_BIND_TO_TEXTURE_RGBA",
-                    "EGL_MIN_SWAP_INTERVAL",
-                    "EGL_MAX_SWAP_INTERVAL",
-                    "EGL_LUMINANCE_SIZE",
-                    "EGL_ALPHA_MASK_SIZE",
-                    "EGL_COLOR_BUFFER_TYPE",
-                    "EGL_RENDERABLE_TYPE",
-                    "EGL_CONFORMANT"
-            };
-            int[] value = new int[1];
-            for (int i = 0; i < attributes.length; i++) {
-                int attribute = attributes[i];
-                String name = names[i];
-                if ( egl.eglGetConfigAttrib(display, config, attribute, value)) {
-                    Log.w(TAG, String.format("  %s: %d\n", name, value[0]));
-                } else {
-                    // Log.w(TAG, String.format("  %s: failed\n", name));
-                    while (egl.eglGetError() != EGL10.EGL_SUCCESS);
-                }
-            }
-        }
-
-        // Subclasses can adjust these values:
-        protected int mRedSize;
-        protected int mGreenSize;
-        protected int mBlueSize;
-        protected int mAlphaSize;
-        protected int mDepthSize;
-        protected int mStencilSize;
-        private int[] mValue = new int[1];
-    }
-
-    private static class Renderer implements GLSurfaceView.Renderer {
-        public void onDrawFrame(GL10 gl) {
-            GLDualLib.step();
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            GLDualLib.init(width, height);
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            // Do nothing.
-        }
-    }
-}
-
diff --git a/opengl/tests/gldual/src/com/android/gldual/GLDualLib.java b/opengl/tests/gldual/src/com/android/gldual/GLDualLib.java
deleted file mode 100644
index d8f765e495..0000000000
--- a/opengl/tests/gldual/src/com/android/gldual/GLDualLib.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gldual;
-
-// Wrapper for native library
-
-public class GLDualLib {
-
-     static {
-         System.loadLibrary("gldualjni");
-     }
-
-    /**
-     * @param width the current view width
-     * @param height the current view height
-     */
-     public static native void init(int width, int height);
-     public static native void step();
-}
diff --git a/opengl/tests/gldual/src/com/android/gldual/TriangleRenderer.java b/opengl/tests/gldual/src/com/android/gldual/TriangleRenderer.java
deleted file mode 100644
index a082d47462..0000000000
--- a/opengl/tests/gldual/src/com/android/gldual/TriangleRenderer.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.gldual;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-import java.nio.ShortBuffer;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.opengl.GLSurfaceView;
-import android.opengl.GLU;
-import android.os.SystemClock;
-
-public class TriangleRenderer implements GLSurfaceView.Renderer{
-
-    public TriangleRenderer() {
-        mTriangle = new Triangle();
-    }
-
-    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-        /*
-         * By default, OpenGL enables features that improve quality
-         * but reduce performance. One might want to tweak that
-         * especially on software renderer.
-         */
-        gl.glDisable(GL10.GL_DITHER);
-
-        /*
-         * Some one-time OpenGL initialization can be made here
-         * probably based on features of this particular context
-         */
-        gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT,
-                GL10.GL_FASTEST);
-
-        gl.glClearColor(.5f, .5f, .5f, 1);
-        gl.glShadeModel(GL10.GL_SMOOTH);
-    }
-
-    public void onDrawFrame(GL10 gl) {
-        /*
-         * By default, OpenGL enables features that improve quality
-         * but reduce performance. One might want to tweak that
-         * especially on software renderer.
-         */
-        gl.glDisable(GL10.GL_DITHER);
-
-        /*
-         * Usually, the first thing one might want to do is to clear
-         * the screen. The most efficient way of doing this is to use
-         * glClear().
-         */
-
-        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-
-        /*
-         * Now we're ready to draw some 3D objects
-         */
-
-        gl.glMatrixMode(GL10.GL_MODELVIEW);
-        gl.glLoadIdentity();
-
-        GLU.gluLookAt(gl, 0, 0, -5, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
-
-        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
-
-        long time = SystemClock.uptimeMillis() % 4000L;
-        float angle = 0.090f * ((int) time);
-
-        gl.glRotatef(angle, 0, 0, 1.0f);
-
-        mTriangle.draw(gl);
-    }
-
-    public void onSurfaceChanged(GL10 gl, int w, int h) {
-        gl.glViewport(0, 0, w, h);
-
-        /*
-        * Set our projection matrix. This doesn't have to be done
-        * each time we draw, but usually a new projection needs to
-        * be set when the viewport is resized.
-        */
-
-        float ratio = (float) w / h;
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glLoadIdentity();
-        gl.glFrustumf(-ratio, ratio, -1, 1, 3, 7);
-
-    }
-
-    private Triangle mTriangle;
-}
-
-class Triangle {
-    public Triangle() {
-
-        // Buffers to be passed to gl*Pointer() functions
-        // must be direct, i.e., they must be placed on the
-        // native heap where the garbage collector cannot
-        // move them.
-        //
-        // Buffers with multi-byte datatypes (e.g., short, int, float)
-        // must have their byte order set to native order
-
-        ByteBuffer vbb = ByteBuffer.allocateDirect(VERTS * 3 * 4);
-        vbb.order(ByteOrder.nativeOrder());
-        mFVertexBuffer = vbb.asFloatBuffer();
-
-        ByteBuffer tbb = ByteBuffer.allocateDirect(VERTS * 2 * 4);
-        tbb.order(ByteOrder.nativeOrder());
-
-        ByteBuffer ibb = ByteBuffer.allocateDirect(VERTS * 2);
-        ibb.order(ByteOrder.nativeOrder());
-        mIndexBuffer = ibb.asShortBuffer();
-
-        // A unit-sided equalateral triangle centered on the origin.
-        float[] coords = {
-                // X, Y, Z
-                -0.5f, -0.25f, 0,
-                 0.5f, -0.25f, 0,
-                 0.0f,  0.559016994f, 0
-        };
-
-        for (int i = 0; i < VERTS; i++) {
-            for(int j = 0; j < 3; j++) {
-                mFVertexBuffer.put(coords[i*3+j] * 2.0f);
-            }
-        }
-
-        for(int i = 0; i < VERTS; i++) {
-            mIndexBuffer.put((short) i);
-        }
-
-        mFVertexBuffer.position(0);
-        mIndexBuffer.position(0);
-    }
-
-    public void draw(GL10 gl) {
-        gl.glFrontFace(GL10.GL_CCW);
-        gl.glVertexPointer(3, GL10.GL_FLOAT, 0, mFVertexBuffer);
-        gl.glDrawElements(GL10.GL_TRIANGLE_STRIP, VERTS,
-                GL10.GL_UNSIGNED_SHORT, mIndexBuffer);
-    }
-
-    private final static int VERTS = 3;
-
-    private FloatBuffer mFVertexBuffer;
-    private ShortBuffer mIndexBuffer;
-}
diff --git a/opengl/tests/gralloc/Android.bp b/opengl/tests/gralloc/Android.bp
deleted file mode 100644
index 33c3dbaa17..0000000000
--- a/opengl/tests/gralloc/Android.bp
+++ /dev/null
@@ -1,18 +0,0 @@
-cc_test {
-    name: "test-opengl-gralloc",
-
-    srcs: ["gralloc.cpp"],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    gtest: false,
-
-    shared_libs: [
-        "libcutils",
-        "libutils",
-        "libui",
-    ],
-}
diff --git a/opengl/tests/gralloc/gralloc.cpp b/opengl/tests/gralloc/gralloc.cpp
deleted file mode 100644
index 29e0882cd0..0000000000
--- a/opengl/tests/gralloc/gralloc.cpp
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- **
- ** Copyright 2009, The Android Open Source Project
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-#define LOG_TAG "StopWatch"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <utils/StopWatch.h>
-#include <utils/Log.h>
-
-#include <ui/GraphicBuffer.h>
-#include <ui/GraphicBufferMapper.h>
-
-using namespace android;
-
-void* lamecpy(void* d, void const* s, size_t size) {
-    char* dst = (char*)d;
-    char const* src = (char const*)s;
-    while (size) {
-        *dst++ = *src++;
-        size--;
-    }
-    return d;
-}
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    size_t size = 128*256*4;
-    void* temp = malloc(size);
-    void* temp2 = malloc(size);
-    memset(temp, 0, size);
-    memset(temp2, 0, size);
-
-
-    sp<GraphicBuffer> buffer = new GraphicBuffer(128, 256, HAL_PIXEL_FORMAT_RGBA_8888,
-            GRALLOC_USAGE_SW_READ_OFTEN |
-            GRALLOC_USAGE_SW_WRITE_OFTEN);
-
-    status_t err = buffer->initCheck();
-    if (err != NO_ERROR) {
-        printf("%s\n", strerror(-err));
-        return 0;
-    }
-
-    void* vaddr;
-    buffer->lock(
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
-            &vaddr);
-
-    {
-        StopWatch watch("memset");
-        for (int i=0 ; i<10 ; i++)
-            memset(vaddr, 0, size);
-    }
-
-    {
-        StopWatch watch("memcpy baseline");
-        for (int i=0 ; i<10 ; i++)
-            memcpy(temp, temp2, size);
-    }
-
-    {
-        StopWatch watch("memcpy from gralloc");
-        for (int i=0 ; i<10 ; i++)
-            memcpy(temp, vaddr, size);
-    }
-
-    {
-        StopWatch watch("memcpy into gralloc");
-        for (int i=0 ; i<10 ; i++)
-            memcpy(vaddr, temp, size);
-    }
-
-
-    {
-        StopWatch watch("lamecpy baseline");
-        for (int i=0 ; i<10 ; i++)
-            lamecpy(temp, temp2, size);
-    }
-
-    {
-        StopWatch watch("lamecpy from gralloc");
-        for (int i=0 ; i<10 ; i++)
-            lamecpy(temp, vaddr, size);
-    }
-
-    {
-        StopWatch watch("lamecpy into gralloc");
-        for (int i=0 ; i<10 ; i++)
-            lamecpy(vaddr, temp, size);
-    }
-
-    buffer->unlock();
-
-    return 0;
-}
diff --git a/opengl/tests/hwc/Android.bp b/opengl/tests/hwc/Android.bp
deleted file mode 100644
index 55f058f922..0000000000
--- a/opengl/tests/hwc/Android.bp
+++ /dev/null
@@ -1,109 +0,0 @@
-// Copyright (C) 2010 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_defaults {
-
-    name: "hwc_tests_defaults",
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-DEGL_EGLEXT_PROTOTYPES",
-        "-Wall",
-        "-Wextra",
-        "-Werror",
-    ],
-}
-
-cc_library_static {
-
-    name: "libhwcTest",
-    srcs: ["hwcTestLib.cpp"],
-
-    static_libs: [
-        "libarect",
-        "libglTest",
-        "libtestUtil",
-    ],
-    shared_libs: [
-        "libui",
-        "libnativewindow"
-    ],
-    defaults: ["hwc_tests_defaults"],
-}
-
-cc_defaults {
-
-    name: "hwc_lib_defaults",
-    shared_libs: [
-        "libcutils",
-        "libEGL",
-        "libGLESv2",
-        "libhardware",
-        "liblog",
-        "libui",
-        "libutils",
-        "libnativewindow"
-    ],
-
-    gtest: false,
-
-    static_libs: [
-        "libglTest",
-        "libhwcTest",
-        "libtestUtil",
-    ],
-}
-
-cc_test {
-
-    name: "hwcStress",
-    srcs: ["hwcStress.cpp"],
-
-    defaults: [
-        "hwc_lib_defaults",
-        "hwc_tests_defaults",
-    ],
-}
-
-cc_test {
-
-    name: "hwcRects",
-    srcs: ["hwcRects.cpp"],
-
-    defaults: [
-        "hwc_lib_defaults",
-        "hwc_tests_defaults",
-    ],
-}
-
-cc_test {
-
-    name: "hwcColorEquiv",
-    srcs: ["hwcColorEquiv.cpp"],
-
-    defaults: [
-        "hwc_lib_defaults",
-        "hwc_tests_defaults",
-    ],
-}
-
-cc_test {
-
-    name: "hwcCommit",
-    srcs: ["hwcCommit.cpp"],
-
-    defaults: [
-        "hwc_lib_defaults",
-        "hwc_tests_defaults",
-    ],
-}
diff --git a/opengl/tests/hwc/hwcColorEquiv.cpp b/opengl/tests/hwc/hwcColorEquiv.cpp
deleted file mode 100644
index a9bbcb6f5f..0000000000
--- a/opengl/tests/hwc/hwcColorEquiv.cpp
+++ /dev/null
@@ -1,436 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-/*
- * Hardware Composer Color Equivalence
- *
- * Synopsis
- *   hwc_colorequiv [options] eFmt
- *
- *     options:
-         -v - verbose
- *       -s <0.##, 0.##, 0.##> - Start color (default: <0.0, 0.0, 0.0>
- *       -e <0.##, 0.##, 0.##> - Ending color (default: <1.0, 1.0, 1.0>
- *       -r fmt - reference graphic format
- *       -D #.## - End of test delay
- *
- *     graphic formats:
- *       RGBA8888 (reference frame default)
- *       RGBX8888
- *       RGB888
- *       RGB565
- *       BGRA8888
- *       RGBA5551
- *       RGBA4444
- *       YV12
- *
- * Description
- *   Renders a horizontal blend in two frames.  The first frame is rendered
- *   in the upper third of the display and is called the reference frame.
- *   The second frame is displayed in the middle third and is called the
- *   equivalence frame.  The primary purpose of this utility is to verify
- *   that the colors produced in the reference and equivalence frames are
- *   the same.  The colors are the same when the colors are the same
- *   vertically between the reference and equivalence frames.
- *
- *   By default the reference frame is rendered through the use of the
- *   RGBA8888 graphic format.  The -r option can be used to specify a
- *   non-default reference frame graphic format.  The graphic format of
- *   the equivalence frame is determined by a single required positional
- *   parameter.  Intentionally there is no default for the graphic format
- *   of the equivalence frame.
- *
- *   The horizontal blend in the reference frame is produced from a linear
- *   interpolation from a start color (default: <0.0, 0.0, 0.0> on the left
- *   side to an end color (default <1.0, 1.0, 1.0> on the right side.  Where
- *   possible the equivalence frame is rendered with the equivalent color
- *   from the reference frame.  A color of black is used in the equivalence
- *   frame for cases where an equivalent color does not exist.
- */
-
-#define LOG_TAG "hwcColorEquivTest"
-
-#include <algorithm>
-#include <assert.h>
-#include <cerrno>
-#include <cmath>
-#include <cstdlib>
-#include <ctime>
-#include <libgen.h>
-#include <sched.h>
-#include <sstream>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <vector>
-
-#include <sys/syscall.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <utils/Log.h>
-#include <testUtil.h>
-
-#include <hardware/hwcomposer.h>
-
-#include "hwcTestLib.h"
-
-using namespace std;
-using namespace android;
-
-// Defaults for command-line options
-const bool defaultVerbose = false;
-const ColorFract defaultStartColor(0.0, 0.0, 0.0);
-const ColorFract defaultEndColor(1.0, 1.0, 1.0);
-const char *defaultRefFormat = "RGBA8888";
-const float defaultEndDelay = 2.0; // Default delay after rendering graphics
-
-// Defines
-#define MAXSTR               100
-#define MAXCMD               200
-#define BITSPERBYTE            8 // TODO: Obtain from <values.h>, once
-                                 // it has been added
-
-#define CMD_STOP_FRAMEWORK   "stop 2>&1"
-#define CMD_START_FRAMEWORK  "start 2>&1"
-
-// Macros
-#define NUMA(a) (sizeof(a) / sizeof((a)[0])) // Num elements in an array
-#define MEMCLR(addr, size) do { \
-        memset((addr), 0, (size)); \
-    } while (0)
-
-// Globals
-static const int texUsage = GraphicBuffer::USAGE_HW_TEXTURE |
-        GraphicBuffer::USAGE_SW_WRITE_RARELY;
-static hwc_composer_device_1_t *hwcDevice;
-static EGLDisplay dpy;
-static EGLSurface surface;
-static EGLint width, height;
-
-// Functions prototypes
-void init(void);
-void printSyntax(const char *cmd);
-
-// Command-line option settings
-static bool verbose = defaultVerbose;
-static ColorFract startRefColor = defaultStartColor;
-static ColorFract endRefColor = defaultEndColor;
-static float endDelay = defaultEndDelay;
-static const struct hwcTestGraphicFormat *refFormat
-    = hwcTestGraphicFormatLookup(defaultRefFormat);
-static const struct hwcTestGraphicFormat *equivFormat;
-
-/*
- * Main
- *
- * Performs the following high-level sequence of operations:
- *
- *   1. Command-line parsing
- *
- *   2. Stop framework
- *
- *   3. Initialization
- *
- *   4. Create Hardware Composer description of reference and equivalence frames
- *
- *   5. Have Hardware Composer render the reference and equivalence frames
- *
- *   6. Delay for amount of time given by endDelay
- *
- *   7. Start framework
- */
-int
-main(int argc, char *argv[])
-{
-    int rv, opt;
-    bool error;
-    char *chptr;
-    char cmd[MAXCMD];
-    string str;
-
-    testSetLogCatTag(LOG_TAG);
-
-    assert(refFormat != NULL);
-
-    testSetLogCatTag(LOG_TAG);
-
-    // Parse command line arguments
-    while ((opt = getopt(argc, argv, "vs:e:r:D:?h")) != -1) {
-        switch (opt) {
-          case 'D': // End of test delay
-                    // Delay between completion of final pass and restart
-                    // of framework
-            endDelay = strtod(optarg, &chptr);
-            if ((*chptr != '\0') || (endDelay < 0.0)) {
-                testPrintE("Invalid command-line specified end of test delay "
-                           "of: %s", optarg);
-                exit(1);
-            }
-            break;
-
-          case 's': // Starting reference color
-            str = optarg;
-            while (optind < argc) {
-                if (*argv[optind] == '-') { break; }
-                char endChar = (str.length() > 1) ? str[str.length() - 1] : 0;
-                if ((endChar == '>') || (endChar == ']')) { break; }
-                str += " " + string(argv[optind++]);
-            }
-            {
-                istringstream in(str);
-                startRefColor = hwcTestParseColor(in, error);
-                // Any parse error or characters not used by parser
-                if (error
-                    || (((unsigned int) in.tellg() != in.str().length())
-                        && (in.tellg() != (streampos) -1))) {
-                    testPrintE("Invalid command-line specified start "
-                               "reference color of: %s", str.c_str());
-                    exit(2);
-                }
-            }
-            break;
-
-          case 'e': // Ending reference color
-            str = optarg;
-            while (optind < argc) {
-                if (*argv[optind] == '-') { break; }
-                char endChar = (str.length() > 1) ? str[str.length() - 1] : 0;
-                if ((endChar == '>') || (endChar == ']')) { break; }
-                str += " " + string(argv[optind++]);
-            }
-            {
-                istringstream in(str);
-                endRefColor = hwcTestParseColor(in, error);
-                // Any parse error or characters not used by parser
-                if (error
-                    || (((unsigned int) in.tellg() != in.str().length())
-                        && (in.tellg() != (streampos) -1))) {
-                    testPrintE("Invalid command-line specified end "
-                               "reference color of: %s", str.c_str());
-                    exit(3);
-                }
-            }
-            break;
-
-          case 'r': // Reference graphic format
-            refFormat = hwcTestGraphicFormatLookup(optarg);
-            if (refFormat == NULL) {
-                testPrintE("Unkown command-line specified reference graphic "
-                           "format of: %s", optarg);
-                printSyntax(basename(argv[0]));
-                exit(4);
-            }
-            break;
-
-          case 'v': // Verbose
-            verbose = true;
-            break;
-
-          case 'h': // Help
-          case '?':
-          default:
-            printSyntax(basename(argv[0]));
-            exit(((optopt == 0) || (optopt == '?')) ? 0 : 5);
-        }
-    }
-
-    // Expect a single positional parameter, which specifies the
-    // equivalence graphic format.
-    if (argc != (optind + 1)) {
-        testPrintE("Expected a single command-line postional parameter");
-        printSyntax(basename(argv[0]));
-        exit(6);
-    }
-    equivFormat = hwcTestGraphicFormatLookup(argv[optind]);
-    if (equivFormat == NULL) {
-        testPrintE("Unkown command-line specified equivalence graphic "
-                   "format of: %s", argv[optind]);
-        printSyntax(basename(argv[0]));
-        exit(7);
-    }
-
-    testPrintI("refFormat: %u %s", refFormat->format, refFormat->desc);
-    testPrintI("equivFormat: %u %s", equivFormat->format, equivFormat->desc);
-    testPrintI("startRefColor: %s", ((string) startRefColor).c_str());
-    testPrintI("endRefColor: %s", ((string) endRefColor).c_str());
-    testPrintI("endDelay: %f", endDelay);
-
-    // Stop framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_STOP_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_STOP_FRAMEWORK);
-        exit(8);
-    }
-    testExecCmd(cmd);
-    testDelay(1.0); // TODO - needs means to query whether asynchronous stop
-                    // framework operation has completed.  For now, just wait
-                    // a long time.
-
-    init();
-
-    // Use the upper third of the display for the reference frame and
-    // the middle third for the equivalence frame.
-    unsigned int refHeight = height / 3;
-    unsigned int refPosX = 0; // Reference frame X position
-    unsigned int refWidth = width - refPosX;
-    if ((refWidth & refFormat->wMod) != 0) {
-        refWidth += refFormat->wMod - (refWidth % refFormat->wMod);
-    }
-    unsigned int equivHeight = height / 3;
-    unsigned int equivPosX = 0;         // Equivalence frame X position
-    unsigned int equivWidth = width - equivPosX;
-    if ((equivWidth & equivFormat->wMod) != 0) {
-        equivWidth += equivFormat->wMod - (equivWidth % equivFormat->wMod);
-    }
-
-    // Create reference and equivalence graphic buffers
-    const unsigned int numFrames = 2;
-    sp<GraphicBuffer> refFrame;
-    refFrame = new GraphicBuffer(refWidth, refHeight,
-                                 refFormat->format, texUsage);
-    if ((rv = refFrame->initCheck()) != NO_ERROR) {
-        testPrintE("refFrame initCheck failed, rv: %i", rv);
-        testPrintE("  width %u height: %u format: %u %s", refWidth, refHeight,
-                   refFormat->format,
-                   hwcTestGraphicFormat2str(refFormat->format));
-        exit(9);
-    }
-    testPrintI("refFrame width: %u height: %u format: %u %s",
-               refWidth, refHeight, refFormat->format,
-               hwcTestGraphicFormat2str(refFormat->format));
-
-    sp<GraphicBuffer> equivFrame;
-    equivFrame = new GraphicBuffer(equivWidth, equivHeight,
-                                   equivFormat->format, texUsage);
-    if ((rv = refFrame->initCheck()) != NO_ERROR) {
-        testPrintE("refFrame initCheck failed, rv: %i", rv);
-        testPrintE("  width %u height: %u format: %u %s", refWidth, refHeight,
-                   refFormat->format,
-                   hwcTestGraphicFormat2str(refFormat->format));
-        exit(10);
-    }
-    testPrintI("equivFrame width: %u height: %u format: %u %s",
-               equivWidth, equivHeight, equivFormat->format,
-               hwcTestGraphicFormat2str(equivFormat->format));
-
-    // Fill the frames with a horizontal blend
-    hwcTestFillColorHBlend(refFrame.get(), refFormat->format,
-                           startRefColor, endRefColor);
-    hwcTestFillColorHBlend(equivFrame.get(), refFormat->format,
-                           startRefColor, endRefColor);
-
-    hwc_display_contents_1_t *list;
-    size_t size = sizeof(hwc_display_contents_1_t) + numFrames * sizeof(hwc_layer_1_t);
-    if ((list = (hwc_display_contents_1_t *) calloc(1, size)) == NULL) {
-        testPrintE("Allocate list failed");
-        exit(11);
-    }
-    list->flags = HWC_GEOMETRY_CHANGED;
-    list->numHwLayers = numFrames;
-
-    hwc_layer_1_t *layer = &list->hwLayers[0];
-    layer->handle = refFrame->handle;
-    layer->blending = HWC_BLENDING_NONE;
-    layer->sourceCrop.left = 0;
-    layer->sourceCrop.top = 0;
-    layer->sourceCrop.right = width;
-    layer->sourceCrop.bottom = refHeight;
-    layer->displayFrame.left = 0;
-    layer->displayFrame.top = 0;
-    layer->displayFrame.right = width;
-    layer->displayFrame.bottom = refHeight;
-    layer->visibleRegionScreen.numRects = 1;
-    layer->visibleRegionScreen.rects = &layer->displayFrame;
-
-    layer++;
-    layer->handle = equivFrame->handle;
-    layer->blending = HWC_BLENDING_NONE;
-    layer->sourceCrop.left = 0;
-    layer->sourceCrop.top = 0;
-    layer->sourceCrop.right = width;
-    layer->sourceCrop.bottom = equivHeight;
-    layer->displayFrame.left = 0;
-    layer->displayFrame.top = refHeight;
-    layer->displayFrame.right = width;
-    layer->displayFrame.bottom = layer->displayFrame.top + equivHeight;
-    layer->visibleRegionScreen.numRects = 1;
-    layer->visibleRegionScreen.rects = &layer->displayFrame;
-
-    // Perform prepare operation
-    if (verbose) { testPrintI("Prepare:"); hwcTestDisplayList(list); }
-    hwcDevice->prepare(hwcDevice, 1, &list);
-    if (verbose) {
-        testPrintI("Post Prepare:");
-        hwcTestDisplayListPrepareModifiable(list);
-    }
-
-    // Turn off the geometry changed flag
-    list->flags &= ~HWC_GEOMETRY_CHANGED;
-
-    if (verbose) {hwcTestDisplayListHandles(list); }
-    list->dpy = dpy;
-    list->sur = surface;
-    hwcDevice->set(hwcDevice, 1, &list);
-
-    testDelay(endDelay);
-
-    // Start framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_START_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_START_FRAMEWORK);
-        exit(12);
-    }
-    testExecCmd(cmd);
-
-    return 0;
-}
-
-void init(void)
-{
-    // Seed pseudo random number generator
-    // Seeding causes fill horizontal blend to fill the pad area with
-    // a deterministic set of values.
-    srand48(0);
-
-    hwcTestInitDisplay(verbose, &dpy, &surface, &width, &height);
-
-    hwcTestOpenHwc(&hwcDevice);
-}
-
-void printSyntax(const char *cmd)
-{
-    testPrintE("  %s [options] graphicFormat", cmd);
-    testPrintE("    options:");
-    testPrintE("      -s <0.##, 0.##, 0.##> - Starting reference color");
-    testPrintE("      -e <0.##, 0.##, 0.##> - Ending reference color");
-    testPrintE("      -r format - Reference graphic format");
-    testPrintE("      -D #.## - End of test delay");
-    testPrintE("      -v Verbose");
-    testPrintE("");
-    testPrintE("    graphic formats:");
-    for (unsigned int n1 = 0; n1 < NUMA(hwcTestGraphicFormat); n1++) {
-        testPrintE("      %s", hwcTestGraphicFormat[n1].desc);
-    }
-}
diff --git a/opengl/tests/hwc/hwcCommit.cpp b/opengl/tests/hwc/hwcCommit.cpp
deleted file mode 100644
index 3686dab654..0000000000
--- a/opengl/tests/hwc/hwcCommit.cpp
+++ /dev/null
@@ -1,1558 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-/*
- * Hardware Composer Commit Points
- *
- * Synopsis
- *   hwcCommit [options] graphicFormat ...
- *     options:
- *       -s [width, height] - Starting dimension
- *       -v - Verbose
- *
- *      graphic formats:
- *        RGBA8888 (reference frame default)
- *        RGBX8888
- *        RGB888
- *        RGB565
- *        BGRA8888
- *        RGBA5551
- *        RGBA4444
- *        YV12
- *
- * Description
- *   The Hardware Composer (HWC) Commit test is a benchmark that
- *   discovers the points at which the HWC will commit to rendering an
- *   overlay(s).  Before rendering a set of overlays, the HWC is shown
- *   the list through a prepare call.  During the prepare call the HWC
- *   is able to examine the list and specify which overlays it is able
- *   to handle.  The overlays that it can't handle are typically composited
- *   by a higher level (e.g. Surface Flinger) and then the original list
- *   plus a composit of what HWC passed on are provided back to the HWC
- *   for rendering.
- *
- *   Once an implementation of the HWC has been shipped, a regression would
- *   likely occur if a latter implementation started passing on conditions
- *   that it used to commit to.  The primary purpose of this benchmark
- *   is the automated discovery of the commit points, where an implementation
- *   is on the edge between committing and not committing.  These are commonly
- *   referred to as commit points.  Between implementations changes to the
- *   commit points are allowed, as long as they improve what the HWC commits
- *   to.  Once an implementation of the HWC is shipped, the commit points are
- *   not allowed to regress in future implementations.
- *
- *   This benchmark takes a sampling and then adjusts until it finds a
- *   commit point.  It doesn't exhaustively check all possible conditions,
- *   which do to the number of combinations would be impossible.  Instead
- *   it starts its search from a starting dimension, that can be changed
- *   via the -s option.  The search is also bounded by a set of search
- *   limits, that are hard-coded into a structure of constants named
- *   searchLimits.  Results that happen to reach a searchLimit are prefixed
- *   with >=, so that it is known that the value could possibly be larger.
- *
- *   Measurements are made for each of the graphic formats specified as
- *   positional parameters on the command-line.  If no graphic formats
- *   are specified on the command line, then by default measurements are
- *   made and reported for each of the known graphic format.
- */
-
-#define LOG_TAG "hwcCommitTest"
-
-#include <algorithm>
-#include <assert.h>
-#include <cerrno>
-#include <cmath>
-#include <cstdlib>
-#include <ctime>
-#include <iomanip>
-#include <istream>
-#include <libgen.h>
-#include <list>
-#include <sched.h>
-#include <sstream>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <vector>
-
-#include <sys/syscall.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <utils/Log.h>
-#include <testUtil.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <glTestLib.h>
-#include "hwcTestLib.h"
-
-using namespace std;
-using namespace android;
-
-// Defaults
-const HwcTestDim defaultStartDim = HwcTestDim(100, 100);
-const bool defaultVerbose = false;
-
-const uint32_t   defaultFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-const int32_t    defaultTransform = 0;
-const uint32_t   defaultBlend = HWC_BLENDING_NONE;
-const ColorFract defaultColor(0.5, 0.5, 0.5);
-const float      defaultAlpha = 1.0; // Opaque
-const HwcTestDim defaultSourceDim(1, 1);
-
-// Global Constants
-const uint32_t printFieldWidth = 2;
-const struct searchLimits {
-    uint32_t   numOverlays;
-    HwcTestDim sourceCrop;
-} searchLimits = {
-    10,
-    HwcTestDim(3000, 2000),
-};
-const struct transformType {
-    const char *desc;
-    uint32_t id;
-} transformType[] = {
-    {"fliph",  HWC_TRANSFORM_FLIP_H},
-    {"flipv",  HWC_TRANSFORM_FLIP_V},
-    {"rot90",  HWC_TRANSFORM_ROT_90},
-    {"rot180", HWC_TRANSFORM_ROT_180},
-    {"rot270", HWC_TRANSFORM_ROT_270},
-};
-const struct blendType {
-    const char *desc;
-    uint32_t id;
-} blendType[] = {
-    {"none", HWC_BLENDING_NONE},
-    {"premult", HWC_BLENDING_PREMULT},
-    {"coverage", HWC_BLENDING_COVERAGE},
-};
-
-// Defines
-#define MAXCMD               200
-#define CMD_STOP_FRAMEWORK   "stop 2>&1"
-#define CMD_START_FRAMEWORK  "start 2>&1"
-
-// Macros
-#define NUMA(a) (sizeof(a) / sizeof((a)[0])) // Num elements in an array
-
-// Local types
-class Rectangle {
-public:
-    explicit Rectangle(uint32_t graphicFormat = defaultFormat,
-              HwcTestDim dfDim = HwcTestDim(1, 1),
-              HwcTestDim sDim = HwcTestDim(1, 1));
-    void setSourceDim(HwcTestDim dim);
-
-    uint32_t     format;
-    uint32_t     transform;
-    int32_t      blend;
-    ColorFract   color;
-    float        alpha;
-    HwcTestDim   sourceDim;
-    struct hwc_rect   sourceCrop;
-    struct hwc_rect   displayFrame;
-};
-
-class Range {
-public:
-    Range(void) : _l(0), _u(0) {}
-    Range(uint32_t lower, uint32_t upper) : _l(lower), _u(upper) {}
-    uint32_t lower(void) { return _l; }
-    uint32_t upper(void) { return _u; }
-
-    operator string();
-
-private:
-    uint32_t _l; // lower
-    uint32_t _u; // upper
-};
-
-Range::operator string()
-{
-    ostringstream out;
-
-    out << '[' << _l << ", " << _u << ']';
-
-    return out.str();
-}
-
-class Rational {
-public:
-    Rational(void) : _n(0), _d(1) {}
-    Rational(uint32_t n, uint32_t d) : _n(n), _d(d) {}
-    uint32_t numerator(void) { return _n; }
-    uint32_t denominator(void) { return _d; }
-    void setNumerator(uint32_t numerator) { _n = numerator; }
-
-    bool operator==(const Rational& other) const;
-    bool operator!=(const Rational& other) const { return !(*this == other); }
-    bool operator<(const Rational& other) const;
-    bool operator>(const Rational& other) const {
-        return (!(*this == other) && !(*this < other));
-    }
-    static void double2Rational(double f, Range nRange, Range dRange,
-                               Rational& lower, Rational& upper);
-        
-    operator string() const;
-    operator double() const { return (double) _n / (double) _d; }
-
-
-private:
-    uint32_t _n;
-    uint32_t _d;
-};
-
-// Globals
-static const int texUsage = GraphicBuffer::USAGE_HW_TEXTURE |
-        GraphicBuffer::USAGE_SW_WRITE_RARELY;
-static hwc_composer_device_1_t *hwcDevice;
-static EGLDisplay dpy;
-static EGLSurface surface;
-static EGLint width, height;
-static size_t maxHeadingLen;
-static vector<string> formats;
-
-// Measurements
-struct meas {
-    uint32_t format;
-    uint32_t startDimOverlays;
-    uint32_t maxNonOverlapping;
-    uint32_t maxOverlapping;
-    list<uint32_t> transforms;
-    list<uint32_t> blends;
-    struct displayFrame {
-        uint32_t minWidth;
-        uint32_t minHeight;
-        HwcTestDim minDim;
-        uint32_t maxWidth;
-        uint32_t maxHeight;
-        HwcTestDim maxDim;
-    } df;
-    struct sourceCrop {
-        uint32_t minWidth;
-        uint32_t minHeight;
-        HwcTestDim minDim;
-        uint32_t maxWidth;
-        uint32_t maxHeight;
-        HwcTestDim maxDim;
-        Rational hScale;
-        HwcTestDim hScaleBestDf;
-        HwcTestDim hScaleBestSc;
-        Rational vScale;
-        HwcTestDim vScaleBestDf;
-        HwcTestDim vScaleBestSc;
-    } sc;
-    vector<uint32_t> overlapBlendNone;
-    vector<uint32_t> overlapBlendPremult;
-    vector<uint32_t> overlapBlendCoverage;
-};
-vector<meas> measurements;
-
-// Function prototypes
-uint32_t numOverlays(list<Rectangle>& rectList);
-uint32_t maxOverlays(uint32_t format, bool allowOverlap);
-list<uint32_t> supportedTransforms(uint32_t format);
-list<uint32_t> supportedBlends(uint32_t format);
-uint32_t dfMinWidth(uint32_t format);
-uint32_t dfMinHeight(uint32_t format);
-uint32_t dfMaxWidth(uint32_t format);
-uint32_t dfMaxHeight(uint32_t format);
-HwcTestDim dfMinDim(uint32_t format);
-HwcTestDim dfMaxDim(uint32_t format);
-uint32_t scMinWidth(uint32_t format, const HwcTestDim& dfDim);
-uint32_t scMinHeight(uint32_t format, const HwcTestDim& dfDim);
-uint32_t scMaxWidth(uint32_t format, const HwcTestDim& dfDim);
-uint32_t scMaxHeight(uint32_t format, const HwcTestDim& dfDim);
-HwcTestDim scMinDim(uint32_t format, const HwcTestDim& dfDim);
-HwcTestDim scMaxDim(uint32_t format, const HwcTestDim& dfDim);
-Rational scHScale(uint32_t format,
-                  const HwcTestDim& dfMin, const HwcTestDim& dfMax,
-                  const HwcTestDim& scMin, const HwcTestDim& scMax,
-                  HwcTestDim& outBestDf, HwcTestDim& outBestSc);
-Rational scVScale(uint32_t format,
-                  const HwcTestDim& dfMin, const HwcTestDim& dfMax,
-                  const HwcTestDim& scMin, const HwcTestDim& scMax,
-                  HwcTestDim& outBestDf, HwcTestDim& outBestSc);
-uint32_t numOverlapping(uint32_t backgroundFormat, uint32_t foregroundFormat,
-                        uint32_t backgroundBlend, uint32_t foregroundBlend);
-string transformList2str(const list<uint32_t>& transformList);
-string blendList2str(const list<uint32_t>& blendList);
-void init(void);
-void printFormatHeadings(size_t indent);
-void printOverlapLine(size_t indent, const string formatStr,
-                      const vector<uint32_t>& results);
-void printSyntax(const char *cmd);
-
-// Command-line option settings
-static bool verbose = defaultVerbose;
-static HwcTestDim startDim = defaultStartDim;
-
-/*
- * Main
- *
- * Performs the following high-level sequence of operations:
- *
- *   1. Command-line parsing
- *
- *   2. Form a list of command-line specified graphic formats.  If
- *      no formats are specified, then form a list of all known formats.
- *
- *   3. Stop framework
- *      Only one user at a time is allowed to use the HWC.  Surface
- *      Flinger uses the HWC and is part of the framework.  Need to
- *      stop the framework so that Surface Flinger will stop using
- *      the HWC.
- *   
- *   4. Initialization
- *
- *   5. For each graphic format in the previously formed list perform
- *      measurements on that format and report the results.
- *
- *   6. Start framework
- */
-int
-main(int argc, char *argv[])
-{
-    int     rv, opt;
-    bool    error;
-    string  str;
-    char cmd[MAXCMD];
-    list<Rectangle> rectList;
-
-    testSetLogCatTag(LOG_TAG);
-
-    // Parse command line arguments
-    while ((opt = getopt(argc, argv, "s:v?h")) != -1) {
-        switch (opt) {
-
-          case 's': // Start Dimension
-            // Use arguments until next starts with a dash
-            // or current ends with a > or ]
-            str = optarg;
-            while (optind < argc) {
-                if (*argv[optind] == '-') { break; }
-                char endChar = (str.length() > 1) ? str[str.length() - 1] : 0;
-                if ((endChar == '>') || (endChar == ']')) { break; }
-                str += " " + string(argv[optind++]);
-            }
-            {
-                istringstream in(str);
-                startDim = hwcTestParseDim(in, error);
-                // Any parse error or characters not used by parser
-                if (error
-                    || (((unsigned int) in.tellg() != in.str().length())
-                        && (in.tellg() != (streampos) -1))) {
-                    testPrintE("Invalid command-line specified start "
-                               "dimension of: %s", str.c_str());
-                    exit(8);
-                }
-            }
-            break;
-
-          case 'v': // Verbose
-            verbose = true;
-            break;
-
-          case 'h': // Help
-          case '?':
-          default:
-            printSyntax(basename(argv[0]));
-            exit(((optopt == 0) || (optopt == '?')) ? 0 : 11);
-        }
-    }
-
-    // Positional parameters
-    // Positional parameters provide the names of graphic formats that
-    // measurements are to be made on.  Measurements are made on all
-    // known graphic formats when no positional parameters are provided.
-    if (optind == argc) {
-        // No command-line specified graphic formats
-        // Add all graphic formats to the list of formats to be measured
-        for (unsigned int n1 = 0; n1 < NUMA(hwcTestGraphicFormat); n1++) {
-            formats.push_back(hwcTestGraphicFormat[n1].desc);
-        }
-    } else {
-        // Add names of command-line specified graphic formats to the
-        // list of formats to be tested
-        for (; argv[optind] != NULL; optind++) {
-            formats.push_back(argv[optind]);
-        }
-    }
-
-    // Determine length of longest specified graphic format.
-    // This value is used for output formating
-    for (vector<string>::iterator it = formats.begin();
-         it != formats.end(); ++it) {
-         maxHeadingLen = max(maxHeadingLen, it->length());
-    }
-
-    // Stop framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_STOP_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_STOP_FRAMEWORK);
-        exit(14);
-    }
-    testExecCmd(cmd);
-    testDelay(1.0); // TODO - needs means to query whether asynchronous stop
-                    // framework operation has completed.  For now, just wait
-                    // a long time.
-
-    testPrintI("startDim: %s", ((string) startDim).c_str());
-
-    init();
-
-    // For each of the graphic formats
-    for (vector<string>::iterator itFormat = formats.begin();
-         itFormat != formats.end(); ++itFormat) {
-
-        // Locate hwcTestLib structure that describes this format
-        const struct hwcTestGraphicFormat *format;
-        format = hwcTestGraphicFormatLookup((*itFormat).c_str());
-        if (format == NULL) {
-            testPrintE("Unknown graphic format of: %s", (*itFormat).c_str());
-            exit(1);
-        }
-
-        // Display format header
-        testPrintI("format: %s", format->desc);
-
-        // Create area to hold the measurements
-        struct meas meas;
-        struct meas *measPtr;
-        meas.format = format->format;
-        measurements.push_back(meas);
-        measPtr = &measurements[measurements.size() - 1];
-
-        // Start dimension num overlays
-        Rectangle rect(format->format, startDim);
-        rectList.clear();
-        rectList.push_back(rect);
-        measPtr->startDimOverlays = numOverlays(rectList);
-        testPrintI("  startDimOverlays: %u", measPtr->startDimOverlays);
-
-        // Skip the rest of the measurements, when the start dimension
-        // doesn't produce an overlay
-        if (measPtr->startDimOverlays == 0) { continue; }
-
-        // Max Overlays
-        measPtr->maxNonOverlapping = maxOverlays(format->format, false);
-        testPrintI("  max nonOverlapping overlays: %s%u",
-                   (measPtr->maxNonOverlapping == searchLimits.numOverlays)
-                       ? ">= " : "",
-                   measPtr->maxNonOverlapping);
-        measPtr->maxOverlapping = maxOverlays(format->format, true);
-        testPrintI("  max Overlapping overlays: %s%u",
-                   (measPtr->maxOverlapping == searchLimits.numOverlays)
-                       ? ">= " : "",
-                   measPtr->maxOverlapping);
-
-        // Transforms and blends
-        measPtr->transforms = supportedTransforms(format->format);
-        testPrintI("  transforms: %s",
-                   transformList2str(measPtr->transforms).c_str());
-        measPtr->blends = supportedBlends(format->format);
-        testPrintI("  blends: %s",
-                   blendList2str(measPtr->blends).c_str());
-
-        // Display frame measurements
-        measPtr->df.minWidth = dfMinWidth(format->format);
-        testPrintI("  dfMinWidth: %u", measPtr->df.minWidth);
-
-        measPtr->df.minHeight = dfMinHeight(format->format);
-        testPrintI("  dfMinHeight: %u", measPtr->df.minHeight);
-
-        measPtr->df.maxWidth = dfMaxWidth(format->format);
-        testPrintI("  dfMaxWidth: %u", measPtr->df.maxWidth);
-
-        measPtr->df.maxHeight = dfMaxHeight(format->format);
-        testPrintI("  dfMaxHeight: %u", measPtr->df.maxHeight);
-
-        measPtr->df.minDim = dfMinDim(format->format);
-        testPrintI("  dfMinDim: %s", ((string) measPtr->df.minDim).c_str());
-
-        measPtr->df.maxDim = dfMaxDim(format->format);
-        testPrintI("  dfMaxDim: %s", ((string) measPtr->df.maxDim).c_str());
-
-        // Source crop measurements
-        measPtr->sc.minWidth = scMinWidth(format->format, measPtr->df.minDim);
-        testPrintI("  scMinWidth: %u", measPtr->sc.minWidth);
-
-        measPtr->sc.minHeight = scMinHeight(format->format, measPtr->df.minDim);
-        testPrintI("  scMinHeight: %u", measPtr->sc.minHeight);
-
-        measPtr->sc.maxWidth = scMaxWidth(format->format, measPtr->df.maxDim);
-        testPrintI("  scMaxWidth: %s%u", (measPtr->sc.maxWidth
-                   == searchLimits.sourceCrop.width()) ? ">= " : "",
-                   measPtr->sc.maxWidth);
-
-        measPtr->sc.maxHeight = scMaxHeight(format->format, measPtr->df.maxDim);
-        testPrintI("  scMaxHeight: %s%u", (measPtr->sc.maxHeight
-                   == searchLimits.sourceCrop.height()) ? ">= " : "",
-                   measPtr->sc.maxHeight);
-
-        measPtr->sc.minDim = scMinDim(format->format, measPtr->df.minDim);
-        testPrintI("  scMinDim: %s", ((string) measPtr->sc.minDim).c_str());
-
-        measPtr->sc.maxDim = scMaxDim(format->format, measPtr->df.maxDim);
-        testPrintI("  scMaxDim: %s%s", ((measPtr->sc.maxDim.width()
-                         >= searchLimits.sourceCrop.width())
-                         || (measPtr->sc.maxDim.width() >=
-                         searchLimits.sourceCrop.height())) ? ">= " : "",
-                   ((string) measPtr->sc.maxDim).c_str());
-
-        measPtr->sc.hScale = scHScale(format->format,
-                                      measPtr->df.minDim, measPtr->df.maxDim,
-                                      measPtr->sc.minDim, measPtr->sc.maxDim,
-                                      measPtr->sc.hScaleBestDf,
-                                      measPtr->sc.hScaleBestSc);
-        testPrintI("  scHScale: %s%f",
-                   (measPtr->sc.hScale
-                       >= Rational(searchLimits.sourceCrop.width(),
-                                   measPtr->df.minDim.width())) ? ">= " : "",
-                   (double) measPtr->sc.hScale);
-        testPrintI("    HScale Best Display Frame: %s",
-                   ((string) measPtr->sc.hScaleBestDf).c_str());
-        testPrintI("    HScale Best Source Crop: %s",
-                   ((string) measPtr->sc.hScaleBestSc).c_str());
-
-        measPtr->sc.vScale = scVScale(format->format,
-                                      measPtr->df.minDim, measPtr->df.maxDim,
-                                      measPtr->sc.minDim, measPtr->sc.maxDim,
-                                      measPtr->sc.vScaleBestDf,
-                                      measPtr->sc.vScaleBestSc);
-        testPrintI("  scVScale: %s%f",
-                   (measPtr->sc.vScale
-                       >= Rational(searchLimits.sourceCrop.height(),
-                                   measPtr->df.minDim.height())) ? ">= " : "",
-                   (double) measPtr->sc.vScale);
-        testPrintI("    VScale Best Display Frame: %s",
-                   ((string) measPtr->sc.vScaleBestDf).c_str());
-        testPrintI("    VScale Best Source Crop: %s",
-                   ((string) measPtr->sc.vScaleBestSc).c_str());
-
-        // Overlap two graphic formats and different blends
-        // Results displayed after all overlap measurments with
-        // current format in the foreground
-        // TODO: make measurments with background blend other than
-        //       none.  All of these measurements are done with a
-        //       background blend of HWC_BLENDING_NONE, with the
-        //       blend type of the foregound being varied.
-        uint32_t foregroundFormat = format->format;
-        for (vector<string>::iterator it = formats.begin();
-             it != formats.end(); ++it) {
-            uint32_t num;
-
-            const struct hwcTestGraphicFormat *backgroundFormatPtr
-                = hwcTestGraphicFormatLookup((*it).c_str());
-            uint32_t backgroundFormat = backgroundFormatPtr->format;
-
-            num = numOverlapping(backgroundFormat, foregroundFormat,
-                                 HWC_BLENDING_NONE, HWC_BLENDING_NONE);
-            measPtr->overlapBlendNone.push_back(num);
-
-            num = numOverlapping(backgroundFormat, foregroundFormat,
-                                 HWC_BLENDING_NONE, HWC_BLENDING_PREMULT);
-            measPtr->overlapBlendPremult.push_back(num);
-
-            num = numOverlapping(backgroundFormat, foregroundFormat,
-                                 HWC_BLENDING_NONE, HWC_BLENDING_COVERAGE);
-            measPtr->overlapBlendCoverage.push_back(num);
-        }
-
-    }
-
-    // Display overlap results
-    size_t indent = 2;
-    testPrintI("overlapping blend: none");
-    printFormatHeadings(indent);
-    for (vector<string>::iterator it = formats.begin();
-         it != formats.end(); ++it) {
-        printOverlapLine(indent, *it, measurements[it
-                         - formats.begin()].overlapBlendNone);
-    }
-    testPrintI("");
-
-    testPrintI("overlapping blend: premult");
-    printFormatHeadings(indent);
-    for (vector<string>::iterator it = formats.begin();
-         it != formats.end(); ++it) {
-        printOverlapLine(indent, *it, measurements[it
-                         - formats.begin()].overlapBlendPremult);
-    }
-    testPrintI("");
-
-    testPrintI("overlapping blend: coverage");
-    printFormatHeadings(indent);
-    for (vector<string>::iterator it = formats.begin();
-         it != formats.end(); ++it) {
-        printOverlapLine(indent, *it, measurements[it
-                         - formats.begin()].overlapBlendCoverage);
-    }
-    testPrintI("");
-
-    // Start framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_START_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_START_FRAMEWORK);
-        exit(21);
-    }
-    testExecCmd(cmd);
-
-    return 0;
-}
-
-// Determine the maximum number of overlays that are all of the same format
-// that the HWC will commit to.  If allowOverlap is true, then the rectangles
-// are laid out on a diagonal starting from the upper left corner.  With
-// each rectangle adjust one pixel to the right and one pixel down.
-// When allowOverlap is false, the rectangles are tiled in column major
-// order.  Note, column major ordering is used so that the initial rectangles
-// are all on different horizontal scan rows.  It is common that hardware
-// has limits on the number of objects it can handle on any single row.
-uint32_t maxOverlays(uint32_t format, bool allowOverlap)
-{
-    unsigned int max = 0;
-
-    for (unsigned int numRects = 1; numRects <= searchLimits.numOverlays;
-         numRects++) {
-        list<Rectangle> rectList;
-
-        for (unsigned int x = 0;
-             (x + startDim.width()) < (unsigned int) width;
-             x += (allowOverlap) ? 1 : startDim.width()) {
-            for (unsigned int y = 0;
-                 (y + startDim.height()) < (unsigned int) height;
-                 y += (allowOverlap) ? 1 : startDim.height()) {
-                Rectangle rect(format, startDim, startDim);
-                rect.displayFrame.left = x;
-                rect.displayFrame.top = y;
-                rect.displayFrame.right = x + startDim.width();
-                rect.displayFrame.bottom = y + startDim.height();
-
-                rectList.push_back(rect);
-
-                if (rectList.size() >= numRects) { break; }
-            }
-            if (rectList.size() >= numRects) { break; }
-        }
-
-        uint32_t num = numOverlays(rectList);
-        if (num > max) { max = num; }
-    }
-
-    return max;
-}
-
-// Measures what transforms (i.e. flip horizontal, rotate 180) are
-// supported by the specified format
-list<uint32_t> supportedTransforms(uint32_t format)
-{
-    list<uint32_t> rv;
-    list<Rectangle> rectList;
-    Rectangle rect(format, startDim);
-
-    // For each of the transform types
-    for (unsigned int idx = 0; idx < NUMA(transformType); idx++) {
-        unsigned int id = transformType[idx].id;
-
-        rect.transform = id;
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-
-        if (num == 1) {
-            rv.push_back(id);
-        }
-    }
-
-    return rv;
-}
-
-// Determines which types of blends (i.e. none, premult, coverage) are
-// supported by the specified format
-list<uint32_t> supportedBlends(uint32_t format)
-{
-    list<uint32_t> rv;
-    list<Rectangle> rectList;
-    Rectangle rect(format, startDim);
-
-    // For each of the blend types
-    for (unsigned int idx = 0; idx < NUMA(blendType); idx++) {
-        unsigned int id = blendType[idx].id;
-
-        rect.blend = id;
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-
-        if (num == 1) {
-            rv.push_back(id);
-        }
-    }
-
-    return rv;
-}
-
-// Determines the minimum width of any display frame of the given format
-// that the HWC will commit to.
-uint32_t dfMinWidth(uint32_t format)
-{
-    uint32_t w;
-    list<Rectangle> rectList;
-
-    for (w = 1; w <= startDim.width(); w++) {
-        HwcTestDim dim(w, startDim.height());
-        Rectangle rect(format, dim);
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return w;
-        }
-    }
-    if (w > startDim.width()) {
-        testPrintE("Failed to locate display frame min width");
-        exit(33);
-    }
-
-    return w;
-}
-
-// Display frame minimum height
-uint32_t dfMinHeight(uint32_t format)
-{
-    uint32_t h;
-    list<Rectangle> rectList;
-
-    for (h = 1; h <= startDim.height(); h++) {
-        HwcTestDim dim(startDim.width(), h);
-        Rectangle rect(format, dim);
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return h;
-        }
-    }
-    if (h > startDim.height()) {
-        testPrintE("Failed to locate display frame min height");
-        exit(34);
-    }
-
-    return h;
-}
-
-// Display frame maximum width
-uint32_t dfMaxWidth(uint32_t format)
-{
-    uint32_t w;
-    list<Rectangle> rectList;
-
-    for (w = width; w >= startDim.width(); w--) {
-        HwcTestDim dim(w, startDim.height());
-        Rectangle rect(format, dim);
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return w;
-        }
-    }
-    if (w < startDim.width()) {
-        testPrintE("Failed to locate display frame max width");
-        exit(35);
-    }
-
-    return w;
-}
-
-// Display frame maximum height
-uint32_t dfMaxHeight(uint32_t format)
-{
-    uint32_t h;
-
-    for (h = height; h >= startDim.height(); h--) {
-        HwcTestDim dim(startDim.width(), h);
-        Rectangle rect(format, dim);
-        list<Rectangle> rectList;
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return h;
-        }
-    }
-    if (h < startDim.height()) {
-        testPrintE("Failed to locate display frame max height");
-        exit(36);
-    }
-
-    return h;
-}
-
-// Determine the minimum number of pixels that the HWC will ever commit to.
-// Note, this might be different that dfMinWidth * dfMinHeight, in that this
-// function adjusts both the width and height from the starting dimension.
-HwcTestDim dfMinDim(uint32_t format)
-{
-    uint64_t bestMinPixels = 0;
-    HwcTestDim bestDim;
-    bool bestSet = false; // True when value has been assigned to
-                          // bestMinPixels and bestDim
-
-    bool origVerbose = verbose;  // Temporarily turn off verbose
-    verbose = false;
-    for (uint32_t w = 1; w <= startDim.width(); w++) {
-        for (uint32_t h = 1; h <= startDim.height(); h++) {
-            if (bestSet && ((w > bestMinPixels) || (h > bestMinPixels))) {
-                break;
-            }
-
-            HwcTestDim dim(w, h);
-            Rectangle rect(format, dim);
-            list<Rectangle> rectList;
-            rectList.push_back(rect);
-            uint32_t num = numOverlays(rectList);
-            if (num > 0) {
-                uint64_t pixels = dim.width() * dim.height();
-                if (!bestSet || (pixels < bestMinPixels)) {
-                    bestMinPixels = pixels;
-                    bestDim = dim;
-                    bestSet = true;
-                }
-            }
-        }
-    }
-    verbose = origVerbose;
-
-    if (!bestSet) {
-        testPrintE("Unable to locate display frame min dimension");
-        exit(20);
-    }
-
-    return bestDim;
-}
-
-// Display frame maximum dimension
-HwcTestDim dfMaxDim(uint32_t format)
-{
-    uint64_t bestMaxPixels = 0;
-    HwcTestDim bestDim;
-    bool bestSet = false; // True when value has been assigned to
-                          // bestMaxPixels and bestDim;
-
-    // Potentially increase benchmark performance by first checking
-    // for the common case of supporting a full display frame.
-    HwcTestDim dim(width, height);
-    Rectangle rect(format, dim);
-    list<Rectangle> rectList;
-    rectList.push_back(rect);
-    uint32_t num = numOverlays(rectList);
-    if (num == 1) { return dim; }
-
-    // TODO: Use a binary search
-    bool origVerbose = verbose;  // Temporarily turn off verbose
-    verbose = false;
-    for (uint32_t w = startDim.width(); w <= (uint32_t) width; w++) {
-        for (uint32_t h = startDim.height(); h <= (uint32_t) height; h++) {
-            if (bestSet && ((w * h) <= bestMaxPixels)) { continue; }
-
-            HwcTestDim dim(w, h);
-            Rectangle rect(format, dim);
-            list<Rectangle> rectList;
-            rectList.push_back(rect);
-            uint32_t num = numOverlays(rectList);
-            if (num > 0) {
-                uint64_t pixels = dim.width() * dim.height();
-                if (!bestSet || (pixels > bestMaxPixels)) {
-                    bestMaxPixels = pixels;
-                    bestDim = dim;
-                    bestSet = true;
-                }
-            }
-        }
-    }
-    verbose = origVerbose;
-
-    if (!bestSet) {
-        testPrintE("Unable to locate display frame max dimension");
-        exit(21);
-    }
-
-    return bestDim;
-}
-
-// Source crop minimum width
-uint32_t scMinWidth(uint32_t format, const HwcTestDim& dfDim)
-{
-    uint32_t w;
-    list<Rectangle> rectList;
-
-    // Source crop frame min width
-    for (w = 1; w <= dfDim.width(); w++) {
-        Rectangle rect(format, dfDim, HwcTestDim(w, dfDim.height()));
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return w;
-        }
-    }
-    testPrintE("Failed to locate source crop min width");
-    exit(35);
-}
-
-// Source crop minimum height
-uint32_t scMinHeight(uint32_t format, const HwcTestDim& dfDim)
-{
-    uint32_t h;
-    list<Rectangle> rectList;
-
-    for (h = 1; h <= dfDim.height(); h++) {
-        Rectangle rect(format, dfDim, HwcTestDim(dfDim.width(), h));
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return h;
-        }
-    }
-    testPrintE("Failed to locate source crop min height");
-    exit(36);
-}
-
-// Source crop maximum width
-uint32_t scMaxWidth(uint32_t format, const HwcTestDim& dfDim)
-{
-    uint32_t w;
-    list<Rectangle> rectList;
-
-    for (w = searchLimits.sourceCrop.width(); w >= dfDim.width(); w--) {
-        Rectangle rect(format, dfDim, HwcTestDim(w, dfDim.height()));
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return w;
-        }
-    }
-    testPrintE("Failed to locate source crop max width");
-    exit(35);
-}
-
-// Source crop maximum height
-uint32_t scMaxHeight(uint32_t format, const HwcTestDim& dfDim)
-{
-    uint32_t h;
-    list<Rectangle> rectList;
-
-    for (h = searchLimits.sourceCrop.height(); h >= dfDim.height(); h--) {
-        Rectangle rect(format, dfDim, HwcTestDim(dfDim.width(), h));
-        rectList.clear();
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-        if (num > 0) {
-            return h;
-        }
-    }
-    testPrintE("Failed to locate source crop max height");
-    exit(36);
-}
-
-// Source crop minimum dimension
-// Discovers the source crop with the least number of pixels that the
-// HWC will commit to.  Note, this may be different from scMinWidth
-// * scMinHeight, in that this function searches for a combination of
-// width and height.  While the other routines always keep one of the
-// dimensions equal to the corresponding start dimension.
-HwcTestDim scMinDim(uint32_t format, const HwcTestDim& dfDim)
-{
-    uint64_t bestMinPixels = 0;
-    HwcTestDim bestDim;
-    bool bestSet = false; // True when value has been assigned to
-                          // bestMinPixels and bestDim
-
-    bool origVerbose = verbose;  // Temporarily turn off verbose
-    verbose = false;
-    for (uint32_t w = 1; w <= dfDim.width(); w++) {
-        for (uint32_t h = 1; h <= dfDim.height(); h++) {
-            if (bestSet && ((w > bestMinPixels) || (h > bestMinPixels))) {
-                break;
-            }
-
-            HwcTestDim dim(w, h);
-            Rectangle rect(format, dfDim, HwcTestDim(w, h));
-            list<Rectangle> rectList;
-            rectList.push_back(rect);
-            uint32_t num = numOverlays(rectList);
-            if (num > 0) {
-                uint64_t pixels = dim.width() * dim.height();
-                if (!bestSet || (pixels < bestMinPixels)) {
-                    bestMinPixels = pixels;
-                    bestDim = dim;
-                    bestSet = true;
-                }
-            }
-        }
-    }
-    verbose = origVerbose;
-
-    if (!bestSet) {
-        testPrintE("Unable to locate source crop min dimension");
-        exit(20);
-    }
-
-    return bestDim;
-}
-
-// Source crop maximum dimension
-HwcTestDim scMaxDim(uint32_t format, const HwcTestDim& dfDim)
-{
-    uint64_t bestMaxPixels = 0;
-    HwcTestDim bestDim;
-    bool bestSet = false; // True when value has been assigned to
-                          // bestMaxPixels and bestDim;
-
-    // Potentially increase benchmark performance by first checking
-    // for the common case of supporting the maximum checked source size
-    HwcTestDim dim = searchLimits.sourceCrop;
-    Rectangle rect(format, dfDim, searchLimits.sourceCrop);
-    list<Rectangle> rectList;
-    rectList.push_back(rect);
-    uint32_t num = numOverlays(rectList);
-    if (num == 1) { return dim; }
-
-    // TODO: Use a binary search
-    bool origVerbose = verbose;  // Temporarily turn off verbose
-    verbose = false;
-    for (uint32_t w = dfDim.width();
-         w <= searchLimits.sourceCrop.width(); w++) {
-        for (uint32_t h = dfDim.height();
-             h <= searchLimits.sourceCrop.height(); h++) {
-            if (bestSet && ((w * h) <= bestMaxPixels)) { continue; }
-
-            HwcTestDim dim(w, h);
-            Rectangle rect(format, dfDim, dim);
-            list<Rectangle> rectList;
-            rectList.push_back(rect);
-            uint32_t num = numOverlays(rectList);
-            if (num > 0) {
-                uint64_t pixels = dim.width() * dim.height();
-                if (!bestSet || (pixels > bestMaxPixels)) {
-                    bestMaxPixels = pixels;
-                    bestDim = dim;
-                    bestSet = true;
-                }
-            }
-        }
-    }
-    verbose = origVerbose;
-
-    if (!bestSet) {
-        testPrintE("Unable to locate source crop max dimension");
-        exit(21);
-    }
-
-    return bestDim;
-}
-
-// Source crop horizontal scale
-// Determines the maximum factor by which the source crop can be larger
-// that the display frame.  The commit point is discovered through a
-// binary search of rational numbers.  The numerator in each of the
-// rational numbers contains the dimension for the source crop, while
-// the denominator specifies the dimension for the display frame.  On
-// each pass of the binary search the mid-point between the greatest
-// point committed to (best) and the smallest point in which a commit
-// has failed is calculated.  This mid-point is then passed to a function
-// named double2Rational, which determines the closest rational numbers
-// just below and above the mid-point.  By default the lower rational
-// number is used for the scale factor on the next pass of the binary
-// search.  The upper value is only used when best is already equal
-// to the lower value.  This only occurs when the lower value has already
-// been tried.
-Rational scHScale(uint32_t format,
-                      const HwcTestDim& dfMin, const HwcTestDim& dfMax,
-                      const HwcTestDim& scMin, const HwcTestDim& scMax,
-                      HwcTestDim& outBestDf, HwcTestDim& outBestSc)
-{
-    HwcTestDim scDim, dfDim; // Source crop and display frame dimension
-    Rational best(0, 1), minBad;  // Current bounds for a binary search
-                                  // MinGood is set below the lowest
-                                  // possible scale.  The value of minBad,
-                                  // will be set by the first pass
-                                  // of the binary search.
-
-    // Perform the passes of the binary search
-    bool firstPass = true;
-    do {
-        // On first pass try the maximum scale within the search limits
-        if (firstPass) {
-            // Try the maximum possible scale, within the search limits
-            scDim = HwcTestDim(searchLimits.sourceCrop.width(), scMin.height());
-            dfDim = dfMin;
-        } else {
-            // Subsequent pass
-            // Halve the difference between best and minBad.
-            Rational lower, upper, selected;
-
-            // Try the closest ratio halfway between minBood and minBad;
-            // TODO: Avoid rounding issue by using Rational type for
-            //       midpoint.  For now will use double, which should
-            //       have more than sufficient resolution.
-            double mid = (double) best
-                         + ((double) minBad - (double) best) / 2.0;
-            Rational::double2Rational(mid,
-                            Range(scMin.width(), scMax.width()),
-                            Range(dfMin.width(), dfMax.width()),
-                            lower, upper);
-            if (((lower == best) && (upper == minBad))) {
-                return best;
-            }
-
-            // Use lower value unless its already been tried
-            selected = (lower != best) ? lower : upper;
-
-            // Assign the size of the source crop and display frame
-            // from the selected ratio of source crop to display frame.
-            scDim = HwcTestDim(selected.numerator(), scMin.height());
-            dfDim = HwcTestDim(selected.denominator(), dfMin.height());
-        }
-
-        // See if the HWC will commit to this combination
-        Rectangle rect(format, dfDim, scDim);
-        list<Rectangle> rectList;
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-
-        if (verbose) {
-            testPrintI("  scHscale num: %u scale: %f dfDim: %s scDim: %s",
-                       num, (float) Rational(scDim.width(), dfDim.width()),
-                       ((string) dfDim).c_str(), ((string) scDim).c_str());
-        }
-        if (num == 1) {
-            // HWC committed to the combination
-            // This is the best scale factor seen so far.  Report the
-            // dimensions to the caller, in case nothing better is seen.
-            outBestDf = dfDim;
-            outBestSc = scDim;
-
-            // Success on the first pass means the largest possible scale
-            // is supported, in which case no need to search any further.
-            if (firstPass) { return Rational(scDim.width(), dfDim.width()); }
-
-            // Update the lower bound of the binary search
-            best = Rational(scDim.width(), dfDim.width());
-        } else {
-            // HWC didn't commit to this combination, so update the
-            // upper bound of the binary search.
-            minBad = Rational(scDim.width(), dfDim.width());
-        }
-
-        firstPass = false;
-    } while (best != minBad);
-
-    return best;
-}
-
-// Source crop vertical scale
-// Determines the maximum factor by which the source crop can be larger
-// that the display frame.  The commit point is discovered through a
-// binary search of rational numbers.  The numerator in each of the
-// rational numbers contains the dimension for the source crop, while
-// the denominator specifies the dimension for the display frame.  On
-// each pass of the binary search the mid-point between the greatest
-// point committed to (best) and the smallest point in which a commit
-// has failed is calculated.  This mid-point is then passed to a function
-// named double2Rational, which determines the closest rational numbers
-// just below and above the mid-point.  By default the lower rational
-// number is used for the scale factor on the next pass of the binary
-// search.  The upper value is only used when best is already equal
-// to the lower value.  This only occurs when the lower value has already
-// been tried.
-Rational scVScale(uint32_t format,
-                      const HwcTestDim& dfMin, const HwcTestDim& dfMax,
-                      const HwcTestDim& scMin, const HwcTestDim& scMax,
-                      HwcTestDim& outBestDf, HwcTestDim& outBestSc)
-{
-    HwcTestDim scDim, dfDim; // Source crop and display frame dimension
-    Rational best(0, 1), minBad;  // Current bounds for a binary search
-                                  // MinGood is set below the lowest
-                                  // possible scale.  The value of minBad,
-                                  // will be set by the first pass
-                                  // of the binary search.
-
-    // Perform the passes of the binary search
-    bool firstPass = true;
-    do {
-        // On first pass try the maximum scale within the search limits
-        if (firstPass) {
-            // Try the maximum possible scale, within the search limits
-            scDim = HwcTestDim(scMin.width(), searchLimits.sourceCrop.height());
-            dfDim = dfMin;
-        } else {
-            // Subsequent pass
-            // Halve the difference between best and minBad.
-            Rational lower, upper, selected;
-
-            // Try the closest ratio halfway between minBood and minBad;
-            // TODO: Avoid rounding issue by using Rational type for
-            //       midpoint.  For now will use double, which should
-            //       have more than sufficient resolution.
-            double mid = (double) best
-                         + ((double) minBad - (double) best) / 2.0;
-            Rational::double2Rational(mid,
-                            Range(scMin.height(), scMax.height()),
-                            Range(dfMin.height(), dfMax.height()),
-                            lower, upper);
-            if (((lower == best) && (upper == minBad))) {
-                return best;
-            }
-
-            // Use lower value unless its already been tried
-            selected = (lower != best) ? lower : upper;
-
-            // Assign the size of the source crop and display frame
-            // from the selected ratio of source crop to display frame.
-            scDim = HwcTestDim(scMin.width(), selected.numerator());
-            dfDim = HwcTestDim(dfMin.width(), selected.denominator());
-        }
-
-        // See if the HWC will commit to this combination
-        Rectangle rect(format, dfDim, scDim);
-        list<Rectangle> rectList;
-        rectList.push_back(rect);
-        uint32_t num = numOverlays(rectList);
-
-        if (verbose) {
-            testPrintI("  scHscale num: %u scale: %f dfDim: %s scDim: %s",
-                       num, (float) Rational(scDim.height(), dfDim.height()),
-                       ((string) dfDim).c_str(), ((string) scDim).c_str());
-        }
-        if (num == 1) {
-            // HWC committed to the combination
-            // This is the best scale factor seen so far.  Report the
-            // dimensions to the caller, in case nothing better is seen.
-            outBestDf = dfDim;
-            outBestSc = scDim;
-
-            // Success on the first pass means the largest possible scale
-            // is supported, in which case no need to search any further.
-            if (firstPass) { return Rational(scDim.height(), dfDim.height()); }
-
-            // Update the lower bound of the binary search
-            best = Rational(scDim.height(), dfDim.height());
-        } else {
-            // HWC didn't commit to this combination, so update the
-            // upper bound of the binary search.
-            minBad = Rational(scDim.height(), dfDim.height());
-        }
-
-        firstPass = false;
-    } while (best != minBad);
-
-    return best;
-}
-
-uint32_t numOverlapping(uint32_t backgroundFormat, uint32_t foregroundFormat,
-                        uint32_t backgroundBlend, uint32_t foregroundBlend)
-{
-    list<Rectangle> rectList;
-
-    Rectangle background(backgroundFormat, startDim, startDim);
-    background.blend = backgroundBlend;
-    rectList.push_back(background);
-
-    // TODO: Handle cases where startDim is so small that adding 5
-    //       causes frames not to overlap.
-    // TODO: Handle cases where startDim is so large that adding 5
-    //       cause a portion or all of the foreground displayFrame
-    //       to be off the display.
-    Rectangle foreground(foregroundFormat, startDim, startDim);
-    foreground.displayFrame.left += 5;
-    foreground.displayFrame.top += 5;
-    foreground.displayFrame.right += 5;
-    foreground.displayFrame.bottom += 5;
-    background.blend = foregroundBlend;
-    rectList.push_back(foreground);
-
-    uint32_t num = numOverlays(rectList);
-
-    return num;
-}
-
-Rectangle::Rectangle(uint32_t graphicFormat, HwcTestDim dfDim,
-                     HwcTestDim sDim) :
-    format(graphicFormat), transform(defaultTransform),
-    blend(defaultBlend), color(defaultColor), alpha(defaultAlpha),
-    sourceCrop(sDim), displayFrame(dfDim)
-{
-    // Set source dimension
-    // Can't use a base initializer, because the setting of format
-    // must be done before setting the sourceDimension.
-    setSourceDim(sDim);
-}
-
-void Rectangle::setSourceDim(HwcTestDim dim)
-{
-    this->sourceDim = dim;
-
-    const struct hwcTestGraphicFormat *attrib;
-    attrib = hwcTestGraphicFormatLookup(this->format);
-    if (attrib != NULL) {
-        if (sourceDim.width() % attrib->wMod) {
-            sourceDim.setWidth(sourceDim.width() + attrib->wMod
-            - (sourceDim.width() % attrib->wMod));
-        }
-        if (sourceDim.height() % attrib->hMod) {
-            sourceDim.setHeight(sourceDim.height() + attrib->hMod
-            - (sourceDim.height() % attrib->hMod));
-        }
-    }
-}
-
-// Rational member functions
-bool Rational::operator==(const Rational& other) const
-{
-    if (((uint64_t) _n * other._d)
-        == ((uint64_t) _d * other._n)) { return true; }
-
-    return false;
-}
-
-bool Rational::operator<(const Rational& other) const
-{
-    if (((uint64_t) _n * other._d)
-        < ((uint64_t) _d * other._n)) { return true; }
-
-    return false;
-}
-
-Rational::operator string() const
-{
-    ostringstream out;
-
-    out << _n << '/' << _d;
-
-    return out.str();
-}
-
-void Rational::double2Rational(double f, Range nRange, Range dRange,
-                    Rational& lower, Rational& upper)
-{
-    Rational bestLower(nRange.lower(), dRange.upper());
-    Rational bestUpper(nRange.upper(), dRange.lower());
-
-    // Search for a better solution
-    for (uint32_t d = dRange.lower(); d <= dRange.upper(); d++) {
-        Rational val(d * f, d);  // Lower, because double to int cast truncates
-
-        if ((val.numerator() < nRange.lower())
-            || (val.numerator() > nRange.upper())) { continue; }
-
-        if (((double) val > (double) bestLower) && ((double) val <= f)) {
-            bestLower = val;
-        } 
-
-        val.setNumerator(val.numerator() + 1);
-        if (val.numerator() > nRange.upper()) { continue; }
-
-        if (((double) val < (double) bestUpper) && ((double) val >= f)) {
-            bestUpper = val;
-        }
-    }
-
-    lower = bestLower;
-    upper = bestUpper;
-}
-
-// Local functions
-
-// Num Overlays
-// Given a list of rectangles, determine how many HWC will commit to render
-uint32_t numOverlays(list<Rectangle>& rectList)
-{
-    hwc_display_contents_1_t *hwcList;
-    list<sp<GraphicBuffer> > buffers;
-
-    hwcList = hwcTestCreateLayerList(rectList.size());
-    if (hwcList == NULL) {
-        testPrintE("numOverlays create hwcList failed");
-        exit(30);
-    }
-
-    hwc_layer_1_t *layer = &hwcList->hwLayers[0];
-    for (std::list<Rectangle>::iterator it = rectList.begin();
-         it != rectList.end(); ++it, ++layer) {
-        // Allocate the texture for the source frame
-        // and push it onto the buffers list, so that it
-        // stays in scope until a return from this function.
-        sp<GraphicBuffer> texture;
-        texture  = new GraphicBuffer(it->sourceDim.width(),
-                                     it->sourceDim.height(),
-                                     it->format, texUsage);
-        buffers.push_back(texture);
-
-        layer->handle = texture->handle;
-        layer->blending = it->blend;
-        layer->transform = it->transform;
-        layer->sourceCrop = it->sourceCrop;
-        layer->displayFrame = it->displayFrame;
-
-        layer->visibleRegionScreen.numRects = 1;
-        layer->visibleRegionScreen.rects = &layer->displayFrame;
-    }
-
-    // Perform prepare operation
-    if (verbose) { testPrintI("Prepare:"); hwcTestDisplayList(hwcList); }
-    hwcDevice->prepare(hwcDevice, 1, &hwcList);
-    if (verbose) {
-        testPrintI("Post Prepare:");
-        hwcTestDisplayListPrepareModifiable(hwcList);
-    }
-
-    // Count the number of overlays
-    uint32_t total = 0;
-    for (unsigned int n1 = 0; n1 < hwcList->numHwLayers; n1++) {
-        if (hwcList->hwLayers[n1].compositionType == HWC_OVERLAY) {
-            total++;
-        }
-    }
-
-    // Free the layer list and graphic buffers
-    hwcTestFreeLayerList(hwcList);
-
-    return total;
-}
-
-string transformList2str(const list<uint32_t>& transformList)
-{
-    ostringstream out;
-
-    for (list<uint32_t>::const_iterator it = transformList.begin();
-         it != transformList.end(); ++it) {
-        uint32_t id = *it;
-
-        if (it != transformList.begin()) {
-            out << ", ";
-        }
-        out << id;
-
-        for (unsigned int idx = 0; idx < NUMA(transformType); idx++) {
-            if (id == transformType[idx].id) {
-                out << " (" << transformType[idx].desc << ')';
-                break;
-            }
-        }
-    }
-
-    return out.str();
-}
-
-string blendList2str(const list<uint32_t>& blendList)
-{
-    ostringstream out;
-
-    for (list<uint32_t>::const_iterator it = blendList.begin();
-         it != blendList.end(); ++it) {
-        uint32_t id = *it;
-
-        if (it != blendList.begin()) {
-            out << ", ";
-        }
-        out << id;
-
-        for (unsigned int idx = 0; idx < NUMA(blendType); idx++) {
-            if (id == blendType[idx].id) {
-                out << " (" << blendType[idx].desc << ')';
-                break;
-            }
-        }
-    }
-
-    return out.str();
-}
-
-void init(void)
-{
-    srand48(0);
-
-    hwcTestInitDisplay(verbose, &dpy, &surface, &width, &height);
-
-    hwcTestOpenHwc(&hwcDevice);
-}
-
-void printFormatHeadings(size_t indent)
-{
-    for (size_t row = 0; row <= maxHeadingLen; row++) {
-        ostringstream line;
-        for(vector<string>::iterator it = formats.begin();
-            it != formats.end(); ++it) {
-            if ((maxHeadingLen - row) <= it->length()) {
-                if (row != maxHeadingLen) {
-                    char ch = (*it)[it->length() - (maxHeadingLen - row)];
-                    line << ' ' << setw(printFieldWidth) << ch;
-                } else {
-                    line << ' ' << string(printFieldWidth, '-');
-                }
-            } else {
-               line << ' ' << setw(printFieldWidth) << "";
-            }
-        }
-        testPrintI("%*s%s", indent + maxHeadingLen, "",
-                   line.str().c_str());
-    }
-}
-
-void printOverlapLine(size_t indent, const string formatStr,
-                        const vector<uint32_t>& results)
-{
-    ostringstream line;
-
-    line << setw(indent + maxHeadingLen - formatStr.length()) << "";
-
-    line << formatStr;
-
-    for (vector<uint32_t>::const_iterator it = results.begin();
-         it != results.end(); ++it) {
-        line << ' ' << setw(printFieldWidth) << *it;
-    }
-
-    testPrintI("%s", line.str().c_str());
-}
-
-void printSyntax(const char *cmd)
-{
-    testPrintE("  %s [options] [graphicFormat] ...",
-               cmd);
-    testPrintE("    options:");
-    testPrintE("      -s [width, height] - start dimension");
-    testPrintE("      -v - Verbose");
-    testPrintE("");
-    testPrintE("    graphic formats:");
-    for (unsigned int n1 = 0; n1 < NUMA(hwcTestGraphicFormat); n1++) {
-        testPrintE("      %s", hwcTestGraphicFormat[n1].desc);
-    }
-}
diff --git a/opengl/tests/hwc/hwcRects.cpp b/opengl/tests/hwc/hwcRects.cpp
deleted file mode 100644
index 5956366809..0000000000
--- a/opengl/tests/hwc/hwcRects.cpp
+++ /dev/null
@@ -1,575 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Hardware Composer Rectangles
- *
- * Synopsis
- *   hwcRects [options] (graphicFormat displayFrame [attributes],)...
- *     options:
- *       -D #.## - End of test delay
- *       -v - Verbose
- *
- *      graphic formats:
- *        RGBA8888 (reference frame default)
- *        RGBX8888
- *        RGB888
- *        RGB565
- *        BGRA8888
- *        RGBA5551
- *        RGBA4444
- *        YV12
- *
- *      displayFrame
- *        [left, top, right, bottom]
- *
- *      attributes:
- *        transform: none | fliph | flipv | rot90 | rot180 | rot270
- *        blend: none | premult | coverage
- *        color: [0.##, 0.##, 0.##]
- *        alpha: 0.##
- *        sourceDim: [width, height]
- *        sourceCrop: [left, top, right, bottom]
- *
- *      Example:
- *        # White YV12 rectangle, with overlapping turquoise
- *        #  RGBA8888 rectangle at 30%% (alpha: 0.7) transparency
- *        hwcRects -v -D 30.0 \
- *          YV12 [50, 80, 200, 300] transform: none \
- *            color: [1.0, 0.5, 0.5], \
- *          RGBA8888 [100, 150, 300, 400] blend: coverage \
- *            color: [0.251, 0.878, 0.816] alpha: 0.7 \
- *            sourceDim: [50, 60] sourceCrop: [5, 8, 12, 15]
- *
- * Description
- *   Constructs a Hardware Composer (HWC) list of frames from
- *   command-line specified parameters.  Then sends it to the HWC
- *   be rendered.  The intended purpose of this tool is as a means to
- *   reproduce and succinctly specify an observed HWC operation, with
- *   no need to modify/compile a program.
- *
- *   The command-line syntax consists of a few standard command-line
- *   options and then a description of one or more frames.  The frame
- *   descriptions are separated from one another via a comma.  The
- *   beginning of a frame description requires the specification
- *   of the graphic format and then the display frame rectangle where
- *   the frame will be displayed.  The display frame rectangle is
- *   specified as follows, with the right and bottom coordinates being
- *   exclusive values:
- *
- *     [left, top, right, bottom]
- *    
- *   After these two required parameters each frame description can
- *   specify 1 or more optional attributes.  The name of each optional
- *   attribute is preceded by a colon.  The current implementation
- *   then requires white space after the colon and then the value of
- *   the attribute is specified.  See the synopsis section above for
- *   a list of attributes and the format of their expected value.
- */
-
-#define LOG_TAG "hwcRectsTest"
-
-#include <algorithm>
-#include <assert.h>
-#include <cerrno>
-#include <cmath>
-#include <cstdlib>
-#include <ctime>
-#include <istream>
-#include <libgen.h>
-#include <list>
-#include <sched.h>
-#include <sstream>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <sys/syscall.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <ui/GraphicBuffer.h>
-#include <utils/Log.h>
-#include <testUtil.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <glTestLib.h>
-#include "hwcTestLib.h"
-
-using namespace std;
-using namespace android;
-
-// Defaults
-const bool defaultVerbose = false;
-const float defaultEndDelay = 2.0; // Default delay after rendering graphics
-
-const uint32_t   defaultFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-const int32_t    defaultTransform = 0;
-const uint32_t   defaultBlend = HWC_BLENDING_NONE;
-const ColorFract defaultColor(0.5, 0.5, 0.5);
-const float      defaultAlpha = 1.0; // Opaque
-const HwcTestDim defaultSourceDim(1, 1);
-const struct hwc_rect defaultSourceCrop = {0, 0, 1, 1};
-const struct hwc_rect defaultDisplayFrame = {0, 0, 100, 100};
-
-// Defines
-#define MAXCMD               200
-#define CMD_STOP_FRAMEWORK   "stop 2>&1"
-#define CMD_START_FRAMEWORK  "start 2>&1"
-
-// Macros
-#define NUMA(a) (sizeof(a) / sizeof((a)[0])) // Num elements in an array
-
-// Local types
-class Rectangle {
-public:
-    Rectangle() : format(defaultFormat), transform(defaultTransform),
-                  blend(defaultBlend), color(defaultColor),
-                  alpha(defaultAlpha), sourceDim(defaultSourceDim),
-                  sourceCrop(defaultSourceCrop),
-                  displayFrame(defaultDisplayFrame) {};
-
-    uint32_t     format;
-    uint32_t     transform;
-    int32_t      blend;
-    ColorFract   color;
-    float        alpha;
-    HwcTestDim   sourceDim;
-    struct hwc_rect   sourceCrop;
-    struct hwc_rect   displayFrame;
-
-    sp<GraphicBuffer> texture;
-};
-
-// Globals
-list<Rectangle> rectangle;
-static const int texUsage = GraphicBuffer::USAGE_HW_TEXTURE |
-        GraphicBuffer::USAGE_SW_WRITE_RARELY;
-static hwc_composer_device_1_t *hwcDevice;
-static EGLDisplay dpy;
-static EGLSurface surface;
-static EGLint width, height;
-
-// Function prototypes
-static Rectangle parseRect(const string& rectStr);
-void init(void);
-void printSyntax(const char *cmd);
-
-// Command-line option settings
-static bool verbose = defaultVerbose;
-static float endDelay = defaultEndDelay;
-
-/*
- * Main
- *
- * Performs the following high-level sequence of operations:
- *
- *   1. Parse command-line options
- *
- *   2. Stop framework
- *
- *   3. Initialization
- *
- *   4. Parse frame descriptions
- *
- *   5. Create HWC list from frame descriptions
- *
- *   6. Have HWC render the list description of the frames
- *
- *   7. Delay for amount of time given by endDelay
- *
- *   8. Start framework
- */
-int
-main(int argc, char *argv[])
-{
-    int     rv, opt;
-    char   *chptr;
-    string  str;
-    char cmd[MAXCMD];
-
-    testSetLogCatTag(LOG_TAG);
-
-    // Parse command line arguments
-    while ((opt = getopt(argc, argv, "D:v?h")) != -1) {
-        switch (opt) {
-          case 'D': // End of test delay
-            endDelay = strtod(optarg, &chptr);
-            if ((*chptr != '\0') || (endDelay < 0.0)) {
-                testPrintE("Invalid command-line specified end of test delay "
-                           "of: %s", optarg);
-                exit(1);
-            }
-            break;
-
-          case 'v': // Verbose
-            verbose = true;
-            break;
-
-          case 'h': // Help
-          case '?':
-          default:
-            printSyntax(basename(argv[0]));
-            exit(((optopt == 0) || (optopt == '?')) ? 0 : 2);
-        }
-    }
-
-    // Stop framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_STOP_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_STOP_FRAMEWORK);
-        exit(3);
-    }
-    testExecCmd(cmd);
-    testDelay(1.0); // TODO - needs means to query whether asyncronous stop
-                    // framework operation has completed.  For now, just wait
-                    // a long time.
-
-    init();
-
-    // Parse rectangle descriptions
-    int numOpen = 0; // Current number of unmatched <[
-    string rectDesc(""); // String description of a single rectangle
-    while (optind < argc) {
-        string argNext = string(argv[optind++]);
-
-        if (rectDesc.length()) { rectDesc += ' '; }
-        rectDesc += argNext;
-
-        // Count number of opening <[ and matching >]
-        // At this point not worried about an opening character being
-        // matched by it's corresponding closing character.  For example,
-        // "<1.0, 2.0]" is incorrect because the opening < should be matched
-        // with a closing >, instead of the closing ].  Such errors are
-        // detected when the actual value is parsed.
-        for (unsigned int n1 = 0; n1 < argNext.length(); n1++) {
-            switch(argNext[n1]) {
-              case '[':
-              case '<':
-                numOpen++;
-                break;
-
-              case ']':
-              case '>':
-                numOpen--;
-                break;
-            }
-
-            // Error anytime there is more closing then opening characters
-            if (numOpen < 0) {
-                testPrintI("Mismatched number of opening <[ with "
-                           "closing >] in: %s", rectDesc.c_str());
-                exit(4);
-            }
-        }
-
-        // Description of a rectangle is complete when all opening
-        // <[ are closed with >] and the string ends with a comma or
-        // there are no more args.
-        if ((numOpen == 0) && rectDesc.length()
-            && ((rectDesc[rectDesc.length() - 1] == ',')
-                || (optind == argc))) {
-            // Remove trailing comma if it is present
-            if (rectDesc[rectDesc.length() - 1] == ',') {
-                rectDesc.erase(rectDesc.length() - 1);
-            }
-
-            // Parse string description of rectangle
-            Rectangle rect = parseRect(rectDesc);
-
-            // Add to the list of rectangles
-            rectangle.push_back(rect);
-
-            // Prepare for description of another rectangle
-            rectDesc = string("");
-        }
-    }
-
-    // Create list of frames
-    hwc_display_contents_1_t *list;
-    list = hwcTestCreateLayerList(rectangle.size());
-    if (list == NULL) {
-        testPrintE("hwcTestCreateLayerList failed");
-        exit(5);
-    }
-
-    hwc_layer_1_t *layer = &list->hwLayers[0];
-    for (std::list<Rectangle>::iterator it = rectangle.begin();
-         it != rectangle.end(); ++it, ++layer) {
-        layer->handle = it->texture->handle;
-        layer->blending = it->blend;
-        layer->transform = it->transform;
-        layer->sourceCrop = it->sourceCrop;
-        layer->displayFrame = it->displayFrame;
-
-        layer->visibleRegionScreen.numRects = 1;
-        layer->visibleRegionScreen.rects = &layer->displayFrame;
-    }
-
-    // Perform prepare operation
-    if (verbose) { testPrintI("Prepare:"); hwcTestDisplayList(list); }
-    hwcDevice->prepare(hwcDevice, 1, &list);
-    if (verbose) {
-        testPrintI("Post Prepare:");
-        hwcTestDisplayListPrepareModifiable(list);
-    }
-
-    // Turn off the geometry changed flag
-    list->flags &= ~HWC_GEOMETRY_CHANGED;
-
-    // Perform the set operation(s)
-    if (verbose) {testPrintI("Set:"); }
-    if (verbose) { hwcTestDisplayListHandles(list); }
-    list->dpy = dpy;
-    list->sur = surface;
-    hwcDevice->set(hwcDevice, 1, &list);
-
-    testDelay(endDelay);
-
-    // Start framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_START_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_START_FRAMEWORK);
-        exit(6);
-    }
-    testExecCmd(cmd);
-
-    return 0;
-}
-
-// Parse string description of rectangle and add it to list of rectangles
-// to be rendered.
-static Rectangle parseRect(const string& rectStr)
-{
-    int rv;
-    string str;
-    bool   error;
-    istringstream in(rectStr);
-    const struct hwcTestGraphicFormat *format;
-    Rectangle rect;
-
-    // Graphic Format
-    in >> str;
-    if (!in) {
-        testPrintE("Error parsing format from: %s", rectStr.c_str());
-        exit(20);
-    }
-    format = hwcTestGraphicFormatLookup(str.c_str());
-    if (format == NULL) {
-        testPrintE("Unknown graphic format in: %s", rectStr.c_str());
-        exit(21);
-    }
-    rect.format = format->format;
-
-    // Display Frame
-    rect.displayFrame = hwcTestParseHwcRect(in, error);
-    if (error) {
-        testPrintE("Invalid display frame in: %s", rectStr.c_str());
-        exit(22);
-    }
-
-    // Set default sourceDim and sourceCrop based on size of display frame.
-    // Default is source size equal to the size of the display frame, with
-    // the source crop being the entire size of the source frame.
-    rect.sourceDim = HwcTestDim(rect.displayFrame.right
-                                     - rect.displayFrame.left,
-                                 rect.displayFrame.bottom
-                                     - rect.displayFrame.top);
-    rect.sourceCrop.left = 0;
-    rect.sourceCrop.top = 0;
-    rect.sourceCrop.right = rect.sourceDim.width();
-    rect.sourceCrop.bottom = rect.sourceDim.height();
-
-    // Optional settings
-    while ((in.tellg() < (streampos) in.str().length())
-           && (in.tellg() != (streampos) -1)) {
-        string attrName;
-
-        in >> attrName;
-        if (in.eof()) { break; }
-        if (!in) {
-            testPrintE("Error reading attribute name in: %s",
-                       rectStr.c_str());
-            exit(23);
-        }
-
-        // Transform
-        if (attrName == "transform:") { // Transform
-            string str;
-
-            in >> str;
-            if (str == "none") {
-                rect.transform = 0;
-            } else if (str == "fliph") {
-                rect.transform = HWC_TRANSFORM_FLIP_H;
-            } else if (str == "flipv") {
-                rect.transform = HWC_TRANSFORM_FLIP_V;
-            } else if (str == "rot90") {
-                rect.transform = HWC_TRANSFORM_ROT_90;
-            } else if (str == "rot180") {
-                rect.transform = HWC_TRANSFORM_ROT_180;
-            } else if (str == "rot270") {
-                rect.transform = HWC_TRANSFORM_ROT_270;
-            } else {
-                testPrintE("Unknown transform of \"%s\" in: %s", str.c_str(),
-                           rectStr.c_str());
-                exit(24);
-            }
-        } else if (attrName == "blend:") { // Blend
-            string str;
-
-            in >> str;
-            if (str == string("none")) {
-                rect.blend = HWC_BLENDING_NONE;
-            } else if (str == "premult") {
-                rect.blend = HWC_BLENDING_PREMULT;
-            } else if (str == "coverage") {
-                rect.blend = HWC_BLENDING_COVERAGE;
-            } else {
-                testPrintE("Unknown blend of \"%s\" in: %s", str.c_str(),
-                           rectStr.c_str());
-                exit(25);
-            }
-        } else if (attrName == "color:") { // Color
-            rect.color = hwcTestParseColor(in, error);
-            if (error) {
-                testPrintE("Error parsing color in: %s", rectStr.c_str());
-                exit(26);
-            }
-        } else if (attrName == "alpha:") { // Alpha
-            in >> rect.alpha;
-            if (!in) {
-                testPrintE("Error parsing value for alpha attribute in: %s",
-                           rectStr.c_str());
-                exit(27);
-            }
-        } else if (attrName == "sourceDim:") { // Source Dimension
-           rect.sourceDim = hwcTestParseDim(in, error);
-            if (error) {
-                testPrintE("Error parsing source dimenision in: %s",
-                           rectStr.c_str());
-                exit(28);
-            }
-        } else if (attrName == "sourceCrop:") { // Source Crop
-            rect.sourceCrop = hwcTestParseHwcRect(in, error);
-            if (error) {
-                testPrintE("Error parsing source crop in: %s",
-                           rectStr.c_str());
-                exit(29);
-            }
-        } else { // Unknown attribute
-            testPrintE("Unknown attribute of \"%s\" in: %s", attrName.c_str(),
-                       rectStr.c_str());
-            exit(30);
-        }
-    }
-
-    // Validate
-    if (((uint32_t) rect.sourceCrop.left >= rect.sourceDim.width())
-        || ((uint32_t) rect.sourceCrop.right > rect.sourceDim.width())
-        || ((uint32_t) rect.sourceCrop.top >= rect.sourceDim.height())
-        || ((uint32_t) rect.sourceCrop.bottom > rect.sourceDim.height())) {
-        testPrintE("Invalid source crop in: %s", rectStr.c_str());
-        exit(31);
-    }
-    if ((rect.displayFrame.left >= width)
-        || (rect.displayFrame.right > width)
-        || (rect.displayFrame.top >= height)
-        || (rect.displayFrame.bottom > height)) {
-        testPrintE("Invalid display frame in: %s", rectStr.c_str());
-        exit(32);
-    }
-    if ((rect.alpha < 0.0) || (rect.alpha > 1.0)) {
-        testPrintE("Invalid alpha in: %s", rectStr.c_str());
-        exit(33);
-    }
-
-    // Create source texture
-    rect.texture = new GraphicBuffer(rect.sourceDim.width(),
-                                     rect.sourceDim.height(),
-                                     rect.format, texUsage);
-    if ((rv = rect.texture->initCheck()) != NO_ERROR) {
-        testPrintE("source texture initCheck failed, rv: %i", rv);
-        testPrintE("  %s", rectStr.c_str());
-
-    }
-
-    // Fill with uniform color
-    hwcTestFillColor(rect.texture.get(), rect.color, rect.alpha);
-    if (verbose) {
-        testPrintI("    buf: %p handle: %p format: %s width: %u height: %u "
-                   "color: %s alpha: %f",
-                   rect.texture.get(), rect.texture->handle, format->desc,
-                   rect.sourceDim.width(), rect.sourceDim.height(),
-                   string(rect.color).c_str(), rect.alpha);
-    }
-
-    return rect;
-}
-
-void init(void)
-{
-    // Seed pseudo random number generator
-    // Needed so that the pad areas of frames are filled with a deterministic
-    // pseudo random value.
-    srand48(0);
-
-    hwcTestInitDisplay(verbose, &dpy, &surface, &width, &height);
-
-    hwcTestOpenHwc(&hwcDevice);
-}
-
-void printSyntax(const char *cmd)
-{
-    testPrintE("  %s [options] (graphicFormat displayFrame [attributes],)...",
-               cmd);
-    testPrintE("    options:");
-    testPrintE("      -D End of test delay");
-    testPrintE("      -v Verbose");
-    testPrintE("");
-    testPrintE("    graphic formats:");
-    for (unsigned int n1 = 0; n1 < NUMA(hwcTestGraphicFormat); n1++) {
-        testPrintE("      %s", hwcTestGraphicFormat[n1].desc);
-    }
-    testPrintE("");
-    testPrintE("    displayFrame");
-    testPrintE("      [left, top, right, bottom]");
-    testPrintE("");
-    testPrintE("    attributes:");
-    testPrintE("      transform: none | fliph | flipv | rot90 | rot180 "
-               " | rot270");
-    testPrintE("      blend: none | premult | coverage");
-    testPrintE("      color: [0.##, 0.##, 0.##]");
-    testPrintE("      alpha: 0.##");
-    testPrintE("      sourceDim: [width, height]");
-    testPrintE("      sourceCrop: [left, top, right, bottom]");
-    testPrintE("");
-    testPrintE("    Example:");
-    testPrintE("      # White YV12 rectangle, with overlapping turquoise ");
-    testPrintE("      #  RGBA8888 rectangle at 30%% (alpha: 0.7) transparency");
-    testPrintE("      %s -v -D 30.0 \\", cmd);
-    testPrintE("        YV12 [50, 80, 200, 300] transform: none \\");
-    testPrintE("          color: [1.0, 0.5, 0.5], \\");
-    testPrintE("        RGBA8888 [100, 150, 300, 400] blend: coverage \\");
-    testPrintE("          color: [0.251, 0.878, 0.816] alpha: 0.7 \\");
-    testPrintE("          sourceDim: [50, 60] sourceCrop: [5, 8, 12, 15]");
-}
diff --git a/opengl/tests/hwc/hwcStress.cpp b/opengl/tests/hwc/hwcStress.cpp
deleted file mode 100644
index 1469f7c76d..0000000000
--- a/opengl/tests/hwc/hwcStress.cpp
+++ /dev/null
@@ -1,646 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-/*
- * Hardware Composer stress test
- *
- * Performs a pseudo-random (prandom) sequence of operations to the
- * Hardware Composer (HWC), for a specified number of passes or for
- * a specified period of time.  By default the period of time is FLT_MAX,
- * so that the number of passes will take precedence.
- *
- * The passes are grouped together, where (pass / passesPerGroup) specifies
- * which group a particular pass is in.  This causes every passesPerGroup
- * worth of sequential passes to be within the same group.  Computationally
- * intensive operations are performed just once at the beginning of a group
- * of passes and then used by all the passes in that group.  This is done
- * so as to increase both the average and peak rate of graphic operations,
- * by moving computationally intensive operations to the beginning of a group.
- * In particular, at the start of each group of passes a set of
- * graphic buffers are created, then used by the first and remaining
- * passes of that group of passes.
- *
- * The per-group initialization of the graphic buffers is performed
- * by a function called initFrames.  This function creates an array
- * of smart pointers to the graphic buffers, in the form of a vector
- * of vectors.  The array is accessed in row major order, so each
- * row is a vector of smart pointers.  All the pointers of a single
- * row point to graphic buffers which use the same pixel format and
- * have the same dimension, although it is likely that each one is
- * filled with a different color.  This is done so that after doing
- * the first HWC prepare then set call, subsequent set calls can
- * be made with each of the layer handles changed to a different
- * graphic buffer within the same row.  Since the graphic buffers
- * in a particular row have the same pixel format and dimension,
- * additional HWC set calls can be made, without having to perform
- * an HWC prepare call.
- *
- * This test supports the following command-line options:
- *
- *   -v        Verbose
- *   -s num    Starting pass
- *   -e num    Ending pass
- *   -p num    Execute the single pass specified by num
- *   -n num    Number of set operations to perform after each prepare operation
- *   -t float  Maximum time in seconds to execute the test
- *   -d float  Delay in seconds performed after each set operation
- *   -D float  Delay in seconds performed after the last pass is executed
- *
- * Typically the test is executed for a large range of passes.  By default
- * passes 0 through 99999 (100,000 passes) are executed.  Although this test
- * does not validate the generated image, at times it is useful to reexecute
- * a particular pass and leave the displayed image on the screen for an
- * extended period of time.  This can be done either by setting the -s
- * and -e options to the desired pass, along with a large value for -D.
- * This can also be done via the -p option, again with a large value for
- * the -D options.
- *
- * So far this test only contains code to create graphic buffers with
- * a continuous solid color.  Although this test is unable to validate the
- * image produced, any image that contains other than rectangles of a solid
- * color are incorrect.  Note that the rectangles may use a transparent
- * color and have a blending operation that causes the color in overlapping
- * rectangles to be mixed.  In such cases the overlapping portions may have
- * a different color from the rest of the rectangle.
- */
-
-#define LOG_TAG "hwcStressTest"
-
-#include <algorithm>
-#include <assert.h>
-#include <cerrno>
-#include <cmath>
-#include <cstdlib>
-#include <ctime>
-#include <libgen.h>
-#include <sched.h>
-#include <sstream>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <vector>
-
-#include <sys/syscall.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <utils/Log.h>
-#include <testUtil.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <glTestLib.h>
-#include "hwcTestLib.h"
-
-using namespace std;
-using namespace android;
-
-const float maxSizeRatio = 1.3;  // Graphic buffers can be upto this munch
-                                 // larger than the default screen size
-const unsigned int passesPerGroup = 10; // A group of passes all use the same
-                                        // graphic buffers
-
-// Ratios at which rare and frequent conditions should be produced
-const float rareRatio = 0.1;
-const float freqRatio = 0.9;
-
-// Defaults for command-line options
-const bool defaultVerbose = false;
-const unsigned int defaultStartPass = 0;
-const unsigned int defaultEndPass = 99999;
-const unsigned int defaultPerPassNumSet = 10;
-const float defaultPerSetDelay = 0.0; // Default delay after each set
-                                      // operation.  Default delay of
-                                      // zero used so as to perform the
-                                      // the set operations as quickly
-                                      // as possible.
-const float defaultEndDelay = 2.0; // Default delay between completion of
-                                   // final pass and restart of framework
-const float defaultDuration = FLT_MAX; // A fairly long time, so that
-                                       // range of passes will have
-                                       // precedence
-
-// Command-line option settings
-static bool verbose = defaultVerbose;
-static unsigned int startPass = defaultStartPass;
-static unsigned int endPass = defaultEndPass;
-static unsigned int numSet = defaultPerPassNumSet;
-static float perSetDelay = defaultPerSetDelay;
-static float endDelay = defaultEndDelay;
-static float duration = defaultDuration;
-
-// Command-line mutual exclusion detection flags.
-// Corresponding flag set true once an option is used.
-bool eFlag, sFlag, pFlag;
-
-#define MAXSTR               100
-#define MAXCMD               200
-#define BITSPERBYTE            8 // TODO: Obtain from <values.h>, once
-                                 // it has been added
-
-#define CMD_STOP_FRAMEWORK   "stop 2>&1"
-#define CMD_START_FRAMEWORK  "start 2>&1"
-
-#define NUMA(a) (sizeof(a) / sizeof((a)[0]))
-#define MEMCLR(addr, size) do { \
-        memset((addr), 0, (size)); \
-    } while (0)
-
-// File scope constants
-const unsigned int blendingOps[] = {
-    HWC_BLENDING_NONE,
-    HWC_BLENDING_PREMULT,
-    HWC_BLENDING_COVERAGE,
-};
-const unsigned int layerFlags[] = {
-    HWC_SKIP_LAYER,
-};
-const vector<unsigned int> vecLayerFlags(layerFlags,
-    layerFlags + NUMA(layerFlags));
-
-const unsigned int transformFlags[] = {
-    HWC_TRANSFORM_FLIP_H,
-    HWC_TRANSFORM_FLIP_V,
-    HWC_TRANSFORM_ROT_90,
-    // ROT_180 & ROT_270 intentionally not listed, because they
-    // they are formed from combinations of the flags already listed.
-};
-const vector<unsigned int> vecTransformFlags(transformFlags,
-    transformFlags + NUMA(transformFlags));
-
-// File scope globals
-static const int texUsage = GraphicBuffer::USAGE_HW_TEXTURE |
-        GraphicBuffer::USAGE_SW_WRITE_RARELY;
-static hwc_composer_device_1_t *hwcDevice;
-static EGLDisplay dpy;
-static EGLSurface surface;
-static EGLint width, height;
-static vector <vector <sp<GraphicBuffer> > > frames;
-
-// File scope prototypes
-void init(void);
-void initFrames(unsigned int seed);
-template <class T> vector<T> vectorRandSelect(const vector<T>& vec, size_t num);
-template <class T> T vectorOr(const vector<T>& vec);
-
-/*
- * Main
- *
- * Performs the following high-level sequence of operations:
- *
- *   1. Command-line parsing
- *
- *   2. Initialization
- *
- *   3. For each pass:
- *
- *        a. If pass is first pass or in a different group from the
- *           previous pass, initialize the array of graphic buffers.
- *
- *        b. Create a HWC list with room to specify a prandomly
- *           selected number of layers.
- *
- *        c. Select a subset of the rows from the graphic buffer array,
- *           such that there is a unique row to be used for each
- *           of the layers in the HWC list.
- *
- *        d. Prandomly fill in the HWC list with handles
- *           selected from any of the columns of the selected row.
- *
- *        e. Pass the populated list to the HWC prepare call.
- *
- *        f. Pass the populated list to the HWC set call.
- *
- *        g. If additional set calls are to be made, then for each
- *           additional set call, select a new set of handles and
- *           perform the set call.
- */
-int
-main(int argc, char *argv[])
-{
-    int rv, opt;
-    char *chptr;
-    unsigned int pass;
-    char cmd[MAXCMD];
-    struct timeval startTime, currentTime, delta;
-
-    testSetLogCatTag(LOG_TAG);
-
-    // Parse command line arguments
-    while ((opt = getopt(argc, argv, "vp:d:D:n:s:e:t:?h")) != -1) {
-        switch (opt) {
-          case 'd': // Delay after each set operation
-            perSetDelay = strtod(optarg, &chptr);
-            if ((*chptr != '\0') || (perSetDelay < 0.0)) {
-                testPrintE("Invalid command-line specified per pass delay of: "
-                           "%s", optarg);
-                exit(1);
-            }
-            break;
-
-          case 'D': // End of test delay
-                    // Delay between completion of final pass and restart
-                    // of framework
-            endDelay = strtod(optarg, &chptr);
-            if ((*chptr != '\0') || (endDelay < 0.0)) {
-                testPrintE("Invalid command-line specified end of test delay "
-                           "of: %s", optarg);
-                exit(2);
-            }
-            break;
-
-          case 't': // Duration
-            duration = strtod(optarg, &chptr);
-            if ((*chptr != '\0') || (duration < 0.0)) {
-                testPrintE("Invalid command-line specified duration of: %s",
-                           optarg);
-                exit(3);
-            }
-            break;
-
-          case 'n': // Num set operations per pass
-            numSet = strtoul(optarg, &chptr, 10);
-            if (*chptr != '\0') {
-                testPrintE("Invalid command-line specified num set per pass "
-                           "of: %s", optarg);
-                exit(4);
-            }
-            break;
-
-          case 's': // Starting Pass
-            sFlag = true;
-            if (pFlag) {
-                testPrintE("Invalid combination of command-line options.");
-                testPrintE("  The -p option is mutually exclusive from the");
-                testPrintE("  -s and -e options.");
-                exit(5);
-            }
-            startPass = strtoul(optarg, &chptr, 10);
-            if (*chptr != '\0') {
-                testPrintE("Invalid command-line specified starting pass "
-                           "of: %s", optarg);
-                exit(6);
-            }
-            break;
-
-          case 'e': // Ending Pass
-            eFlag = true;
-            if (pFlag) {
-                testPrintE("Invalid combination of command-line options.");
-                testPrintE("  The -p option is mutually exclusive from the");
-                testPrintE("  -s and -e options.");
-                exit(7);
-            }
-            endPass = strtoul(optarg, &chptr, 10);
-            if (*chptr != '\0') {
-                testPrintE("Invalid command-line specified ending pass "
-                           "of: %s", optarg);
-                exit(8);
-            }
-            break;
-
-          case 'p': // Run a single specified pass
-            pFlag = true;
-            if (sFlag || eFlag) {
-                testPrintE("Invalid combination of command-line options.");
-                testPrintE("  The -p option is mutually exclusive from the");
-                testPrintE("  -s and -e options.");
-                exit(9);
-            }
-            startPass = endPass = strtoul(optarg, &chptr, 10);
-            if (*chptr != '\0') {
-                testPrintE("Invalid command-line specified pass of: %s",
-                           optarg);
-                exit(10);
-            }
-            break;
-
-          case 'v': // Verbose
-            verbose = true;
-            break;
-
-          case 'h': // Help
-          case '?':
-          default:
-            testPrintE("  %s [options]", basename(argv[0]));
-            testPrintE("    options:");
-            testPrintE("      -p Execute specified pass");
-            testPrintE("      -s Starting pass");
-            testPrintE("      -e Ending pass");
-            testPrintE("      -t Duration");
-            testPrintE("      -d Delay after each set operation");
-            testPrintE("      -D End of test delay");
-            testPrintE("      -n Num set operations per pass");
-            testPrintE("      -v Verbose");
-            exit(((optopt == 0) || (optopt == '?')) ? 0 : 11);
-        }
-    }
-    if (endPass < startPass) {
-        testPrintE("Unexpected ending pass before starting pass");
-        testPrintE("  startPass: %u endPass: %u", startPass, endPass);
-        exit(12);
-    }
-    if (argc != optind) {
-        testPrintE("Unexpected command-line postional argument");
-        testPrintE("  %s [-s start_pass] [-e end_pass] [-t duration]",
-            basename(argv[0]));
-        exit(13);
-    }
-    testPrintI("duration: %g", duration);
-    testPrintI("startPass: %u", startPass);
-    testPrintI("endPass: %u", endPass);
-    testPrintI("numSet: %u", numSet);
-
-    // Stop framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_STOP_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_STOP_FRAMEWORK);
-        exit(14);
-    }
-    testExecCmd(cmd);
-    testDelay(1.0); // TODO - need means to query whether asyncronous stop
-                    // framework operation has completed.  For now, just wait
-                    // a long time.
-
-    init();
-
-    // For each pass
-    gettimeofday(&startTime, NULL);
-    for (pass = startPass; pass <= endPass; pass++) {
-        // Stop if duration of work has already been performed
-        gettimeofday(&currentTime, NULL);
-        delta = tvDelta(&startTime, &currentTime);
-        if (tv2double(&delta) > duration) { break; }
-
-        // Regenerate a new set of test frames when this pass is
-        // either the first pass or is in a different group then
-        // the previous pass.  A group of passes are passes that
-        // all have the same quotient when their pass number is
-        // divided by passesPerGroup.
-        if ((pass == startPass)
-            || ((pass / passesPerGroup) != ((pass - 1) / passesPerGroup))) {
-            initFrames(pass / passesPerGroup);
-        }
-
-        testPrintI("==== Starting pass: %u", pass);
-
-        // Cause deterministic sequence of prandom numbers to be
-        // generated for this pass.
-        srand48(pass);
-
-        hwc_display_contents_1_t *list;
-        list = hwcTestCreateLayerList(testRandMod(frames.size()) + 1);
-        if (list == NULL) {
-            testPrintE("hwcTestCreateLayerList failed");
-            exit(20);
-        }
-
-        // Prandomly select a subset of frames to be used by this pass.
-        vector <vector <sp<GraphicBuffer> > > selectedFrames;
-        selectedFrames = vectorRandSelect(frames, list->numHwLayers);
-
-        // Any transform tends to create a layer that the hardware
-        // composer is unable to support and thus has to leave for
-        // SurfaceFlinger.  Place heavy bias on specifying no transforms.
-        bool noTransform = testRandFract() > rareRatio;
-
-        for (unsigned int n1 = 0; n1 < list->numHwLayers; n1++) {
-            unsigned int idx = testRandMod(selectedFrames[n1].size());
-            sp<GraphicBuffer> gBuf = selectedFrames[n1][idx];
-            hwc_layer_1_t *layer = &list->hwLayers[n1];
-            layer->handle = gBuf->handle;
-
-            layer->blending = blendingOps[testRandMod(NUMA(blendingOps))];
-            layer->flags = (testRandFract() > rareRatio) ? 0
-                : vectorOr(vectorRandSelect(vecLayerFlags,
-                           testRandMod(vecLayerFlags.size() + 1)));
-            layer->transform = (noTransform || testRandFract() > rareRatio) ? 0
-                : vectorOr(vectorRandSelect(vecTransformFlags,
-                           testRandMod(vecTransformFlags.size() + 1)));
-            layer->sourceCrop.left = testRandMod(gBuf->getWidth());
-            layer->sourceCrop.top = testRandMod(gBuf->getHeight());
-            layer->sourceCrop.right = layer->sourceCrop.left
-                + testRandMod(gBuf->getWidth() - layer->sourceCrop.left) + 1;
-            layer->sourceCrop.bottom = layer->sourceCrop.top
-                + testRandMod(gBuf->getHeight() - layer->sourceCrop.top) + 1;
-            layer->displayFrame.left = testRandMod(width);
-            layer->displayFrame.top = testRandMod(height);
-            layer->displayFrame.right = layer->displayFrame.left
-                + testRandMod(width - layer->displayFrame.left) + 1;
-            layer->displayFrame.bottom = layer->displayFrame.top
-                + testRandMod(height - layer->displayFrame.top) + 1;
-
-            // Increase the frequency that a scale factor of 1.0 from
-            // the sourceCrop to displayFrame occurs.  This is the
-            // most common scale factor used by applications and would
-            // be rarely produced by this stress test without this
-            // logic.
-            if (testRandFract() <= freqRatio) {
-                // Only change to scale factor to 1.0 if both the
-                // width and height will fit.
-                int sourceWidth = layer->sourceCrop.right
-                                  - layer->sourceCrop.left;
-                int sourceHeight = layer->sourceCrop.bottom
-                                   - layer->sourceCrop.top;
-                if (((layer->displayFrame.left + sourceWidth) <= width)
-                    && ((layer->displayFrame.top + sourceHeight) <= height)) {
-                    layer->displayFrame.right = layer->displayFrame.left
-                                                + sourceWidth;
-                    layer->displayFrame.bottom = layer->displayFrame.top
-                                                 + sourceHeight;
-                }
-            }
-
-            layer->visibleRegionScreen.numRects = 1;
-            layer->visibleRegionScreen.rects = &layer->displayFrame;
-        }
-
-        // Perform prepare operation
-        if (verbose) { testPrintI("Prepare:"); hwcTestDisplayList(list); }
-        hwcDevice->prepare(hwcDevice, 1, &list);
-        if (verbose) {
-            testPrintI("Post Prepare:");
-            hwcTestDisplayListPrepareModifiable(list);
-        }
-
-        // Turn off the geometry changed flag
-        list->flags &= ~HWC_GEOMETRY_CHANGED;
-
-        // Perform the set operation(s)
-        if (verbose) {testPrintI("Set:"); }
-        for (unsigned int n1 = 0; n1 < numSet; n1++) {
-            if (verbose) { hwcTestDisplayListHandles(list); }
-            list->dpy = dpy;
-            list->sur = surface;
-            hwcDevice->set(hwcDevice, 1, &list);
-
-            // Prandomly select a new set of handles
-            for (unsigned int n1 = 0; n1 < list->numHwLayers; n1++) {
-                unsigned int idx = testRandMod(selectedFrames[n1].size());
-                sp<GraphicBuffer> gBuf = selectedFrames[n1][idx];
-                hwc_layer_1_t *layer = &list->hwLayers[n1];
-                layer->handle = (native_handle_t *) gBuf->handle;
-            }
-
-            testDelay(perSetDelay);
-        }
-
-        hwcTestFreeLayerList(list);
-        testPrintI("==== Completed pass: %u", pass);
-    }
-
-    testDelay(endDelay);
-
-    // Start framework
-    rv = snprintf(cmd, sizeof(cmd), "%s", CMD_START_FRAMEWORK);
-    if (rv >= (signed) sizeof(cmd) - 1) {
-        testPrintE("Command too long for: %s", CMD_START_FRAMEWORK);
-        exit(21);
-    }
-    testExecCmd(cmd);
-
-    testPrintI("Successfully completed %u passes", pass - startPass);
-
-    return 0;
-}
-
-void init(void)
-{
-    srand48(0); // Defensively set pseudo random number generator.
-                // Should not need to set this, because a stress test
-                // sets the seed on each pass.  Defensively set it here
-                // so that future code that uses pseudo random numbers
-                // before the first pass will be deterministic.
-
-    hwcTestInitDisplay(verbose, &dpy, &surface, &width, &height);
-
-    hwcTestOpenHwc(&hwcDevice);
-}
-
-/*
- * Initialize Frames
- *
- * Creates an array of graphic buffers, within the global variable
- * named frames.  The graphic buffers are contained within a vector of
- * vectors.  All the graphic buffers in a particular row are of the same
- * format and dimension.  Each graphic buffer is uniformly filled with a
- * prandomly selected color.  It is likely that each buffer, even
- * in the same row, will be filled with a unique color.
- */
-void initFrames(unsigned int seed)
-{
-    int rv;
-    const size_t maxRows = 5;
-    const size_t minCols = 2;  // Need at least double buffering
-    const size_t maxCols = 4;  // One more than triple buffering
-
-    if (verbose) { testPrintI("initFrames seed: %u", seed); }
-    srand48(seed);
-    size_t rows = testRandMod(maxRows) + 1;
-
-    frames.clear();
-    frames.resize(rows);
-
-    for (unsigned int row = 0; row < rows; row++) {
-        // All frames within a row have to have the same format and
-        // dimensions.  Width and height need to be >= 1.
-        unsigned int formatIdx = testRandMod(NUMA(hwcTestGraphicFormat));
-        const struct hwcTestGraphicFormat *formatPtr
-            = &hwcTestGraphicFormat[formatIdx];
-        int format = formatPtr->format;
-
-        // Pick width and height, which must be >= 1 and the size
-        // mod the wMod/hMod value must be equal to 0.
-        size_t w = (width * maxSizeRatio) * testRandFract();
-        size_t h = (height * maxSizeRatio) * testRandFract();
-        w = max(size_t(1u), w);
-        h = max(size_t(1u), h);
-        if ((w % formatPtr->wMod) != 0) {
-            w += formatPtr->wMod - (w % formatPtr->wMod);
-        }
-        if ((h % formatPtr->hMod) != 0) {
-            h += formatPtr->hMod - (h % formatPtr->hMod);
-        }
-        if (verbose) {
-            testPrintI("  frame %u width: %u height: %u format: %u %s",
-                       row, w, h, format, hwcTestGraphicFormat2str(format));
-        }
-
-        size_t cols = testRandMod((maxCols + 1) - minCols) + minCols;
-        frames[row].resize(cols);
-        for (unsigned int col = 0; col < cols; col++) {
-            ColorFract color(testRandFract(), testRandFract(), testRandFract());
-            float alpha = testRandFract();
-
-            frames[row][col] = new GraphicBuffer(w, h, format, texUsage);
-            if ((rv = frames[row][col]->initCheck()) != NO_ERROR) {
-                testPrintE("GraphicBuffer initCheck failed, rv: %i", rv);
-                testPrintE("  frame %u width: %u height: %u format: %u %s",
-                           row, w, h, format, hwcTestGraphicFormat2str(format));
-                exit(80);
-            }
-
-            hwcTestFillColor(frames[row][col].get(), color, alpha);
-            if (verbose) {
-                testPrintI("    buf: %p handle: %p color: %s alpha: %f",
-                           frames[row][col].get(), frames[row][col]->handle,
-                           string(color).c_str(), alpha);
-            }
-        }
-    }
-}
-
-/*
- * Vector Random Select
- *
- * Prandomly selects and returns num elements from vec.
- */
-template <class T>
-vector<T> vectorRandSelect(const vector<T>& vec, size_t num)
-{
-    vector<T> rv = vec;
-
-    while (rv.size() > num) {
-        rv.erase(rv.begin() + testRandMod(rv.size()));
-    }
-
-    return rv;
-}
-
-/*
- * Vector Or
- *
- * Or's togethen the values of each element of vec and returns the result.
- */
-template <class T>
-T vectorOr(const vector<T>& vec)
-{
-    T rv = 0;
-
-    for (size_t n1 = 0; n1 < vec.size(); n1++) {
-        rv |= vec[n1];
-    }
-
-    return rv;
-}
diff --git a/opengl/tests/hwc/hwcTestLib.cpp b/opengl/tests/hwc/hwcTestLib.cpp
deleted file mode 100644
index 3b0ca744bd..0000000000
--- a/opengl/tests/hwc/hwcTestLib.cpp
+++ /dev/null
@@ -1,1015 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-/*
- * Hardware Composer Test Library
- * Utility library functions for use by the Hardware Composer test cases
- */
-
-#include <arpa/inet.h> // For ntohl() and htonl()
-
-#include <cmath>
-#include <sstream>
-#include <string>
-
-#include "hwcTestLib.h"
-
-#include "EGLUtils.h"
-
-// Defines
-#define NUMA(a) (sizeof(a) / sizeof((a)[0]))
-
-// Function Prototypes
-static void printGLString(const char *name, GLenum s);
-static void checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE);
-static void printEGLConfiguration(EGLDisplay dpy, EGLConfig config);
-
-using namespace std;
-using namespace android;
-
-
-#define BITSPERBYTE            8 // TODO: Obtain from <values.h>, once
-                                 // it has been added
-
-// Initialize Display
-void hwcTestInitDisplay(bool verbose, EGLDisplay *dpy, EGLSurface *surface,
-    EGLint *width, EGLint *height)
-{
-    static EGLContext context;
-
-    EGLBoolean returnValue;
-    EGLConfig myConfig = {0};
-    EGLint contextAttribs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
-    EGLint sConfigAttribs[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_NONE };
-    EGLint majorVersion, minorVersion;
-
-    checkEglError("<init>");
-    *dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    checkEglError("eglGetDisplay");
-    if (*dpy == EGL_NO_DISPLAY) {
-        testPrintE("eglGetDisplay returned EGL_NO_DISPLAY");
-        exit(70);
-    }
-
-    returnValue = eglInitialize(*dpy, &majorVersion, &minorVersion);
-    checkEglError("eglInitialize", returnValue);
-    if (verbose) {
-        testPrintI("EGL version %d.%d", majorVersion, minorVersion);
-    }
-    if (returnValue != EGL_TRUE) {
-        testPrintE("eglInitialize failed");
-        exit(71);
-    }
-
-    // The tests want to stop the framework and play with the hardware
-    // composer, which means it doesn't make sense to use WindowSurface
-    // here.  android_createDisplaySurface() is going away, so just
-    // politely fail here.
-    EGLNativeWindowType window = NULL; //android_createDisplaySurface();
-    if (window == NULL) {
-        testPrintE("android_createDisplaySurface failed");
-        exit(72);
-    }
-    returnValue = EGLUtils::selectConfigForNativeWindow(*dpy,
-        sConfigAttribs, window, &myConfig);
-    if (returnValue) {
-        testPrintE("EGLUtils::selectConfigForNativeWindow() returned %d",
-            returnValue);
-        exit(73);
-    }
-    checkEglError("EGLUtils::selectConfigForNativeWindow");
-
-    if (verbose) {
-        testPrintI("Chose this configuration:");
-        printEGLConfiguration(*dpy, myConfig);
-    }
-
-    *surface = eglCreateWindowSurface(*dpy, myConfig, window, NULL);
-    checkEglError("eglCreateWindowSurface");
-    if (*surface == EGL_NO_SURFACE) {
-        testPrintE("gelCreateWindowSurface failed.");
-        exit(74);
-    }
-
-    context = eglCreateContext(*dpy, myConfig, EGL_NO_CONTEXT, contextAttribs);
-    checkEglError("eglCreateContext");
-    if (context == EGL_NO_CONTEXT) {
-        testPrintE("eglCreateContext failed");
-        exit(75);
-    }
-    returnValue = eglMakeCurrent(*dpy, *surface, *surface, context);
-    checkEglError("eglMakeCurrent", returnValue);
-    if (returnValue != EGL_TRUE) {
-        testPrintE("eglMakeCurrent failed");
-        exit(76);
-    }
-    eglQuerySurface(*dpy, *surface, EGL_WIDTH, width);
-    checkEglError("eglQuerySurface");
-    eglQuerySurface(*dpy, *surface, EGL_HEIGHT, height);
-    checkEglError("eglQuerySurface");
-
-    if (verbose) {
-        testPrintI("Window dimensions: %d x %d", *width, *height);
-
-        printGLString("Version", GL_VERSION);
-        printGLString("Vendor", GL_VENDOR);
-        printGLString("Renderer", GL_RENDERER);
-        printGLString("Extensions", GL_EXTENSIONS);
-    }
-}
-
-// Open Hardware Composer Device
-void hwcTestOpenHwc(hwc_composer_device_1_t **hwcDevicePtr)
-{
-    int rv;
-    hw_module_t const *hwcModule;
-
-    if ((rv = hw_get_module(HWC_HARDWARE_MODULE_ID, &hwcModule)) != 0) {
-        testPrintE("hw_get_module failed, rv: %i", rv);
-        errno = -rv;
-        perror(NULL);
-        exit(77);
-    }
-    if ((rv = hwc_open_1(hwcModule, hwcDevicePtr)) != 0) {
-        testPrintE("hwc_open failed, rv: %i", rv);
-        errno = -rv;
-        perror(NULL);
-        exit(78);
-    }
-}
-
-// Color fraction class to string conversion
-ColorFract::operator string()
-{
-    ostringstream out;
-
-    out << '[' << this->c1() << ", "
-        << this->c2() << ", "
-        << this->c3() << ']';
-
-    return out.str();
-}
-
-// Dimension class to string conversion
-HwcTestDim::operator string()
-{
-    ostringstream out;
-
-    out << '[' << this->width() << ", "
-        << this->height() << ']';
-
-    return out.str();
-}
-
-// Dimension class to hwc_rect conversion
-HwcTestDim::operator hwc_rect() const
-{
-    hwc_rect rect;
-
-    rect.left = rect.top = 0;
-
-    rect.right = this->_w;
-    rect.bottom = this->_h;
-
-    return rect;
-}
-
-// Hardware Composer rectangle to string conversion
-string hwcTestRect2str(const struct hwc_rect& rect)
-{
-    ostringstream out;
-
-    out << '[';
-    out << rect.left << ", ";
-    out << rect.top << ", ";
-    out << rect.right << ", ";
-    out << rect.bottom;
-    out << ']';
-
-    return out.str();
-}
-
-// Parse HWC rectangle description of form [left, top, right, bottom]
-struct hwc_rect hwcTestParseHwcRect(istringstream& in, bool& error)
-{
-    struct hwc_rect rect;
-    char chStart, ch;
-
-    // Defensively specify that an error occurred.  Will clear
-    // error flag if all of parsing succeeds.
-    error = true;
-
-    // First character should be a [ or <
-    in >> chStart;
-    if (!in || ((chStart != '<') && (chStart != '['))) { return rect; }
-
-    // Left
-    in >> rect.left;
-    if (!in) { return rect; }
-    in >> ch;
-    if (!in || (ch != ',')) { return rect; }
-
-    // Top
-    in >> rect.top;
-    if (!in) { return rect; }
-    in >> ch;
-    if (!in || (ch != ',')) { return rect; }
-
-    // Right
-    in >> rect.right;
-    if (!in) { return rect; }
-    in >> ch;
-    if (!in || (ch != ',')) { return rect; }
-
-    // Bottom
-    in >> rect.bottom;
-    if (!in) { return rect; }
-
-    // Closing > or ]
-    in >> ch;
-    if (!in) { return rect; }
-    if (((chStart == '<') && (ch != '>'))
-        || ((chStart == '[') && (ch != ']'))) { return rect; }
-
-    // Validate right and bottom are greater than left and top
-    if ((rect.right <= rect.left) || (rect.bottom <= rect.top)) { return rect; }
-
-    // Made It, clear error indicator
-    error = false;
-
-    return rect;
-}
-
-// Parse dimension of form [width, height]
-HwcTestDim hwcTestParseDim(istringstream& in, bool& error)
-{
-    HwcTestDim dim;
-    char chStart, ch;
-    uint32_t val;
-
-    // Defensively specify that an error occurred.  Will clear
-    // error flag if all of parsing succeeds.
-    error = true;
-
-    // First character should be a [ or <
-    in >> chStart;
-    if (!in || ((chStart != '<') && (chStart != '['))) { return dim; }
-
-    // Width
-    in >> val;
-    if (!in) { return dim; }
-    dim.setWidth(val);
-    in >> ch;
-    if (!in || (ch != ',')) { return dim; }
-
-    // Height
-    in >> val;
-    if (!in) { return dim; }
-    dim.setHeight(val);
-
-    // Closing > or ]
-    in >> ch;
-    if (!in) { return dim; }
-    if (((chStart == '<') && (ch != '>'))
-        || ((chStart == '[') && (ch != ']'))) { return dim; }
-
-    // Validate width and height greater than 0
-    if ((dim.width() <= 0) || (dim.height() <= 0)) { return dim; }
-
-    // Made It, clear error indicator
-    error = false;
-    return dim;
-}
-
-// Parse fractional color of form [0.##, 0.##, 0.##]
-// Fractional values can be from 0.0 to 1.0 inclusive.  Note, integer
-// values of 0.0 and 1.0, which are non-fractional, are considered valid.
-// They are an exception, all other valid inputs are fractions.
-ColorFract hwcTestParseColor(istringstream& in, bool& error)
-{
-    ColorFract color;
-    char chStart, ch;
-    float c1, c2, c3;
-
-    // Defensively specify that an error occurred.  Will clear
-    // error flag if all of parsing succeeds.
-    error = true;
-
-    // First character should be a [ or <
-    in >> chStart;
-    if (!in || ((chStart != '<') && (chStart != '['))) { return color; }
-
-    // 1st Component
-    in >> c1;
-    if (!in) { return color; }
-    if ((c1 < 0.0) || (c1 > 1.0)) { return color; }
-    in >> ch;
-    if (!in || (ch != ',')) { return color; }
-
-    // 2nd Component
-    in >> c2;
-    if (!in) { return color; }
-    if ((c2 < 0.0) || (c2 > 1.0)) { return color; }
-    in >> ch;
-    if (!in || (ch != ',')) { return color; }
-
-    // 3rd Component
-    in >> c3;
-    if (!in) { return color; }
-    if ((c3 < 0.0) || (c3 > 1.0)) { return color; }
-
-    // Closing > or ]
-    in >> ch;
-    if (!in) { return color; }
-    if (((chStart == '<') && (ch != '>'))
-        || ((chStart == '[') && (ch != ']'))) { return color; }
-
-    // Are all the components fractional
-    if ((c1 < 0.0) || (c1 > 1.0)
-        || (c2 < 0.0) || (c2 > 1.0)
-        || (c3 < 0.0) || (c3 > 1.0)) { return color; }
-
-    // Made It, clear error indicator
-    error = false;
-
-    return ColorFract(c1, c2, c3);
-}
-
-// Look up and return pointer to structure with the characteristics
-// of the graphic format named by the desc parameter.  Search failure
-// indicated by the return of NULL.
-const struct hwcTestGraphicFormat *hwcTestGraphicFormatLookup(const char *desc)
-{
-    for (unsigned int n1 = 0; n1 < NUMA(hwcTestGraphicFormat); n1++) {
-        if (string(desc) == string(hwcTestGraphicFormat[n1].desc)) {
-            return &hwcTestGraphicFormat[n1];
-        }
-    }
-
-    return NULL;
-}
-
-// Look up and return pointer to structure with the characteristics
-// of the graphic format specified by the id parameter.  Search failure
-// indicated by the return of NULL.
-const struct hwcTestGraphicFormat *hwcTestGraphicFormatLookup(uint32_t id)
-{
-    for (unsigned int n1 = 0; n1 < NUMA(hwcTestGraphicFormat); n1++) {
-        if (id == hwcTestGraphicFormat[n1].format) {
-            return &hwcTestGraphicFormat[n1];
-        }
-    }
-
-    return NULL;
-}
-
-
-// Given the integer ID of a graphic format, return a pointer to
-// a string that describes the format.
-const char *hwcTestGraphicFormat2str(uint32_t format)
-{
-    const static char *unknown = "unknown";
-
-    for (unsigned int n1 = 0; n1 < NUMA(hwcTestGraphicFormat); n1++) {
-        if (format == hwcTestGraphicFormat[n1].format) {
-            return hwcTestGraphicFormat[n1].desc;
-        }
-    }
-
-    return unknown;
-}
-
-/*
- * hwcTestCreateLayerList
- * Dynamically creates layer list with numLayers worth
- * of hwLayers entries.
- */
-hwc_display_contents_1_t *hwcTestCreateLayerList(size_t numLayers)
-{
-    hwc_display_contents_1_t *list;
-
-    size_t size = sizeof(hwc_display_contents_1_t) + numLayers * sizeof(hwc_layer_1_t);
-    if ((list = (hwc_display_contents_1_t *) calloc(1, size)) == NULL) {
-        return NULL;
-    }
-    list->flags = HWC_GEOMETRY_CHANGED;
-    list->numHwLayers = numLayers;
-
-    return list;
-}
-
-/*
- * hwcTestFreeLayerList
- * Frees memory previous allocated via hwcTestCreateLayerList().
- */
-void hwcTestFreeLayerList(hwc_display_contents_1_t *list)
-{
-    free(list);
-}
-
-// Display the settings of the layer list pointed to by list
-void hwcTestDisplayList(hwc_display_contents_1_t *list)
-{
-    testPrintI("  flags: %#x%s", list->flags,
-               (list->flags & HWC_GEOMETRY_CHANGED) ? " GEOMETRY_CHANGED" : "");
-    testPrintI("  numHwLayers: %u", list->numHwLayers);
-
-    for (unsigned int layer = 0; layer < list->numHwLayers; layer++) {
-        testPrintI("    layer %u compositionType: %#x%s%s", layer,
-                   list->hwLayers[layer].compositionType,
-                   (list->hwLayers[layer].compositionType == HWC_FRAMEBUFFER)
-                       ? " FRAMEBUFFER" : "",
-                   (list->hwLayers[layer].compositionType == HWC_OVERLAY)
-                       ? " OVERLAY" : "");
-
-        testPrintI("      hints: %#x",
-                   list->hwLayers[layer].hints,
-                   (list->hwLayers[layer].hints & HWC_HINT_TRIPLE_BUFFER)
-                       ? " TRIPLE_BUFFER" : "",
-                   (list->hwLayers[layer].hints & HWC_HINT_CLEAR_FB)
-                       ? " CLEAR_FB" : "");
-
-        testPrintI("      flags: %#x%s",
-                   list->hwLayers[layer].flags,
-                   (list->hwLayers[layer].flags & HWC_SKIP_LAYER)
-                       ? " SKIP_LAYER" : "");
-
-        testPrintI("      handle: %p",
-                   list->hwLayers[layer].handle);
-
-        // Intentionally skipped display of ROT_180 & ROT_270,
-        // which are formed from combinations of the other flags.
-        testPrintI("      transform: %#x%s%s%s",
-                   list->hwLayers[layer].transform,
-                   (list->hwLayers[layer].transform & HWC_TRANSFORM_FLIP_H)
-                       ? " FLIP_H" : "",
-                   (list->hwLayers[layer].transform & HWC_TRANSFORM_FLIP_V)
-                       ? " FLIP_V" : "",
-                   (list->hwLayers[layer].transform & HWC_TRANSFORM_ROT_90)
-                       ? " ROT_90" : "");
-
-        testPrintI("      blending: %#x%s%s%s",
-                   list->hwLayers[layer].blending,
-                   (list->hwLayers[layer].blending == HWC_BLENDING_NONE)
-                       ? " NONE" : "",
-                   (list->hwLayers[layer].blending == HWC_BLENDING_PREMULT)
-                       ? " PREMULT" : "",
-                   (list->hwLayers[layer].blending == HWC_BLENDING_COVERAGE)
-                       ? " COVERAGE" : "");
-
-        testPrintI("      sourceCrop: %s",
-                   hwcTestRect2str(list->hwLayers[layer].sourceCrop).c_str());
-        testPrintI("      displayFrame: %s",
-                   hwcTestRect2str(list->hwLayers[layer].displayFrame).c_str());
-        testPrintI("      scaleFactor: [%f, %f]",
-                   (float) (list->hwLayers[layer].sourceCrop.right
-                            - list->hwLayers[layer].sourceCrop.left)
-                       / (float) (list->hwLayers[layer].displayFrame.right
-                            - list->hwLayers[layer].displayFrame.left),
-                   (float) (list->hwLayers[layer].sourceCrop.bottom
-                            - list->hwLayers[layer].sourceCrop.top)
-                       / (float) (list->hwLayers[layer].displayFrame.bottom
-                            - list->hwLayers[layer].displayFrame.top));
-    }
-}
-
-/*
- * Display List Prepare Modifiable
- *
- * Displays the portions of a list that are meant to be modified by
- * a prepare call.
- */
-void hwcTestDisplayListPrepareModifiable(hwc_display_contents_1_t *list)
-{
-    uint32_t numOverlays = 0;
-    for (unsigned int layer = 0; layer < list->numHwLayers; layer++) {
-        if (list->hwLayers[layer].compositionType == HWC_OVERLAY) {
-            numOverlays++;
-        }
-        testPrintI("    layer %u compositionType: %#x%s%s", layer,
-                   list->hwLayers[layer].compositionType,
-                   (list->hwLayers[layer].compositionType == HWC_FRAMEBUFFER)
-                       ? " FRAMEBUFFER" : "",
-                   (list->hwLayers[layer].compositionType == HWC_OVERLAY)
-                       ? " OVERLAY" : "");
-        testPrintI("      hints: %#x%s%s",
-                   list->hwLayers[layer].hints,
-                   (list->hwLayers[layer].hints & HWC_HINT_TRIPLE_BUFFER)
-                       ? " TRIPLE_BUFFER" : "",
-                   (list->hwLayers[layer].hints & HWC_HINT_CLEAR_FB)
-                       ? " CLEAR_FB" : "");
-    }
-    testPrintI("    numOverlays: %u", numOverlays);
-}
-
-/*
- * Display List Handles
- *
- * Displays the handles of all the graphic buffers in the list.
- */
-void hwcTestDisplayListHandles(hwc_display_contents_1_t *list)
-{
-    const unsigned int maxLayersPerLine = 6;
-
-    ostringstream str("  layers:");
-    for (unsigned int layer = 0; layer < list->numHwLayers; layer++) {
-        str << ' ' << list->hwLayers[layer].handle;
-        if (((layer % maxLayersPerLine) == (maxLayersPerLine - 1))
-            && (layer != list->numHwLayers - 1)) {
-            testPrintI("%s", str.str().c_str());
-            str.str("    ");
-        }
-    }
-    testPrintI("%s", str.str().c_str());
-}
-
-// Returns a uint32_t that contains a format specific representation of a
-// single pixel of the given color and alpha values.
-uint32_t hwcTestColor2Pixel(uint32_t format, ColorFract color, float alpha)
-{
-    const struct attrib {
-        uint32_t format;
-        bool   hostByteOrder;
-        size_t bytes;
-        size_t c1Offset;
-        size_t c1Size;
-        size_t c2Offset;
-        size_t c2Size;
-        size_t c3Offset;
-        size_t c3Size;
-        size_t aOffset;
-        size_t aSize;
-    } attributes[] = {
-        {HAL_PIXEL_FORMAT_RGBA_8888, false, 4,  0, 8,  8, 8, 16, 8, 24, 8},
-        {HAL_PIXEL_FORMAT_RGBX_8888, false, 4,  0, 8,  8, 8, 16, 8,  0, 0},
-        {HAL_PIXEL_FORMAT_RGB_888,   false, 3,  0, 8,  8, 8, 16, 8,  0, 0},
-        {HAL_PIXEL_FORMAT_RGB_565,   true,  2,  0, 5,  5, 6, 11, 5,  0, 0},
-        {HAL_PIXEL_FORMAT_BGRA_8888, false, 4, 16, 8,  8, 8,  0, 8, 24, 8},
-        {HAL_PIXEL_FORMAT_YV12,      true,  3, 16, 8,  8, 8,  0, 8,  0, 0},  
-    };
-
-    const struct attrib *attrib;
-    for (attrib = attributes; attrib < attributes + NUMA(attributes);
-         attrib++) {
-        if (attrib->format == format) { break; }
-    }
-    if (attrib >= attributes + NUMA(attributes)) {
-        testPrintE("colorFract2Pixel unsupported format of: %u", format);
-        exit(80);
-    }
-
-    uint32_t pixel;
-    pixel = htonl((uint32_t) round((((1 << attrib->c1Size) - 1) * color.c1()))
-         << ((sizeof(pixel) * BITSPERBYTE)
-             - (attrib->c1Offset + attrib->c1Size)));
-    pixel |= htonl((uint32_t) round((((1 << attrib->c2Size) - 1) * color.c2()))
-         << ((sizeof(pixel) * BITSPERBYTE)
-             - (attrib->c2Offset + attrib->c2Size)));
-    pixel |= htonl((uint32_t) round((((1 << attrib->c3Size) - 1) * color.c3()))
-         << ((sizeof(pixel) * BITSPERBYTE)
-             - (attrib->c3Offset + attrib->c3Size)));
-    if (attrib->aSize) {
-        pixel |= htonl((uint32_t) round((((1 << attrib->aSize) - 1) * alpha))
-             << ((sizeof(pixel) * BITSPERBYTE)
-                 - (attrib->aOffset + attrib->aSize)));
-    }
-    if (attrib->hostByteOrder) {
-        pixel = ntohl(pixel);
-        pixel >>= sizeof(pixel) * BITSPERBYTE - attrib->bytes * BITSPERBYTE;
-    }
-
-    return pixel;
-}
-
-// Sets the pixel at the given x and y coordinates to the color and alpha
-// value given by pixel.  The contents of pixel is format specific.  It's
-// value should come from a call to hwcTestColor2Pixel().
-void hwcTestSetPixel(GraphicBuffer *gBuf, unsigned char *buf,
-              uint32_t x, uint32_t y, uint32_t pixel)
-{
-
-    const struct attrib {
-        int format;
-        size_t bytes;
-    } attributes[] = {
-        {HAL_PIXEL_FORMAT_RGBA_8888,  4},
-        {HAL_PIXEL_FORMAT_RGBX_8888,  4},
-        {HAL_PIXEL_FORMAT_RGB_888,    3},
-        {HAL_PIXEL_FORMAT_RGB_565,    2},
-        {HAL_PIXEL_FORMAT_BGRA_8888,  4},
-    };
-
-    if (gBuf->getPixelFormat() == HAL_PIXEL_FORMAT_YV12) {
-        uint32_t yPlaneOffset, uPlaneOffset, vPlaneOffset;
-        uint32_t yPlaneStride = gBuf->getStride();
-        uint32_t uPlaneStride = ((gBuf->getStride() / 2) + 0xf) & ~0xf;
-        uint32_t vPlaneStride = uPlaneStride;
-        yPlaneOffset = 0;
-        vPlaneOffset = yPlaneOffset + yPlaneStride * gBuf->getHeight();
-        uPlaneOffset = vPlaneOffset
-                       + vPlaneStride * (gBuf->getHeight() / 2);
-        *(buf + yPlaneOffset + y * yPlaneStride + x) = pixel & 0xff;
-        *(buf + uPlaneOffset + (y / 2) * uPlaneStride + (x / 2))
-            = (pixel & 0xff00) >> 8;
-        *(buf + vPlaneOffset + (y / 2) * vPlaneStride + (x / 2))
-            = (pixel & 0xff0000) >> 16;
-
-        return;
-    }
-
-    const struct attrib *attrib;
-    for (attrib = attributes; attrib < attributes + NUMA(attributes);
-         attrib++) {
-        if (attrib->format == gBuf->getPixelFormat()) { break; }
-    }
-    if (attrib >= attributes + NUMA(attributes)) {
-        testPrintE("setPixel unsupported format of: %u",
-                   gBuf->getPixelFormat());
-        exit(90);
-    }
-
-    memmove(buf + ((gBuf->getStride() * attrib->bytes) * y)
-            + (attrib->bytes * x), &pixel, attrib->bytes);
-}
-
-// Fill a given graphic buffer with a uniform color and alpha
-void hwcTestFillColor(GraphicBuffer *gBuf, ColorFract color, float alpha)
-{
-    unsigned char* buf = NULL;
-    status_t err;
-    uint32_t pixel;
-
-    pixel = hwcTestColor2Pixel(gBuf->getPixelFormat(), color, alpha);
-
-    err = gBuf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&buf));
-    if (err != 0) {
-        testPrintE("hwcTestFillColor lock failed: %d", err);
-        exit(100);
-    }
-
-    for (unsigned int x = 0; x < gBuf->getStride(); x++) {
-        for (unsigned int y = 0; y < gBuf->getHeight(); y++) {
-            hwcTestSetPixel(gBuf, buf, x, y, (x < gBuf->getWidth())
-                            ? pixel : testRand());
-        }
-    }
-
-    err = gBuf->unlock();
-    if (err != 0) {
-        testPrintE("hwcTestFillColor unlock failed: %d", err);
-        exit(101);
-    }
-}
-
-// Fill the given buffer with a horizontal blend of colors, with the left
-// side color given by startColor and the right side color given by
-// endColor.  The startColor and endColor values are specified in the format
-// given by colorFormat, which might be different from the format of the
-// graphic buffer.  When different, a color conversion is done when possible
-// to the graphic format of the graphic buffer.  A color of black is
-// produced for cases where the conversion is impossible (e.g. out of gamut
-// values).
-void hwcTestFillColorHBlend(GraphicBuffer *gBuf, uint32_t colorFormat,
-                            ColorFract startColor, ColorFract endColor)
-{
-    status_t err;
-    unsigned char* buf = NULL;
-    const uint32_t width = gBuf->getWidth();
-    const uint32_t height = gBuf->getHeight();
-    const uint32_t stride = gBuf->getStride();
-
-    err = gBuf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&buf));
-    if (err != 0) {
-        testPrintE("hwcTestFillColorHBlend lock failed: %d", err);
-        exit(110);
-    }
-
-    for (unsigned int x = 0; x < stride; x++) {
-        uint32_t pixel;
-        if (x < width) {
-            ColorFract color(startColor.c1() + (endColor.c1() - startColor.c1())
-                                 * ((float) x / (float) (width - 1)),
-                             startColor.c2() + (endColor.c2() - startColor.c2())
-                                 * ((float) x / (float) (width - 1)),
-                             startColor.c3() + (endColor.c3() - startColor.c3())
-                                 * ((float) x / (float) (width - 1)));
-
-            // When formats differ, convert colors.
-            // Important to not convert when formats are the same, since
-            // out of gamut colors are always converted to black.
-            if (colorFormat != (uint32_t) gBuf->getPixelFormat()) {
-                hwcTestColorConvert(colorFormat, gBuf->getPixelFormat(), color);
-            }
-            pixel = hwcTestColor2Pixel(gBuf->getPixelFormat(), color, 1.0);
-        } else {
-            // Fill pad with random values
-            pixel = testRand();
-        }
-
-        for (unsigned int y = 0; y < height; y++) {
-            hwcTestSetPixel(gBuf, buf, x, y, pixel);
-        }
-    }
-
-    err = gBuf->unlock();
-    if (err != 0) {
-        testPrintE("hwcTestFillColorHBlend unlock failed: %d", err);
-        exit(111);
-    }
-}
-
-/*
- * When possible, converts color specified as a full range value in
- * the fromFormat, into an equivalent full range color in the toFormat.
- * When conversion is impossible (e.g. out of gamut color) a color
- * or black in the full range output format is produced.  The input
- * color is given as a fractional color in the parameter named color.
- * The produced color is written over the same parameter used to
- * provide the input color.
- *
- * Each graphic format has 3 color components and each of these
- * components has both a full and in gamut range.  This function uses
- * a table that provides the full and in gamut ranges of each of the
- * supported graphic formats.  The full range is given by members named
- * c[123]Min to c[123]Max, while the in gamut range is given by members
- * named c[123]Low to c[123]High.  In most cases the full and in gamut
- * ranges are equivalent.  This occurs when the c[123]Min == c[123]Low and
- * c[123]High == c[123]Max.
- *
- * The input and produced colors are both specified as a fractional amount
- * of the full range.  The diagram below provides an overview of the
- * conversion process.  The main steps are:
- *
- *   1. Produce black if the input color is out of gamut.
- *
- *   2. Convert the in gamut color into the fraction of the fromFromat
- *      in gamut range.
- *
- *   3. Convert from the fraction of the in gamut from format range to
- *      the fraction of the in gamut to format range.  Produce black
- *      if an equivalent color does not exists.
- *
- *   4. Covert from the fraction of the in gamut to format to the
- *      fraction of the full range to format.
- *
- *       From Format                 To Format
- *    max           high            high        max
- *    ----+                 +-----------+
- *    high \               /             \      high
- *    ------\-------------+               +-------->
- *           \
- *            \                   +--- black --+
- *             \                 /              \
- *              \               /                +-->
- *    low        \             /                  low
- *    -------- ---+-- black --+
- *    min             low           low           min
- *     ^               ^      ^      ^             ^
- *     |               |      |      |             |
- *     |               |      |      |             +-- fraction of full range
- *     |               |      |      +-- fraction of valid range
- *     |               |      +-- fromFormat to toFormat color conversion
- *     |               +-- fraction of valid range
- *     +-- fraction of full range
- */
-void hwcTestColorConvert(uint32_t fromFormat, uint32_t toFormat,
-                  ColorFract& color)
-{
-    const struct attrib {
-        uint32_t     format;
-        bool         rgb;
-        bool         yuv;
-        int          c1Min, c1Low, c1High, c1Max;
-        int          c2Min, c2Low, c2High, c2Max;
-        int          c3Min, c3Low, c3High, c3Max;
-    } attributes[] = {
-        {HAL_PIXEL_FORMAT_RGBA_8888, true,  false,
-         0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255},
-        {HAL_PIXEL_FORMAT_RGBX_8888, true,  false,
-         0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255},
-        {HAL_PIXEL_FORMAT_RGB_888,   true,  false,
-         0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255},
-        {HAL_PIXEL_FORMAT_RGB_565,   true,  false,
-         0, 0, 31, 31, 0, 0, 63, 63, 0, 0, 31, 31},
-        {HAL_PIXEL_FORMAT_BGRA_8888, true,  false,
-         0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255},
-        {HAL_PIXEL_FORMAT_YV12,      false, true,
-         0, 16, 235, 255, 0, 16, 240, 255, 0, 16, 240, 255},
-    };
-
-    const struct attrib *fromAttrib;
-    for (fromAttrib = attributes; fromAttrib < attributes + NUMA(attributes);
-         fromAttrib++) {
-        if (fromAttrib->format == fromFormat) { break; }
-    }
-    if (fromAttrib >= attributes + NUMA(attributes)) {
-        testPrintE("hwcTestColorConvert unsupported from format of: %u",
-                   fromFormat);
-        exit(120);
-    }
-
-    const struct attrib *toAttrib;
-    for (toAttrib = attributes; toAttrib < attributes + NUMA(attributes);
-         toAttrib++) {
-        if (toAttrib->format == toFormat) { break; }
-    }
-    if (toAttrib >= attributes + NUMA(attributes)) {
-        testPrintE("hwcTestColorConvert unsupported to format of: %u",
-                   toFormat);
-        exit(121);
-    }
-
-    // Produce black if any of the from components are outside the
-    // valid color range
-    float c1Val = fromAttrib->c1Min
-        + ((float) (fromAttrib->c1Max - fromAttrib->c1Min) * color.c1());
-    float c2Val = fromAttrib->c2Min
-        + ((float) (fromAttrib->c2Max - fromAttrib->c2Min) * color.c2());
-    float c3Val = fromAttrib->c3Min
-        + ((float) (fromAttrib->c3Max - fromAttrib->c3Min) * color.c3());
-    if ((c1Val < fromAttrib->c1Low) || (c1Val > fromAttrib->c1High)
-        || (c2Val < fromAttrib->c2Low) || (c2Val > fromAttrib->c2High)
-        || (c3Val < fromAttrib->c3Low) || (c3Val > fromAttrib->c3High)) {
-
-        // Return black
-        // Will use representation of black from RGBA8888 graphic format
-        // and recursively convert it to the requested graphic format.
-        color = ColorFract(0.0, 0.0, 0.0);
-        hwcTestColorConvert(HAL_PIXEL_FORMAT_RGBA_8888, toFormat, color);
-        return;
-    }
-
-    // Within from format, convert from fraction of full range
-    // to fraction of valid range
-    color = ColorFract((c1Val - fromAttrib->c1Low)
-                           / (fromAttrib->c1High - fromAttrib->c1Low),
-                       (c2Val - fromAttrib->c2Low)
-                           / (fromAttrib->c2High - fromAttrib->c2Low),
-                       (c3Val - fromAttrib->c3Low)
-                           / (fromAttrib->c3High - fromAttrib->c3Low));
-
-    // If needed perform RGB to YUV conversion
-    float wr = 0.2126, wg = 0.7152, wb = 0.0722; // ITU709 recommended constants
-    if (fromAttrib->rgb && toAttrib->yuv) {
-        float r = color.c1(), g = color.c2(), b = color.c3();
-        float y = wr * r + wg * g + wb * b;
-        float u = 0.5 * ((b - y) / (1.0 - wb)) + 0.5;
-        float v = 0.5 * ((r - y) / (1.0 - wr)) + 0.5;
-
-        // Produce black if color is outside the YUV gamut
-        if ((y < 0.0) || (y > 1.0)
-            || (u < 0.0) || (u > 1.0)
-            || (v < 0.0) || (v > 1.0)) {
-            y = 0.0;
-            u = v = 0.5;
-        }
-
-        color = ColorFract(y, u, v);
-    }
-
-    // If needed perform YUV to RGB conversion
-    // Equations determined from the ITU709 equations for RGB to YUV
-    // conversion, plus the following algebra:
-    //
-    //   u = 0.5 * ((b - y) / (1.0 - wb)) + 0.5
-    //   0.5 * ((b - y) / (1.0 - wb)) = u - 0.5
-    //   (b - y) / (1.0 - wb) = 2 * (u - 0.5)
-    //   b - y = 2 * (u - 0.5) * (1.0 - wb)
-    //   b = 2 * (u - 0.5) * (1.0 - wb) + y
-    //
-    //   v = 0.5 * ((r -y) / (1.0 - wr)) + 0.5
-    //   0.5 * ((r - y) / (1.0 - wr)) = v - 0.5
-    //   (r - y) / (1.0 - wr) = 2 * (v - 0.5)
-    //   r - y = 2 * (v - 0.5) * (1.0 - wr)
-    //   r = 2 * (v - 0.5) * (1.0 - wr) + y
-    //
-    //   y = wr * r + wg * g + wb * b
-    //   wr * r + wg * g + wb * b = y
-    //   wg * g = y - wr * r - wb * b
-    //   g = (y - wr * r - wb * b) / wg
-    if (fromAttrib->yuv && toAttrib->rgb) {
-        float y = color.c1(), u = color.c2(), v = color.c3();
-        float r = 2.0 * (v - 0.5) * (1.0 - wr) + y;
-        float b = 2.0 * (u - 0.5) * (1.0 - wb) + y;
-        float g = (y - wr * r - wb * b) / wg;
-
-        // Produce black if color is outside the RGB gamut
-        if ((r < 0.0) || (r > 1.0)
-            || (g < 0.0) || (g > 1.0)
-            || (b < 0.0) || (b > 1.0)) {
-            r = g = b = 0.0;
-        }
-
-        color = ColorFract(r, g, b);
-    }
-
-    // Within to format, convert from fraction of valid range
-    // to fraction of full range
-    c1Val = (toAttrib->c1Low
-        + (float) (toAttrib->c1High - toAttrib->c1Low) * color.c1());
-    c2Val = (toAttrib->c1Low
-        + (float) (toAttrib->c2High - toAttrib->c2Low) * color.c2());
-    c3Val = (toAttrib->c1Low
-        + (float) (toAttrib->c3High - toAttrib->c3Low) * color.c3());
-    color = ColorFract((float) (c1Val - toAttrib->c1Min)
-                           / (float) (toAttrib->c1Max - toAttrib->c1Min),
-                       (float) (c2Val - toAttrib->c2Min)
-                           / (float) (toAttrib->c2Max - toAttrib->c2Min),
-                       (float) (c3Val - toAttrib->c3Min)
-                           / (float) (toAttrib->c3Max - toAttrib->c3Min));
-}
-
-// TODO: Use PrintGLString, CechckGlError, and PrintEGLConfiguration
-//       from libglTest
-static void printGLString(const char *name, GLenum s)
-{
-    const char *v = (const char *) glGetString(s);
-
-    if (v == NULL) {
-        testPrintI("GL %s unknown", name);
-    } else {
-        testPrintI("GL %s = %s", name, v);
-    }
-}
-
-static void checkEglError(const char* op, EGLBoolean returnVal)
-{
-    if (returnVal != EGL_TRUE) {
-        testPrintE("%s() returned %d", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        testPrintE("after %s() eglError %s (0x%x)",
-                   op, EGLUtils::strerror(error), error);
-    }
-}
-
-static void printEGLConfiguration(EGLDisplay dpy, EGLConfig config)
-{
-
-#define X(VAL) {VAL, #VAL}
-    struct {EGLint attribute; const char* name;} names[] = {
-    X(EGL_BUFFER_SIZE),
-    X(EGL_ALPHA_SIZE),
-    X(EGL_BLUE_SIZE),
-    X(EGL_GREEN_SIZE),
-    X(EGL_RED_SIZE),
-    X(EGL_DEPTH_SIZE),
-    X(EGL_STENCIL_SIZE),
-    X(EGL_CONFIG_CAVEAT),
-    X(EGL_CONFIG_ID),
-    X(EGL_LEVEL),
-    X(EGL_MAX_PBUFFER_HEIGHT),
-    X(EGL_MAX_PBUFFER_PIXELS),
-    X(EGL_MAX_PBUFFER_WIDTH),
-    X(EGL_NATIVE_RENDERABLE),
-    X(EGL_NATIVE_VISUAL_ID),
-    X(EGL_NATIVE_VISUAL_TYPE),
-    X(EGL_SAMPLES),
-    X(EGL_SAMPLE_BUFFERS),
-    X(EGL_SURFACE_TYPE),
-    X(EGL_TRANSPARENT_TYPE),
-    X(EGL_TRANSPARENT_RED_VALUE),
-    X(EGL_TRANSPARENT_GREEN_VALUE),
-    X(EGL_TRANSPARENT_BLUE_VALUE),
-    X(EGL_BIND_TO_TEXTURE_RGB),
-    X(EGL_BIND_TO_TEXTURE_RGBA),
-    X(EGL_MIN_SWAP_INTERVAL),
-    X(EGL_MAX_SWAP_INTERVAL),
-    X(EGL_LUMINANCE_SIZE),
-    X(EGL_ALPHA_MASK_SIZE),
-    X(EGL_COLOR_BUFFER_TYPE),
-    X(EGL_RENDERABLE_TYPE),
-    X(EGL_CONFORMANT),
-   };
-#undef X
-
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute,
-                                              &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            testPrintI(" %s: %d (%#x)", names[j].name, value, value);
-        }
-    }
-    testPrintI("");
-}
diff --git a/opengl/tests/hwc/hwcTestLib.h b/opengl/tests/hwc/hwcTestLib.h
deleted file mode 100644
index 922fc1990b..0000000000
--- a/opengl/tests/hwc/hwcTestLib.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-/*
- * Hardware Composer Test Library Header
- */
-
-#include <sstream>
-#include <string>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <utils/Log.h>
-#include <testUtil.h>
-
-#include <hardware/hwcomposer.h>
-
-// Characteristics of known graphic formats
-const struct hwcTestGraphicFormat {
-    uint32_t format;
-    const char *desc;
-    uint32_t wMod, hMod; // Width/height mod this value must equal zero
-} hwcTestGraphicFormat[] = {
-    {HAL_PIXEL_FORMAT_RGBA_8888, "RGBA8888", 1, 1},
-    {HAL_PIXEL_FORMAT_RGBX_8888, "RGBX8888", 1, 1},
-    {HAL_PIXEL_FORMAT_RGB_888,   "RGB888",   1, 1},
-    {HAL_PIXEL_FORMAT_RGB_565,   "RGB565",   1, 1},
-    {HAL_PIXEL_FORMAT_BGRA_8888, "BGRA8888", 1, 1},
-    {HAL_PIXEL_FORMAT_YV12,      "YV12",     2, 2},
-};
-
-// Represent RGB color as fraction of color components.
-// Each of the color components are expected in the range [0.0, 1.0]
-class ColorFract {
-  public:
-    ColorFract(): _c1(0.0), _c2(0.0), _c3(0.0) {};
-    ColorFract(float c1, float c2, float c3): _c1(c1), _c2(c2), _c3(c3) {};
-    float c1(void) const { return _c1; }
-    float c2(void) const { return _c2; }
-    float c3(void) const { return _c3; }
-
-    operator std::string();
-
-  private:
-    float _c1;
-    float _c2;
-    float _c3;
-};
-
-// Represent RGB color as fraction of color components.
-// Each of the color components are expected in the range [0.0, 1.0]
-class ColorRGB {
-  public:
-    ColorRGB(): _r(0.0), _g(0.0), _b(0.0) {};
-    ColorRGB(float f): _r(f), _g(f), _b(f) {}; // Gray, NOLINT(implicit)
-    ColorRGB(float r, float g, float b): _r(r), _g(g), _b(b) {};
-    float r(void) const { return _r; }
-    float g(void) const { return _g; }
-    float b(void) const { return _b; }
-
-  private:
-    float _r;
-    float _g;
-    float _b;
-};
-
-// Dimension - width and height of a rectanguler area
-class HwcTestDim {
-  public:
-    HwcTestDim(): _w(0), _h(0) {};
-    HwcTestDim(uint32_t w, uint32_t h) : _w(w), _h(h) {}
-    uint32_t width(void) const { return _w; }
-    uint32_t height(void) const { return _h; }
-    void setWidth(uint32_t w) { _w = w; }
-    void setHeight(uint32_t h) { _h = h; }
-
-    operator std::string();
-    operator hwc_rect() const;
-
-  private:
-    uint32_t _w;
-    uint32_t _h;
-};
-
-// Function Prototypes
-void hwcTestInitDisplay(bool verbose, EGLDisplay *dpy, EGLSurface *surface,
-    EGLint *width, EGLint *height);
-void hwcTestOpenHwc(hwc_composer_device_1_t **hwcDevicePtr);
-const struct hwcTestGraphicFormat *hwcTestGraphicFormatLookup(const char *desc);
-const struct hwcTestGraphicFormat *hwcTestGraphicFormatLookup(uint32_t id);
-const char *hwcTestGraphicFormat2str(uint32_t format);
-std::string hwcTestRect2str(const struct hwc_rect& rect);
-
-hwc_display_contents_1_t *hwcTestCreateLayerList(size_t numLayers);
-void hwcTestFreeLayerList(hwc_display_contents_1_t *list);
-void hwcTestDisplayList(hwc_display_contents_1_t *list);
-void hwcTestDisplayListPrepareModifiable(hwc_display_contents_1_t *list);
-void hwcTestDisplayListHandles(hwc_display_contents_1_t *list);
-
-uint32_t hwcTestColor2Pixel(uint32_t format, ColorFract color, float alpha);
-void hwcTestColorConvert(uint32_t fromFormat, uint32_t toFormat,
-                  ColorFract& color);
-void hwcTestSetPixel(android::GraphicBuffer *gBuf, unsigned char *buf,
-                     uint32_t x, uint32_t y, uint32_t pixel);
-void hwcTestFillColor(android::GraphicBuffer *gBuf, ColorFract color,
-                      float alpha);
-void hwcTestFillColorHBlend(android::GraphicBuffer *gBuf,
-                            uint32_t colorFormat,
-                            ColorFract startColor, ColorFract endColor);
-ColorFract hwcTestParseColor(std::istringstream& in, bool& error);
-struct hwc_rect hwcTestParseHwcRect(std::istringstream& in, bool& error);
-HwcTestDim hwcTestParseDim(std::istringstream& in, bool& error);
diff --git a/opengl/tests/lib/Android.bp b/opengl/tests/lib/Android.bp
deleted file mode 100644
index 2f6095d8e7..0000000000
--- a/opengl/tests/lib/Android.bp
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright (C) 2010 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_library_static {
-
-    name: "libglTest",
-    srcs: [
-        "glTestLib.cpp",
-        "WindowSurface.cpp",
-    ],
-    export_include_dirs: ["include"],
-
-    cflags: [
-        "-DGL_GLEXT_PROTOTYPES",
-        "-DEGL_EGLEXT_PROTOTYPES",
-        "-Wall",
-        "-Wextra",
-        "-Werror",
-    ],
-
-    shared_libs: ["libgui"],
-    static_libs: [
-        "libarect",
-        "libtestUtil",
-    ],
-
-}
diff --git a/opengl/tests/lib/WindowSurface.cpp b/opengl/tests/lib/WindowSurface.cpp
deleted file mode 100644
index 142894524d..0000000000
--- a/opengl/tests/lib/WindowSurface.cpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <WindowSurface.h>
-
-#include <gui/SurfaceComposerClient.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/Surface.h>
-#include <ui/DisplayInfo.h>
-
-using namespace android;
-
-WindowSurface::WindowSurface() {
-    status_t err;
-
-    sp<SurfaceComposerClient> surfaceComposerClient = new SurfaceComposerClient;
-    err = surfaceComposerClient->initCheck();
-    if (err != NO_ERROR) {
-        fprintf(stderr, "SurfaceComposerClient::initCheck error: %#x\n", err);
-        return;
-    }
-
-    // Get main display parameters.
-    sp<IBinder> mainDpy = SurfaceComposerClient::getBuiltInDisplay(
-            ISurfaceComposer::eDisplayIdMain);
-    DisplayInfo mainDpyInfo;
-    err = SurfaceComposerClient::getDisplayInfo(mainDpy, &mainDpyInfo);
-    if (err != NO_ERROR) {
-        fprintf(stderr, "ERROR: unable to get display characteristics\n");
-        return;
-    }
-
-    uint32_t width, height;
-    if (mainDpyInfo.orientation != DISPLAY_ORIENTATION_0 &&
-            mainDpyInfo.orientation != DISPLAY_ORIENTATION_180) {
-        // rotated
-        width = mainDpyInfo.h;
-        height = mainDpyInfo.w;
-    } else {
-        width = mainDpyInfo.w;
-        height = mainDpyInfo.h;
-    }
-
-    sp<SurfaceControl> sc = surfaceComposerClient->createSurface(
-            String8("Benchmark"), width, height,
-            PIXEL_FORMAT_RGBX_8888, ISurfaceComposerClient::eOpaque);
-    if (sc == NULL || !sc->isValid()) {
-        fprintf(stderr, "Failed to create SurfaceControl\n");
-        return;
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    err = sc->setLayer(0x7FFFFFFF);     // always on top
-    if (err != NO_ERROR) {
-        fprintf(stderr, "SurfaceComposer::setLayer error: %#x\n", err);
-        return;
-    }
-
-    err = sc->show();
-    if (err != NO_ERROR) {
-        fprintf(stderr, "SurfaceComposer::show error: %#x\n", err);
-        return;
-    }
-    SurfaceComposerClient::closeGlobalTransaction();
-
-    mSurfaceControl = sc;
-}
-
-EGLNativeWindowType WindowSurface::getSurface() const {
-    sp<ANativeWindow> anw = mSurfaceControl->getSurface();
-    return (EGLNativeWindowType) anw.get();
-}
-
diff --git a/opengl/tests/lib/glTestLib.cpp b/opengl/tests/lib/glTestLib.cpp
deleted file mode 100644
index 213dffd50f..0000000000
--- a/opengl/tests/lib/glTestLib.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-/*
- * Graphics Test Library
- */
-
-#include <glTestLib.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include "EGLUtils.h"
-
-#include <utils/Log.h>
-#include <testUtil.h>
-
-using namespace android;
-
-void glTestPrintGLString(const char *name, GLenum s)
-{
-    const char *v = (const char *) glGetString(s);
-
-    if (v == NULL) {
-        testPrintI("GL %s unknown", name);
-    } else {
-        testPrintI("GL %s = %s", name, v);
-    }
-}
-
-void glTestCheckEglError(const char* op, EGLBoolean returnVal)
-{
-    if (returnVal != EGL_TRUE) {
-        testPrintE("%s() returned %d", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error
-            = eglGetError()) {
-        testPrintE("after %s() eglError %s (0x%x)",
-                   op, EGLUtils::strerror(error), error);
-    }
-}
-
-void glTestCheckGlError(const char* op)
-{
-    for (GLint error = glGetError(); error; error
-            = glGetError()) {
-        testPrintE("after %s() glError (0x%x)", op, error);
-    }
-}
-
-void glTestPrintEGLConfiguration(EGLDisplay dpy, EGLConfig config)
-{
-
-#define X(VAL) {VAL, #VAL}
-    struct {EGLint attribute; const char* name;} names[] = {
-    X(EGL_BUFFER_SIZE),
-    X(EGL_ALPHA_SIZE),
-    X(EGL_BLUE_SIZE),
-    X(EGL_GREEN_SIZE),
-    X(EGL_RED_SIZE),
-    X(EGL_DEPTH_SIZE),
-    X(EGL_STENCIL_SIZE),
-    X(EGL_CONFIG_CAVEAT),
-    X(EGL_CONFIG_ID),
-    X(EGL_LEVEL),
-    X(EGL_MAX_PBUFFER_HEIGHT),
-    X(EGL_MAX_PBUFFER_PIXELS),
-    X(EGL_MAX_PBUFFER_WIDTH),
-    X(EGL_NATIVE_RENDERABLE),
-    X(EGL_NATIVE_VISUAL_ID),
-    X(EGL_NATIVE_VISUAL_TYPE),
-    X(EGL_SAMPLES),
-    X(EGL_SAMPLE_BUFFERS),
-    X(EGL_SURFACE_TYPE),
-    X(EGL_TRANSPARENT_TYPE),
-    X(EGL_TRANSPARENT_RED_VALUE),
-    X(EGL_TRANSPARENT_GREEN_VALUE),
-    X(EGL_TRANSPARENT_BLUE_VALUE),
-    X(EGL_BIND_TO_TEXTURE_RGB),
-    X(EGL_BIND_TO_TEXTURE_RGBA),
-    X(EGL_MIN_SWAP_INTERVAL),
-    X(EGL_MAX_SWAP_INTERVAL),
-    X(EGL_LUMINANCE_SIZE),
-    X(EGL_ALPHA_MASK_SIZE),
-    X(EGL_COLOR_BUFFER_TYPE),
-    X(EGL_RENDERABLE_TYPE),
-    X(EGL_CONFORMANT),
-   };
-#undef X
-
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute,
-                                              &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            testPrintI(" %s: %d (%#x)", names[j].name, value, value);
-        }
-    }
-    testPrintI("");
-}
diff --git a/opengl/tests/lib/include/EGLUtils.h b/opengl/tests/lib/include/EGLUtils.h
deleted file mode 100644
index 9dc6bcf56a..0000000000
--- a/opengl/tests/lib/include/EGLUtils.h
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#ifndef ANDROID_UI_EGLUTILS_H
-#define ANDROID_UI_EGLUTILS_H
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <vector>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <system/window.h>
-#include <utils/Errors.h>
-#include <utils/String8.h>
-
-extern "C" EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name);
-
-// ----------------------------------------------------------------------------
-namespace android {
-// ----------------------------------------------------------------------------
-
-class EGLUtils
-{
-public:
-
-    static inline const char *strerror(EGLint err);
-
-    static inline status_t selectConfigForPixelFormat(
-            EGLDisplay dpy,
-            EGLint const* attrs,
-            int32_t format,
-            EGLConfig* outConfig);
-
-    static inline status_t selectConfigForNativeWindow(
-            EGLDisplay dpy,
-            EGLint const* attrs,
-            EGLNativeWindowType window,
-            EGLConfig* outConfig);
-
-    static inline String8 printGLString(const char* name, GLenum s);
-    static inline String8 printEGLString(EGLDisplay dpy, const char* name, GLenum s);
-    static inline String8 checkEglError(const char* op, EGLBoolean returnVal);
-    static inline String8 checkGlError(const char* op);
-    static inline String8 printEGLConfiguration(EGLDisplay dpy, EGLConfig config);
-    static inline bool printEGLConfigurations(EGLDisplay dpy, String8& msg);
-    static inline bool printEGLConfigurations(FILE* output, EGLDisplay dpy);
-    static inline String8 decodeColorSpace(EGLint colorSpace);
-    static inline bool hasEglExtension(EGLDisplay dpy, const char* name);
-    static inline bool hasExtension(const char* exts, const char* name);
-};
-
-// ----------------------------------------------------------------------------
-
-const char *EGLUtils::strerror(EGLint err)
-{
-    switch (err){
-        case EGL_SUCCESS:           return "EGL_SUCCESS";
-        case EGL_NOT_INITIALIZED:   return "EGL_NOT_INITIALIZED";
-        case EGL_BAD_ACCESS:        return "EGL_BAD_ACCESS";
-        case EGL_BAD_ALLOC:         return "EGL_BAD_ALLOC";
-        case EGL_BAD_ATTRIBUTE:     return "EGL_BAD_ATTRIBUTE";
-        case EGL_BAD_CONFIG:        return "EGL_BAD_CONFIG";
-        case EGL_BAD_CONTEXT:       return "EGL_BAD_CONTEXT";
-        case EGL_BAD_CURRENT_SURFACE: return "EGL_BAD_CURRENT_SURFACE";
-        case EGL_BAD_DISPLAY:       return "EGL_BAD_DISPLAY";
-        case EGL_BAD_MATCH:         return "EGL_BAD_MATCH";
-        case EGL_BAD_NATIVE_PIXMAP: return "EGL_BAD_NATIVE_PIXMAP";
-        case EGL_BAD_NATIVE_WINDOW: return "EGL_BAD_NATIVE_WINDOW";
-        case EGL_BAD_PARAMETER:     return "EGL_BAD_PARAMETER";
-        case EGL_BAD_SURFACE:       return "EGL_BAD_SURFACE";
-        case EGL_CONTEXT_LOST:      return "EGL_CONTEXT_LOST";
-        default: return "UNKNOWN";
-    }
-}
-
-status_t EGLUtils::selectConfigForPixelFormat(
-        EGLDisplay dpy,
-        EGLint const* attrs,
-        int32_t format,
-        EGLConfig* outConfig)
-{
-    EGLint numConfigs = -1, n=0;
-
-    if (!attrs)
-        return BAD_VALUE;
-
-    if (outConfig == NULL)
-        return BAD_VALUE;
-
-    // Get all the "potential match" configs...
-    if (eglGetConfigs(dpy, NULL, 0, &numConfigs) == EGL_FALSE)
-        return BAD_VALUE;
-
-    std::vector<EGLConfig> configs(numConfigs);
-    if (eglChooseConfig(dpy, attrs, configs.data(), numConfigs, &n) == EGL_FALSE) {
-        return BAD_VALUE;
-    }
-
-    int i;
-    EGLConfig config = NULL;
-    for (i=0 ; i<n ; i++) {
-        EGLint nativeVisualId = 0;
-        eglGetConfigAttrib(dpy, configs[i], EGL_NATIVE_VISUAL_ID, &nativeVisualId);
-        if (nativeVisualId>0 && format == nativeVisualId) {
-            config = configs[i];
-            break;
-        }
-    }
-
-    if (i<n) {
-        *outConfig = config;
-        return NO_ERROR;
-    }
-
-    return NAME_NOT_FOUND;
-}
-
-status_t EGLUtils::selectConfigForNativeWindow(
-        EGLDisplay dpy,
-        EGLint const* attrs,
-        EGLNativeWindowType window,
-        EGLConfig* outConfig)
-{
-    int err;
-    int format;
-
-    if (!window)
-        return BAD_VALUE;
-
-    if ((err = window->query(window, NATIVE_WINDOW_FORMAT, &format)) < 0) {
-        return err;
-    }
-
-    return selectConfigForPixelFormat(dpy, attrs, format, outConfig);
-}
-
-String8 EGLUtils::printGLString(const char* name, GLenum s) {
-    String8 msg;
-    const char* v = reinterpret_cast<const char*>(glGetString(s));
-    msg.appendFormat("GL %s = %s\n", name, v);
-    return msg;
-}
-
-String8 EGLUtils::printEGLString(EGLDisplay dpy, const char* name, GLenum s) {
-    String8 msg;
-    const char* v = static_cast<const char*>(eglQueryString(dpy, s));
-    msg.appendFormat("GL %s = %s\n", name, v);
-    const char* va = (const char*)eglQueryStringImplementationANDROID(dpy, s);
-    msg.appendFormat("ImplementationANDROID: %s = %s\n", name, va);
-    return msg;
-}
-
-String8 EGLUtils::checkEglError(const char* op, EGLBoolean returnVal = EGL_TRUE) {
-    String8 msg;
-    if (returnVal != EGL_TRUE) {
-        msg.appendFormat("%s() returned %d\n", op, returnVal);
-    }
-
-    for (EGLint error = eglGetError(); error != EGL_SUCCESS; error = eglGetError()) {
-        msg.appendFormat("after %s() eglError %s (0x%x)\n", op, EGLUtils::strerror(error), error);
-    }
-    return msg;
-}
-
-String8 EGLUtils::checkGlError(const char* op) {
-    String8 msg;
-    for (GLint error = glGetError(); error != GL_NO_ERROR; error = glGetError()) {
-        msg.appendFormat("after %s() glError (0x%x)\n", op, error);
-    }
-    return msg;
-}
-
-String8 EGLUtils::printEGLConfiguration(EGLDisplay dpy, EGLConfig config) {
-#define X(VAL) \
-    { VAL, #VAL }
-    struct {
-        EGLint attribute;
-        const char* name;
-    } names[] = {
-            X(EGL_BUFFER_SIZE),
-            X(EGL_ALPHA_SIZE),
-            X(EGL_BLUE_SIZE),
-            X(EGL_GREEN_SIZE),
-            X(EGL_RED_SIZE),
-            X(EGL_DEPTH_SIZE),
-            X(EGL_STENCIL_SIZE),
-            X(EGL_CONFIG_CAVEAT),
-            X(EGL_CONFIG_ID),
-            X(EGL_LEVEL),
-            X(EGL_MAX_PBUFFER_HEIGHT),
-            X(EGL_MAX_PBUFFER_PIXELS),
-            X(EGL_MAX_PBUFFER_WIDTH),
-            X(EGL_NATIVE_RENDERABLE),
-            X(EGL_NATIVE_VISUAL_ID),
-            X(EGL_NATIVE_VISUAL_TYPE),
-            X(EGL_SAMPLES),
-            X(EGL_SAMPLE_BUFFERS),
-            X(EGL_SURFACE_TYPE),
-            X(EGL_TRANSPARENT_TYPE),
-            X(EGL_TRANSPARENT_RED_VALUE),
-            X(EGL_TRANSPARENT_GREEN_VALUE),
-            X(EGL_TRANSPARENT_BLUE_VALUE),
-            X(EGL_BIND_TO_TEXTURE_RGB),
-            X(EGL_BIND_TO_TEXTURE_RGBA),
-            X(EGL_MIN_SWAP_INTERVAL),
-            X(EGL_MAX_SWAP_INTERVAL),
-            X(EGL_LUMINANCE_SIZE),
-            X(EGL_ALPHA_MASK_SIZE),
-            X(EGL_COLOR_BUFFER_TYPE),
-            X(EGL_RENDERABLE_TYPE),
-            X(EGL_CONFORMANT),
-    };
-#undef X
-
-    String8 msg;
-    for (size_t j = 0; j < sizeof(names) / sizeof(names[0]); j++) {
-        EGLint value = -1;
-        EGLint returnVal = eglGetConfigAttrib(dpy, config, names[j].attribute, &value);
-        EGLint error = eglGetError();
-        if (returnVal && error == EGL_SUCCESS) {
-            msg.appendFormat(" %s: %d (0x%x)", names[j].name, value, value);
-        }
-    }
-    msg.append("\n");
-    return msg;
-}
-
-bool EGLUtils::printEGLConfigurations(EGLDisplay dpy, String8& msg) {
-    EGLint numConfig = 0;
-    EGLint returnVal = eglGetConfigs(dpy, NULL, 0, &numConfig);
-    msg.append(checkEglError("eglGetConfigs", returnVal));
-    if (!returnVal) {
-        return false;
-    }
-
-    msg.appendFormat("Number of EGL configuration: %d\n", numConfig);
-
-    std::vector<EGLConfig> configs(numConfig);
-
-    returnVal = eglGetConfigs(dpy, configs.data(), numConfig, &numConfig);
-    msg.append(checkEglError("eglGetConfigs", returnVal));
-    if (!returnVal) {
-        return false;
-    }
-
-    for (int i = 0; i < numConfig; i++) {
-        msg.appendFormat("Configuration %d\n", i);
-        msg.append(printEGLConfiguration(dpy, configs[i]));
-    }
-
-    return true;
-}
-
-bool EGLUtils::printEGLConfigurations(FILE* output, EGLDisplay dpy) {
-    String8 msg;
-    bool status = printEGLConfigurations(dpy, msg);
-    fprintf(output, "%s", msg.c_str());
-    return status;
-}
-
-String8 EGLUtils::decodeColorSpace(EGLint colorSpace) {
-    switch (colorSpace) {
-        case EGL_GL_COLORSPACE_SRGB_KHR:
-            return String8("EGL_GL_COLORSPACE_SRGB_KHR");
-        case EGL_GL_COLORSPACE_DISPLAY_P3_EXT:
-            return String8("EGL_GL_COLORSPACE_DISPLAY_P3_EXT");
-        case  EGL_GL_COLORSPACE_LINEAR_KHR:
-            return String8("EGL_GL_COLORSPACE_LINEAR_KHR");
-        default:
-            return String8::format("UNKNOWN ColorSpace %d", colorSpace);
-    }
-}
-
-bool EGLUtils::hasExtension(const char* exts, const char* name) {
-    size_t nameLen = strlen(name);
-    if (exts) {
-        for (const char* match = strstr(exts, name); match; match = strstr(match + nameLen, name)) {
-            if (match[nameLen] == '\0' || match[nameLen] == ' ') {
-                return true;
-            }
-        }
-    }
-    return false;
-}
-
-bool EGLUtils::hasEglExtension(EGLDisplay dpy, const char* name) {
-    return hasExtension(eglQueryString(dpy, EGL_EXTENSIONS), name);
-}
-
-// ----------------------------------------------------------------------------
-}; // namespace android
-// ----------------------------------------------------------------------------
-
-#endif /* ANDROID_UI_EGLUTILS_H */
diff --git a/opengl/tests/lib/include/WindowSurface.h b/opengl/tests/lib/include/WindowSurface.h
deleted file mode 100644
index 0ec1404556..0000000000
--- a/opengl/tests/lib/include/WindowSurface.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef OPENGL_TESTS_WINDOWSURFACE_H
-#define OPENGL_TESTS_WINDOWSURFACE_H
-
-#include <gui/SurfaceControl.h>
-
-#include <EGL/egl.h>
-
-namespace android {
-
-/*
- * A window that covers the entire display surface.
- *
- * The window is destroyed when this object is destroyed, so don't try
- * to use the surface after that point.
- */
-class WindowSurface {
-public:
-    // Creates the window.
-    WindowSurface();
-
-    // Retrieves a handle to the window.
-    EGLNativeWindowType getSurface() const;
-
-private:
-    WindowSurface(const WindowSurface&);
-    WindowSurface& operator=(const WindowSurface&);
-
-    sp<SurfaceControl> mSurfaceControl;
-};
-
-} // namespace android
-
-#endif /* OPENGL_TESTS_WINDOWSURFACE_H */
diff --git a/opengl/tests/lib/include/glTestLib.h b/opengl/tests/lib/include/glTestLib.h
deleted file mode 100644
index c91c594882..0000000000
--- a/opengl/tests/lib/include/glTestLib.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-/*
- * Graphics Test Library Header
- */
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include "EGLUtils.h"
-
-void glTestPrintGLString(const char *name, GLenum s);
-void glTestCheckEglError(const char* op, EGLBoolean returnVal = EGL_TRUE);
-void glTestCheckGlError(const char* op);
-void glTestPrintEGLConfiguration(EGLDisplay dpy, EGLConfig config);
diff --git a/opengl/tests/lighting1709/Android.mk b/opengl/tests/lighting1709/Android.mk
deleted file mode 100644
index 004723176e..0000000000
--- a/opengl/tests/lighting1709/Android.mk
+++ /dev/null
@@ -1,12 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := tests
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := LightingTest
-LOCAL_SDK_VERSION := current
-LOCAL_CERTIFICATE := platform
-
-include $(BUILD_PACKAGE)
diff --git a/opengl/tests/lighting1709/AndroidManifest.xml b/opengl/tests/lighting1709/AndroidManifest.xml
deleted file mode 100644
index 6c23d422f5..0000000000
--- a/opengl/tests/lighting1709/AndroidManifest.xml
+++ /dev/null
@@ -1,13 +0,0 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-        package="com.android.lightingtest">
-
-    <application>
-        <activity android:name="ClearActivity" android:label="LightingTest">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/lighting1709/src/com/android/lightingtest/ClearActivity.java b/opengl/tests/lighting1709/src/com/android/lightingtest/ClearActivity.java
deleted file mode 100644
index 3ae8c5ca29..0000000000
--- a/opengl/tests/lighting1709/src/com/android/lightingtest/ClearActivity.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.lightingtest;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.app.Activity;
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.MotionEvent;
-
-public class ClearActivity extends Activity {
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mGLView = new ClearGLSurfaceView(this);
-        setContentView(mGLView);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        mGLView.onPause();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mGLView.onResume();
-    }
-    private GLSurfaceView mGLView;
-}
-
-class ClearGLSurfaceView extends GLSurfaceView {
-    public ClearGLSurfaceView(Context context) {
-        super(context);
-        mRenderer = new ClearRenderer();
-        setRenderer(mRenderer);
-    }
-
-    ClearRenderer mRenderer;
-}
-
-class ClearRenderer implements GLSurfaceView.Renderer {
-    public ClearRenderer() {
-    }
-
-    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-        // Do nothing special.
-    }
-
-    public void onSurfaceChanged(GL10 gl, int w, int h) {
-        // Compute the projection matrix
-        gl.glMatrixMode(GL10.GL_PROJECTION);
-        gl.glLoadIdentity();
-
-        // Compute the boundaries of the frustum
-        float fl = (float) (-(w / 2)) / 288;
-        float fr = (float) (w / 2) / 288;
-        float ft = (float) (h / 2) / 288;
-        float fb = (float) (-(h / 2)) / 288;
-
-        // Set the view frustum
-        gl.glFrustumf(fl, fr, fb, ft, 1.0f, 2000.0f);
-
-        // Set the viewport dimensions
-        gl.glMatrixMode(GL10.GL_MODELVIEW);
-        gl.glLoadIdentity();
-        gl.glViewport(0, 0, w, h);
-    }
-
-    public void onDrawFrame(GL10 gl) {
-        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-
-        final float lightOff[]        = {0.0f, 0.0f,  0.0f, 1.0f};
-        final float lightAmbient[]    = {5.0f, 0.0f,  0.0f, 1.0f};
-        final float lightDiffuse[]    = {0.0f, 2.0f,  0.0f, 0.0f};
-        final float lightPosSpot[]    = {0.0f, 0.0f, -8.0f, 1.0f};
-
-        final float pos[] = {
-                    -5.0f, -1.5f, 0.0f,
-                     0.0f, -1.5f, 0.0f,
-                     5.0f, -1.5f, 0.0f,
-                };
-        
-        final float v[] = new float[9];
-        ByteBuffer vbb = ByteBuffer.allocateDirect(v.length*4);
-        vbb.order(ByteOrder.nativeOrder());
-        FloatBuffer vb = vbb.asFloatBuffer();
-
-        gl.glDisable(GL10.GL_DITHER);
-
-        gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_AMBIENT, lightAmbient, 0);
-        gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightDiffuse, 0);
-        gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_SPECULAR, lightOff, 0);
-        gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPosSpot, 0);
-        gl.glEnable(GL10.GL_LIGHT0);
-        
-        gl.glEnable(GL10.GL_LIGHTING);
-
-
-        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
-        gl.glNormal3f(0, 0, 1);
-        
-
-        // draw first 3 triangles, without using transforms
-        for (int i=0 ; i<3 ; i++) {
-            v[0] = -1; v[1] =-1; v[2] = -10;
-            v[3] =  0; v[4] = 1; v[5] = -10;
-            v[6] =  1; v[7] =-1; v[8] = -10;
-            for (int j=0 ; j<3 ; j++) {
-                v[j*3+0] -= pos[i*3+0];
-                v[j*3+1] -= pos[i*3+1];
-                v[j*3+2] -= pos[i*3+2];
-            }
-            vb.put(v).position(0);
-            gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vb);
-            gl.glDrawArrays(GL10.GL_TRIANGLE_STRIP, 0, 3);
-        }
-        
-        // draw the 2nd batch this time with transforms
-        v[0] = -1; v[1] =-1; v[2] = -10;
-        v[3] =  0; v[4] = 1; v[5] = -10;
-        v[6] =  1; v[7] =-1; v[8] = -10;
-        vb.put(v).position(0);
-        gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vb);
-
-        // draw lower left triangle
-        gl.glPushMatrix();
-        gl.glTranslatef(pos[0], pos[1], pos[2]);
-        gl.glDrawArrays(GL10.GL_TRIANGLE_STRIP, 0, 3);
-        gl.glPopMatrix();
-
-        // draw lower middle triangle
-        gl.glPushMatrix();
-        gl.glTranslatef(pos[3], pos[4], pos[5]);
-        gl.glDrawArrays(GL10.GL_TRIANGLE_STRIP, 0, 3);
-        gl.glPopMatrix();
-
-        // draw lower right triangle
-        gl.glPushMatrix();
-        gl.glTranslatef(pos[6], pos[7], pos[8]);
-        gl.glDrawArrays(GL10.GL_TRIANGLE_STRIP, 0, 3);
-        gl.glPopMatrix();      
-    }
-
-    public int[] getConfigSpec() {
-        int[] configSpec = { EGL10.EGL_DEPTH_SIZE, 16, EGL10.EGL_NONE };
-        return configSpec;      
-    }
-}
-
diff --git a/opengl/tests/linetex/Android.mk b/opengl/tests/linetex/Android.mk
deleted file mode 100644
index 3df0a0fef7..0000000000
--- a/opengl/tests/linetex/Android.mk
+++ /dev/null
@@ -1,25 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-	linetex.cpp
-
-LOCAL_CFLAGS := -Wall -Werror
-
-LOCAL_SHARED_LIBRARIES := \
-	libcutils \
-    libEGL \
-    libGLESv1_CM \
-    libui \
-    libgui \
-    libutils
-
-LOCAL_STATIC_LIBRARIES += libglTest
-
-LOCAL_C_INCLUDES += $(call include-path-for, opengl-tests-includes)
-
-LOCAL_MODULE:= test-opengl-linetex
-
-LOCAL_MODULE_TAGS := optional
-
-include $(BUILD_EXECUTABLE)
diff --git a/opengl/tests/linetex/linetex.cpp b/opengl/tests/linetex/linetex.cpp
deleted file mode 100644
index cdc051bc5a..0000000000
--- a/opengl/tests/linetex/linetex.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License"); 
-** you may not use this file except in compliance with the License. 
-** You may obtain a copy of the License at 
-**
-**     http://www.apache.org/licenses/LICENSE-2.0 
-**
-** Unless required by applicable law or agreed to in writing, software 
-** distributed under the License is distributed on an "AS IS" BASIS, 
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-** See the License for the specific language governing permissions and 
-** limitations under the License.
-*/
-
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <utils/StopWatch.h>
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    EGLint configAttribs[] = {
-         EGL_DEPTH_SIZE, 0,
-         EGL_NONE
-     };
-     
-     EGLint majorVersion;
-     EGLint minorVersion;
-     EGLContext context;
-     EGLConfig config;
-     EGLSurface surface;
-     EGLint w, h;
-     EGLDisplay dpy;
-
-     WindowSurface windowSurface;
-     EGLNativeWindowType window = windowSurface.getSurface();
-     
-     dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-     eglInitialize(dpy, &majorVersion, &minorVersion);
-          
-     status_t err = EGLUtils::selectConfigForNativeWindow(
-             dpy, configAttribs, window, &config);
-     if (err) {
-         fprintf(stderr, "couldn't find an EGLConfig matching the screen format\n");
-         return 0;
-     }
-
-     surface = eglCreateWindowSurface(dpy, config, window, NULL);
-     context = eglCreateContext(dpy, config, NULL, NULL);
-     eglMakeCurrent(dpy, surface, surface, context);   
-     eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-     eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-     
-     printf("w=%d, h=%d\n", w, h);
-     
-     glBindTexture(GL_TEXTURE_2D, 0);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-     glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-     glDisable(GL_DITHER);
-     glDisable(GL_BLEND);
-     glEnable(GL_TEXTURE_2D);
-     glColor4f(1,1,1,1);
-
-
-     // default pack-alignment is 4
-     const uint16_t t16[64] = { 0xFFFF, 0, 0xF800, 0, 0x07E0, 0, 0x001F, 0 };
-
-     const GLfloat fh = h;
-     const GLfloat fw2 = w/2;
-     const GLfloat vertices[4][2] = {
-             { fw2,  0  },
-             { fw2,  fh }
-     };
-
-     const GLfloat texCoords[4][2] = {
-             { 0,  0 },
-             { 1,  1 }
-     };
-
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 1, 4, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, t16);
-
-     glViewport(0, 0, w, h);
-     glMatrixMode(GL_PROJECTION);
-     glLoadIdentity();
-     glOrthof(0, w, 0, h, 0, 1);
-
-     glEnableClientState(GL_VERTEX_ARRAY);
-     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-     glVertexPointer(2, GL_FLOAT, 0, vertices);
-     glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
-
-     glClearColor(0,0,0,0);
-     glClear(GL_COLOR_BUFFER_BIT);
-     glDrawArrays(GL_LINES, 0, 2);
-     eglSwapBuffers(dpy, surface);
-
-     usleep(5*1000000);
-
-     eglTerminate(dpy);
-     
-     return 0;
-}
diff --git a/opengl/tests/swapinterval/Android.mk b/opengl/tests/swapinterval/Android.mk
deleted file mode 100644
index 2a2c12f17a..0000000000
--- a/opengl/tests/swapinterval/Android.mk
+++ /dev/null
@@ -1,25 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-	swapinterval.cpp
-
-LOCAL_CFLAGS := -Wall -Werror
-
-LOCAL_SHARED_LIBRARIES := \
-	libcutils \
-	libutils \
-    libEGL \
-    libGLESv1_CM \
-    libui \
-    libgui
-
-LOCAL_STATIC_LIBRARIES += libglTest
-
-LOCAL_C_INCLUDES += $(call include-path-for, opengl-tests-includes)
-
-LOCAL_MODULE:= test-opengl-swapinterval
-
-LOCAL_MODULE_TAGS := optional
-
-include $(BUILD_EXECUTABLE)
diff --git a/opengl/tests/swapinterval/swapinterval.cpp b/opengl/tests/swapinterval/swapinterval.cpp
deleted file mode 100644
index c4261e68f6..0000000000
--- a/opengl/tests/swapinterval/swapinterval.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- **
- ** Copyright 2006, The Android Open Source Project
- **
- ** Licensed under the Apache License, Version 2.0 (the "License"); 
- ** you may not use this file except in compliance with the License. 
- ** You may obtain a copy of the License at 
- **
- **     http://www.apache.org/licenses/LICENSE-2.0 
- **
- ** Unless required by applicable law or agreed to in writing, software 
- ** distributed under the License is distributed on an "AS IS" BASIS, 
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- ** See the License for the specific language governing permissions and 
- ** limitations under the License.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <utils/StopWatch.h>
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    EGLint configAttribs[] = {
-            EGL_SURFACE_TYPE,   EGL_WINDOW_BIT,
-            EGL_NONE
-    };
-
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EGLContext context;
-    EGLConfig config;
-    EGLint numConfigs=0;
-    EGLSurface surface;
-    EGLint w, h;
-    EGLDisplay dpy;
-
-    
-    WindowSurface windowSurface;
-    EGLNativeWindowType window = windowSurface.getSurface();
-
-    dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    eglInitialize(dpy, &majorVersion, &minorVersion);
-    eglGetConfigs(dpy, NULL, 0, &numConfigs);
-    printf("# configs = %d\n", numConfigs);
-
-    status_t err = EGLUtils::selectConfigForNativeWindow(
-            dpy, configAttribs, window, &config);
-    if (err) {
-        fprintf(stderr, "error: %s", EGLUtils::strerror(eglGetError()));
-        eglTerminate(dpy);
-        return 0;
-    }
-
-    EGLint r,g,b,a, vid;
-    eglGetConfigAttrib(dpy, config, EGL_RED_SIZE,   &r);
-    eglGetConfigAttrib(dpy, config, EGL_GREEN_SIZE, &g);
-    eglGetConfigAttrib(dpy, config, EGL_BLUE_SIZE,  &b);
-    eglGetConfigAttrib(dpy, config, EGL_ALPHA_SIZE, &a);
-    eglGetConfigAttrib(dpy, config, EGL_NATIVE_VISUAL_ID, &vid);
-
-    surface = eglCreateWindowSurface(dpy, config, window, NULL);
-    if (surface == EGL_NO_SURFACE) {
-        EGLint err = eglGetError();
-        fprintf(stderr, "error: %s, config=%p, format = %d-%d-%d-%d, visual-id = %d\n",
-                EGLUtils::strerror(err), config, r,g,b,a, vid);
-        eglTerminate(dpy);
-        return 0;
-    } else {
-        printf("config=%p, format = %d-%d-%d-%d, visual-id = %d\n",
-                config, r,g,b,a, vid);
-    }
-
-    context = eglCreateContext(dpy, config, NULL, NULL);
-    eglMakeCurrent(dpy, surface, surface, context);   
-    eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-    eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-
-    printf("w=%d, h=%d\n", w, h);
-
-    glDisable(GL_DITHER);
-    glEnable(GL_BLEND);
-
-    glViewport(0, 0, w, h);
-    glOrthof(0, w, 0, h, 0, 1);
-
-    eglSwapInterval(dpy, 1);
-
-    glClearColor(1,0,0,0);
-    glClear(GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(dpy, surface);
-
-
-    int time = 10;
-    printf("screen should flash red/green quickly for %d s...\n", time);
-
-    int c = 0;
-    nsecs_t start = systemTime();
-    nsecs_t t;
-    do {
-        glClearColor(1,0,0,0);
-        glClear(GL_COLOR_BUFFER_BIT);
-        eglSwapBuffers(dpy, surface);
-        glClearColor(0,1,0,0);
-        glClear(GL_COLOR_BUFFER_BIT);
-        eglSwapBuffers(dpy, surface);
-        t = systemTime() - start;
-        c += 2;
-    } while (int(ns2s(t))<=time);
-
-    double p =  (double(t) / c) / 1000000000.0;
-    printf("refresh-rate is %f fps (%f ms)\n", 1.0f/p, p*1000.0);
-
-    eglTerminate(dpy);
-
-    return 0;
-}
diff --git a/opengl/tests/testFramerate/Android.mk b/opengl/tests/testFramerate/Android.mk
deleted file mode 100644
index 2864fcf2c4..0000000000
--- a/opengl/tests/testFramerate/Android.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-#########################################################################
-# Test framerate and look for hiccups
-#########################################################################
-
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := TestFramerate
-LOCAL_PRIVATE_PLATFORM_APIS := true
-
-include $(BUILD_PACKAGE)
diff --git a/opengl/tests/testFramerate/AndroidManifest.xml b/opengl/tests/testFramerate/AndroidManifest.xml
deleted file mode 100644
index 85617f4797..0000000000
--- a/opengl/tests/testFramerate/AndroidManifest.xml
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.testframerate">
-    <uses-sdk android:targetSdkVersion="8" android:minSdkVersion="8" />
-
-    <application
-            android:label="@string/testFramerate_activity">
-        <activity android:name="TestFramerateActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-                android:launchMode="singleTask"
-                android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/testFramerate/res/values/strings.xml b/opengl/tests/testFramerate/res/values/strings.xml
deleted file mode 100644
index baadf0ed6c..0000000000
--- a/opengl/tests/testFramerate/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="testFramerate_activity">TestFramerate</string>
-
-</resources>
-
diff --git a/opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateActivity.java b/opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateActivity.java
deleted file mode 100644
index cbe279b079..0000000000
--- a/opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateActivity.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.testframerate;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.WindowManager;
-
-import java.io.File;
-
-
-public class TestFramerateActivity extends Activity {
-
-    TestFramerateView mView;
-
-    @Override protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        mView = new TestFramerateView(getApplication());
-        setContentView(mView);
-        mView.setFocusableInTouchMode(true);
-    }
-
-    @Override protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateView.java b/opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateView.java
deleted file mode 100644
index f3fb5de414..0000000000
--- a/opengl/tests/testFramerate/src/com/android/testframerate/TestFramerateView.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.testframerate;
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.os.SystemProperties;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.opengl.GLES20;
-
-class TestFramerateView extends GLSurfaceView {
-    private static String TAG = "TestFramerateView";
-
-    public TestFramerateView(Context context) {
-        super(context);
-        setEGLContextClientVersion(2);
-        setRenderer(new Renderer());
-    }
-
-    private long mLastTime_us = 0;
-    private long mNumShortFramesElapsed = 0;
-    private void registerTime(long now_us) {
-        long longFrameTime_ms = Integer.parseInt(SystemProperties.get("debug.longframe_ms", "16"));
-        long elapsedTime_us = now_us - mLastTime_us;
-        float fps = 1000000.f / elapsedTime_us;
-        if (mLastTime_us > 0 && elapsedTime_us > longFrameTime_ms*1000) {
-          Log.v(TAG, "Long frame: " + elapsedTime_us/1000.f + " ms (" + fps + " fps)");
-          if (mNumShortFramesElapsed > 0) {
-            Log.v(TAG, "  Short frames since last long frame: " + mNumShortFramesElapsed);
-            mNumShortFramesElapsed = 0;
-          }
-        } else {
-            ++mNumShortFramesElapsed;
-        }
-
-        mLastTime_us = now_us;
-    }
-
-    private class Renderer implements GLSurfaceView.Renderer {
-        public Renderer() {
-        }
-
-
-        public void onDrawFrame(GL10 gl) {
-            long now_us = System.nanoTime() / 1000;
-            registerTime(now_us);
-
-            float red = (now_us % 1000000) / 1000000.f;
-            float green = (now_us % 2000000) / 2000000.f;
-            float blue = (now_us % 3000000) / 3000000.f;
-            GLES20.glClearColor(red, green, blue, 1.0f);
-            GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            GLES20.glViewport(0, 0, width, height);
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-        }
-
-    }
-}
diff --git a/opengl/tests/testLatency/Android.mk b/opengl/tests/testLatency/Android.mk
deleted file mode 100644
index 96417c7ef5..0000000000
--- a/opengl/tests/testLatency/Android.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-#########################################################################
-# Test end-to-end latency.
-#########################################################################
-
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SDK_VERSION := 8
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := TestLatency
-
-include $(BUILD_PACKAGE)
diff --git a/opengl/tests/testLatency/AndroidManifest.xml b/opengl/tests/testLatency/AndroidManifest.xml
deleted file mode 100644
index 59f2643a39..0000000000
--- a/opengl/tests/testLatency/AndroidManifest.xml
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.testlatency">
-    <uses-sdk android:targetSdkVersion="8" android:minSdkVersion="8" />
-
-    <application
-            android:label="@string/testLatency_activity">
-        <activity android:name="TestLatencyActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-                android:launchMode="singleTask"
-                android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/testLatency/res/values/strings.xml b/opengl/tests/testLatency/res/values/strings.xml
deleted file mode 100644
index d80b77cfad..0000000000
--- a/opengl/tests/testLatency/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="testLatency_activity">TestLatency</string>
-
-</resources>
-
diff --git a/opengl/tests/testLatency/src/com/android/testlatency/TestLatencyActivity.java b/opengl/tests/testLatency/src/com/android/testlatency/TestLatencyActivity.java
deleted file mode 100644
index ed993cb34c..0000000000
--- a/opengl/tests/testLatency/src/com/android/testlatency/TestLatencyActivity.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.testlatency;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.WindowManager;
-
-import java.io.File;
-
-
-public class TestLatencyActivity extends Activity {
-
-    TestLatencyView mView;
-
-    @Override protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        mView = new TestLatencyView(getApplication());
-        setContentView(mView);
-        mView.setFocusableInTouchMode(true);
-    }
-
-    @Override protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/testLatency/src/com/android/testlatency/TestLatencyView.java b/opengl/tests/testLatency/src/com/android/testlatency/TestLatencyView.java
deleted file mode 100644
index d62bf17487..0000000000
--- a/opengl/tests/testLatency/src/com/android/testlatency/TestLatencyView.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.testlatency;
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
-import android.opengl.GLES20;
-
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class TestLatencyView extends GLSurfaceView {
-    private static String TAG = "TestLatencyiew";
-    private float mX;
-    private float mY;
-    private float mDX;
-    private float mDY;
-    private long  mT;
-    private long  mDT;
-
-    public TestLatencyView(Context context) {
-        super(context);
-        setEGLContextClientVersion(2);
-        setRenderer(new Renderer());
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        switch (event.getAction()) {
-        case MotionEvent.ACTION_MOVE:
-            float x = event.getX();
-            float y = event.getY();
-            long  t = event.getEventTime();
-            synchronized(this) {
-                mDT = t - mT;
-                mT = t;
-                mDX = x - mX;
-                mX = x;
-                mDY = y - mY;
-                mY = y;
-            }
-            break;
-        default:
-            break;
-        }
-        return true;
-    }
-
-    private class Renderer implements GLSurfaceView.Renderer {
-        private float mScaleX, mScaleY, mOffsetX, mOffsetY;
-        private final float MS_PER_FRAME = 1000 / 60;
-        public Renderer() {
-            mTriangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length * 4)
-                .order(ByteOrder.nativeOrder()).asFloatBuffer();
-        }
-
-
-        public void onDrawFrame(GL10 gl) {
-            GLES20.glClearColor(0.4f, 0.4f, 0.4f, 1.0f);
-            GLES20.glClear( GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
-            GLES20.glUseProgram(mProgram);
-            checkGlError("glUseProgram");
-
-            float x, y, dx, dy;
-            long t, dt;
-            synchronized(TestLatencyView.this) {
-                x = mX;
-                y = mY;
-                dx = mDX;
-                dy = mDY;
-                dt = mDT;
-            }
-
-            if (dt > 0) {
-                dx = dx * MS_PER_FRAME / dt;
-                dy = dy * MS_PER_FRAME / dt;
-            }
-
-            GLES20.glEnableVertexAttribArray(mvPositionHandle);
-            checkGlError("glEnableVertexAttribArray");
-            GLES20.glEnableVertexAttribArray(mvColorHandle);
-            checkGlError("glEnableVertexAttribArray");
-            for(int step = 0; step < 8; step++) {
-                float sx = (x + dx * step) * mScaleX + mOffsetX;
-                float sy = (y + dy * step) * mScaleY + mOffsetY;
-                int cbase = step * 4;
-
-                for (int i = 0; i < mTriangleVerticesData.length; i += 6) {
-                    mTriangleVerticesData2[i] = sx + mTriangleVerticesData[i];
-                    mTriangleVerticesData2[i+1] = -sy + mTriangleVerticesData[i+1];
-                    mTriangleVerticesData2[i+2] = mColors[cbase];
-                    mTriangleVerticesData2[i+3] = mColors[cbase+1];
-                    mTriangleVerticesData2[i+4] = mColors[cbase+2];
-                    mTriangleVerticesData2[i+5] = mColors[cbase+3];
-                }
-                mTriangleVertices.position(0);
-                mTriangleVertices.put(mTriangleVerticesData2).position(0);
-
-                GLES20.glVertexAttribPointer(mvPositionHandle, 2, GLES20.GL_FLOAT, false, 6*4, mTriangleVertices);
-                checkGlError("glVertexAttribPointer mvPosition");
-                mTriangleVertices.put(mTriangleVerticesData2).position(2);
-                GLES20.glVertexAttribPointer(mvColorHandle, 4, GLES20.GL_FLOAT, false, 6*4, mTriangleVertices);
-                checkGlError("glVertexAttribPointer mvColor");
-                GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);
-                checkGlError("glDrawArrays");
-            }
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            GLES20.glViewport(0, 0, width, height);
-            mScaleX = 2.0f / width;
-            mScaleY = 2.0f / height;
-            mOffsetX = -1f;
-            mOffsetY = -1f;
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            mProgram = createProgram(mVertexShader, mFragmentShader);
-            if (mProgram == 0) {
-                return;
-            }
-            mvPositionHandle = GLES20.glGetAttribLocation(mProgram, "aPosition");
-            checkGlError("glGetAttribLocation");
-            if (mvPositionHandle == -1) {
-                throw new RuntimeException("Could not get attrib location for vPosition");
-            }
-            mvColorHandle = GLES20.glGetAttribLocation(mProgram, "aColor");
-            checkGlError("glGetAttribLocation");
-            if (mvColorHandle == -1) {
-                throw new RuntimeException("Could not get attrib location for vColor");
-            }
-        }
-
-        private int loadShader(int shaderType, String source) {
-            int shader = GLES20.glCreateShader(shaderType);
-            if (shader != 0) {
-                GLES20.glShaderSource(shader, source);
-                GLES20.glCompileShader(shader);
-                int[] compiled = new int[1];
-                GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0);
-                if (compiled[0] == 0) {
-                    Log.e(TAG, "Could not compile shader " + shaderType + ":");
-                    Log.e(TAG, GLES20.glGetShaderInfoLog(shader));
-                    GLES20.glDeleteShader(shader);
-                    shader = 0;
-                }
-            }
-            return shader;
-        }
-
-        private int createProgram(String vertexSource, String fragmentSource) {
-            int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);
-            if (vertexShader == 0) {
-                return 0;
-            }
-
-            int pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);
-            if (pixelShader == 0) {
-                return 0;
-            }
-
-            int program = GLES20.glCreateProgram();
-            if (program != 0) {
-                GLES20.glAttachShader(program, vertexShader);
-                checkGlError("glAttachShader vertexShader");
-                GLES20.glAttachShader(program, pixelShader);
-                checkGlError("glAttachShader pixelShader");
-                GLES20.glLinkProgram(program);
-                int[] linkStatus = new int[1];
-                GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0);
-                if (linkStatus[0] != GLES20.GL_TRUE) {
-                    Log.e(TAG, "Could not link program: ");
-                    Log.e(TAG, GLES20.glGetProgramInfoLog(program));
-                    GLES20.glDeleteProgram(program);
-                    program = 0;
-                }
-            }
-            return program;
-        }
-
-        private void checkGlError(String op) {
-            int error;
-            while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
-                Log.e(TAG, op + ": glError " + error);
-                throw new RuntimeException(op + ": glError " + error);
-            }
-        }
-
-        // X, Y, R G B A
-        private final float[] mTriangleVerticesData = {
-                -0.025f, 0.3f, 0.0f, 1.0f, 0.0f, 1.0f,
-                 0.0f  , 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
-                 0.025f, 0.3f, 1.0f, 1.0f, 255.0f, 1.0f
-                };
-
-        // Color cascade:
-        private final float[] mColors = {
-                0.0f, 0.0f, 0.0f, 1.0f,
-                0.5f, 0.0f, 0.0f, 1.0f,
-                0.0f, 0.5f, 0.0f, 1.0f,
-                0.5f, 0.5f, 0.0f, 1.0f,
-
-                0.0f, 0.0f, 0.5f, 1.0f,
-                1.0f, 0.0f, 0.0f, 1.0f,
-                1.0f, 1.0f, 1.0f, 1.0f,
-                0.0f, 1.0f, 0.0f, 1.0f
-        };
-
-        private float[] mTriangleVerticesData2 = new float[mTriangleVerticesData.length];
-        private FloatBuffer mTriangleVertices;
-
-        private final String mVertexShader = "attribute vec4 aPosition;\n"
-            + "attribute vec4 aColor;\n"
-            + "varying vec4 vColor;\n"
-            + "void main() {\n"
-            + "  gl_Position = aPosition;\n"
-            + "  vColor = aColor;\n"
-            + "}\n";
-
-        private final String mFragmentShader = "precision mediump float;\n"
-            + "varying vec4 vColor;\n"
-            + "void main() {\n"
-            + "  gl_FragColor = vColor;\n"
-            + "}\n";
-
-        private int mProgram;
-        private int mvPositionHandle;
-        private int mvColorHandle;
-
-    }
-}
-
diff --git a/opengl/tests/testPauseResume/Android.mk b/opengl/tests/testPauseResume/Android.mk
deleted file mode 100644
index dda5424360..0000000000
--- a/opengl/tests/testPauseResume/Android.mk
+++ /dev/null
@@ -1,19 +0,0 @@
-#########################################################################
-# OpenGL ES JNI sample
-# This makefile builds both an activity and a shared library.
-#########################################################################
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := TestEGL
-LOCAL_SDK_VERSION := current
-
-include $(BUILD_PACKAGE)
diff --git a/opengl/tests/testPauseResume/AndroidManifest.xml b/opengl/tests/testPauseResume/AndroidManifest.xml
deleted file mode 100644
index 1879bc3217..0000000000
--- a/opengl/tests/testPauseResume/AndroidManifest.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.test">
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <application
-            android:label="@string/test_activity">
-        <activity android:name="TestActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-            	android:launchMode="singleTask"
-            	android:screenOrientation="landscape"
-            	android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/testPauseResume/README b/opengl/tests/testPauseResume/README
deleted file mode 100644
index 87db74a5d8..0000000000
--- a/opengl/tests/testPauseResume/README
+++ /dev/null
@@ -1,37 +0,0 @@
-Repro steps:
-
-build, install and run the attached test program TestEgl.apk
-
-The program does not draw anything to the screen, it just prints to the log, so use adb logcat to watch the output.
-
-Expected behavior:
-
-constantly increasing "step" count:
-
-
-W/TestActivity( 1885): ****** step 235 resume
-W/TestActivity( 1885): step 236 pause
-W/TestActivity( 1885): ****** step 236 resume
-
-and so on.
-
-Actual behavior:
-
-W/TestActivity( 1466): ****** step 25 resume
-W/TestActivity( 1466): step 26 pause
-W/TestActivity( 1466): ****** step 26 resume
-W/dalvikvm( 1466): threadid=8: thread exiting with uncaught exception (group=0x4001d7f0)
-E/AndroidRuntime( 1466): FATAL EXCEPTION: GLThread 9
-E/AndroidRuntime( 1466): java.lang.RuntimeException: createContext failed: EGL_BAD_ALLOC
-E/AndroidRuntime( 1466):        at android.opengl.GLSurfaceView$EglHelper.throwEglException(GLSurfaceView.java:1067)
-E/AndroidRuntime( 1466):        at android.opengl.GLSurfaceView$EglHelper.throwEglException(GLSurfaceView.java:1059)
-E/AndroidRuntime( 1466):        at android.opengl.GLSurfaceView$EglHelper.start(GLSurfaceView.java:925)
-E/AndroidRuntime( 1466):        at android.opengl.GLSurfaceView$GLThread.guardedRun(GLSurfaceView.java:1236)
-E/AndroidRuntime( 1466):        at android.opengl.GLSurfaceView$GLThread.run(GLSurfaceView.java:1106)
-W/TestActivity( 1466): step 27 pause
-W/TestActivity( 1466): ****** step 27 resume
-W/TestActivity( 1466): step 28 pause
-W/TestActivity( 1466): ****** step 28 resume
-
-
-See http://b/issue?id=2550745 for further details.
diff --git a/opengl/tests/testPauseResume/res/values/strings.xml b/opengl/tests/testPauseResume/res/values/strings.xml
deleted file mode 100644
index b4c98fe2aa..0000000000
--- a/opengl/tests/testPauseResume/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="test_activity">Test Egl</string>
-
-</resources>
-
diff --git a/opengl/tests/testPauseResume/src/com/android/test/TestActivity.java b/opengl/tests/testPauseResume/src/com/android/test/TestActivity.java
deleted file mode 100644
index 9dc713216d..0000000000
--- a/opengl/tests/testPauseResume/src/com/android/test/TestActivity.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.test;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-
-public class TestActivity extends Activity {
-    private final static String TAG = "TestActivity";
-    TestView mView;
-    boolean mToggle;
-    int mCount;
-    final static int PAUSE_DELAY = 100;
-    Runnable mRunnable = new Runnable() {
-        public void run() {
-        if (mToggle) {
-            Log.w(TAG, "****** step " + mCount + " resume");
-            mCount++;
-            mView.onResume();
-        } else {
-            Log.w(TAG, "step " + mCount + " pause");
-            mView.onPause();
-        }
-        mToggle = ! mToggle;
-        mView.postDelayed(mRunnable, PAUSE_DELAY);
-        }
-    };
-
-    @Override
-    protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        mView = new TestView(getApplication());
-	    mView.setFocusableInTouchMode(true);
-	    setContentView(mView);
-        mView.postDelayed(mRunnable, PAUSE_DELAY);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/testPauseResume/src/com/android/test/TestView.java b/opengl/tests/testPauseResume/src/com/android/test/TestView.java
deleted file mode 100644
index 8c28f13edb..0000000000
--- a/opengl/tests/testPauseResume/src/com/android/test/TestView.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.test;
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class TestView extends GLSurfaceView {
-    TestView(Context context) {
-        super(context);
-        init();
-    }
-
-    public TestView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    private void init() {
-        setRenderer(new Renderer());
-    }
-
-    private class Renderer implements GLSurfaceView.Renderer {
-        private static final String TAG = "Renderer";
-        public void onDrawFrame(GL10 gl) {
-            // Do nothing.
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            // Do nothing.
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-            // Do nothing.
-        }
-    }
-}
-
diff --git a/opengl/tests/testViewport/Android.mk b/opengl/tests/testViewport/Android.mk
deleted file mode 100644
index 9980e7dbc7..0000000000
--- a/opengl/tests/testViewport/Android.mk
+++ /dev/null
@@ -1,22 +0,0 @@
-#########################################################################
-# OpenGL ES JNI sample
-# This makefile builds both an activity and a shared library.
-#########################################################################
-TOP_LOCAL_PATH:= $(call my-dir)
-
-# Build activity
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files)
-
-LOCAL_PACKAGE_NAME := TestViewport
-
-# Set a specific SDK version so we can run on Froyo.
-
-LOCAL_SDK_VERSION := 8
-
-include $(BUILD_PACKAGE)
diff --git a/opengl/tests/testViewport/AndroidManifest.xml b/opengl/tests/testViewport/AndroidManifest.xml
deleted file mode 100644
index ba178bb182..0000000000
--- a/opengl/tests/testViewport/AndroidManifest.xml
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2009 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.android.test">
-    <uses-sdk android:targetSdkVersion="8" android:minSdkVersion="8" />
-    <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <application
-            android:label="@string/test_activity">
-        <activity android:name="TestActivity"
-                android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
-            	android:configChanges="orientation|keyboardHidden">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-</manifest>
diff --git a/opengl/tests/testViewport/README b/opengl/tests/testViewport/README
deleted file mode 100644
index c06abc9405..0000000000
--- a/opengl/tests/testViewport/README
+++ /dev/null
@@ -1,28 +0,0 @@
-Repro steps:
-
-build, install and run the attached test program TestViewport.apk
-
-Run on Sapphire with Froyo.
-
-The program clears the screen to blue, then draws a full screen white quad that
-is alligned to the screen.
-(Therefore the whole screen should appear to be white.)
-
-
-Note that screen is all white.
-
-Rotate screen 90 degrees.
-
-Expected: screen is still all white.
-
-Actual: screen is blue with offset white rectangle.
-
-This bug only happens on Sapphire, it works correctly on Passion.
-
-What happens:
-
-I think the bug is that the gl.glViewport() call in onSurfaceChanged() is
-being ignored by the OpenGL driver.
-
-NOTE: If a gl.glViewport call is added at the beginning of the onDrawFrame()
-call (which means it is called before every draw), the program runs correctly.
diff --git a/opengl/tests/testViewport/res/values/strings.xml b/opengl/tests/testViewport/res/values/strings.xml
deleted file mode 100644
index c037a7cbbe..0000000000
--- a/opengl/tests/testViewport/res/values/strings.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2006 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!-- This file contains resource definitions for displayed strings, allowing
-     them to be changed based on the locale and options. -->
-
-<resources>
-    <!-- Simple strings. -->
-    <string name="test_activity">Test Viewport</string>
-
-</resources>
-
diff --git a/opengl/tests/testViewport/src/com/android/test/TestActivity.java b/opengl/tests/testViewport/src/com/android/test/TestActivity.java
deleted file mode 100644
index cc7e4500d6..0000000000
--- a/opengl/tests/testViewport/src/com/android/test/TestActivity.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.test;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.util.Log;
-
-public class TestActivity extends Activity {
-    private final static String TAG = "TestActivity";
-    TestView mView;
-
-    @Override
-    protected void onCreate(Bundle icicle) {
-        super.onCreate(icicle);
-        mView = new TestView(getApplication());
-	    mView.setFocusableInTouchMode(true);
-	    setContentView(mView);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        mView.onPause();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        mView.onResume();
-    }
-}
diff --git a/opengl/tests/testViewport/src/com/android/test/TestView.java b/opengl/tests/testViewport/src/com/android/test/TestView.java
deleted file mode 100644
index 23cc37d1f1..0000000000
--- a/opengl/tests/testViewport/src/com/android/test/TestView.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.test;
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.CharBuffer;
-import java.nio.FloatBuffer;
-
-import android.content.Context;
-import android.opengl.GLSurfaceView;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL;
-import javax.microedition.khronos.opengles.GL10;
-import javax.microedition.khronos.opengles.GL11;
-/**
- * An implementation of SurfaceView that uses the dedicated surface for
- * displaying an OpenGL animation.  This allows the animation to run in a
- * separate thread, without requiring that it be driven by the update mechanism
- * of the view hierarchy.
- *
- * The application-specific rendering code is delegated to a GLView.Renderer
- * instance.
- */
-class TestView extends GLSurfaceView {
-    TestView(Context context) {
-        super(context);
-        init();
-    }
-
-    public TestView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    private void init() {
-        setRenderer(new Renderer());
-        setRenderMode(RENDERMODE_WHEN_DIRTY);
-    }
-    
-        /** A grid is a topologically rectangular array of vertices.
-    *
-    * The vertex and index data are held in VBO objects because on most
-    * GPUs VBO objects are the fastest way of rendering static vertex
-    * and index data.
-    *
-    */
-
-   private static class Grid {
-       // Size of vertex data elements in bytes:
-       final static int FLOAT_SIZE = 4;
-       final static int CHAR_SIZE = 2;
-
-       // Vertex structure:
-       // float x, y, z;
-
-       final static int VERTEX_SIZE = 3 * FLOAT_SIZE;
-
-       private int mVertexBufferObjectId;
-       private int mElementBufferObjectId;
-
-       // These buffers are used to hold the vertex and index data while
-       // constructing the grid. Once createBufferObjects() is called
-       // the buffers are nulled out to save memory.
-
-       private ByteBuffer mVertexByteBuffer;
-       private FloatBuffer mVertexBuffer;
-       private CharBuffer mIndexBuffer;
-
-       private int mW;
-       private int mH;
-       private int mIndexCount;
-
-       public Grid(int w, int h) {
-           if (w < 0 || w >= 65536) {
-               throw new IllegalArgumentException("w");
-           }
-           if (h < 0 || h >= 65536) {
-               throw new IllegalArgumentException("h");
-           }
-           if (w * h >= 65536) {
-               throw new IllegalArgumentException("w * h >= 65536");
-           }
-
-           mW = w;
-           mH = h;
-           int size = w * h;
-
-           mVertexByteBuffer = ByteBuffer.allocateDirect(VERTEX_SIZE * size)
-               .order(ByteOrder.nativeOrder());
-           mVertexBuffer = mVertexByteBuffer.asFloatBuffer();
-
-           int quadW = mW - 1;
-           int quadH = mH - 1;
-           int quadCount = quadW * quadH;
-           int indexCount = quadCount * 6;
-           mIndexCount = indexCount;
-           mIndexBuffer = ByteBuffer.allocateDirect(CHAR_SIZE * indexCount)
-               .order(ByteOrder.nativeOrder()).asCharBuffer();
-
-           /*
-            * Initialize triangle list mesh.
-            *
-            *     [0]-----[  1] ...
-            *      |    /   |
-            *      |   /    |
-            *      |  /     |
-            *     [w]-----[w+1] ...
-            *      |       |
-            *
-            */
-
-           {
-               int i = 0;
-               for (int y = 0; y < quadH; y++) {
-                   for (int x = 0; x < quadW; x++) {
-                       char a = (char) (y * mW + x);
-                       char b = (char) (y * mW + x + 1);
-                       char c = (char) ((y + 1) * mW + x);
-                       char d = (char) ((y + 1) * mW + x + 1);
-
-                       mIndexBuffer.put(i++, a);
-                       mIndexBuffer.put(i++, c);
-                       mIndexBuffer.put(i++, b);
-
-                       mIndexBuffer.put(i++, b);
-                       mIndexBuffer.put(i++, c);
-                       mIndexBuffer.put(i++, d);
-                   }
-               }
-           }
-
-       }
-
-       public void set(int i, int j, float x, float y, float z) {
-           if (i < 0 || i >= mW) {
-               throw new IllegalArgumentException("i");
-           }
-           if (j < 0 || j >= mH) {
-               throw new IllegalArgumentException("j");
-           }
-
-           int index = mW * j + i;
-
-           mVertexBuffer.position(index * VERTEX_SIZE / FLOAT_SIZE);
-           mVertexBuffer.put(x);
-           mVertexBuffer.put(y);
-           mVertexBuffer.put(z);
-       }
-
-       public void createBufferObjects(GL gl) {
-           // Generate a the vertex and element buffer IDs
-           int[] vboIds = new int[2];
-           GL11 gl11 = (GL11) gl;
-           gl11.glGenBuffers(2, vboIds, 0);
-           mVertexBufferObjectId = vboIds[0];
-           mElementBufferObjectId = vboIds[1];
-
-           // Upload the vertex data
-           gl11.glBindBuffer(GL11.GL_ARRAY_BUFFER, mVertexBufferObjectId);
-           mVertexByteBuffer.position(0);
-           gl11.glBufferData(GL11.GL_ARRAY_BUFFER, mVertexByteBuffer.capacity(), mVertexByteBuffer, GL11.GL_STATIC_DRAW);
-
-           gl11.glBindBuffer(GL11.GL_ELEMENT_ARRAY_BUFFER, mElementBufferObjectId);
-           mIndexBuffer.position(0);
-           gl11.glBufferData(GL11.GL_ELEMENT_ARRAY_BUFFER, mIndexBuffer.capacity() * CHAR_SIZE, mIndexBuffer, GL11.GL_STATIC_DRAW);
-
-           // We don't need the in-memory data any more
-           mVertexBuffer = null;
-           mVertexByteBuffer = null;
-           mIndexBuffer = null;
-       }
-
-       public void draw(GL10 gl) {
-           GL11 gl11 = (GL11) gl;
-
-           gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
-
-           gl11.glBindBuffer(GL11.GL_ARRAY_BUFFER, mVertexBufferObjectId);
-           gl11.glVertexPointer(3, GL10.GL_FLOAT, VERTEX_SIZE, 0);
-           
-           gl11.glBindBuffer(GL11.GL_ELEMENT_ARRAY_BUFFER, mElementBufferObjectId);
-           gl11.glDrawElements(GL10.GL_TRIANGLES, mIndexCount, GL10.GL_UNSIGNED_SHORT, 0);
-           gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
-           gl11.glBindBuffer(GL11.GL_ARRAY_BUFFER, 0);
-           gl11.glBindBuffer(GL11.GL_ELEMENT_ARRAY_BUFFER, 0);
-       }
-   }
-
-
-    private class Renderer implements GLSurfaceView.Renderer {
-        private static final String TAG = "Renderer";
-        private Grid mGrid;
-        
-        public void onDrawFrame(GL10 gl) {
-			gl.glClearColor(0,0,1,1);
-			gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
-            mGrid.draw(gl);
-        }
-
-        public void onSurfaceChanged(GL10 gl, int width, int height) {
-            gl.glViewport(0, 0, width, height);
-			gl.glMatrixMode(GL11.GL_PROJECTION);
-			gl.glLoadIdentity();
-			gl.glOrthof(0, width, height, 0, -1, 1);
-			gl.glMatrixMode(GL11.GL_MODELVIEW);
-            createGrid(gl, width, height);
-        }
-
-        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
-        }
-        
-        private void createGrid(GL10 gl, float w, float h) {
-        mGrid = new Grid(2, 2);
-			for (int j = 0; j < 2; j++) {
-				for (int i = 0; i < 2; i++) {
-					float x = w * i;
-					float y = h * j;
-					float z = 0.0f;
-					mGrid.set(i,j, x, y, z);
-				}
-			}
-			mGrid.createBufferObjects(gl);
-		}
-    }
-}
-
diff --git a/opengl/tests/textures/Android.mk b/opengl/tests/textures/Android.mk
deleted file mode 100644
index 629a2d2a78..0000000000
--- a/opengl/tests/textures/Android.mk
+++ /dev/null
@@ -1,26 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-	textures.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-	libcutils \
-    libEGL \
-    libGLESv1_CM \
-    libui \
-    libgui \
-    libutils
-
-LOCAL_STATIC_LIBRARIES += libglTest
-
-LOCAL_C_INCLUDES += $(call include-path-for, opengl-tests-includes)
-
-LOCAL_MODULE:= test-opengl-textures
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -DGL_GLEXT_PROTOTYPES
-LOCAL_CFLAGS += -Wall -Werror
-
-include $(BUILD_EXECUTABLE)
diff --git a/opengl/tests/textures/textures.cpp b/opengl/tests/textures/textures.cpp
deleted file mode 100644
index bdb5c8283a..0000000000
--- a/opengl/tests/textures/textures.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License"); 
-** you may not use this file except in compliance with the License. 
-** You may obtain a copy of the License at 
-**
-**     http://www.apache.org/licenses/LICENSE-2.0 
-**
-** Unless required by applicable law or agreed to in writing, software 
-** distributed under the License is distributed on an "AS IS" BASIS, 
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-** See the License for the specific language governing permissions and 
-** limitations under the License.
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-using namespace android;
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    EGLint configAttribs[] = {
-         EGL_DEPTH_SIZE, 0,
-         EGL_NONE
-     };
-     
-     EGLint majorVersion;
-     EGLint minorVersion;
-     EGLContext context;
-     EGLConfig config;
-     EGLSurface surface;
-     EGLint w, h;
-     EGLDisplay dpy;
-
-     WindowSurface windowSurface;
-     EGLNativeWindowType window = windowSurface.getSurface();
-     
-     dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-     eglInitialize(dpy, &majorVersion, &minorVersion);
-          
-     status_t err = EGLUtils::selectConfigForNativeWindow(
-             dpy, configAttribs, window, &config);
-     if (err) {
-         fprintf(stderr, "couldn't find an EGLConfig matching the screen format\n");
-         return 0;
-     }
-
-     surface = eglCreateWindowSurface(dpy, config, window, NULL);
-     context = eglCreateContext(dpy, config, NULL, NULL);
-     eglMakeCurrent(dpy, surface, surface, context);   
-     eglQuerySurface(dpy, surface, EGL_WIDTH, &w);
-     eglQuerySurface(dpy, surface, EGL_HEIGHT, &h);
-     GLint dim = w<h ? w : h;
-
-
-     GLint crop[4] = { 0, 4, 4, -4 };
-     glBindTexture(GL_TEXTURE_2D, 0);
-     glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-     glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-     glEnable(GL_TEXTURE_2D);
-     glColor4f(1,1,1,1);
-
-     // packing is always 4
-     uint8_t t8[]  = { 
-             0x00, 0x55, 0x00, 0x55, 
-             0xAA, 0xFF, 0xAA, 0xFF,
-             0x00, 0x55, 0x00, 0x55, 
-             0xAA, 0xFF, 0xAA, 0xFF  };
-
-     uint16_t t16[]  = { 
-             0x0000, 0x5555, 0x0000, 0x5555, 
-             0xAAAA, 0xFFFF, 0xAAAA, 0xFFFF,
-             0x0000, 0x5555, 0x0000, 0x5555, 
-             0xAAAA, 0xFFFF, 0xAAAA, 0xFFFF  };
-
-     uint32_t t32[]  = { 
-             0xFF000000, 0xFF0000FF, 0xFF00FF00, 0xFFFF0000, 
-             0xFF00FF00, 0xFFFF0000, 0xFF000000, 0xFF0000FF, 
-             0xFF00FFFF, 0xFF00FF00, 0x00FF00FF, 0xFFFFFF00, 
-             0xFF000000, 0xFFFF00FF, 0xFF00FFFF, 0xFFFFFFFF
-     };
-
-
-     glClear(GL_COLOR_BUFFER_BIT);
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, 4, 4, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, t8);
-     glDrawTexiOES(0, 0, 0, dim/2, dim/2);
-
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 4, 4, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, t16);
-     glDrawTexiOES(dim/2, 0, 0, dim/2, dim/2);
-
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 0, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4, t16);
-     glDrawTexiOES(0, dim/2, 0, dim/2, dim/2);
-
-     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 0, GL_RGBA, GL_UNSIGNED_BYTE, t32);
-     glDrawTexiOES(dim/2, dim/2, 0, dim/2, dim/2);
-
-     eglSwapBuffers(dpy, surface);
-
-     sleep(2);      // so you have a chance to admire it
-     return 0;
-}
diff --git a/opengl/tests/tritex/Android.mk b/opengl/tests/tritex/Android.mk
deleted file mode 100644
index 7055afab55..0000000000
--- a/opengl/tests/tritex/Android.mk
+++ /dev/null
@@ -1,25 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-	tritex.cpp
-
-LOCAL_CFLAGS := -Wall -Werror
-
-LOCAL_SHARED_LIBRARIES := \
-	libcutils \
-    libEGL \
-    libGLESv1_CM \
-    libui \
-    libgui \
-    libutils
-
-LOCAL_STATIC_LIBRARIES += libglTest
-
-LOCAL_C_INCLUDES += $(call include-path-for, opengl-tests-includes)
-
-LOCAL_MODULE:= test-opengl-tritex
-
-LOCAL_MODULE_TAGS := optional
-
-include $(BUILD_EXECUTABLE)
diff --git a/opengl/tests/tritex/tritex.cpp b/opengl/tests/tritex/tritex.cpp
deleted file mode 100644
index c008003636..0000000000
--- a/opengl/tests/tritex/tritex.cpp
+++ /dev/null
@@ -1,274 +0,0 @@
-// Calls glDrawElements() the number of times specified by
-// ITERATIONS. Should draw a checkerboard on the screen after
-// a few seconds.
-//
-// Ported from a Java version by Google.
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-#include <GLES/glext.h>
-
-#include <WindowSurface.h>
-#include <EGLUtils.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-using namespace android;
-
-EGLDisplay eglDisplay;
-EGLSurface eglSurface;
-EGLContext eglContext;
-GLuint texture;
-
-#define FIXED_ONE 0x10000
-#define ITERATIONS 50
-
-int init_gl_surface(const WindowSurface&);
-void free_gl_surface(void);
-void init_scene(void);
-void render(int quads);
-void create_texture(void);
-int readTimer(void);
-
-static void gluLookAt(float eyeX, float eyeY, float eyeZ,
-        float centerX, float centerY, float centerZ, float upX, float upY,
-        float upZ)
-{
-    // See the OpenGL GLUT documentation for gluLookAt for a description
-    // of the algorithm. We implement it in a straightforward way:
-
-    float fx = centerX - eyeX;
-    float fy = centerY - eyeY;
-    float fz = centerZ - eyeZ;
-
-    // Normalize f
-    float rlf = 1.0f / sqrtf(fx*fx + fy*fy + fz*fz);
-    fx *= rlf;
-    fy *= rlf;
-    fz *= rlf;
-
-    // Normalize up
-    float rlup = 1.0f / sqrtf(upX*upX + upY*upY + upZ*upZ);
-    upX *= rlup;
-    upY *= rlup;
-    upZ *= rlup;
-
-    // compute s = f x up (x means "cross product")
-
-    float sx = fy * upZ - fz * upY;
-    float sy = fz * upX - fx * upZ;
-    float sz = fx * upY - fy * upX;
-
-    // compute u = s x f
-    float ux = sy * fz - sz * fy;
-    float uy = sz * fx - sx * fz;
-    float uz = sx * fy - sy * fx;
-
-    float m[16] ;
-    m[0] = sx;
-    m[1] = ux;
-    m[2] = -fx;
-    m[3] = 0.0f;
-
-    m[4] = sy;
-    m[5] = uy;
-    m[6] = -fy;
-    m[7] = 0.0f;
-
-    m[8] = sz;
-    m[9] = uz;
-    m[10] = -fz;
-    m[11] = 0.0f;
-
-    m[12] = 0.0f;
-    m[13] = 0.0f;
-    m[14] = 0.0f;
-    m[15] = 1.0f;
-
-    glMultMatrixf(m);
-    glTranslatef(-eyeX, -eyeY, -eyeZ);
-}
-
-int main(int argc, char **argv)
-{
-    printf("Initializing EGL...\n");
-
-    WindowSurface windowSurface;
-    if(!init_gl_surface(windowSurface))
-    {
-        printf("GL initialisation failed - exiting\n");
-        return 0;
-    }
-
-    init_scene();
-
-    create_texture();
-
-    printf("Start test...\n");
-
-    render(argc==2 ? atoi(argv[1]) : ITERATIONS);
-
-    free_gl_surface();
-
-    return 0;
-}
-
-int init_gl_surface(const WindowSurface& windowSurface)
-{
-    EGLConfig myConfig = {0};
-    EGLint attrib[] =
-    {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_DEPTH_SIZE,     16,
-            EGL_NONE
-    };
-
-    if ( (eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY)) == EGL_NO_DISPLAY )
-    {
-        printf("eglGetDisplay failed\n");
-        return 0;
-    }
-
-    if ( eglInitialize(eglDisplay, NULL, NULL) != EGL_TRUE )
-    {
-        printf("eglInitialize failed\n");
-        return 0;
-    }
-
-    EGLNativeWindowType window = windowSurface.getSurface();
-    EGLUtils::selectConfigForNativeWindow(eglDisplay, attrib, window, &myConfig);
-
-    if ( (eglSurface = eglCreateWindowSurface(eglDisplay, myConfig,
-            window, 0)) == EGL_NO_SURFACE )
-    {
-        printf("eglCreateWindowSurface failed\n");
-        return 0;
-    }
-
-    if ( (eglContext = eglCreateContext(eglDisplay, myConfig, 0, 0)) == EGL_NO_CONTEXT )
-    {
-        printf("eglCreateContext failed\n");
-        return 0;
-    }
-
-    if ( eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext) != EGL_TRUE )
-    {
-        printf("eglMakeCurrent failed\n");
-        return 0;
-    }
-
-    return 1;
-}
-
-void free_gl_surface(void)
-{
-    if (eglDisplay != EGL_NO_DISPLAY)
-    {
-        eglMakeCurrent( EGL_NO_DISPLAY, EGL_NO_SURFACE,
-                EGL_NO_SURFACE, EGL_NO_CONTEXT );
-        eglDestroyContext( eglDisplay, eglContext );
-        eglDestroySurface( eglDisplay, eglSurface );
-        eglTerminate( eglDisplay );
-        eglDisplay = EGL_NO_DISPLAY;
-    }
-}
-
-void init_scene(void)
-{
-    glDisable(GL_DITHER);
-    glEnable(GL_CULL_FACE);
-
-    float ratio = 320.0f / 480.0f;
-    glViewport(0, 0, 320, 480);
-
-    glMatrixMode(GL_PROJECTION);
-    glLoadIdentity();
-    glFrustumf(-ratio, ratio, -1, 1, 1, 10);
-
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
-    gluLookAt(
-            0, 0, 3,  // eye
-            0, 0, 0,  // center
-            0, 1, 0); // up
-
-    glEnable(GL_TEXTURE_2D);
-    glEnableClientState(GL_VERTEX_ARRAY);
-    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-}
-
-void create_texture(void)
-{
-    const unsigned int on = 0xff0000ff;
-    const unsigned int off = 0xffffffff;
-    const unsigned int pixels[] =
-    {
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-            on, off, on, off, on, off, on, off,
-            off, on, off, on, off, on, off, on,
-    };
-    glGenTextures(1, &texture);
-    glBindTexture(GL_TEXTURE_2D, texture);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 8, 8, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-}
-
-void render(int quads)
-{
-    int i, j;
-
-    const GLfloat vertices[] = {
-            -1,  -1,  0,
-             1,  -1,  0,
-             1,   1,  0,
-            -1,   1,  0
-    };
-
-    const GLfixed texCoords[] = {
-            0,            0,
-            FIXED_ONE,    0,
-            FIXED_ONE,    FIXED_ONE,
-            0,            FIXED_ONE
-    };
-
-    const GLushort quadIndices[] = { 0, 1, 2,  0, 2, 3 };
-
-
-    GLushort* indices = (GLushort*)malloc(quads*sizeof(quadIndices));
-    for (i=0 ; i<quads ; i++)
-        memcpy(indices+(sizeof(quadIndices)/sizeof(indices[0]))*i, quadIndices, sizeof(quadIndices));
-
-    glVertexPointer(3, GL_FLOAT, 0, vertices);
-    glTexCoordPointer(2, GL_FIXED, 0, texCoords);
-
-    // make sure to do a couple eglSwapBuffers to make sure there are
-    // no problems with the very first ones (who knows)
-    glClearColor(0.4, 0.4, 0.4, 0.4);
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(eglDisplay, eglSurface);
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(eglDisplay, eglSurface);
-    glClearColor(1.0, 1.0, 1.0, 1.0);
-
-    for (j=0 ; j<10 ; j++) {
-        printf("loop %d / 10 (%d quads / loop)\n", j, quads);
-
-        int nelem = sizeof(quadIndices)/sizeof(quadIndices[0]);
-        glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
-        glDrawElements(GL_TRIANGLES, nelem*quads, GL_UNSIGNED_SHORT, indices);
-        eglSwapBuffers(eglDisplay, eglSurface);
-    }
-
-    free(indices);
-}
-
diff --git a/opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp b/opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp
index f90e3ec590..f6813fdc03 100644
--- a/opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp
+++ b/opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp
@@ -17,10 +17,11 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include "jni.h"
-#include <nativehelper/JNIHelp.h>
+#include "JNIHelp.h"
 #include <android_runtime/AndroidRuntime.h>
 #include <android_runtime/android_view_Surface.h>
 #include <android_runtime/android_graphics_SurfaceTexture.h>
diff --git a/opengl/tools/glgen/stubs/egl/EGLExtcHeader.cpp b/opengl/tools/glgen/stubs/egl/EGLExtcHeader.cpp
index 12b96f40d7..4df61d3126 100644
--- a/opengl/tools/glgen/stubs/egl/EGLExtcHeader.cpp
+++ b/opengl/tools/glgen/stubs/egl/EGLExtcHeader.cpp
@@ -17,10 +17,11 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include "jni.h"
-#include <nativehelper/JNIHelp.h>
+#include "JNIHelp.h"
 #include <android_runtime/AndroidRuntime.h>
 #include <android_runtime/android_view_Surface.h>
 #include <android_runtime/android_graphics_SurfaceTexture.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES10ExtcHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES10ExtcHeader.cpp
index dd17ca458a..1fa92758ad 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES10ExtcHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES10ExtcHeader.cpp
@@ -18,6 +18,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <GLES/gl.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES10cHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES10cHeader.cpp
index dd17ca458a..1fa92758ad 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES10cHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES10cHeader.cpp
@@ -18,6 +18,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <GLES/gl.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES11ExtcHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES11ExtcHeader.cpp
index dd17ca458a..1fa92758ad 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES11ExtcHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES11ExtcHeader.cpp
@@ -18,6 +18,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <GLES/gl.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES11cHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES11cHeader.cpp
index dd17ca458a..1fa92758ad 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES11cHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES11cHeader.cpp
@@ -18,6 +18,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <GLES/gl.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES20cHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES20cHeader.cpp
index b2bbdf6fe9..4004a7dfcf 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES20cHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES20cHeader.cpp
@@ -18,6 +18,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <GLES2/gl2.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES30cHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES30cHeader.cpp
index b039bc9a83..c5bdf323fc 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES30cHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES30cHeader.cpp
@@ -18,6 +18,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <GLES3/gl3.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES31ExtcHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES31ExtcHeader.cpp
index dd00e9205c..2260a80bb4 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES31ExtcHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES31ExtcHeader.cpp
@@ -17,6 +17,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <GLES3/gl31.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES31cHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES31cHeader.cpp
index 88e00bef6e..130612d7cc 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES31cHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES31cHeader.cpp
@@ -17,6 +17,7 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <stdint.h>
diff --git a/opengl/tools/glgen/stubs/gles11/GLES32cHeader.cpp b/opengl/tools/glgen/stubs/gles11/GLES32cHeader.cpp
index 3e7ec8b2de..e9c5fc7696 100644
--- a/opengl/tools/glgen/stubs/gles11/GLES32cHeader.cpp
+++ b/opengl/tools/glgen/stubs/gles11/GLES32cHeader.cpp
@@ -17,7 +17,8 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include <stdint.h>
-#include <GLES3/gl32.h>
+#include <GLES3/gl32.h>
\ No newline at end of file
diff --git a/opengl/tools/glgen/stubs/gles11/common.cpp b/opengl/tools/glgen/stubs/gles11/common.cpp
index 2163d7600d..7062c5751f 100644
--- a/opengl/tools/glgen/stubs/gles11/common.cpp
+++ b/opengl/tools/glgen/stubs/gles11/common.cpp
@@ -1,5 +1,5 @@
 #include <jni.h>
-#include <nativehelper/JNIHelp.h>
+#include <JNIHelp.h>
 #include <android_runtime/AndroidRuntime.h>
 #include <utils/misc.h>
 #include <assert.h>
diff --git a/opengl/tools/glgen/stubs/jsr239/GLCHeader.cpp b/opengl/tools/glgen/stubs/jsr239/GLCHeader.cpp
index 29296ff6a9..026cb371aa 100644
--- a/opengl/tools/glgen/stubs/jsr239/GLCHeader.cpp
+++ b/opengl/tools/glgen/stubs/jsr239/GLCHeader.cpp
@@ -17,10 +17,11 @@
 // This source file is automatically generated
 
 #pragma GCC diagnostic ignored "-Wunused-variable"
+#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 #include "jni.h"
-#include <nativehelper/JNIHelp.h>
+#include "JNIHelp.h"
 #include <android_runtime/AndroidRuntime.h>
 #include <utils/misc.h>
 
-- 
2.17.0

