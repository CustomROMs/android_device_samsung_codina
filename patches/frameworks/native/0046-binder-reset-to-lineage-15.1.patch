From 8d40329891d162859c5a1e8f8dd1329f81422698 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 3 Sep 2018 06:43:30 +0300
Subject: [PATCH 46/46] binder: reset to lineage-15.1

Change-Id: I4f49ba75e652653b47ddddbed0c37a1a6fdcb1fd
---
 libs/binder/Android.bp                        |    3 +-
 libs/binder/AppOpsManager.cpp                 |   22 +-
 libs/binder/Binder.cpp                        |   22 +-
 libs/binder/BpBinder.cpp                      |  138 +-
 libs/binder/BufferedTextOutput.cpp            |   18 +-
 libs/binder/Debug.cpp                         |    6 +-
 libs/binder/IAppOpsService.cpp                |    2 +-
 libs/binder/IInterface.cpp                    |    4 +-
 libs/binder/IMemory.cpp                       |   22 +-
 libs/binder/IPCThreadState.cpp                |   63 +-
 libs/binder/IResultReceiver.cpp               |    4 +-
 libs/binder/IServiceManager.cpp               |   20 +-
 libs/binder/IShellCallback.cpp                |    2 +-
 libs/binder/MemoryDealer.cpp                  |   34 +-
 libs/binder/MemoryHeapBase.cpp                |   16 +-
 libs/binder/Parcel.cpp                        |  110 +-
 libs/binder/PermissionCache.cpp               |    2 +-
 libs/binder/ProcessInfoService.cpp            |    6 +-
 libs/binder/ProcessState.cpp                  |   50 +-
 libs/binder/Static.cpp                        |   15 +
 libs/binder/Value.cpp                         |   26 +-
 libs/binder/include/binder/AppOpsManager.h    |   18 +
 libs/binder/include/binder/BpBinder.h         |   26 +-
 libs/binder/include/binder/IInterface.h       |    2 +-
 libs/binder/include/binder/ProcessState.h     |    5 +-
 libs/binder/tests/Android.bp                  |  147 --
 .../tests/binderDriverInterfaceTest.cpp       |  370 -----
 libs/binder/tests/binderLibTest.cpp           | 1360 -----------------
 libs/binder/tests/binderSafeInterfaceTest.cpp |  819 ----------
 libs/binder/tests/binderTextOutputTest.cpp    |  176 ---
 libs/binder/tests/binderThroughputTest.cpp    |  400 -----
 libs/binder/tests/binderValueTypeTest.cpp     |  111 --
 libs/binder/tests/schd-dbg.cpp                |  502 ------
 33 files changed, 256 insertions(+), 4265 deletions(-)
 delete mode 100644 libs/binder/tests/Android.bp
 delete mode 100644 libs/binder/tests/binderDriverInterfaceTest.cpp
 delete mode 100644 libs/binder/tests/binderLibTest.cpp
 delete mode 100644 libs/binder/tests/binderSafeInterfaceTest.cpp
 delete mode 100644 libs/binder/tests/binderTextOutputTest.cpp
 delete mode 100644 libs/binder/tests/binderThroughputTest.cpp
 delete mode 100644 libs/binder/tests/binderValueTypeTest.cpp
 delete mode 100644 libs/binder/tests/schd-dbg.cpp

diff --git a/libs/binder/Android.bp b/libs/binder/Android.bp
index 2a39638e56..09829aeb27 100644
--- a/libs/binder/Android.bp
+++ b/libs/binder/Android.bp
@@ -82,6 +82,7 @@ cc_library {
         "-Wall",
         "-Wextra",
         "-DDISABLE_ASHMEM_TRACKING",
+        "-DSTE_HARDWARE",
     ],
     product_variables: {
         binder32bit: {
@@ -118,5 +119,3 @@ filegroup {
         "aidl/android/content/pm/IPackageManagerNative.aidl",
     ],
 }
-
-subdirs = ["tests"]
diff --git a/libs/binder/AppOpsManager.cpp b/libs/binder/AppOpsManager.cpp
index 4a9b9a7608..f3b86ae311 100644
--- a/libs/binder/AppOpsManager.cpp
+++ b/libs/binder/AppOpsManager.cpp
@@ -42,7 +42,7 @@ static sp<IBinder> gToken;
 
 static const sp<IBinder>& getToken(const sp<IAppOpsService>& service) {
     pthread_mutex_lock(&gTokenMutex);
-    if (gToken == nullptr || gToken->pingBinder() != NO_ERROR) {
+    if (gToken == NULL || gToken->pingBinder() != NO_ERROR) {
         gToken = service->getToken(new BBinder());
     }
     pthread_mutex_unlock(&gTokenMutex);
@@ -63,16 +63,16 @@ sp<IAppOpsService> AppOpsManager::getService()
     std::lock_guard<Mutex> scoped_lock(mLock);
     int64_t startTime = 0;
     sp<IAppOpsService> service = mService;
-    while (service == nullptr || !IInterface::asBinder(service)->isBinderAlive()) {
+    while (service == NULL || !IInterface::asBinder(service)->isBinderAlive()) {
         sp<IBinder> binder = defaultServiceManager()->checkService(_appops);
-        if (binder == nullptr) {
+        if (binder == NULL) {
             // Wait for the app ops service to come back...
             if (startTime == 0) {
                 startTime = uptimeMillis();
                 ALOGI("Waiting for app ops service");
             } else if ((uptimeMillis()-startTime) > 10000) {
                 ALOGW("Waiting too long for app ops service, giving up");
-                service = nullptr;
+                service = NULL;
                 break;
             }
             sleep(1);
@@ -88,28 +88,28 @@ sp<IAppOpsService> AppOpsManager::getService()
 int32_t AppOpsManager::checkOp(int32_t op, int32_t uid, const String16& callingPackage)
 {
     sp<IAppOpsService> service = getService();
-    return service != nullptr
+    return service != NULL
             ? service->checkOperation(op, uid, callingPackage)
             : APP_OPS_MANAGER_UNAVAILABLE_MODE;
 }
 
 int32_t AppOpsManager::noteOp(int32_t op, int32_t uid, const String16& callingPackage) {
     sp<IAppOpsService> service = getService();
-    return service != nullptr
+    return service != NULL
             ? service->noteOperation(op, uid, callingPackage)
             : APP_OPS_MANAGER_UNAVAILABLE_MODE;
 }
 
 int32_t AppOpsManager::startOp(int32_t op, int32_t uid, const String16& callingPackage) {
     sp<IAppOpsService> service = getService();
-    return service != nullptr
+    return service != NULL
             ? service->startOperation(getToken(service), op, uid, callingPackage)
             : APP_OPS_MANAGER_UNAVAILABLE_MODE;
 }
 
 void AppOpsManager::finishOp(int32_t op, int32_t uid, const String16& callingPackage) {
     sp<IAppOpsService> service = getService();
-    if (service != nullptr) {
+    if (service != NULL) {
         service->finishOperation(getToken(service), op, uid, callingPackage);
     }
 }
@@ -117,21 +117,21 @@ void AppOpsManager::finishOp(int32_t op, int32_t uid, const String16& callingPac
 void AppOpsManager::startWatchingMode(int32_t op, const String16& packageName,
         const sp<IAppOpsCallback>& callback) {
     sp<IAppOpsService> service = getService();
-    if (service != nullptr) {
+    if (service != NULL) {
         service->startWatchingMode(op, packageName, callback);
     }
 }
 
 void AppOpsManager::stopWatchingMode(const sp<IAppOpsCallback>& callback) {
     sp<IAppOpsService> service = getService();
-    if (service != nullptr) {
+    if (service != NULL) {
         service->stopWatchingMode(callback);
     }
 }
 
 int32_t AppOpsManager::permissionToOpCode(const String16& permission) {
     sp<IAppOpsService> service = getService();
-    if (service != nullptr) {
+    if (service != NULL) {
         return service->permissionToOpCode(permission);
     }
     return -1;
diff --git a/libs/binder/Binder.cpp b/libs/binder/Binder.cpp
index 1bd7c4fb42..890ef30ec7 100644
--- a/libs/binder/Binder.cpp
+++ b/libs/binder/Binder.cpp
@@ -43,17 +43,17 @@ IBinder::~IBinder()
 
 sp<IInterface>  IBinder::queryLocalInterface(const String16& /*descriptor*/)
 {
-    return nullptr;
+    return NULL;
 }
 
 BBinder* IBinder::localBinder()
 {
-    return nullptr;
+    return NULL;
 }
 
 BpBinder* IBinder::remoteBinder()
 {
-    return nullptr;
+    return NULL;
 }
 
 bool IBinder::checkSubclass(const void* /*subclassID*/) const
@@ -76,8 +76,8 @@ status_t IBinder::shellCommand(const sp<IBinder>& target, int in, int out, int e
     for (size_t i = 0; i < numArgs; i++) {
         send.writeString16(args[i]);
     }
-    send.writeStrongBinder(callback != nullptr ? IInterface::asBinder(callback) : nullptr);
-    send.writeStrongBinder(resultReceiver != nullptr ? IInterface::asBinder(resultReceiver) : nullptr);
+    send.writeStrongBinder(callback != NULL ? IInterface::asBinder(callback) : NULL);
+    send.writeStrongBinder(resultReceiver != NULL ? IInterface::asBinder(resultReceiver) : NULL);
     return target->transact(SHELL_COMMAND_TRANSACTION, send, &reply);
 }
 
@@ -130,7 +130,7 @@ status_t BBinder::transact(
             break;
     }
 
-    if (reply != nullptr) {
+    if (reply != NULL) {
         reply->setDataPosition(0);
     }
 
@@ -171,7 +171,7 @@ void BBinder::attachObject(
             delete e;
             e = expected;  // Filled in by CAS
         }
-        if (e == nullptr) return; // out of memory
+        if (e == 0) return; // out of memory
     }
 
     AutoMutex _l(e->mLock);
@@ -181,7 +181,7 @@ void BBinder::attachObject(
 void* BBinder::findObject(const void* objectID) const
 {
     Extras* e = mExtras.load(std::memory_order_acquire);
-    if (!e) return nullptr;
+    if (!e) return NULL;
 
     AutoMutex _l(e->mLock);
     return e->mObjects.find(objectID);
@@ -246,11 +246,9 @@ status_t BBinder::onTransact(
             (void)out;
             (void)err;
 
-            if (resultReceiver != nullptr) {
+            if (resultReceiver != NULL) {
                 resultReceiver->send(INVALID_OPERATION);
             }
-
-            return NO_ERROR;
         }
 
         case SYSPROPS_TRANSACTION: {
@@ -273,7 +271,7 @@ enum {
 };
 
 BpRefBase::BpRefBase(const sp<IBinder>& o)
-    : mRemote(o.get()), mRefs(nullptr), mState(0)
+    : mRemote(o.get()), mRefs(NULL), mState(0)
 {
     extendObjectLifetime(OBJECT_LIFETIME_WEAK);
 
diff --git a/libs/binder/BpBinder.cpp b/libs/binder/BpBinder.cpp
index 75ad5d51b5..c0e029622a 100644
--- a/libs/binder/BpBinder.cpp
+++ b/libs/binder/BpBinder.cpp
@@ -21,7 +21,6 @@
 
 #include <binder/IPCThreadState.h>
 #include <binder/IResultReceiver.h>
-#include <cutils/compiler.h>
 #include <utils/Log.h>
 
 #include <stdio.h>
@@ -33,23 +32,6 @@ namespace android {
 
 // ---------------------------------------------------------------------------
 
-Mutex BpBinder::sTrackingLock;
-std::unordered_map<int32_t,uint32_t> BpBinder::sTrackingMap;
-int BpBinder::sNumTrackedUids = 0;
-std::atomic_bool BpBinder::sCountByUidEnabled(false);
-binder_proxy_limit_callback BpBinder::sLimitCallback;
-bool BpBinder::sBinderProxyThrottleCreate = false;
-
-// Arbitrarily high value that probably distinguishes a bad behaving app
-uint32_t BpBinder::sBinderProxyCountHighWatermark = 2500;
-// Another arbitrary value a binder count needs to drop below before another callback will be called
-uint32_t BpBinder::sBinderProxyCountLowWatermark = 2000;
-
-enum {
-    CALLBACK_TRIGGERED_MASK = 0x80000000,   // A flag denoting that the callback has been called
-    COUNTING_VALUE_MASK = 0x7FFFFFFF,       // A mask of the remaining bits for the count value
-};
-
 BpBinder::ObjectManager::ObjectManager()
 {
 }
@@ -80,7 +62,7 @@ void BpBinder::ObjectManager::attach(
 void* BpBinder::ObjectManager::find(const void* objectID) const
 {
     const ssize_t i = mObjects.indexOfKey(objectID);
-    if (i < 0) return nullptr;
+    if (i < 0) return NULL;
     return mObjects.valueAt(i).object;
 }
 
@@ -95,7 +77,7 @@ void BpBinder::ObjectManager::kill()
     ALOGV("Killing %zu objects in manager %p", N, this);
     for (size_t i=0; i<N; i++) {
         const entry_t& e = mObjects.valueAt(i);
-        if (e.func != nullptr) {
+        if (e.func != NULL) {
             e.func(mObjects.keyAt(i), e.object, e.cleanupCookie);
         }
     }
@@ -105,47 +87,11 @@ void BpBinder::ObjectManager::kill()
 
 // ---------------------------------------------------------------------------
 
-
-BpBinder* BpBinder::create(int32_t handle) {
-    int32_t trackedUid = -1;
-    if (sCountByUidEnabled) {
-        BpBinder* out;
-        trackedUid = IPCThreadState::self()->getCallingUid();
-        AutoMutex _l(sTrackingLock);
-        if ((sTrackingMap[trackedUid] & COUNTING_VALUE_MASK) >= sBinderProxyCountHighWatermark) {
-            ALOGE("Too many binder proxy objects sent to uid %d from uid %d (over %d proxies held)",
-                   getuid(), trackedUid, sBinderProxyCountHighWatermark);
-
-            if (sBinderProxyThrottleCreate) {
-                ALOGE("Returning Null Binder Proxy Object to uid %d", trackedUid);
-                out = nullptr;
-            } else {
-                // increment and construct here in case callback has an async kill causing a race
-                sTrackingMap[trackedUid]++;
-                out = new BpBinder(handle, trackedUid);
-            }
-
-            if (sLimitCallback && !(sTrackingMap[trackedUid] & CALLBACK_TRIGGERED_MASK)) {
-                sTrackingMap[trackedUid] |= CALLBACK_TRIGGERED_MASK;
-                sLimitCallback(trackedUid);
-            }
-        } else {
-            sTrackingMap[trackedUid]++;
-            out = new BpBinder(handle, trackedUid);
-        }
-
-        return out;
-    } else {
-        return new BpBinder(handle, trackedUid);
-    }
-}
-
-BpBinder::BpBinder(int32_t handle, int32_t trackedUid)
+BpBinder::BpBinder(int32_t handle)
     : mHandle(handle)
     , mAlive(1)
     , mObitsSent(0)
-    , mObituaries(nullptr)
-    , mTrackedUid(trackedUid)
+    , mObituaries(NULL)
 {
     ALOGV("Creating BpBinder %p handle %d\n", this, mHandle);
 
@@ -233,7 +179,7 @@ status_t BpBinder::linkToDeath(
     ob.cookie = cookie;
     ob.flags = flags;
 
-    LOG_ALWAYS_FATAL_IF(recipient == nullptr,
+    LOG_ALWAYS_FATAL_IF(recipient == NULL,
                         "linkToDeath(): recipient must be non-NULL");
 
     {
@@ -273,9 +219,9 @@ status_t BpBinder::unlinkToDeath(
     for (size_t i=0; i<N; i++) {
         const Obituary& obit = mObituaries->itemAt(i);
         if ((obit.recipient == recipient
-                    || (recipient == nullptr && obit.cookie == cookie))
+                    || (recipient == NULL && obit.cookie == cookie))
                 && obit.flags == flags) {
-            if (outRecipient != nullptr) {
+            if (outRecipient != NULL) {
                 *outRecipient = mObituaries->itemAt(i).recipient;
             }
             mObituaries->removeAt(i);
@@ -285,7 +231,7 @@ status_t BpBinder::unlinkToDeath(
                 self->clearDeathNotification(mHandle, this);
                 self->flushCommands();
                 delete mObituaries;
-                mObituaries = nullptr;
+                mObituaries = NULL;
             }
             return NO_ERROR;
         }
@@ -304,12 +250,12 @@ void BpBinder::sendObituary()
 
     mLock.lock();
     Vector<Obituary>* obits = mObituaries;
-    if(obits != nullptr) {
+    if(obits != NULL) {
         ALOGV("Clearing sent death notification: %p handle %d\n", this, mHandle);
         IPCThreadState* self = IPCThreadState::self();
         self->clearDeathNotification(mHandle, this);
         self->flushCommands();
-        mObituaries = nullptr;
+        mObituaries = NULL;
     }
     mObitsSent = 1;
     mLock.unlock();
@@ -317,7 +263,7 @@ void BpBinder::sendObituary()
     ALOGV("Reporting death of proxy %p for %zu recipients\n",
         this, obits ? obits->size() : 0U);
 
-    if (obits != nullptr) {
+    if (obits != NULL) {
         const size_t N = obits->size();
         for (size_t i=0; i<N; i++) {
             reportOneDeath(obits->itemAt(i));
@@ -331,7 +277,7 @@ void BpBinder::reportOneDeath(const Obituary& obit)
 {
     sp<DeathRecipient> recipient = obit.recipient.promote();
     ALOGV("Reporting death to recipient: %p\n", recipient.get());
-    if (recipient == nullptr) return;
+    if (recipient == NULL) return;
 
     recipient->binderDied(this);
 }
@@ -369,33 +315,15 @@ BpBinder::~BpBinder()
 
     IPCThreadState* ipc = IPCThreadState::self();
 
-    if (mTrackedUid >= 0) {
-        AutoMutex _l(sTrackingLock);
-        if (CC_UNLIKELY(sTrackingMap[mTrackedUid] == 0)) {
-            ALOGE("Unexpected Binder Proxy tracking decrement in %p handle %d\n", this, mHandle);
-        } else {
-            if (CC_UNLIKELY(
-                (sTrackingMap[mTrackedUid] & CALLBACK_TRIGGERED_MASK) &&
-                ((sTrackingMap[mTrackedUid] & COUNTING_VALUE_MASK) <= sBinderProxyCountLowWatermark)
-                )) {
-                // Clear the Callback Triggered bit when crossing below the low watermark
-                sTrackingMap[mTrackedUid] &= ~CALLBACK_TRIGGERED_MASK;
-            }
-            if (--sTrackingMap[mTrackedUid] == 0) {
-                sTrackingMap.erase(mTrackedUid);
-            }
-        }
-    }
-
     mLock.lock();
     Vector<Obituary>* obits = mObituaries;
-    if(obits != nullptr) {
+    if(obits != NULL) {
         if (ipc) ipc->clearDeathNotification(mHandle, this);
-        mObituaries = nullptr;
+        mObituaries = NULL;
     }
     mLock.unlock();
 
-    if (obits != nullptr) {
+    if (obits != NULL) {
         // XXX Should we tell any remaining DeathRecipient
         // objects that the last strong ref has gone away, so they
         // are no longer linked?
@@ -432,42 +360,6 @@ bool BpBinder::onIncStrongAttempted(uint32_t /*flags*/, const void* /*id*/)
     return ipc ? ipc->attemptIncStrongHandle(mHandle) == NO_ERROR : false;
 }
 
-uint32_t BpBinder::getBinderProxyCount(uint32_t uid)
-{
-    AutoMutex _l(sTrackingLock);
-    auto it = sTrackingMap.find(uid);
-    if (it != sTrackingMap.end()) {
-        return it->second & COUNTING_VALUE_MASK;
-    }
-    return 0;
-}
-
-void BpBinder::getCountByUid(Vector<uint32_t>& uids, Vector<uint32_t>& counts)
-{
-    AutoMutex _l(sTrackingLock);
-    uids.setCapacity(sTrackingMap.size());
-    counts.setCapacity(sTrackingMap.size());
-    for (const auto& it : sTrackingMap) {
-        uids.push_back(it.first);
-        counts.push_back(it.second & COUNTING_VALUE_MASK);
-    }
-}
-
-void BpBinder::enableCountByUid() { sCountByUidEnabled.store(true); }
-void BpBinder::disableCountByUid() { sCountByUidEnabled.store(false); }
-void BpBinder::setCountByUidEnabled(bool enable) { sCountByUidEnabled.store(enable); }
-
-void BpBinder::setLimitCallback(binder_proxy_limit_callback cb) {
-    AutoMutex _l(sTrackingLock);
-    sLimitCallback = cb;
-}
-
-void BpBinder::setBinderProxyCountWatermarks(int high, int low) {
-    AutoMutex _l(sTrackingLock);
-    sBinderProxyCountHighWatermark = high;
-    sBinderProxyCountLowWatermark = low;
-}
-
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/libs/binder/BufferedTextOutput.cpp b/libs/binder/BufferedTextOutput.cpp
index d516eb1d54..e72e254f9d 100644
--- a/libs/binder/BufferedTextOutput.cpp
+++ b/libs/binder/BufferedTextOutput.cpp
@@ -37,7 +37,7 @@ struct BufferedTextOutput::BufferState : public RefBase
 {
     explicit BufferState(int32_t _seq)
         : seq(_seq)
-        , buffer(nullptr)
+        , buffer(NULL)
         , bufferPos(0)
         , bufferSize(0)
         , atFront(true)
@@ -88,7 +88,7 @@ struct BufferedTextOutput::ThreadState
     Vector<sp<BufferedTextOutput::BufferState> > states;
 };
 
-static pthread_mutex_t gMutex = PTHREAD_MUTEX_INITIALIZER;
+static mutex_t          gMutex;
 
 static thread_store_t   tls;
 
@@ -114,7 +114,7 @@ static int32_t allocBufferIndex()
 {
     int32_t res = -1;
     
-    pthread_mutex_lock(&gMutex);
+    mutex_lock(&gMutex);
     
     if (gFreeBufferIndex >= 0) {
         res = gFreeBufferIndex;
@@ -126,17 +126,17 @@ static int32_t allocBufferIndex()
         gTextBuffers.add(-1);
     }
 
-    pthread_mutex_unlock(&gMutex);
+    mutex_unlock(&gMutex);
     
     return res;
 }
 
 static void freeBufferIndex(int32_t idx)
 {
-    pthread_mutex_lock(&gMutex);
+    mutex_lock(&gMutex);
     gTextBuffers.editItemAt(idx) = gFreeBufferIndex;
     gFreeBufferIndex = idx;
-    pthread_mutex_unlock(&gMutex);
+    mutex_unlock(&gMutex);
 }
 
 // ---------------------------------------------------------------------------
@@ -267,13 +267,13 @@ BufferedTextOutput::BufferState* BufferedTextOutput::getBuffer() const
     if ((mFlags&MULTITHREADED) != 0) {
         ThreadState* ts = getThreadState();
         if (ts) {
-            while (ts->states.size() <= (size_t)mIndex) ts->states.add(nullptr);
+            while (ts->states.size() <= (size_t)mIndex) ts->states.add(NULL);
             BufferState* bs = ts->states[mIndex].get();
-            if (bs != nullptr && bs->seq == mSeq) return bs;
+            if (bs != NULL && bs->seq == mSeq) return bs;
             
             ts->states.editItemAt(mIndex) = new BufferState(mIndex);
             bs = ts->states[mIndex].get();
-            if (bs != nullptr) return bs;
+            if (bs != NULL) return bs;
         }
     }
     
diff --git a/libs/binder/Debug.cpp b/libs/binder/Debug.cpp
index f38bbb2f32..4ac61a3007 100644
--- a/libs/binder/Debug.cpp
+++ b/libs/binder/Debug.cpp
@@ -165,13 +165,13 @@ void printHexData(int32_t indent, const void *buf, size_t length,
         else if (bytesPerLine >= 8) alignment = 2;
         else alignment = 1;
     }
-    if (func == nullptr) func = defaultPrintFunc;
+    if (func == NULL) func = defaultPrintFunc;
 
     size_t offset;
 
     unsigned char *pos = (unsigned char *)buf;
 
-    if (pos == nullptr) {
+    if (pos == NULL) {
         if (singleLineBytesCutoff < 0) func(cookie, "\n");
         func(cookie, "(NULL)");
         return;
@@ -297,7 +297,7 @@ void printHexData(int32_t indent, const void *buf, size_t length,
 
 ssize_t getBinderKernelReferences(size_t count, uintptr_t* buf) {
     sp<ProcessState> proc = ProcessState::selfOrNull();
-    if (proc.get() == nullptr) {
+    if (proc.get() == NULL) {
         return 0;
     }
 
diff --git a/libs/binder/IAppOpsService.cpp b/libs/binder/IAppOpsService.cpp
index c38568c40f..638ae5c8ac 100644
--- a/libs/binder/IAppOpsService.cpp
+++ b/libs/binder/IAppOpsService.cpp
@@ -108,7 +108,7 @@ public:
         data.writeStrongBinder(clientToken);
         remote()->transact(GET_TOKEN_TRANSACTION, data, &reply);
         // fail on exception
-        if (reply.readExceptionCode() != 0) return nullptr;
+        if (reply.readExceptionCode() != 0) return NULL;
         return reply.readStrongBinder();
     }
 
diff --git a/libs/binder/IInterface.cpp b/libs/binder/IInterface.cpp
index 6b7729186e..2fcd3d92fb 100644
--- a/libs/binder/IInterface.cpp
+++ b/libs/binder/IInterface.cpp
@@ -32,14 +32,14 @@ IInterface::~IInterface() {
 // static
 sp<IBinder> IInterface::asBinder(const IInterface* iface)
 {
-    if (iface == nullptr) return nullptr;
+    if (iface == NULL) return NULL;
     return const_cast<IInterface*>(iface)->onAsBinder();
 }
 
 // static
 sp<IBinder> IInterface::asBinder(const sp<IInterface>& iface)
 {
-    if (iface == nullptr) return nullptr;
+    if (iface == NULL) return NULL;
     return iface->onAsBinder();
 }
 
diff --git a/libs/binder/IMemory.cpp b/libs/binder/IMemory.cpp
index 7afec454a2..5c1a4f41e0 100644
--- a/libs/binder/IMemory.cpp
+++ b/libs/binder/IMemory.cpp
@@ -130,7 +130,7 @@ class BpMemory : public BpInterface<IMemory>
 public:
     explicit BpMemory(const sp<IBinder>& impl);
     virtual ~BpMemory();
-    virtual sp<IMemoryHeap> getMemory(ssize_t* offset=nullptr, size_t* size=nullptr) const;
+    virtual sp<IMemoryHeap> getMemory(ssize_t* offset=0, size_t* size=0) const;
 
 private:
     mutable sp<IMemoryHeap> mHeap;
@@ -145,22 +145,22 @@ void* IMemory::fastPointer(const sp<IBinder>& binder, ssize_t offset) const
     sp<IMemoryHeap> realHeap = BpMemoryHeap::get_heap(binder);
     void* const base = realHeap->base();
     if (base == MAP_FAILED)
-        return nullptr;
+        return 0;
     return static_cast<char*>(base) + offset;
 }
 
 void* IMemory::pointer() const {
     ssize_t offset;
     sp<IMemoryHeap> heap = getMemory(&offset);
-    void* const base = heap!=nullptr ? heap->base() : MAP_FAILED;
+    void* const base = heap!=0 ? heap->base() : MAP_FAILED;
     if (base == MAP_FAILED)
-        return nullptr;
+        return 0;
     return static_cast<char*>(base) + offset;
 }
 
 size_t IMemory::size() const {
     size_t size;
-    getMemory(nullptr, &size);
+    getMemory(NULL, &size);
     return size;
 }
 
@@ -183,16 +183,16 @@ BpMemory::~BpMemory()
 
 sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
 {
-    if (mHeap == nullptr) {
+    if (mHeap == 0) {
         Parcel data, reply;
         data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
         if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
             sp<IBinder> heap = reply.readStrongBinder();
             ssize_t o = reply.readInt32();
             size_t s = reply.readInt32();
-            if (heap != nullptr) {
+            if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
-                if (mHeap != nullptr) {
+                if (mHeap != 0) {
                     size_t heapSize = mHeap->getSize();
                     if (s <= heapSize
                             && o >= 0
@@ -202,7 +202,7 @@ sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
                     } else {
                         // Hm.
                         android_errorWriteWithInfoLog(0x534e4554,
-                            "26877992", -1, nullptr, 0);
+                            "26877992", -1, NULL, 0);
                         mOffset = 0;
                         mSize = 0;
                     }
@@ -212,7 +212,7 @@ sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
-    return (mSize > 0) ? mHeap : nullptr;
+    return (mSize > 0) ? mHeap : 0;
 }
 
 // ---------------------------------------------------------------------------
@@ -334,7 +334,7 @@ void BpMemoryHeap::assertReallyMapped() const
                 access |= PROT_WRITE;
             }
             mRealHeap = true;
-            mBase = mmap(nullptr, size, access, MAP_SHARED, fd, offset);
+            mBase = mmap(0, size, access, MAP_SHARED, fd, offset);
             if (mBase == MAP_FAILED) {
                 ALOGE("cannot map BpMemoryHeap (binder=%p), size=%zd, fd=%d (%s)",
                         IInterface::asBinder(this).get(), size, fd, strerror(errno));
diff --git a/libs/binder/IPCThreadState.cpp b/libs/binder/IPCThreadState.cpp
index 33ec65f10e..e8329613ab 100644
--- a/libs/binder/IPCThreadState.cpp
+++ b/libs/binder/IPCThreadState.cpp
@@ -289,7 +289,7 @@ restart:
 
     if (gShutdown) {
         ALOGW("Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n");
-        return nullptr;
+        return NULL;
     }
 
     pthread_mutex_lock(&gTLSMutex);
@@ -299,7 +299,7 @@ restart:
             pthread_mutex_unlock(&gTLSMutex);
             ALOGW("IPCThreadState::self() unable to create TLS key, expect a crash: %s\n",
                     strerror(key_create_value));
-            return nullptr;
+            return NULL;
         }
         gHaveTLS = true;
     }
@@ -314,7 +314,7 @@ IPCThreadState* IPCThreadState::selfOrNull()
         IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);
         return st;
     }
-    return nullptr;
+    return NULL;
 }
 
 void IPCThreadState::shutdown()
@@ -326,7 +326,7 @@ void IPCThreadState::shutdown()
         IPCThreadState* st = (IPCThreadState*)pthread_getspecific(gTLS);
         if (st) {
             delete st;
-            pthread_setspecific(gTLS, nullptr);
+            pthread_setspecific(gTLS, NULL);
         }
         pthread_key_delete(gTLS);
         gHaveTLS = false;
@@ -470,33 +470,22 @@ status_t IPCThreadState::getAndExecuteCommand()
 void IPCThreadState::processPendingDerefs()
 {
     if (mIn.dataPosition() >= mIn.dataSize()) {
-        /*
-         * The decWeak()/decStrong() calls may cause a destructor to run,
-         * which in turn could have initiated an outgoing transaction,
-         * which in turn could cause us to add to the pending refs
-         * vectors; so instead of simply iterating, loop until they're empty.
-         *
-         * We do this in an outer loop, because calling decStrong()
-         * may result in something being added to mPendingWeakDerefs,
-         * which could be delayed until the next incoming command
-         * from the driver if we don't process it now.
-         */
-        while (mPendingWeakDerefs.size() > 0 || mPendingStrongDerefs.size() > 0) {
-            while (mPendingWeakDerefs.size() > 0) {
-                RefBase::weakref_type* refs = mPendingWeakDerefs[0];
-                mPendingWeakDerefs.removeAt(0);
+        size_t numPending = mPendingWeakDerefs.size();
+        if (numPending > 0) {
+            for (size_t i = 0; i < numPending; i++) {
+                RefBase::weakref_type* refs = mPendingWeakDerefs[i];
                 refs->decWeak(mProcess.get());
             }
+            mPendingWeakDerefs.clear();
+        }
 
-            if (mPendingStrongDerefs.size() > 0) {
-                // We don't use while() here because we don't want to re-order
-                // strong and weak decs at all; if this decStrong() causes both a
-                // decWeak() and a decStrong() to be queued, we want to process
-                // the decWeak() first.
-                BBinder* obj = mPendingStrongDerefs[0];
-                mPendingStrongDerefs.removeAt(0);
+        numPending = mPendingStrongDerefs.size();
+        if (numPending > 0) {
+            for (size_t i = 0; i < numPending; i++) {
+                BBinder* obj = mPendingStrongDerefs[i];
                 obj->decStrong(mProcess.get());
             }
+            mPendingStrongDerefs.clear();
         }
     }
 }
@@ -571,7 +560,7 @@ status_t IPCThreadState::transact(int32_t handle,
                                   uint32_t code, const Parcel& data,
                                   Parcel* reply, uint32_t flags)
 {
-    status_t err;
+    status_t err = data.errorCheck();
 
     flags |= TF_ACCEPT_FDS;
 
@@ -582,9 +571,11 @@ status_t IPCThreadState::transact(int32_t handle,
             << indent << data << dedent << endl;
     }
 
-    LOG_ONEWAY(">>>> SEND from pid %d uid %d %s", getpid(), getuid(),
-        (flags & TF_ONE_WAY) == 0 ? "READ REPLY" : "ONE WAY");
-    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr);
+    if (err == NO_ERROR) {
+        LOG_ONEWAY(">>>> SEND from pid %d uid %d %s", getpid(), getuid(),
+            (flags & TF_ONE_WAY) == 0 ? "READ REPLY" : "ONE WAY");
+        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
+    }
 
     if (err != NO_ERROR) {
         if (reply) reply->setError(err);
@@ -621,7 +612,7 @@ status_t IPCThreadState::transact(int32_t handle,
             else alog << "(none requested)" << endl;
         }
     } else {
-        err = waitForResponse(nullptr, nullptr);
+        err = waitForResponse(NULL, NULL);
     }
 
     return err;
@@ -684,7 +675,7 @@ void IPCThreadState::expungeHandle(int32_t handle, IBinder* binder)
 #if LOG_REFCOUNTS
     ALOGV("IPCThreadState::expungeHandle(%ld)\n", handle);
 #endif
-    self()->mProcess->expungeHandle(handle, binder); // NOLINT
+    self()->mProcess->expungeHandle(handle, binder);
 }
 
 status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
@@ -725,7 +716,7 @@ status_t IPCThreadState::sendReply(const Parcel& reply, uint32_t flags)
     err = writeTransactionData(BC_REPLY, flags, -1, 0, reply, &statusBuffer);
     if (err < NO_ERROR) return err;
 
-    return waitForResponse(nullptr, nullptr);
+    return waitForResponse(NULL, NULL);
 }
 
 status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
@@ -785,14 +776,14 @@ status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
                             freeBuffer, this);
                     } else {
                         err = *reinterpret_cast<const status_t*>(tr.data.ptr.buffer);
-                        freeBuffer(nullptr,
+                        freeBuffer(NULL,
                             reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                             tr.data_size,
                             reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
                             tr.offsets_size/sizeof(binder_size_t), this);
                     }
                 } else {
-                    freeBuffer(nullptr,
+                    freeBuffer(NULL,
                         reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
                         tr.data_size,
                         reinterpret_cast<const binder_size_t*>(tr.data.ptr.offsets),
@@ -1185,7 +1176,7 @@ void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data,
         alog << "Writing BC_FREE_BUFFER for " << data << endl;
     }
     ALOG_ASSERT(data != NULL, "Called with NULL data");
-    if (parcel != nullptr) parcel->closeFileDescriptors();
+    if (parcel != NULL) parcel->closeFileDescriptors();
     IPCThreadState* state = self();
     state->mOut.writeInt32(BC_FREE_BUFFER);
     state->mOut.writePointer((uintptr_t)data);
diff --git a/libs/binder/IResultReceiver.cpp b/libs/binder/IResultReceiver.cpp
index 14b5259536..646809e089 100644
--- a/libs/binder/IResultReceiver.cpp
+++ b/libs/binder/IResultReceiver.cpp
@@ -40,7 +40,7 @@ public:
         Parcel data;
         data.writeInterfaceToken(IResultReceiver::getInterfaceDescriptor());
         data.writeInt32(resultCode);
-        remote()->transact(OP_SEND, data, nullptr, IBinder::FLAG_ONEWAY);
+        remote()->transact(OP_SEND, data, NULL, IBinder::FLAG_ONEWAY);
     }
 };
 
@@ -56,7 +56,7 @@ status_t BnResultReceiver::onTransact(
             CHECK_INTERFACE(IResultReceiver, data, reply);
             int32_t resultCode = data.readInt32();
             send(resultCode);
-            if (reply != nullptr) {
+            if (reply != NULL) {
                 reply->writeNoException();
             }
             return NO_ERROR;
diff --git a/libs/binder/IServiceManager.cpp b/libs/binder/IServiceManager.cpp
index 001dc9e6cd..c7a0f43a9d 100644
--- a/libs/binder/IServiceManager.cpp
+++ b/libs/binder/IServiceManager.cpp
@@ -33,14 +33,14 @@ namespace android {
 
 sp<IServiceManager> defaultServiceManager()
 {
-    if (gDefaultServiceManager != nullptr) return gDefaultServiceManager;
+    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;
 
     {
         AutoMutex _l(gDefaultServiceManagerLock);
-        while (gDefaultServiceManager == nullptr) {
+        while (gDefaultServiceManager == NULL) {
             gDefaultServiceManager = interface_cast<IServiceManager>(
-                ProcessState::self()->getContextObject(nullptr));
-            if (gDefaultServiceManager == nullptr)
+                ProcessState::self()->getContextObject(NULL));
+            if (gDefaultServiceManager == NULL)
                 sleep(1);
         }
     }
@@ -50,7 +50,7 @@ sp<IServiceManager> defaultServiceManager()
 
 bool checkCallingPermission(const String16& permission)
 {
-    return checkCallingPermission(permission, nullptr, nullptr);
+    return checkCallingPermission(permission, NULL, NULL);
 }
 
 static String16 _permission("permission");
@@ -76,7 +76,7 @@ bool checkPermission(const String16& permission, pid_t pid, uid_t uid)
     int64_t startTime = 0;
 
     while (true) {
-        if (pc != nullptr) {
+        if (pc != NULL) {
             bool res = pc->checkPermission(permission, pid, uid);
             if (res) {
                 if (startTime != 0) {
@@ -97,14 +97,14 @@ bool checkPermission(const String16& permission, pid_t pid, uid_t uid)
             // Object is dead!
             gDefaultServiceManagerLock.lock();
             if (gPermissionController == pc) {
-                gPermissionController = nullptr;
+                gPermissionController = NULL;
             }
             gDefaultServiceManagerLock.unlock();
         }
 
         // Need to retrieve the permission controller.
         sp<IBinder> binder = defaultServiceManager()->checkService(_permission);
-        if (binder == nullptr) {
+        if (binder == NULL) {
             // Wait for the permission controller to come back...
             if (startTime == 0) {
                 startTime = uptimeMillis();
@@ -146,9 +146,9 @@ public:
                 sleep(1);
             }
             sp<IBinder> svc = checkService(name);
-            if (svc != nullptr) return svc;
+            if (svc != NULL) return svc;
         }
-        return nullptr;
+        return NULL;
     }
 
     virtual sp<IBinder> checkService( const String16& name) const
diff --git a/libs/binder/IShellCallback.cpp b/libs/binder/IShellCallback.cpp
index 4568a426cd..c793df3266 100644
--- a/libs/binder/IShellCallback.cpp
+++ b/libs/binder/IShellCallback.cpp
@@ -65,7 +65,7 @@ status_t BnShellCallback::onTransact(
             String16 path(data.readString16());
             String16 seLinuxContext(data.readString16());
             int fd = openOutputFile(path, seLinuxContext);
-            if (reply != nullptr) {
+            if (reply != NULL) {
                 reply->writeNoException();
                 if (fd >= 0) {
                     reply->writeInt32(1);
diff --git a/libs/binder/MemoryDealer.cpp b/libs/binder/MemoryDealer.cpp
index eacad3b6b3..2a15773aa3 100644
--- a/libs/binder/MemoryDealer.cpp
+++ b/libs/binder/MemoryDealer.cpp
@@ -52,8 +52,8 @@ class LinkedList
     NODE*  mLast;
 
 public:
-                LinkedList() : mFirst(nullptr), mLast(nullptr) { }
-    bool        isEmpty() const { return mFirst == nullptr; }
+                LinkedList() : mFirst(0), mLast(0) { }
+    bool        isEmpty() const { return mFirst == 0; }
     NODE const* head() const { return mFirst; }
     NODE*       head() { return mFirst; }
     NODE const* tail() const { return mLast; }
@@ -62,7 +62,7 @@ public:
     void insertAfter(NODE* node, NODE* newNode) {
         newNode->prev = node;
         newNode->next = node->next;
-        if (node->next == nullptr) mLast = newNode;
+        if (node->next == 0) mLast = newNode;
         else                 node->next->prev = newNode;
         node->next = newNode;
     }
@@ -70,17 +70,17 @@ public:
     void insertBefore(NODE* node, NODE* newNode) {
          newNode->prev = node->prev;
          newNode->next = node;
-         if (node->prev == nullptr)   mFirst = newNode;
+         if (node->prev == 0)   mFirst = newNode;
          else                   node->prev->next = newNode;
          node->prev = newNode;
     }
 
     void insertHead(NODE* newNode) {
-        if (mFirst == nullptr) {
+        if (mFirst == 0) {
             mFirst = mLast = newNode;
-            newNode->prev = newNode->next = nullptr;
+            newNode->prev = newNode->next = 0;
         } else {
-            newNode->prev = nullptr;
+            newNode->prev = 0;
             newNode->next = mFirst;
             mFirst->prev = newNode;
             mFirst = newNode;
@@ -99,9 +99,9 @@ public:
     }
 
     NODE* remove(NODE* node) {
-        if (node->prev == nullptr)    mFirst = node->next;
+        if (node->prev == 0)    mFirst = node->next;
         else                    node->prev->next = node->next;
-        if (node->next == nullptr)    mLast = node->prev;
+        if (node->next == 0)    mLast = node->prev;
         else                    node->next->prev = node->prev;
         return node;
     }
@@ -141,7 +141,7 @@ private:
 
     struct chunk_t {
         chunk_t(size_t start, size_t size)
-        : start(start), size(size), free(1), prev(nullptr), next(nullptr) {
+        : start(start), size(size), free(1), prev(0), next(0) {
         }
         size_t              start;
         size_t              size : 28;
@@ -289,15 +289,7 @@ SimpleBestFitAllocator::SimpleBestFitAllocator(size_t size)
 SimpleBestFitAllocator::~SimpleBestFitAllocator()
 {
     while(!mList.isEmpty()) {
-        chunk_t* removed = mList.remove(mList.head());
-#ifdef __clang_analyzer__
-        // Clang static analyzer gets confused in this loop
-        // and generates a false positive warning about accessing
-        // memory that is already freed.
-        // Add an "assert" to avoid the confusion.
-        LOG_ALWAYS_FATAL_IF(mList.head() == removed);
-#endif
-        delete removed;
+        delete mList.remove(mList.head());
     }
 }
 
@@ -329,7 +321,7 @@ ssize_t SimpleBestFitAllocator::alloc(size_t size, uint32_t flags)
         return 0;
     }
     size = (size + kMemoryAlign-1) / kMemoryAlign;
-    chunk_t* free_chunk = nullptr;
+    chunk_t* free_chunk = 0;
     chunk_t* cur = mList.head();
 
     size_t pagesize = getpagesize();
@@ -418,7 +410,7 @@ SimpleBestFitAllocator::chunk_t* SimpleBestFitAllocator::dealloc(size_t start)
         }
         cur = cur->next;
     }
-    return nullptr;
+    return 0;
 }
 
 void SimpleBestFitAllocator::dump(const char* what) const
diff --git a/libs/binder/MemoryHeapBase.cpp b/libs/binder/MemoryHeapBase.cpp
index 9850ad9624..03f00be6a2 100644
--- a/libs/binder/MemoryHeapBase.cpp
+++ b/libs/binder/MemoryHeapBase.cpp
@@ -36,17 +36,17 @@ namespace android {
 
 MemoryHeapBase::MemoryHeapBase()
     : mFD(-1), mSize(0), mBase(MAP_FAILED),
-      mDevice(nullptr), mNeedUnmap(false), mOffset(0)
+      mDevice(NULL), mNeedUnmap(false), mOffset(0)
 {
 }
 
 MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, char const * name)
     : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags),
-      mDevice(nullptr), mNeedUnmap(false), mOffset(0)
+      mDevice(0), mNeedUnmap(false), mOffset(0)
 {
     const size_t pagesize = getpagesize();
     size = ((size + pagesize-1) & ~(pagesize-1));
-    int fd = ashmem_create_region(name == nullptr ? "MemoryHeapBase" : name, size);
+    int fd = ashmem_create_region(name == NULL ? "MemoryHeapBase" : name, size);
     ALOGE_IF(fd<0, "error creating ashmem region: %s", strerror(errno));
     if (fd >= 0) {
         if (mapfd(fd, size) == NO_ERROR) {
@@ -59,7 +59,7 @@ MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, char const * name)
 
 MemoryHeapBase::MemoryHeapBase(const char* device, size_t size, uint32_t flags)
     : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags),
-      mDevice(nullptr), mNeedUnmap(false), mOffset(0)
+      mDevice(0), mNeedUnmap(false), mOffset(0)
 {
     int open_flags = O_RDWR;
     if (flags & NO_CACHING)
@@ -78,7 +78,7 @@ MemoryHeapBase::MemoryHeapBase(const char* device, size_t size, uint32_t flags)
 
 MemoryHeapBase::MemoryHeapBase(int fd, size_t size, uint32_t flags, uint32_t offset)
     : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags),
-      mDevice(nullptr), mNeedUnmap(false), mOffset(0)
+      mDevice(0), mNeedUnmap(false), mOffset(0)
 {
     const size_t pagesize = getpagesize();
     size = ((size + pagesize-1) & ~(pagesize-1));
@@ -109,7 +109,7 @@ status_t MemoryHeapBase::mapfd(int fd, size_t size, uint32_t offset)
     }
 
     if ((mFlags & DONT_MAP_LOCALLY) == 0) {
-        void* base = (uint8_t*)mmap(nullptr, size,
+        void* base = (uint8_t*)mmap(0, size,
                 PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset);
         if (base == MAP_FAILED) {
             ALOGE("mmap(fd=%d, size=%u) failed (%s)",
@@ -121,7 +121,7 @@ status_t MemoryHeapBase::mapfd(int fd, size_t size, uint32_t offset)
         mBase = base;
         mNeedUnmap = true;
     } else  {
-        mBase = nullptr; // not MAP_FAILED
+        mBase = 0; // not MAP_FAILED
         mNeedUnmap = false;
     }
     mFD = fd;
@@ -143,7 +143,7 @@ void MemoryHeapBase::dispose()
             //ALOGD("munmap(fd=%d, base=%p, size=%lu)", fd, mBase, mSize);
             munmap(mBase, mSize);
         }
-        mBase = nullptr;
+        mBase = 0;
         mSize = 0;
         close(fd);
     }
diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp
index fe4722b29d..da3bb1d228 100644
--- a/libs/binder/Parcel.cpp
+++ b/libs/binder/Parcel.cpp
@@ -117,7 +117,7 @@ void acquire_object(const sp<ProcessState>& proc,
             return;
         case BINDER_TYPE_HANDLE: {
             const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);
-            if (b != nullptr) {
+            if (b != NULL) {
                 LOG_REFS("Parcel %p acquiring reference on remote %p", who, b.get());
                 b->incStrong(who);
             }
@@ -125,11 +125,11 @@ void acquire_object(const sp<ProcessState>& proc,
         }
         case BINDER_TYPE_WEAK_HANDLE: {
             const wp<IBinder> b = proc->getWeakProxyForHandle(obj.handle);
-            if (b != nullptr) b.get_refs()->incWeak(who);
+            if (b != NULL) b.get_refs()->incWeak(who);
             return;
         }
         case BINDER_TYPE_FD: {
-            if ((obj.cookie != 0) && (outAshmemSize != nullptr) && ashmem_valid(obj.handle)) {
+            if ((obj.cookie != 0) && (outAshmemSize != NULL) && ashmem_valid(obj.handle)) {
                 // If we own an ashmem fd, keep track of how much memory it refers to.
                 int size = ashmem_get_size_region(obj.handle);
                 if (size > 0) {
@@ -146,7 +146,7 @@ void acquire_object(const sp<ProcessState>& proc,
 void acquire_object(const sp<ProcessState>& proc,
     const flat_binder_object& obj, const void* who)
 {
-    acquire_object(proc, obj, who, nullptr);
+    acquire_object(proc, obj, who, NULL);
 }
 
 static void release_object(const sp<ProcessState>& proc,
@@ -165,7 +165,7 @@ static void release_object(const sp<ProcessState>& proc,
             return;
         case BINDER_TYPE_HANDLE: {
             const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);
-            if (b != nullptr) {
+            if (b != NULL) {
                 LOG_REFS("Parcel %p releasing reference on remote %p", who, b.get());
                 b->decStrong(who);
             }
@@ -173,12 +173,12 @@ static void release_object(const sp<ProcessState>& proc,
         }
         case BINDER_TYPE_WEAK_HANDLE: {
             const wp<IBinder> b = proc->getWeakProxyForHandle(obj.handle);
-            if (b != nullptr) b.get_refs()->decWeak(who);
+            if (b != NULL) b.get_refs()->decWeak(who);
             return;
         }
         case BINDER_TYPE_FD: {
             if (obj.cookie != 0) { // owned
-                if ((outAshmemSize != nullptr) && ashmem_valid(obj.handle)) {
+                if ((outAshmemSize != NULL) && ashmem_valid(obj.handle)) {
                     int size = ashmem_get_size_region(obj.handle);
                     if (size > 0) {
                         *outAshmemSize -= size;
@@ -197,7 +197,7 @@ static void release_object(const sp<ProcessState>& proc,
 void release_object(const sp<ProcessState>& proc,
     const flat_binder_object& obj, const void* who)
 {
-    release_object(proc, obj, who, nullptr);
+    release_object(proc, obj, who, NULL);
 }
 
 inline static status_t finish_flatten_binder(
@@ -219,11 +219,11 @@ status_t flatten_binder(const sp<ProcessState>& /*proc*/,
         obj.flags = 0x13 | FLAT_BINDER_FLAG_ACCEPTS_FDS;
     }
 
-    if (binder != nullptr) {
+    if (binder != NULL) {
         IBinder *local = binder->localBinder();
         if (!local) {
             BpBinder *proxy = binder->remoteBinder();
-            if (proxy == nullptr) {
+            if (proxy == NULL) {
                 ALOGE("null proxy");
             }
             const int32_t handle = proxy ? proxy->handle() : 0;
@@ -251,13 +251,13 @@ status_t flatten_binder(const sp<ProcessState>& /*proc*/,
     flat_binder_object obj;
 
     obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
-    if (binder != nullptr) {
+    if (binder != NULL) {
         sp<IBinder> real = binder.promote();
-        if (real != nullptr) {
+        if (real != NULL) {
             IBinder *local = real->localBinder();
             if (!local) {
                 BpBinder *proxy = real->remoteBinder();
-                if (proxy == nullptr) {
+                if (proxy == NULL) {
                     ALOGE("null proxy");
                 }
                 const int32_t handle = proxy ? proxy->handle() : 0;
@@ -284,13 +284,13 @@ status_t flatten_binder(const sp<ProcessState>& /*proc*/,
         obj.hdr.type = BINDER_TYPE_BINDER;
         obj.binder = 0;
         obj.cookie = 0;
-        return finish_flatten_binder(nullptr, obj, out);
+        return finish_flatten_binder(NULL, obj, out);
 
     } else {
         obj.hdr.type = BINDER_TYPE_BINDER;
         obj.binder = 0;
         obj.cookie = 0;
-        return finish_flatten_binder(nullptr, obj, out);
+        return finish_flatten_binder(NULL, obj, out);
     }
 }
 
@@ -310,7 +310,7 @@ status_t unflatten_binder(const sp<ProcessState>& proc,
         switch (flat->hdr.type) {
             case BINDER_TYPE_BINDER:
                 *out = reinterpret_cast<IBinder*>(flat->cookie);
-                return finish_unflatten_binder(nullptr, *flat, in);
+                return finish_unflatten_binder(NULL, *flat, in);
             case BINDER_TYPE_HANDLE:
                 *out = proc->getStrongProxyForHandle(flat->handle);
                 return finish_unflatten_binder(
@@ -329,16 +329,16 @@ status_t unflatten_binder(const sp<ProcessState>& proc,
         switch (flat->hdr.type) {
             case BINDER_TYPE_BINDER:
                 *out = reinterpret_cast<IBinder*>(flat->cookie);
-                return finish_unflatten_binder(nullptr, *flat, in);
+                return finish_unflatten_binder(NULL, *flat, in);
             case BINDER_TYPE_WEAK_BINDER:
                 if (flat->binder != 0) {
                     out->set_object_and_refs(
                         reinterpret_cast<IBinder*>(flat->cookie),
                         reinterpret_cast<RefBase::weakref_type*>(flat->binder));
                 } else {
-                    *out = nullptr;
+                    *out = NULL;
                 }
-                return finish_unflatten_binder(nullptr, *flat, in);
+                return finish_unflatten_binder(NULL, *flat, in);
             case BINDER_TYPE_HANDLE:
             case BINDER_TYPE_WEAK_HANDLE:
                 *out = proc->getWeakProxyForHandle(flat->handle);
@@ -525,7 +525,7 @@ status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
             if (newSize*sizeof(binder_size_t) < mObjectsSize) return NO_MEMORY;   // overflow
             binder_size_t *objects =
                 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
-            if (objects == (binder_size_t*)nullptr) {
+            if (objects == (binder_size_t*)0) {
                 return NO_MEMORY;
             }
             mObjects = objects;
@@ -617,7 +617,7 @@ bool Parcel::enforceInterface(const String16& interface,
                               IPCThreadState* threadState) const
 {
     int32_t strictPolicy = readInt32();
-    if (threadState == nullptr) {
+    if (threadState == NULL) {
         threadState = IPCThreadState::self();
     }
     if ((threadState->getLastTransactionBinderFlags() &
@@ -725,14 +725,14 @@ void* Parcel::writeInplace(size_t len)
     if (len > INT32_MAX) {
         // don't accept size_t values which may have come from an
         // inadvertent conversion from a negative int.
-        return nullptr;
+        return NULL;
     }
 
     const size_t padded = pad_size(len);
 
     // sanity check for integer overflow
     if (mDataPos+padded < mDataPos) {
-        return nullptr;
+        return NULL;
     }
 
     if ((mDataPos+padded) <= mDataCapacity) {
@@ -763,7 +763,7 @@ restart_write:
 
     status_t err = growData(padded);
     if (err == NO_ERROR) goto restart_write;
-    return nullptr;
+    return NULL;
 }
 
 status_t Parcel::writeUtf8AsUtf16(const std::string& str) {
@@ -1066,7 +1066,7 @@ status_t Parcel::writeString16(const String16& str)
 
 status_t Parcel::writeString16(const char16_t* str, size_t len)
 {
-    if (str == nullptr) return writeInt32(-1);
+    if (str == NULL) return writeInt32(-1);
 
     status_t err = writeInt32(len);
     if (err == NO_ERROR) {
@@ -1237,7 +1237,7 @@ status_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)
     if (result < 0) {
         status = result;
     } else {
-        void* ptr = ::mmap(nullptr, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+        void* ptr = ::mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
         if (ptr == MAP_FAILED) {
             status = -errno;
         } else {
@@ -1301,10 +1301,10 @@ status_t Parcel::write(const FlattenableHelperInterface& val)
 
     // payload
     void* const buf = this->writeInplace(pad_size(len));
-    if (buf == nullptr)
+    if (buf == NULL)
         return BAD_VALUE;
 
-    int* fds = nullptr;
+    int* fds = NULL;
     if (fd_count) {
         fds = new (std::nothrow) int[fd_count];
         if (fds == nullptr) {
@@ -1364,7 +1364,7 @@ restart_write:
         size_t newSize = ((mObjectsSize+2)*3)/2;
         if (newSize*sizeof(binder_size_t) < mObjectsSize) return NO_MEMORY;   // overflow
         binder_size_t* objects = (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
-        if (objects == nullptr) return NO_MEMORY;
+        if (objects == NULL) return NO_MEMORY;
         mObjects = objects;
         mObjectsCapacity = newSize;
     }
@@ -1410,7 +1410,7 @@ status_t Parcel::writeMap(const ::android::binder::Map& map_in)
 
 status_t Parcel::writeNullableMap(const std::unique_ptr<binder::Map>& map)
 {
-    if (map == nullptr) {
+    if (map == NULL) {
         return writeInt32(-1);
     }
 
@@ -1520,7 +1520,7 @@ const void* Parcel::readInplace(size_t len) const
     if (len > INT32_MAX) {
         // don't accept size_t values which may have come from an
         // inadvertent conversion from a negative int.
-        return nullptr;
+        return NULL;
     }
 
     if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize
@@ -1530,7 +1530,7 @@ const void* Parcel::readInplace(size_t len) const
         ALOGV("readInplace Setting data pos of %p to %zu", this, mDataPos);
         return data;
     }
-    return nullptr;
+    return NULL;
 }
 
 template<class T>
@@ -1971,7 +1971,7 @@ const char* Parcel::readCString() const
             return str;
         }
     }
-    return nullptr;
+    return NULL;
 }
 
 String8 Parcel::readString8() const
@@ -2002,7 +2002,7 @@ status_t Parcel::readString8(String8* pArg) const
         return OK;
     }
     const char* str = (const char*)readInplace(size + 1);
-    if (str == nullptr) {
+    if (str == NULL) {
         return BAD_VALUE;
     }
     pArg->setTo(str, size);
@@ -2061,12 +2061,12 @@ const char16_t* Parcel::readString16Inplace(size_t* outLen) const
     if (size >= 0 && size < INT32_MAX) {
         *outLen = size;
         const char16_t* str = (const char16_t*)readInplace((size+1)*sizeof(char16_t));
-        if (str != nullptr) {
+        if (str != NULL) {
             return str;
         }
     }
     *outLen = 0;
-    return nullptr;
+    return NULL;
 }
 
 status_t Parcel::readStrongBinder(sp<IBinder>* val) const
@@ -2131,13 +2131,13 @@ native_handle* Parcel::readNativeHandle() const
     int numFds, numInts;
     status_t err;
     err = readInt32(&numFds);
-    if (err != NO_ERROR) return nullptr;
+    if (err != NO_ERROR) return 0;
     err = readInt32(&numInts);
-    if (err != NO_ERROR) return nullptr;
+    if (err != NO_ERROR) return 0;
 
     native_handle* h = native_handle_create(numFds, numInts);
     if (!h) {
-        return nullptr;
+        return 0;
     }
 
     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
@@ -2147,14 +2147,14 @@ native_handle* Parcel::readNativeHandle() const
                 close(h->data[j]);
             }
             native_handle_delete(h);
-            return nullptr;
+            return 0;
         }
     }
     err = read(h->data + numFds, sizeof(int)*numInts);
     if (err != NO_ERROR) {
         native_handle_close(h);
         native_handle_delete(h);
-        h = nullptr;
+        h = 0;
     }
     return h;
 }
@@ -2243,7 +2243,7 @@ status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
     int fd = readFileDescriptor();
     if (fd == int(BAD_TYPE)) return BAD_VALUE;
 
-    void* ptr = ::mmap(nullptr, len, isMutable ? PROT_READ | PROT_WRITE : PROT_READ,
+    void* ptr = ::mmap(NULL, len, isMutable ? PROT_READ | PROT_WRITE : PROT_READ,
             MAP_SHARED, fd, 0);
     if (ptr == MAP_FAILED) return NO_MEMORY;
 
@@ -2272,10 +2272,10 @@ status_t Parcel::read(FlattenableHelperInterface& val) const
 
     // payload
     void const* const buf = this->readInplace(pad_size(len));
-    if (buf == nullptr)
+    if (buf == NULL)
         return BAD_VALUE;
 
-    int* fds = nullptr;
+    int* fds = NULL;
     if (fd_count) {
         fds = new (std::nothrow) int[fd_count];
         if (fds == nullptr) {
@@ -2366,7 +2366,7 @@ const flat_binder_object* Parcel::readObject(bool nullMetaData) const
         ALOGW("Attempt to read object from Parcel %p at offset %zu that is not in the object list",
              this, DPOS);
     }
-    return nullptr;
+    return NULL;
 }
 
 void Parcel::closeFileDescriptors()
@@ -2583,7 +2583,7 @@ status_t Parcel::restartWrite(size_t desired)
     ALOGV("restartWrite Setting data pos of %p to %zu", this, mDataPos);
 
     free(mObjects);
-    mObjects = nullptr;
+    mObjects = NULL;
     mObjectsSize = mObjectsCapacity = 0;
     mNextObjectHint = 0;
     mHasFds = false;
@@ -2630,7 +2630,7 @@ status_t Parcel::continueWrite(size_t desired)
             mError = NO_MEMORY;
             return NO_MEMORY;
         }
-        binder_size_t* objects = nullptr;
+        binder_size_t* objects = NULL;
 
         if (objectsSize) {
             objects = (binder_size_t*)calloc(objectsSize, sizeof(binder_size_t));
@@ -2657,7 +2657,7 @@ status_t Parcel::continueWrite(size_t desired)
         }
         //ALOGI("Freeing data ref of %p (pid=%d)", this, getpid());
         mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
-        mOwner = nullptr;
+        mOwner = NULL;
 
         LOG_ALLOC("Parcel %p: taking ownership of %zu capacity", this, desired);
         pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
@@ -2711,7 +2711,7 @@ status_t Parcel::continueWrite(size_t desired)
                 pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
                 mData = data;
                 mDataCapacity = desired;
-            } else {
+            } else if (desired > mDataCapacity) {
                 mError = NO_MEMORY;
                 return NO_MEMORY;
             }
@@ -2734,7 +2734,7 @@ status_t Parcel::continueWrite(size_t desired)
             return NO_MEMORY;
         }
 
-        if(!(mDataCapacity == 0 && mObjects == nullptr
+        if(!(mDataCapacity == 0 && mObjects == NULL
              && mObjectsCapacity == 0)) {
             ALOGE("continueWrite: %zu/%p/%zu/%zu", mDataCapacity, mObjects, mObjectsCapacity, desired);
         }
@@ -2759,20 +2759,20 @@ void Parcel::initState()
 {
     LOG_ALLOC("Parcel %p: initState", this);
     mError = NO_ERROR;
-    mData = nullptr;
+    mData = 0;
     mDataSize = 0;
     mDataCapacity = 0;
     mDataPos = 0;
     ALOGV("initState Setting data size of %p to %zu", this, mDataSize);
     ALOGV("initState Setting data pos of %p to %zu", this, mDataPos);
-    mObjects = nullptr;
+    mObjects = NULL;
     mObjectsSize = 0;
     mObjectsCapacity = 0;
     mNextObjectHint = 0;
     mHasFds = false;
     mFdsKnown = true;
     mAllowFds = true;
-    mOwner = nullptr;
+    mOwner = NULL;
 #ifndef DISABLE_ASHMEM_TRACKING
     mOpenAshmemSize = 0;
 #endif
@@ -2829,7 +2829,7 @@ size_t Parcel::getOpenAshmemSize() const
 // --- Parcel::Blob ---
 
 Parcel::Blob::Blob() :
-        mFd(-1), mData(nullptr), mSize(0), mMutable(false) {
+        mFd(-1), mData(NULL), mSize(0), mMutable(false) {
 }
 
 Parcel::Blob::~Blob() {
@@ -2852,7 +2852,7 @@ void Parcel::Blob::init(int fd, void* data, size_t size, bool isMutable) {
 
 void Parcel::Blob::clear() {
     mFd = -1;
-    mData = nullptr;
+    mData = NULL;
     mSize = 0;
     mMutable = false;
 }
diff --git a/libs/binder/PermissionCache.cpp b/libs/binder/PermissionCache.cpp
index a4c28ad74e..a503be8cd7 100644
--- a/libs/binder/PermissionCache.cpp
+++ b/libs/binder/PermissionCache.cpp
@@ -75,7 +75,7 @@ void PermissionCache::purge() {
 }
 
 bool PermissionCache::checkCallingPermission(const String16& permission) {
-    return PermissionCache::checkCallingPermission(permission, nullptr, nullptr);
+    return PermissionCache::checkCallingPermission(permission, NULL, NULL);
 }
 
 bool PermissionCache::checkCallingPermission(
diff --git a/libs/binder/ProcessInfoService.cpp b/libs/binder/ProcessInfoService.cpp
index 5cb2033b07..8939d9c9b2 100644
--- a/libs/binder/ProcessInfoService.cpp
+++ b/libs/binder/ProcessInfoService.cpp
@@ -36,7 +36,7 @@ status_t ProcessInfoService::getProcessStatesImpl(size_t length, /*in*/ int32_t*
 
     for (int i = 0; i < BINDER_ATTEMPT_LIMIT; i++) {
 
-        if (pis != nullptr) {
+        if (pis != NULL) {
             err = pis->getProcessStatesFromPids(length, /*in*/ pids, /*out*/ states);
             if (err == NO_ERROR) return NO_ERROR; // success
             if (IInterface::asBinder(pis)->isBinderAlive()) return err;
@@ -68,7 +68,7 @@ status_t ProcessInfoService::getProcessStatesScoresImpl(size_t length,
 
     for (int i = 0; i < BINDER_ATTEMPT_LIMIT; i++) {
 
-        if (pis != nullptr) {
+        if (pis != NULL) {
             err = pis->getProcessStatesAndOomScoresFromPids(length,
                     /*in*/ pids, /*out*/ states, /*out*/ scores);
             if (err == NO_ERROR) return NO_ERROR; // success
@@ -93,7 +93,7 @@ status_t ProcessInfoService::getProcessStatesScoresImpl(size_t length,
 
 void ProcessInfoService::updateBinderLocked() {
     const sp<IServiceManager> sm(defaultServiceManager());
-    if (sm != nullptr) {
+    if (sm != NULL) {
         const String16 name("processinfo");
         mProcessInfoService = interface_cast<IProcessInfoService>(sm->checkService(name));
     }
diff --git a/libs/binder/ProcessState.cpp b/libs/binder/ProcessState.cpp
index 53f8dddfe1..e71e4489bc 100644
--- a/libs/binder/ProcessState.cpp
+++ b/libs/binder/ProcessState.cpp
@@ -74,7 +74,7 @@ protected:
 sp<ProcessState> ProcessState::self()
 {
     Mutex::Autolock _l(gProcessMutex);
-    if (gProcess != nullptr) {
+    if (gProcess != NULL) {
         return gProcess;
     }
     gProcess = new ProcessState(kDefaultDriver);
@@ -84,7 +84,7 @@ sp<ProcessState> ProcessState::self()
 sp<ProcessState> ProcessState::initWithDriver(const char* driver)
 {
     Mutex::Autolock _l(gProcessMutex);
-    if (gProcess != nullptr) {
+    if (gProcess != NULL) {
         // Allow for initWithDriver to be called repeatedly with the same
         // driver.
         if (!strcmp(gProcess->getDriverName().c_str(), driver)) {
@@ -128,18 +128,18 @@ sp<IBinder> ProcessState::getContextObject(const String16& name, const sp<IBinde
 {
     mLock.lock();
     sp<IBinder> object(
-        mContexts.indexOfKey(name) >= 0 ? mContexts.valueFor(name) : nullptr);
+        mContexts.indexOfKey(name) >= 0 ? mContexts.valueFor(name) : NULL);
     mLock.unlock();
     
     //printf("Getting context object %s for %p\n", String8(name).string(), caller.get());
     
-    if (object != nullptr) return object;
+    if (object != NULL) return object;
 
     // Don't attempt to retrieve contexts if we manage them
     if (mManagesContexts) {
         ALOGE("getContextObject(%s) failed, but we manage the contexts!\n",
             String8(name).string());
-        return nullptr;
+        return NULL;
     }
     
     IPCThreadState* ipc = IPCThreadState::self();
@@ -156,7 +156,7 @@ sp<IBinder> ProcessState::getContextObject(const String16& name, const sp<IBinde
     
     ipc->flushCommands();
     
-    if (object != nullptr) setContextObject(object, name);
+    if (object != NULL) setContextObject(object, name);
     return object;
 }
 
@@ -186,8 +186,8 @@ bool ProcessState::becomeContextManager(context_check_func checkFunc, void* user
         if (result == 0) {
             mManagesContexts = true;
         } else if (result == -1) {
-            mBinderContextCheckFunc = nullptr;
-            mBinderContextUserData = nullptr;
+            mBinderContextCheckFunc = NULL;
+            mBinderContextUserData = NULL;
             ALOGE("Binder ioctl to become context manager failed: %s\n", strerror(errno));
         }
     }
@@ -213,7 +213,7 @@ ssize_t ProcessState::getKernelReferences(size_t buf_count, uintptr_t* buf)
 
     binder_node_debug_info info = {};
 
-    uintptr_t* end = buf ? buf + buf_count : nullptr;
+    uintptr_t* end = buf ? buf + buf_count : NULL;
     size_t count = 0;
 
     do {
@@ -239,10 +239,10 @@ ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)
     const size_t N=mHandleToObject.size();
     if (N <= (size_t)handle) {
         handle_entry e;
-        e.binder = nullptr;
-        e.refs = nullptr;
+        e.binder = NULL;
+        e.refs = NULL;
         status_t err = mHandleToObject.insertAt(e, N, handle+1-N);
-        if (err < NO_ERROR) return nullptr;
+        if (err < NO_ERROR) return NULL;
     }
     return &mHandleToObject.editItemAt(handle);
 }
@@ -255,12 +255,12 @@ sp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)
 
     handle_entry* e = lookupHandleLocked(handle);
 
-    if (e != nullptr) {
+    if (e != NULL) {
         // We need to create a new BpBinder if there isn't currently one, OR we
         // are unable to acquire a weak reference on this current one.  See comment
         // in getWeakProxyForHandle() for more info about this.
         IBinder* b = e->binder;
-        if (b == nullptr || !e->refs->attemptIncWeak(this)) {
+        if (b == NULL || !e->refs->attemptIncWeak(this)) {
             if (handle == 0) {
                 // Special case for context manager...
                 // The context manager is the only object for which we create
@@ -283,12 +283,12 @@ sp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)
 
                 Parcel data;
                 status_t status = IPCThreadState::self()->transact(
-                        0, IBinder::PING_TRANSACTION, data, nullptr, 0);
+                        0, IBinder::PING_TRANSACTION, data, NULL, 0);
                 if (status == DEAD_OBJECT)
-                   return nullptr;
+                   return NULL;
             }
 
-            b = BpBinder::create(handle);
+            b = new BpBinder(handle); 
             e->binder = b;
             if (b) e->refs = b->getWeakRefs();
             result = b;
@@ -312,7 +312,7 @@ wp<IBinder> ProcessState::getWeakProxyForHandle(int32_t handle)
 
     handle_entry* e = lookupHandleLocked(handle);
 
-    if (e != nullptr) {        
+    if (e != NULL) {        
         // We need to create a new BpBinder if there isn't currently one, OR we
         // are unable to acquire a weak reference on this current one.  The
         // attemptIncWeak() is safe because we know the BpBinder destructor will always
@@ -321,8 +321,8 @@ wp<IBinder> ProcessState::getWeakProxyForHandle(int32_t handle)
         // releasing a reference on this BpBinder, and a new reference on its handle
         // arriving from the driver.
         IBinder* b = e->binder;
-        if (b == nullptr || !e->refs->attemptIncWeak(this)) {
-            b = BpBinder::create(handle);
+        if (b == NULL || !e->refs->attemptIncWeak(this)) {
+            b = new BpBinder(handle);
             result = b;
             e->binder = b;
             if (b) e->refs = b->getWeakRefs();
@@ -344,7 +344,7 @@ void ProcessState::expungeHandle(int32_t handle, IBinder* binder)
     // This handle may have already been replaced with a new BpBinder
     // (if someone failed the AttemptIncWeak() above); we don't want
     // to overwrite it.
-    if (e && e->binder == binder) e->binder = nullptr;
+    if (e && e->binder == binder) e->binder = NULL;
 }
 
 String8 ProcessState::makeBinderThreadName() {
@@ -422,17 +422,17 @@ ProcessState::ProcessState(const char *driver)
     , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)
     , mStarvationStartTimeMs(0)
     , mManagesContexts(false)
-    , mBinderContextCheckFunc(nullptr)
-    , mBinderContextUserData(nullptr)
+    , mBinderContextCheckFunc(NULL)
+    , mBinderContextUserData(NULL)
     , mThreadPoolStarted(false)
     , mThreadPoolSeq(1)
 {
     if (mDriverFD >= 0) {
         // mmap the binder, providing a chunk of virtual address space to receive transactions.
-        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
+        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
         if (mVMStart == MAP_FAILED) {
             // *sigh*
-            ALOGE("Using %s failed: unable to mmap transaction memory.\n", mDriverName.c_str());
+            ALOGE("Using /dev/binder failed: unable to mmap transaction memory.\n");
             close(mDriverFD);
             mDriverFD = -1;
             mDriverName.clear();
diff --git a/libs/binder/Static.cpp b/libs/binder/Static.cpp
index c3ba5a23c5..f0613d1631 100644
--- a/libs/binder/Static.cpp
+++ b/libs/binder/Static.cpp
@@ -75,6 +75,21 @@ TextOutput& aerr(gStderrTextOutput);
 Mutex gProcessMutex;
 sp<ProcessState> gProcess;
 
+class LibBinderIPCtStatics
+{
+public:
+    LibBinderIPCtStatics()
+    {
+    }
+    
+    ~LibBinderIPCtStatics()
+    {
+        IPCThreadState::shutdown();
+    }
+};
+
+static LibBinderIPCtStatics gIPCStatics;
+
 // ------------ IServiceManager.cpp
 
 Mutex gDefaultServiceManagerLock;
diff --git a/libs/binder/Value.cpp b/libs/binder/Value.cpp
index 2b263ed2ee..fd1dfd5ada 100644
--- a/libs/binder/Value.cpp
+++ b/libs/binder/Value.cpp
@@ -143,12 +143,12 @@ template<typename T> bool Value::ContentBase::get(T* out) const
 
 // ====================================================================
 
-Value::Value() : mContent(nullptr)
+Value::Value() : mContent(NULL)
 {
 }
 
 Value::Value(const Value& value)
-    : mContent(value.mContent ? value.mContent->clone() : nullptr)
+    : mContent(value.mContent ? value.mContent->clone() : NULL)
 {
 }
 
@@ -165,8 +165,8 @@ bool Value::operator==(const Value& rhs) const
         return true;
     }
 
-    if ( (lhs.mContent == nullptr)
-      || (rhs.mContent == nullptr)
+    if ( (lhs.mContent == NULL)
+      || (rhs.mContent == NULL)
     ) {
         return false;
     }
@@ -182,29 +182,27 @@ Value& Value::swap(Value &rhs)
 
 Value& Value::operator=(const Value& rhs)
 {
-    if (this != &rhs) {
-        delete mContent;
-        mContent = rhs.mContent
-            ? rhs.mContent->clone()
-            : nullptr;
-    }
+    delete mContent;
+    mContent = rhs.mContent
+        ? rhs.mContent->clone()
+        : NULL;
     return *this;
 }
 
 bool Value::empty() const
 {
-    return mContent == nullptr;
+    return mContent == NULL;
 }
 
 void Value::clear()
 {
     delete mContent;
-    mContent = nullptr;
+    mContent = NULL;
 }
 
 int32_t Value::parcelType() const
 {
-    const void* t_info(mContent ? mContent->type_ptr() : nullptr);
+    const void* t_info(mContent ? mContent->type_ptr() : NULL);
 
     if (t_info == internal_type_ptr<bool>()) return VAL_BOOLEAN;
     if (t_info == internal_type_ptr<uint8_t>()) return VAL_BYTE;
@@ -381,7 +379,7 @@ status_t Value::readFromParcel(const Parcel* parcel)
     int32_t value_type = VAL_NULL;
 
     delete mContent;
-    mContent = nullptr;
+    mContent = NULL;
 
     RETURN_IF_FAILED(parcel->readInt32(&value_type));
 
diff --git a/libs/binder/include/binder/AppOpsManager.h b/libs/binder/include/binder/AppOpsManager.h
index 4212776e89..1beabd3fc4 100644
--- a/libs/binder/include/binder/AppOpsManager.h
+++ b/libs/binder/include/binder/AppOpsManager.h
@@ -92,7 +92,25 @@ public:
         OP_PROCESS_OUTGOING_CALLS = 54,
         OP_USE_FINGERPRINT = 55,
         OP_BODY_SENSORS = 56,
+        OP_READ_CELL_BROADCASTS = 57,
+        OP_MOCK_LOCATION = 58,
+        OP_READ_EXTERNAL_STORAGE = 59,
+        OP_WRITE_EXTERNAL_STORAGE = 60,
+        OP_TURN_SCREEN_ON = 61,
+        OP_GET_ACCOUNTS = 62,
+        OP_RUN_IN_BACKGROUND = 63,
         OP_AUDIO_ACCESSIBILITY_VOLUME = 64,
+        OP_READ_PHONE_NUMBERS = 65,
+        OP_REQUEST_INSTALL_PACKAGES = 66,
+        OP_PICTURE_IN_PICTURE = 67,
+        OP_INSTANT_APP_START_FOREGROUND = 68,
+        OP_ANSWER_PHONE_CALLS = 69,
+        OP_CHANGE_WIFI_STATE = 70,
+        OP_BLUETOOTH_CHANGE = 71,
+        OP_BOOT_COMPLETED = 72,
+        OP_NFC_CHANGE = 73,
+        OP_DATA_CONNECT_CHANGE = 74,
+        OP_SU = 75
     };
 
     AppOpsManager();
diff --git a/libs/binder/include/binder/BpBinder.h b/libs/binder/include/binder/BpBinder.h
index 8bd297bcfb..7ef93aa390 100644
--- a/libs/binder/include/binder/BpBinder.h
+++ b/libs/binder/include/binder/BpBinder.h
@@ -19,20 +19,15 @@
 
 #include <binder/IBinder.h>
 #include <utils/KeyedVector.h>
-#include <utils/Mutex.h>
 #include <utils/threads.h>
 
-#include <unordered_map>
-
 // ---------------------------------------------------------------------------
 namespace android {
 
-using binder_proxy_limit_callback = void(*)(int);
-
 class BpBinder : public IBinder
 {
 public:
-    static BpBinder*    create(int32_t handle);
+                        BpBinder(int32_t handle);
 
     inline  int32_t     handle() const { return mHandle; }
 
@@ -66,14 +61,6 @@ public:
             status_t    setConstantData(const void* data, size_t size);
             void        sendObituary();
 
-    static uint32_t     getBinderProxyCount(uint32_t uid);
-    static void         getCountByUid(Vector<uint32_t>& uids, Vector<uint32_t>& counts);
-    static void         enableCountByUid();
-    static void         disableCountByUid();
-    static void         setCountByUidEnabled(bool enable);
-    static void         setLimitCallback(binder_proxy_limit_callback cb);
-    static void         setBinderProxyCountWatermarks(int high, int low);
-
     class ObjectManager
     {
     public:
@@ -104,7 +91,6 @@ public:
     };
 
 protected:
-                        BpBinder(int32_t handle,int32_t trackedUid);
     virtual             ~BpBinder();
     virtual void        onFirstRef();
     virtual void        onLastStrongRef(const void* id);
@@ -129,16 +115,6 @@ private:
             ObjectManager       mObjects;
             Parcel*             mConstantData;
     mutable String16            mDescriptorCache;
-            int32_t             mTrackedUid;
-
-    static Mutex                                sTrackingLock;
-    static std::unordered_map<int32_t,uint32_t> sTrackingMap;
-    static int                                  sNumTrackedUids;
-    static std::atomic_bool                     sCountByUidEnabled;
-    static binder_proxy_limit_callback          sLimitCallback;
-    static uint32_t                             sBinderProxyCountHighWatermark;
-    static uint32_t                             sBinderProxyCountLowWatermark;
-    static bool                                 sBinderProxyThrottleCreate;
 };
 
 }; // namespace android
diff --git a/libs/binder/include/binder/IInterface.h b/libs/binder/include/binder/IInterface.h
index 227d0ae861..0f1fe5b670 100644
--- a/libs/binder/include/binder/IInterface.h
+++ b/libs/binder/include/binder/IInterface.h
@@ -142,7 +142,7 @@ inline IBinder* BpInterface<INTERFACE>::onAsBinder()
 {
     return remote();
 }
-
+    
 // ----------------------------------------------------------------------
 
 }; // namespace android
diff --git a/libs/binder/include/binder/ProcessState.h b/libs/binder/include/binder/ProcessState.h
index 13f67baee1..f85c2612d4 100644
--- a/libs/binder/include/binder/ProcessState.h
+++ b/libs/binder/include/binder/ProcessState.h
@@ -36,12 +36,9 @@ class ProcessState : public virtual RefBase
 public:
     static  sp<ProcessState>    self();
     static  sp<ProcessState>    selfOrNull();
-
     /* initWithDriver() can be used to configure libbinder to use
      * a different binder driver dev node. It must be called *before*
-     * any call to ProcessState::self(). The default is /dev/vndbinder
-     * for processes built with the VNDK and /dev/binder for those
-     * which are not.
+     * any call to ProcessState::self(). /dev/binder remains the default.
      */
     static  sp<ProcessState>    initWithDriver(const char *driver);
 
diff --git a/libs/binder/tests/Android.bp b/libs/binder/tests/Android.bp
deleted file mode 100644
index c451780dd7..0000000000
--- a/libs/binder/tests/Android.bp
+++ /dev/null
@@ -1,147 +0,0 @@
-//
-// Copyright (C) 2014 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-cc_defaults {
-    name: "binder_test_defaults",
-    cflags: [
-        "-Wall",
-        "-Werror",
-        "-Wno-unused-private-field",
-        "-Wno-unused-variable",
-    ],
-}
-
-cc_test {
-    name: "binderDriverInterfaceTest_IPC_32",
-    srcs: ["binderDriverInterfaceTest.cpp"],
-    defaults: ["binder_test_defaults"],
-    compile_multilib: "32",
-    cflags: ["-DBINDER_IPC_32BIT=1"],
-}
-
-cc_test {
-    product_variables: {
-        binder32bit: {
-            cflags: ["-DBINDER_IPC_32BIT=1"],
-        },
-    },
-
-    name: "binderDriverInterfaceTest",
-    srcs: ["binderDriverInterfaceTest.cpp"],
-    defaults: ["binder_test_defaults"],
-}
-
-cc_test {
-    name: "binderValueTypeTest",
-    srcs: ["binderValueTypeTest.cpp"],
-    defaults: ["binder_test_defaults"],
-    shared_libs: [
-        "libbinder",
-        "libutils",
-    ],
-}
-
-cc_test {
-    name: "binderLibTest_IPC_32",
-    srcs: ["binderLibTest.cpp"],
-    defaults: ["binder_test_defaults"],
-    shared_libs: [
-        "libbinder",
-        "libutils",
-    ],
-    compile_multilib: "32",
-    cflags: ["-DBINDER_IPC_32BIT=1"],
-}
-
-cc_test {
-    product_variables: {
-        binder32bit: {
-            cflags: ["-DBINDER_IPC_32BIT=1"],
-        },
-    },
-
-    defaults: ["binder_test_defaults"],
-    name: "binderLibTest",
-    srcs: ["binderLibTest.cpp"],
-    shared_libs: [
-        "libbinder",
-        "libutils",
-    ],
-}
-
-cc_test {
-    name: "binderThroughputTest",
-    srcs: ["binderThroughputTest.cpp"],
-    defaults: ["binder_test_defaults"],
-    shared_libs: [
-        "libbinder",
-        "libutils",
-    ],
-    clang: true,
-    cflags: [
-        "-g",
-        "-Wno-missing-field-initializers",
-        "-Wno-sign-compare",
-        "-O3",
-    ],
-}
-
-cc_test {
-    name: "binderTextOutputTest",
-    srcs: ["binderTextOutputTest.cpp"],
-    defaults: ["binder_test_defaults"],
-    shared_libs: [
-        "libbinder",
-        "libutils",
-        "libbase",
-    ],
-}
-
-cc_test {
-    name: "schd-dbg",
-    srcs: ["schd-dbg.cpp"],
-    defaults: ["binder_test_defaults"],
-    shared_libs: [
-        "libbinder",
-        "libutils",
-        "libbase",
-    ],
-}
-
-cc_test {
-    name: "binderSafeInterfaceTest",
-    srcs: ["binderSafeInterfaceTest.cpp"],
-    defaults: ["binder_test_defaults"],
-
-    cppflags: [
-        "-Weverything",
-        "-Wno-c++98-compat",
-        "-Wno-c++98-compat-pedantic",
-        "-Wno-global-constructors",
-        "-Wno-padded",
-        "-Wno-weak-vtables",
-    ],
-
-    cpp_std: "experimental",
-    gnu_extensions: false,
-
-    shared_libs: [
-        "libbinder",
-        "libcutils",
-        "liblog",
-        "libutils",
-    ],
-}
diff --git a/libs/binder/tests/binderDriverInterfaceTest.cpp b/libs/binder/tests/binderDriverInterfaceTest.cpp
deleted file mode 100644
index 77ebac8f5a..0000000000
--- a/libs/binder/tests/binderDriverInterfaceTest.cpp
+++ /dev/null
@@ -1,370 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <gtest/gtest.h>
-#include <linux/android/binder.h>
-#include <binder/IBinder.h>
-#include <sys/mman.h>
-#include <poll.h>
-
-#define BINDER_DEV_NAME "/dev/binder"
-
-testing::Environment* binder_env;
-
-class BinderDriverInterfaceTestEnv : public ::testing::Environment {
-        virtual void SetUp() {
-            int ret;
-            uint32_t max_threads = 0;
-
-            m_binderFd = open(BINDER_DEV_NAME, O_RDWR | O_NONBLOCK | O_CLOEXEC);
-            ASSERT_GE(m_binderFd, 0);
-            m_buffer = mmap(nullptr, 64*1024, PROT_READ, MAP_SHARED, m_binderFd, 0);
-            ASSERT_NE(m_buffer, (void *)nullptr);
-            ret = ioctl(m_binderFd, BINDER_SET_MAX_THREADS, &max_threads);
-            EXPECT_EQ(0, ret);
-            EnterLooper();
-        }
-        virtual void TearDown() {
-            close(m_binderFd);
-        }
-    private:
-        int m_binderFd;
-        void *m_buffer;
-    public:
-        int getBinderFd(void) {
-            return m_binderFd;
-        }
-        void EnterLooper(void) {
-            int ret;
-            const uint32_t bc[] = {
-                BC_ENTER_LOOPER,
-            };
-            struct binder_write_read bwr = binder_write_read();
-            bwr.write_buffer = (uintptr_t)bc;
-            bwr.write_size = sizeof(bc);
-            ret = ioctl(m_binderFd, BINDER_WRITE_READ, &bwr);
-            EXPECT_EQ(0, ret);
-            if (ret < 0) {
-                    EXPECT_EQ(0, errno);
-            }
-            EXPECT_EQ(sizeof(bc), bwr.write_consumed);
-        }
-};
-
-class BinderDriverInterfaceTest : public ::testing::Test {
-    public:
-        virtual void SetUp() {
-            m_binderFd = static_cast<BinderDriverInterfaceTestEnv *>(binder_env)->getBinderFd();
-        }
-        virtual void TearDown() {
-        }
-    protected:
-        /* The ioctl must either return 0, or if it doesn't errno should be accepted_errno */
-        void binderTestIoctlSuccessOrError(int cmd, void *arg, int accepted_errno) {
-            int ret;
-
-            ret = ioctl(m_binderFd, cmd, arg);
-            if (ret != 0) {
-                EXPECT_EQ(errno, accepted_errno);
-            }
-        }
-
-        void binderTestIoctlRetErr2(int cmd, void *arg, int expect_ret, int expect_errno, int accept_errno) {
-            int ret;
-
-            ret = ioctl(m_binderFd, cmd, arg);
-            EXPECT_EQ(expect_ret, ret);
-            if (ret < 0) {
-                if (errno != accept_errno)
-                    EXPECT_EQ(expect_errno, errno);
-            }
-        }
-        void binderTestIoctlErr2(int cmd, void *arg, int expect_errno, int accept_errno) {
-            binderTestIoctlRetErr2(cmd, arg, -1, expect_errno, accept_errno);
-        }
-        void binderTestIoctlErr1(int cmd, void *arg, int expect_errno) {
-            binderTestIoctlErr2(cmd, arg, expect_errno, expect_errno);
-        }
-        void binderTestIoctl(int cmd, void *arg) {
-            binderTestIoctlRetErr2(cmd, arg, 0, 0, 0);
-        }
-        void binderTestIoctlUnimplemented(int cmd, void *arg) {
-            int ret;
-
-            ret = ioctl(m_binderFd, cmd, arg);
-            if (ret < 0) {
-                /* Not currently implmented. Allow ret == -1, errno == EINVAL */
-                EXPECT_EQ(-1, ret);
-                EXPECT_EQ(EINVAL, errno);
-            }
-        }
-        void binderTestReadEmpty(void) {
-            size_t i;
-            uint32_t br[32];
-            struct binder_write_read bwr = binder_write_read();
-            SCOPED_TRACE("TestReadEmpty");
-            bwr.read_buffer = (uintptr_t)br;
-            bwr.read_size = sizeof(br);
-            binderTestIoctlErr1(BINDER_WRITE_READ, &bwr, EAGAIN);
-            EXPECT_EQ(0u, bwr.read_consumed);
-            for (i = 0; i * sizeof(uint32_t) < bwr.read_consumed; i++) {
-                SCOPED_TRACE(testing::Message() << "i = " << i);
-                EXPECT_EQ(BR_NOOP, br[i]);
-            }
-        }
-        void binderWaitForReadData(int timeout_ms) {
-            int ret;
-            pollfd pfd = pollfd();
-
-            pfd.fd = m_binderFd;
-            pfd.events = POLLIN;
-            ret = poll(&pfd, 1, timeout_ms);
-            EXPECT_EQ(1, ret);
-        }
-    private:
-        int m_binderFd;
-};
-
-TEST_F(BinderDriverInterfaceTest, Version) {
-    struct binder_version version;
-    binderTestIoctl(BINDER_VERSION, &version);
-    ASSERT_EQ(BINDER_CURRENT_PROTOCOL_VERSION, version.protocol_version);
-}
-
-TEST_F(BinderDriverInterfaceTest, OpenNoMmap) {
-    int binderFd = open(BINDER_DEV_NAME, O_RDWR | O_NONBLOCK | O_CLOEXEC);
-    ASSERT_GE(binderFd, 0);
-    close(binderFd);
-}
-
-TEST_F(BinderDriverInterfaceTest, WriteReadNull) {
-    binderTestIoctlErr1(BINDER_WRITE_READ, nullptr, EFAULT);
-}
-
-TEST_F(BinderDriverInterfaceTest, SetIdleTimeoutNull) {
-    binderTestIoctlErr2(BINDER_SET_IDLE_TIMEOUT, nullptr, EFAULT, EINVAL);
-}
-
-TEST_F(BinderDriverInterfaceTest, SetMaxThreadsNull) {
-    binderTestIoctlErr2(BINDER_SET_MAX_THREADS, nullptr, EFAULT, EINVAL); /* TODO: don't accept EINVAL */
-}
-
-TEST_F(BinderDriverInterfaceTest, SetIdlePriorityNull) {
-    binderTestIoctlErr2(BINDER_SET_IDLE_PRIORITY, nullptr, EFAULT, EINVAL);
-}
-
-TEST_F(BinderDriverInterfaceTest, VersionNull) {
-    binderTestIoctlErr2(BINDER_VERSION, nullptr, EFAULT, EINVAL); /* TODO: don't accept EINVAL */
-}
-
-TEST_F(BinderDriverInterfaceTest, SetIdleTimeoutNoTest) {
-    int64_t idle_timeout = 100000;
-    binderTestIoctlUnimplemented(BINDER_SET_IDLE_TIMEOUT, &idle_timeout);
-}
-
-TEST_F(BinderDriverInterfaceTest, SetMaxThreads) {
-    uint32_t max_threads = 0;
-    binderTestIoctl(BINDER_SET_MAX_THREADS, &max_threads);
-}
-
-TEST_F(BinderDriverInterfaceTest, SetIdlePriorityNoTest) {
-    int idle_priority = 0;
-    binderTestIoctlUnimplemented(BINDER_SET_IDLE_PRIORITY, &idle_priority);
-}
-
-TEST_F(BinderDriverInterfaceTest, SetContextMgrBusy) {
-    int32_t dummy = 0;
-    binderTestIoctlErr1(BINDER_SET_CONTEXT_MGR, &dummy, EBUSY);
-}
-
-TEST_F(BinderDriverInterfaceTest, ThreadExit) {
-    int32_t dummy = 0;
-    binderTestIoctl(BINDER_THREAD_EXIT, &dummy);
-    static_cast<BinderDriverInterfaceTestEnv *>(binder_env)->EnterLooper();
-}
-
-TEST_F(BinderDriverInterfaceTest, WriteReadEmpty) {
-    struct binder_write_read bwr = binder_write_read();
-    binderTestIoctl(BINDER_WRITE_READ, &bwr);
-}
-
-TEST_F(BinderDriverInterfaceTest, Read) {
-    binderTestReadEmpty();
-}
-
-TEST_F(BinderDriverInterfaceTest, IncRefsAcquireReleaseDecRefs) {
-    const uint32_t bc[] = {
-        BC_INCREFS,
-        0,
-        BC_ACQUIRE,
-        0,
-        BC_RELEASE,
-        0,
-        BC_DECREFS,
-        0,
-    };
-    struct binder_write_read bwr = binder_write_read();
-    bwr.write_buffer = (uintptr_t)bc;
-    bwr.write_size = sizeof(bc);
-    binderTestIoctl(BINDER_WRITE_READ, &bwr);
-    EXPECT_EQ(sizeof(bc), bwr.write_consumed);
-    binderTestReadEmpty();
-}
-
-TEST_F(BinderDriverInterfaceTest, Transaction) {
-    binder_uintptr_t cookie = 1234;
-    struct {
-        uint32_t cmd1;
-        struct binder_transaction_data arg1;
-    } __attribute__((packed)) bc1 = {
-        .cmd1 = BC_TRANSACTION,
-        .arg1 = {
-            .target = { 0 },
-            .cookie = 0,
-            .code = android::IBinder::PING_TRANSACTION,
-            .flags = 0,
-            .sender_pid = 0,
-            .sender_euid = 0,
-            .data_size = 0,
-            .offsets_size = 0,
-            .data = {
-                .ptr = {0, 0},
-            },
-        },
-    };
-    struct {
-        uint32_t cmd0;
-        uint32_t cmd1;
-        uint32_t cmd2;
-        binder_transaction_data arg2;
-        uint32_t pad[16];
-    } __attribute__((packed)) br;
-    struct binder_write_read bwr = binder_write_read();
-
-    bwr.write_buffer = (uintptr_t)&bc1;
-    bwr.write_size = sizeof(bc1);
-    bwr.read_buffer = (uintptr_t)&br;
-    bwr.read_size = sizeof(br);
-
-    {
-        SCOPED_TRACE("1st WriteRead");
-        binderTestIoctlSuccessOrError(BINDER_WRITE_READ, &bwr, EAGAIN);
-    }
-    EXPECT_EQ(sizeof(bc1), bwr.write_consumed);
-    if (bwr.read_consumed < offsetof(typeof(br), pad)) {
-        SCOPED_TRACE("2nd WriteRead");
-        binderWaitForReadData(10000);
-        binderTestIoctl(BINDER_WRITE_READ, &bwr);
-    }
-    EXPECT_EQ(offsetof(typeof(br), pad), bwr.read_consumed);
-    if (bwr.read_consumed > offsetof(typeof(br), cmd0))
-        EXPECT_EQ(BR_NOOP, br.cmd0);
-    if (bwr.read_consumed > offsetof(typeof(br), cmd1))
-        EXPECT_EQ(BR_TRANSACTION_COMPLETE, br.cmd1);
-    if (bwr.read_consumed > offsetof(typeof(br), cmd2))
-        EXPECT_EQ(BR_REPLY, br.cmd2);
-    if (bwr.read_consumed >= offsetof(typeof(br), pad)) {
-        EXPECT_EQ(0u, br.arg2.target.ptr);
-        EXPECT_EQ(0u, br.arg2.cookie);
-        EXPECT_EQ(0u, br.arg2.code);
-        EXPECT_EQ(0u, br.arg2.flags);
-        EXPECT_EQ(0u, br.arg2.data_size);
-        EXPECT_EQ(0u, br.arg2.offsets_size);
-
-        SCOPED_TRACE("3rd WriteRead");
-
-        binderTestReadEmpty();
-
-        struct {
-            uint32_t cmd1;
-            binder_uintptr_t arg1;
-        } __attribute__((packed)) bc2 = {
-            .cmd1 = BC_FREE_BUFFER,
-            .arg1 = br.arg2.data.ptr.buffer,
-        };
-
-        bwr.write_buffer = (uintptr_t)&bc2;
-        bwr.write_size = sizeof(bc2);
-        bwr.write_consumed = 0;
-        bwr.read_size = 0;
-
-        binderTestIoctl(BINDER_WRITE_READ, &bwr);
-        EXPECT_EQ(sizeof(bc2), bwr.write_consumed);
-    }
-    binderTestReadEmpty();
-}
-
-TEST_F(BinderDriverInterfaceTest, RequestDeathNotification) {
-    binder_uintptr_t cookie = 1234;
-    struct {
-        uint32_t cmd0;
-        uint32_t arg0;
-        uint32_t cmd1;
-        struct binder_handle_cookie arg1;
-        uint32_t cmd2;
-        struct binder_handle_cookie arg2;
-        uint32_t cmd3;
-        uint32_t arg3;
-    } __attribute__((packed)) bc = {
-        .cmd0 = BC_INCREFS,
-        .arg0 = 0,
-        .cmd1 = BC_REQUEST_DEATH_NOTIFICATION,
-        .arg1 = {
-            .handle = 0,
-            .cookie = cookie,
-        },
-        .cmd2 = BC_CLEAR_DEATH_NOTIFICATION,
-        .arg2 = {
-            .handle = 0,
-            .cookie = cookie,
-        },
-        .cmd3 = BC_DECREFS,
-        .arg3 = 0,
-    };
-    struct {
-        uint32_t cmd0;
-        uint32_t cmd1;
-        binder_uintptr_t arg1;
-        uint32_t pad[16];
-    } __attribute__((packed)) br;
-    struct binder_write_read bwr = binder_write_read();
-
-    bwr.write_buffer = (uintptr_t)&bc;
-    bwr.write_size = sizeof(bc);
-    bwr.read_buffer = (uintptr_t)&br;
-    bwr.read_size = sizeof(br);
-
-    binderTestIoctl(BINDER_WRITE_READ, &bwr);
-    EXPECT_EQ(sizeof(bc), bwr.write_consumed);
-    EXPECT_EQ(sizeof(br) - sizeof(br.pad), bwr.read_consumed);
-    EXPECT_EQ(BR_NOOP, br.cmd0);
-    EXPECT_EQ(BR_CLEAR_DEATH_NOTIFICATION_DONE, br.cmd1);
-    EXPECT_EQ(cookie, br.arg1);
-    binderTestReadEmpty();
-}
-
-int main(int argc, char **argv) {
-    ::testing::InitGoogleTest(&argc, argv);
-
-    binder_env = AddGlobalTestEnvironment(new BinderDriverInterfaceTestEnv());
-
-    return RUN_ALL_TESTS();
-}
diff --git a/libs/binder/tests/binderLibTest.cpp b/libs/binder/tests/binderLibTest.cpp
deleted file mode 100644
index f23ac52b93..0000000000
--- a/libs/binder/tests/binderLibTest.cpp
+++ /dev/null
@@ -1,1360 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <poll.h>
-#include <pthread.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <gtest/gtest.h>
-
-#include <binder/Binder.h>
-#include <binder/IBinder.h>
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
-
-#include <sys/epoll.h>
-
-#define ARRAY_SIZE(array) (sizeof array / sizeof array[0])
-
-using namespace android;
-
-static ::testing::AssertionResult IsPageAligned(void *buf) {
-    if (((unsigned long)buf & ((unsigned long)PAGE_SIZE - 1)) == 0)
-        return ::testing::AssertionSuccess();
-    else
-        return ::testing::AssertionFailure() << buf << " is not page aligned";
-}
-
-static testing::Environment* binder_env;
-static char *binderservername;
-static char *binderserversuffix;
-static char binderserverarg[] = "--binderserver";
-
-static String16 binderLibTestServiceName = String16("test.binderLib");
-
-enum BinderLibTestTranscationCode {
-    BINDER_LIB_TEST_NOP_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,
-    BINDER_LIB_TEST_REGISTER_SERVER,
-    BINDER_LIB_TEST_ADD_SERVER,
-    BINDER_LIB_TEST_ADD_POLL_SERVER,
-    BINDER_LIB_TEST_CALL_BACK,
-    BINDER_LIB_TEST_CALL_BACK_VERIFY_BUF,
-    BINDER_LIB_TEST_DELAYED_CALL_BACK,
-    BINDER_LIB_TEST_NOP_CALL_BACK,
-    BINDER_LIB_TEST_GET_SELF_TRANSACTION,
-    BINDER_LIB_TEST_GET_ID_TRANSACTION,
-    BINDER_LIB_TEST_INDIRECT_TRANSACTION,
-    BINDER_LIB_TEST_SET_ERROR_TRANSACTION,
-    BINDER_LIB_TEST_GET_STATUS_TRANSACTION,
-    BINDER_LIB_TEST_ADD_STRONG_REF_TRANSACTION,
-    BINDER_LIB_TEST_LINK_DEATH_TRANSACTION,
-    BINDER_LIB_TEST_WRITE_FILE_TRANSACTION,
-    BINDER_LIB_TEST_WRITE_PARCEL_FILE_DESCRIPTOR_TRANSACTION,
-    BINDER_LIB_TEST_PROMOTE_WEAK_REF_TRANSACTION,
-    BINDER_LIB_TEST_EXIT_TRANSACTION,
-    BINDER_LIB_TEST_DELAYED_EXIT_TRANSACTION,
-    BINDER_LIB_TEST_GET_PTR_SIZE_TRANSACTION,
-    BINDER_LIB_TEST_CREATE_BINDER_TRANSACTION,
-};
-
-pid_t start_server_process(int arg2, bool usePoll = false)
-{
-    int ret;
-    pid_t pid;
-    status_t status;
-    int pipefd[2];
-    char stri[16];
-    char strpipefd1[16];
-    char usepoll[2];
-    char *childargv[] = {
-        binderservername,
-        binderserverarg,
-        stri,
-        strpipefd1,
-        usepoll,
-        binderserversuffix,
-        nullptr
-    };
-
-    ret = pipe(pipefd);
-    if (ret < 0)
-        return ret;
-
-    snprintf(stri, sizeof(stri), "%d", arg2);
-    snprintf(strpipefd1, sizeof(strpipefd1), "%d", pipefd[1]);
-    snprintf(usepoll, sizeof(usepoll), "%d", usePoll ? 1 : 0);
-
-    pid = fork();
-    if (pid == -1)
-        return pid;
-    if (pid == 0) {
-        close(pipefd[0]);
-        execv(binderservername, childargv);
-        status = -errno;
-        write(pipefd[1], &status, sizeof(status));
-        fprintf(stderr, "execv failed, %s\n", strerror(errno));
-        _exit(EXIT_FAILURE);
-    }
-    close(pipefd[1]);
-    ret = read(pipefd[0], &status, sizeof(status));
-    //printf("pipe read returned %d, status %d\n", ret, status);
-    close(pipefd[0]);
-    if (ret == sizeof(status)) {
-        ret = status;
-    } else {
-        kill(pid, SIGKILL);
-        if (ret >= 0) {
-            ret = NO_INIT;
-        }
-    }
-    if (ret < 0) {
-        wait(nullptr);
-        return ret;
-    }
-    return pid;
-}
-
-class BinderLibTestEnv : public ::testing::Environment {
-    public:
-        BinderLibTestEnv() {}
-        sp<IBinder> getServer(void) {
-            return m_server;
-        }
-
-    private:
-        virtual void SetUp() {
-            m_serverpid = start_server_process(0);
-            //printf("m_serverpid %d\n", m_serverpid);
-            ASSERT_GT(m_serverpid, 0);
-
-            sp<IServiceManager> sm = defaultServiceManager();
-            //printf("%s: pid %d, get service\n", __func__, m_pid);
-            m_server = sm->getService(binderLibTestServiceName);
-            ASSERT_TRUE(m_server != nullptr);
-            //printf("%s: pid %d, get service done\n", __func__, m_pid);
-        }
-        virtual void TearDown() {
-            status_t ret;
-            Parcel data, reply;
-            int exitStatus;
-            pid_t pid;
-
-            //printf("%s: pid %d\n", __func__, m_pid);
-            if (m_server != nullptr) {
-                ret = m_server->transact(BINDER_LIB_TEST_GET_STATUS_TRANSACTION, data, &reply);
-                EXPECT_EQ(0, ret);
-                ret = m_server->transact(BINDER_LIB_TEST_EXIT_TRANSACTION, data, &reply, TF_ONE_WAY);
-                EXPECT_EQ(0, ret);
-            }
-            if (m_serverpid > 0) {
-                //printf("wait for %d\n", m_pids[i]);
-                pid = wait(&exitStatus);
-                EXPECT_EQ(m_serverpid, pid);
-                EXPECT_TRUE(WIFEXITED(exitStatus));
-                EXPECT_EQ(0, WEXITSTATUS(exitStatus));
-            }
-        }
-
-        pid_t m_serverpid;
-        sp<IBinder> m_server;
-};
-
-class BinderLibTest : public ::testing::Test {
-    public:
-        virtual void SetUp() {
-            m_server = static_cast<BinderLibTestEnv *>(binder_env)->getServer();
-        }
-        virtual void TearDown() {
-        }
-    protected:
-        sp<IBinder> addServerEtc(int32_t *idPtr, int code)
-        {
-            int ret;
-            int32_t id;
-            Parcel data, reply;
-            sp<IBinder> binder;
-
-            ret = m_server->transact(code, data, &reply);
-            EXPECT_EQ(NO_ERROR, ret);
-
-            EXPECT_FALSE(binder != nullptr);
-            binder = reply.readStrongBinder();
-            EXPECT_TRUE(binder != nullptr);
-            ret = reply.readInt32(&id);
-            EXPECT_EQ(NO_ERROR, ret);
-            if (idPtr)
-                *idPtr = id;
-            return binder;
-        }
-
-        sp<IBinder> addServer(int32_t *idPtr = nullptr)
-        {
-            return addServerEtc(idPtr, BINDER_LIB_TEST_ADD_SERVER);
-        }
-
-        sp<IBinder> addPollServer(int32_t *idPtr = nullptr)
-        {
-            return addServerEtc(idPtr, BINDER_LIB_TEST_ADD_POLL_SERVER);
-        }
-
-        void waitForReadData(int fd, int timeout_ms) {
-            int ret;
-            pollfd pfd = pollfd();
-
-            pfd.fd = fd;
-            pfd.events = POLLIN;
-            ret = poll(&pfd, 1, timeout_ms);
-            EXPECT_EQ(1, ret);
-        }
-
-        sp<IBinder> m_server;
-};
-
-class BinderLibTestBundle : public Parcel
-{
-    public:
-        BinderLibTestBundle(void) {}
-        BinderLibTestBundle(const Parcel *source) : m_isValid(false) {
-            int32_t mark;
-            int32_t bundleLen;
-            size_t pos;
-
-            if (source->readInt32(&mark))
-                return;
-            if (mark != MARK_START)
-                return;
-            if (source->readInt32(&bundleLen))
-                return;
-            pos = source->dataPosition();
-            if (Parcel::appendFrom(source, pos, bundleLen))
-                return;
-            source->setDataPosition(pos + bundleLen);
-            if (source->readInt32(&mark))
-                return;
-            if (mark != MARK_END)
-                return;
-            m_isValid = true;
-            setDataPosition(0);
-        }
-        void appendTo(Parcel *dest) {
-            dest->writeInt32(MARK_START);
-            dest->writeInt32(dataSize());
-            dest->appendFrom(this, 0, dataSize());
-            dest->writeInt32(MARK_END);
-        };
-        bool isValid(void) {
-            return m_isValid;
-        }
-    private:
-        enum {
-            MARK_START  = B_PACK_CHARS('B','T','B','S'),
-            MARK_END    = B_PACK_CHARS('B','T','B','E'),
-        };
-        bool m_isValid;
-};
-
-class BinderLibTestEvent
-{
-    public:
-        BinderLibTestEvent(void)
-            : m_eventTriggered(false)
-        {
-            pthread_mutex_init(&m_waitMutex, nullptr);
-            pthread_cond_init(&m_waitCond, nullptr);
-        }
-        int waitEvent(int timeout_s)
-        {
-            int ret;
-            pthread_mutex_lock(&m_waitMutex);
-            if (!m_eventTriggered) {
-                struct timespec ts;
-                clock_gettime(CLOCK_REALTIME, &ts);
-                ts.tv_sec += timeout_s;
-                pthread_cond_timedwait(&m_waitCond, &m_waitMutex, &ts);
-            }
-            ret = m_eventTriggered ? NO_ERROR : TIMED_OUT;
-            pthread_mutex_unlock(&m_waitMutex);
-            return ret;
-        }
-        pthread_t getTriggeringThread()
-        {
-            return m_triggeringThread;
-        }
-    protected:
-        void triggerEvent(void) {
-            pthread_mutex_lock(&m_waitMutex);
-            pthread_cond_signal(&m_waitCond);
-            m_eventTriggered = true;
-            m_triggeringThread = pthread_self();
-            pthread_mutex_unlock(&m_waitMutex);
-        };
-    private:
-        pthread_mutex_t m_waitMutex;
-        pthread_cond_t m_waitCond;
-        bool m_eventTriggered;
-        pthread_t m_triggeringThread;
-};
-
-class BinderLibTestCallBack : public BBinder, public BinderLibTestEvent
-{
-    public:
-        BinderLibTestCallBack()
-            : m_result(NOT_ENOUGH_DATA)
-            , m_prev_end(nullptr)
-        {
-        }
-        status_t getResult(void)
-        {
-            return m_result;
-        }
-
-    private:
-        virtual status_t onTransact(uint32_t code,
-                                    const Parcel& data, Parcel* reply,
-                                    uint32_t flags = 0)
-        {
-            (void)reply;
-            (void)flags;
-            switch(code) {
-            case BINDER_LIB_TEST_CALL_BACK: {
-                status_t status = data.readInt32(&m_result);
-                if (status != NO_ERROR) {
-                    m_result = status;
-                }
-                triggerEvent();
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_CALL_BACK_VERIFY_BUF: {
-                sp<IBinder> server;
-                int ret;
-                const uint8_t *buf = data.data();
-                size_t size = data.dataSize();
-                if (m_prev_end) {
-                    /* 64-bit kernel needs at most 8 bytes to align buffer end */
-                    EXPECT_LE((size_t)(buf - m_prev_end), (size_t)8);
-                } else {
-                    EXPECT_TRUE(IsPageAligned((void *)buf));
-                }
-
-                m_prev_end = buf + size + data.objectsCount() * sizeof(binder_size_t);
-
-                if (size > 0) {
-                    server = static_cast<BinderLibTestEnv *>(binder_env)->getServer();
-                    ret = server->transact(BINDER_LIB_TEST_INDIRECT_TRANSACTION,
-                                           data, reply);
-                    EXPECT_EQ(NO_ERROR, ret);
-                }
-                return NO_ERROR;
-            }
-            default:
-                return UNKNOWN_TRANSACTION;
-            }
-        }
-
-        status_t m_result;
-        const uint8_t *m_prev_end;
-};
-
-class TestDeathRecipient : public IBinder::DeathRecipient, public BinderLibTestEvent
-{
-    private:
-        virtual void binderDied(const wp<IBinder>& who) {
-            (void)who;
-            triggerEvent();
-        };
-};
-
-TEST_F(BinderLibTest, NopTransaction) {
-    status_t ret;
-    Parcel data, reply;
-    ret = m_server->transact(BINDER_LIB_TEST_NOP_TRANSACTION, data, &reply);
-    EXPECT_EQ(NO_ERROR, ret);
-}
-
-TEST_F(BinderLibTest, SetError) {
-    int32_t testValue[] = { 0, -123, 123 };
-    for (size_t i = 0; i < ARRAY_SIZE(testValue); i++) {
-        status_t ret;
-        Parcel data, reply;
-        data.writeInt32(testValue[i]);
-        ret = m_server->transact(BINDER_LIB_TEST_SET_ERROR_TRANSACTION, data, &reply);
-        EXPECT_EQ(testValue[i], ret);
-    }
-}
-
-TEST_F(BinderLibTest, GetId) {
-    status_t ret;
-    int32_t id;
-    Parcel data, reply;
-    ret = m_server->transact(BINDER_LIB_TEST_GET_ID_TRANSACTION, data, &reply);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = reply.readInt32(&id);
-    EXPECT_EQ(NO_ERROR, ret);
-    EXPECT_EQ(0, id);
-}
-
-TEST_F(BinderLibTest, PtrSize) {
-    status_t ret;
-    int32_t ptrsize;
-    Parcel data, reply;
-    sp<IBinder> server = addServer();
-    ASSERT_TRUE(server != nullptr);
-    ret = server->transact(BINDER_LIB_TEST_GET_PTR_SIZE_TRANSACTION, data, &reply);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = reply.readInt32(&ptrsize);
-    EXPECT_EQ(NO_ERROR, ret);
-    RecordProperty("TestPtrSize", sizeof(void *));
-    RecordProperty("ServerPtrSize", sizeof(void *));
-}
-
-TEST_F(BinderLibTest, IndirectGetId2)
-{
-    status_t ret;
-    int32_t id;
-    int32_t count;
-    Parcel data, reply;
-    int32_t serverId[3];
-
-    data.writeInt32(ARRAY_SIZE(serverId));
-    for (size_t i = 0; i < ARRAY_SIZE(serverId); i++) {
-        sp<IBinder> server;
-        BinderLibTestBundle datai;
-
-        server = addServer(&serverId[i]);
-        ASSERT_TRUE(server != nullptr);
-        data.writeStrongBinder(server);
-        data.writeInt32(BINDER_LIB_TEST_GET_ID_TRANSACTION);
-        datai.appendTo(&data);
-    }
-
-    ret = m_server->transact(BINDER_LIB_TEST_INDIRECT_TRANSACTION, data, &reply);
-    ASSERT_EQ(NO_ERROR, ret);
-
-    ret = reply.readInt32(&id);
-    ASSERT_EQ(NO_ERROR, ret);
-    EXPECT_EQ(0, id);
-
-    ret = reply.readInt32(&count);
-    ASSERT_EQ(NO_ERROR, ret);
-    EXPECT_EQ(ARRAY_SIZE(serverId), (size_t)count);
-
-    for (size_t i = 0; i < (size_t)count; i++) {
-        BinderLibTestBundle replyi(&reply);
-        EXPECT_TRUE(replyi.isValid());
-        ret = replyi.readInt32(&id);
-        EXPECT_EQ(NO_ERROR, ret);
-        EXPECT_EQ(serverId[i], id);
-        EXPECT_EQ(replyi.dataSize(), replyi.dataPosition());
-    }
-
-    EXPECT_EQ(reply.dataSize(), reply.dataPosition());
-}
-
-TEST_F(BinderLibTest, IndirectGetId3)
-{
-    status_t ret;
-    int32_t id;
-    int32_t count;
-    Parcel data, reply;
-    int32_t serverId[3];
-
-    data.writeInt32(ARRAY_SIZE(serverId));
-    for (size_t i = 0; i < ARRAY_SIZE(serverId); i++) {
-        sp<IBinder> server;
-        BinderLibTestBundle datai;
-        BinderLibTestBundle datai2;
-
-        server = addServer(&serverId[i]);
-        ASSERT_TRUE(server != nullptr);
-        data.writeStrongBinder(server);
-        data.writeInt32(BINDER_LIB_TEST_INDIRECT_TRANSACTION);
-
-        datai.writeInt32(1);
-        datai.writeStrongBinder(m_server);
-        datai.writeInt32(BINDER_LIB_TEST_GET_ID_TRANSACTION);
-        datai2.appendTo(&datai);
-
-        datai.appendTo(&data);
-    }
-
-    ret = m_server->transact(BINDER_LIB_TEST_INDIRECT_TRANSACTION, data, &reply);
-    ASSERT_EQ(NO_ERROR, ret);
-
-    ret = reply.readInt32(&id);
-    ASSERT_EQ(NO_ERROR, ret);
-    EXPECT_EQ(0, id);
-
-    ret = reply.readInt32(&count);
-    ASSERT_EQ(NO_ERROR, ret);
-    EXPECT_EQ(ARRAY_SIZE(serverId), (size_t)count);
-
-    for (size_t i = 0; i < (size_t)count; i++) {
-        int32_t counti;
-
-        BinderLibTestBundle replyi(&reply);
-        EXPECT_TRUE(replyi.isValid());
-        ret = replyi.readInt32(&id);
-        EXPECT_EQ(NO_ERROR, ret);
-        EXPECT_EQ(serverId[i], id);
-
-        ret = replyi.readInt32(&counti);
-        ASSERT_EQ(NO_ERROR, ret);
-        EXPECT_EQ(1, counti);
-
-        BinderLibTestBundle replyi2(&replyi);
-        EXPECT_TRUE(replyi2.isValid());
-        ret = replyi2.readInt32(&id);
-        EXPECT_EQ(NO_ERROR, ret);
-        EXPECT_EQ(0, id);
-        EXPECT_EQ(replyi2.dataSize(), replyi2.dataPosition());
-
-        EXPECT_EQ(replyi.dataSize(), replyi.dataPosition());
-    }
-
-    EXPECT_EQ(reply.dataSize(), reply.dataPosition());
-}
-
-TEST_F(BinderLibTest, CallBack)
-{
-    status_t ret;
-    Parcel data, reply;
-    sp<BinderLibTestCallBack> callBack = new BinderLibTestCallBack();
-    data.writeStrongBinder(callBack);
-    ret = m_server->transact(BINDER_LIB_TEST_NOP_CALL_BACK, data, &reply, TF_ONE_WAY);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = callBack->waitEvent(5);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = callBack->getResult();
-    EXPECT_EQ(NO_ERROR, ret);
-}
-
-TEST_F(BinderLibTest, AddServer)
-{
-    sp<IBinder> server = addServer();
-    ASSERT_TRUE(server != nullptr);
-}
-
-TEST_F(BinderLibTest, DeathNotificationNoRefs)
-{
-    status_t ret;
-
-    sp<TestDeathRecipient> testDeathRecipient = new TestDeathRecipient();
-
-    {
-        sp<IBinder> binder = addServer();
-        ASSERT_TRUE(binder != nullptr);
-        ret = binder->linkToDeath(testDeathRecipient);
-        EXPECT_EQ(NO_ERROR, ret);
-    }
-    IPCThreadState::self()->flushCommands();
-    ret = testDeathRecipient->waitEvent(5);
-    EXPECT_EQ(NO_ERROR, ret);
-#if 0 /* Is there an unlink api that does not require a strong reference? */
-    ret = binder->unlinkToDeath(testDeathRecipient);
-    EXPECT_EQ(NO_ERROR, ret);
-#endif
-}
-
-TEST_F(BinderLibTest, DeathNotificationWeakRef)
-{
-    status_t ret;
-    wp<IBinder> wbinder;
-
-    sp<TestDeathRecipient> testDeathRecipient = new TestDeathRecipient();
-
-    {
-        sp<IBinder> binder = addServer();
-        ASSERT_TRUE(binder != nullptr);
-        ret = binder->linkToDeath(testDeathRecipient);
-        EXPECT_EQ(NO_ERROR, ret);
-        wbinder = binder;
-    }
-    IPCThreadState::self()->flushCommands();
-    ret = testDeathRecipient->waitEvent(5);
-    EXPECT_EQ(NO_ERROR, ret);
-#if 0 /* Is there an unlink api that does not require a strong reference? */
-    ret = binder->unlinkToDeath(testDeathRecipient);
-    EXPECT_EQ(NO_ERROR, ret);
-#endif
-}
-
-TEST_F(BinderLibTest, DeathNotificationStrongRef)
-{
-    status_t ret;
-    sp<IBinder> sbinder;
-
-    sp<TestDeathRecipient> testDeathRecipient = new TestDeathRecipient();
-
-    {
-        sp<IBinder> binder = addServer();
-        ASSERT_TRUE(binder != nullptr);
-        ret = binder->linkToDeath(testDeathRecipient);
-        EXPECT_EQ(NO_ERROR, ret);
-        sbinder = binder;
-    }
-    {
-        Parcel data, reply;
-        ret = sbinder->transact(BINDER_LIB_TEST_EXIT_TRANSACTION, data, &reply, TF_ONE_WAY);
-        EXPECT_EQ(0, ret);
-    }
-    IPCThreadState::self()->flushCommands();
-    ret = testDeathRecipient->waitEvent(5);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = sbinder->unlinkToDeath(testDeathRecipient);
-    EXPECT_EQ(DEAD_OBJECT, ret);
-}
-
-TEST_F(BinderLibTest, DeathNotificationMultiple)
-{
-    status_t ret;
-    const int clientcount = 2;
-    sp<IBinder> target;
-    sp<IBinder> linkedclient[clientcount];
-    sp<BinderLibTestCallBack> callBack[clientcount];
-    sp<IBinder> passiveclient[clientcount];
-
-    target = addServer();
-    ASSERT_TRUE(target != nullptr);
-    for (int i = 0; i < clientcount; i++) {
-        {
-            Parcel data, reply;
-
-            linkedclient[i] = addServer();
-            ASSERT_TRUE(linkedclient[i] != nullptr);
-            callBack[i] = new BinderLibTestCallBack();
-            data.writeStrongBinder(target);
-            data.writeStrongBinder(callBack[i]);
-            ret = linkedclient[i]->transact(BINDER_LIB_TEST_LINK_DEATH_TRANSACTION, data, &reply, TF_ONE_WAY);
-            EXPECT_EQ(NO_ERROR, ret);
-        }
-        {
-            Parcel data, reply;
-
-            passiveclient[i] = addServer();
-            ASSERT_TRUE(passiveclient[i] != nullptr);
-            data.writeStrongBinder(target);
-            ret = passiveclient[i]->transact(BINDER_LIB_TEST_ADD_STRONG_REF_TRANSACTION, data, &reply, TF_ONE_WAY);
-            EXPECT_EQ(NO_ERROR, ret);
-        }
-    }
-    {
-        Parcel data, reply;
-        ret = target->transact(BINDER_LIB_TEST_EXIT_TRANSACTION, data, &reply, TF_ONE_WAY);
-        EXPECT_EQ(0, ret);
-    }
-
-    for (int i = 0; i < clientcount; i++) {
-        ret = callBack[i]->waitEvent(5);
-        EXPECT_EQ(NO_ERROR, ret);
-        ret = callBack[i]->getResult();
-        EXPECT_EQ(NO_ERROR, ret);
-    }
-}
-
-TEST_F(BinderLibTest, DeathNotificationThread)
-{
-    status_t ret;
-    sp<BinderLibTestCallBack> callback;
-    sp<IBinder> target = addServer();
-    ASSERT_TRUE(target != nullptr);
-    sp<IBinder> client = addServer();
-    ASSERT_TRUE(client != nullptr);
-
-    sp<TestDeathRecipient> testDeathRecipient = new TestDeathRecipient();
-
-    ret = target->linkToDeath(testDeathRecipient);
-    EXPECT_EQ(NO_ERROR, ret);
-
-    {
-        Parcel data, reply;
-        ret = target->transact(BINDER_LIB_TEST_EXIT_TRANSACTION, data, &reply, TF_ONE_WAY);
-        EXPECT_EQ(0, ret);
-    }
-
-    /* Make sure it's dead */
-    testDeathRecipient->waitEvent(5);
-
-    /* Now, pass the ref to another process and ask that process to
-     * call linkToDeath() on it, and wait for a response. This tests
-     * two things:
-     * 1) You still get death notifications when calling linkToDeath()
-     *    on a ref that is already dead when it was passed to you.
-     * 2) That death notifications are not directly pushed to the thread
-     *    registering them, but to the threadpool (proc workqueue) instead.
-     *
-     * 2) is tested because the thread handling BINDER_LIB_TEST_DEATH_TRANSACTION
-     * is blocked on a condition variable waiting for the death notification to be
-     * called; therefore, that thread is not available for handling proc work.
-     * So, if the death notification was pushed to the thread workqueue, the callback
-     * would never be called, and the test would timeout and fail.
-     *
-     * Note that we can't do this part of the test from this thread itself, because
-     * the binder driver would only push death notifications to the thread if
-     * it is a looper thread, which this thread is not.
-     *
-     * See b/23525545 for details.
-     */
-    {
-        Parcel data, reply;
-
-        callback = new BinderLibTestCallBack();
-        data.writeStrongBinder(target);
-        data.writeStrongBinder(callback);
-        ret = client->transact(BINDER_LIB_TEST_LINK_DEATH_TRANSACTION, data, &reply, TF_ONE_WAY);
-        EXPECT_EQ(NO_ERROR, ret);
-    }
-
-    ret = callback->waitEvent(5);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = callback->getResult();
-    EXPECT_EQ(NO_ERROR, ret);
-}
-
-TEST_F(BinderLibTest, PassFile) {
-    int ret;
-    int pipefd[2];
-    uint8_t buf[1] = { 0 };
-    uint8_t write_value = 123;
-
-    ret = pipe2(pipefd, O_NONBLOCK);
-    ASSERT_EQ(0, ret);
-
-    {
-        Parcel data, reply;
-        uint8_t writebuf[1] = { write_value };
-
-        ret = data.writeFileDescriptor(pipefd[1], true);
-        EXPECT_EQ(NO_ERROR, ret);
-
-        ret = data.writeInt32(sizeof(writebuf));
-        EXPECT_EQ(NO_ERROR, ret);
-
-        ret = data.write(writebuf, sizeof(writebuf));
-        EXPECT_EQ(NO_ERROR, ret);
-
-        ret = m_server->transact(BINDER_LIB_TEST_WRITE_FILE_TRANSACTION, data, &reply);
-        EXPECT_EQ(NO_ERROR, ret);
-    }
-
-    ret = read(pipefd[0], buf, sizeof(buf));
-    EXPECT_EQ(sizeof(buf), (size_t)ret);
-    EXPECT_EQ(write_value, buf[0]);
-
-    waitForReadData(pipefd[0], 5000); /* wait for other proccess to close pipe */
-
-    ret = read(pipefd[0], buf, sizeof(buf));
-    EXPECT_EQ(0, ret);
-
-    close(pipefd[0]);
-}
-
-TEST_F(BinderLibTest, PassParcelFileDescriptor) {
-    const int datasize = 123;
-    std::vector<uint8_t> writebuf(datasize);
-    for (size_t i = 0; i < writebuf.size(); ++i) {
-        writebuf[i] = i;
-    }
-
-    android::base::unique_fd read_end, write_end;
-    {
-        int pipefd[2];
-        ASSERT_EQ(0, pipe2(pipefd, O_NONBLOCK));
-        read_end.reset(pipefd[0]);
-        write_end.reset(pipefd[1]);
-    }
-    {
-        Parcel data;
-        EXPECT_EQ(NO_ERROR, data.writeDupParcelFileDescriptor(write_end.get()));
-        write_end.reset();
-        EXPECT_EQ(NO_ERROR, data.writeInt32(datasize));
-        EXPECT_EQ(NO_ERROR, data.write(writebuf.data(), datasize));
-
-        Parcel reply;
-        EXPECT_EQ(NO_ERROR,
-                  m_server->transact(BINDER_LIB_TEST_WRITE_PARCEL_FILE_DESCRIPTOR_TRANSACTION, data,
-                                     &reply));
-    }
-    std::vector<uint8_t> readbuf(datasize);
-    EXPECT_EQ(datasize, read(read_end.get(), readbuf.data(), datasize));
-    EXPECT_EQ(writebuf, readbuf);
-
-    waitForReadData(read_end.get(), 5000); /* wait for other proccess to close pipe */
-
-    EXPECT_EQ(0, read(read_end.get(), readbuf.data(), datasize));
-}
-
-TEST_F(BinderLibTest, PromoteLocal) {
-    sp<IBinder> strong = new BBinder();
-    wp<IBinder> weak = strong;
-    sp<IBinder> strong_from_weak = weak.promote();
-    EXPECT_TRUE(strong != nullptr);
-    EXPECT_EQ(strong, strong_from_weak);
-    strong = nullptr;
-    strong_from_weak = nullptr;
-    strong_from_weak = weak.promote();
-    EXPECT_TRUE(strong_from_weak == nullptr);
-}
-
-TEST_F(BinderLibTest, PromoteRemote) {
-    int ret;
-    Parcel data, reply;
-    sp<IBinder> strong = new BBinder();
-    sp<IBinder> server = addServer();
-
-    ASSERT_TRUE(server != nullptr);
-    ASSERT_TRUE(strong != nullptr);
-
-    ret = data.writeWeakBinder(strong);
-    EXPECT_EQ(NO_ERROR, ret);
-
-    ret = server->transact(BINDER_LIB_TEST_PROMOTE_WEAK_REF_TRANSACTION, data, &reply);
-    EXPECT_GE(ret, 0);
-}
-
-TEST_F(BinderLibTest, CheckHandleZeroBinderHighBitsZeroCookie) {
-    status_t ret;
-    Parcel data, reply;
-
-    ret = m_server->transact(BINDER_LIB_TEST_GET_SELF_TRANSACTION, data, &reply);
-    EXPECT_EQ(NO_ERROR, ret);
-
-    const flat_binder_object *fb = reply.readObject(false);
-    ASSERT_TRUE(fb != nullptr);
-    EXPECT_EQ(BINDER_TYPE_HANDLE, fb->hdr.type);
-    EXPECT_EQ(m_server, ProcessState::self()->getStrongProxyForHandle(fb->handle));
-    EXPECT_EQ((binder_uintptr_t)0, fb->cookie);
-    EXPECT_EQ((uint64_t)0, (uint64_t)fb->binder >> 32);
-}
-
-TEST_F(BinderLibTest, FreedBinder) {
-    status_t ret;
-
-    sp<IBinder> server = addServer();
-    ASSERT_TRUE(server != nullptr);
-
-    __u32 freedHandle;
-    wp<IBinder> keepFreedBinder;
-    {
-        Parcel data, reply;
-        data.writeBool(false); /* request weak reference */
-        ret = server->transact(BINDER_LIB_TEST_CREATE_BINDER_TRANSACTION, data, &reply);
-        ASSERT_EQ(NO_ERROR, ret);
-        struct flat_binder_object *freed = (struct flat_binder_object *)(reply.data());
-        freedHandle = freed->handle;
-        /* Add a weak ref to the freed binder so the driver does not
-         * delete its reference to it - otherwise the transaction
-         * fails regardless of whether the driver is fixed.
-         */
-        keepFreedBinder = reply.readWeakBinder();
-    }
-    {
-        Parcel data, reply;
-        data.writeStrongBinder(server);
-        /* Replace original handle with handle to the freed binder */
-        struct flat_binder_object *strong = (struct flat_binder_object *)(data.data());
-        __u32 oldHandle = strong->handle;
-        strong->handle = freedHandle;
-        ret = server->transact(BINDER_LIB_TEST_ADD_STRONG_REF_TRANSACTION, data, &reply);
-        /* Returns DEAD_OBJECT (-32) if target crashes and
-         * FAILED_TRANSACTION if the driver rejects the invalid
-         * object.
-         */
-        EXPECT_EQ((status_t)FAILED_TRANSACTION, ret);
-        /* Restore original handle so parcel destructor does not use
-         * the wrong handle.
-         */
-        strong->handle = oldHandle;
-    }
-}
-
-TEST_F(BinderLibTest, CheckNoHeaderMappedInUser) {
-    status_t ret;
-    Parcel data, reply;
-    sp<BinderLibTestCallBack> callBack = new BinderLibTestCallBack();
-    for (int i = 0; i < 2; i++) {
-        BinderLibTestBundle datai;
-        datai.appendFrom(&data, 0, data.dataSize());
-
-        data.freeData();
-        data.writeInt32(1);
-        data.writeStrongBinder(callBack);
-        data.writeInt32(BINDER_LIB_TEST_CALL_BACK_VERIFY_BUF);
-
-        datai.appendTo(&data);
-    }
-    ret = m_server->transact(BINDER_LIB_TEST_INDIRECT_TRANSACTION, data, &reply);
-    EXPECT_EQ(NO_ERROR, ret);
-}
-
-TEST_F(BinderLibTest, OnewayQueueing)
-{
-    status_t ret;
-    Parcel data, data2;
-
-    sp<IBinder> pollServer = addPollServer();
-
-    sp<BinderLibTestCallBack> callBack = new BinderLibTestCallBack();
-    data.writeStrongBinder(callBack);
-    data.writeInt32(500000); // delay in us before calling back
-
-    sp<BinderLibTestCallBack> callBack2 = new BinderLibTestCallBack();
-    data2.writeStrongBinder(callBack2);
-    data2.writeInt32(0); // delay in us
-
-    ret = pollServer->transact(BINDER_LIB_TEST_DELAYED_CALL_BACK, data, nullptr, TF_ONE_WAY);
-    EXPECT_EQ(NO_ERROR, ret);
-
-    // The delay ensures that this second transaction will end up on the async_todo list
-    // (for a single-threaded server)
-    ret = pollServer->transact(BINDER_LIB_TEST_DELAYED_CALL_BACK, data2, nullptr, TF_ONE_WAY);
-    EXPECT_EQ(NO_ERROR, ret);
-
-    // The server will ensure that the two transactions are handled in the expected order;
-    // If the ordering is not as expected, an error will be returned through the callbacks.
-    ret = callBack->waitEvent(2);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = callBack->getResult();
-    EXPECT_EQ(NO_ERROR, ret);
-
-    ret = callBack2->waitEvent(2);
-    EXPECT_EQ(NO_ERROR, ret);
-    ret = callBack2->getResult();
-    EXPECT_EQ(NO_ERROR, ret);
-}
-
-class BinderLibTestService : public BBinder
-{
-    public:
-        BinderLibTestService(int32_t id)
-            : m_id(id)
-            , m_nextServerId(id + 1)
-            , m_serverStartRequested(false)
-            , m_callback(nullptr)
-        {
-            pthread_mutex_init(&m_serverWaitMutex, nullptr);
-            pthread_cond_init(&m_serverWaitCond, nullptr);
-        }
-        ~BinderLibTestService()
-        {
-            exit(EXIT_SUCCESS);
-        }
-
-        void processPendingCall() {
-            if (m_callback != nullptr) {
-                Parcel data;
-                data.writeInt32(NO_ERROR);
-                m_callback->transact(BINDER_LIB_TEST_CALL_BACK, data, nullptr, TF_ONE_WAY);
-                m_callback = nullptr;
-            }
-        }
-
-        virtual status_t onTransact(uint32_t code,
-                                    const Parcel& data, Parcel* reply,
-                                    uint32_t flags = 0) {
-            //printf("%s: code %d\n", __func__, code);
-            (void)flags;
-
-            if (getuid() != (uid_t)IPCThreadState::self()->getCallingUid()) {
-                return PERMISSION_DENIED;
-            }
-            switch (code) {
-            case BINDER_LIB_TEST_REGISTER_SERVER: {
-                int32_t id;
-                sp<IBinder> binder;
-                id = data.readInt32();
-                binder = data.readStrongBinder();
-                if (binder == nullptr) {
-                    return BAD_VALUE;
-                }
-
-                if (m_id != 0)
-                    return INVALID_OPERATION;
-
-                pthread_mutex_lock(&m_serverWaitMutex);
-                if (m_serverStartRequested) {
-                    m_serverStartRequested = false;
-                    m_serverStarted = binder;
-                    pthread_cond_signal(&m_serverWaitCond);
-                }
-                pthread_mutex_unlock(&m_serverWaitMutex);
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_ADD_POLL_SERVER:
-            case BINDER_LIB_TEST_ADD_SERVER: {
-                int ret;
-                uint8_t buf[1] = { 0 };
-                int serverid;
-
-                if (m_id != 0) {
-                    return INVALID_OPERATION;
-                }
-                pthread_mutex_lock(&m_serverWaitMutex);
-                if (m_serverStartRequested) {
-                    ret = -EBUSY;
-                } else {
-                    serverid = m_nextServerId++;
-                    m_serverStartRequested = true;
-                    bool usePoll = code == BINDER_LIB_TEST_ADD_POLL_SERVER;
-
-                    pthread_mutex_unlock(&m_serverWaitMutex);
-                    ret = start_server_process(serverid, usePoll);
-                    pthread_mutex_lock(&m_serverWaitMutex);
-                }
-                if (ret > 0) {
-                    if (m_serverStartRequested) {
-                        struct timespec ts;
-                        clock_gettime(CLOCK_REALTIME, &ts);
-                        ts.tv_sec += 5;
-                        ret = pthread_cond_timedwait(&m_serverWaitCond, &m_serverWaitMutex, &ts);
-                    }
-                    if (m_serverStartRequested) {
-                        m_serverStartRequested = false;
-                        ret = -ETIMEDOUT;
-                    } else {
-                        reply->writeStrongBinder(m_serverStarted);
-                        reply->writeInt32(serverid);
-                        m_serverStarted = nullptr;
-                        ret = NO_ERROR;
-                    }
-                } else if (ret >= 0) {
-                    m_serverStartRequested = false;
-                    ret = UNKNOWN_ERROR;
-                }
-                pthread_mutex_unlock(&m_serverWaitMutex);
-                return ret;
-            }
-            case BINDER_LIB_TEST_NOP_TRANSACTION:
-                return NO_ERROR;
-            case BINDER_LIB_TEST_DELAYED_CALL_BACK: {
-                // Note: this transaction is only designed for use with a
-                // poll() server. See comments around epoll_wait().
-                if (m_callback != nullptr) {
-                    // A callback was already pending; this means that
-                    // we received a second call while still processing
-                    // the first one. Fail the test.
-                    sp<IBinder> callback = data.readStrongBinder();
-                    Parcel data2;
-                    data2.writeInt32(UNKNOWN_ERROR);
-
-                    callback->transact(BINDER_LIB_TEST_CALL_BACK, data2, nullptr, TF_ONE_WAY);
-                } else {
-                    m_callback = data.readStrongBinder();
-                    int32_t delayUs = data.readInt32();
-                    /*
-                     * It's necessary that we sleep here, so the next
-                     * transaction the caller makes will be queued to
-                     * the async queue.
-                     */
-                    usleep(delayUs);
-
-                    /*
-                     * Now when we return, libbinder will tell the kernel
-                     * we are done with this transaction, and the kernel
-                     * can move the queued transaction to either the
-                     * thread todo worklist (for kernels without the fix),
-                     * or the proc todo worklist. In case of the former,
-                     * the next outbound call will pick up the pending
-                     * transaction, which leads to undesired reentrant
-                     * behavior. This is caught in the if() branch above.
-                     */
-                }
-
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_NOP_CALL_BACK: {
-                Parcel data2, reply2;
-                sp<IBinder> binder;
-                binder = data.readStrongBinder();
-                if (binder == nullptr) {
-                    return BAD_VALUE;
-                }
-                data2.writeInt32(NO_ERROR);
-                binder->transact(BINDER_LIB_TEST_CALL_BACK, data2, &reply2);
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_GET_SELF_TRANSACTION:
-                reply->writeStrongBinder(this);
-                return NO_ERROR;
-            case BINDER_LIB_TEST_GET_ID_TRANSACTION:
-                reply->writeInt32(m_id);
-                return NO_ERROR;
-            case BINDER_LIB_TEST_INDIRECT_TRANSACTION: {
-                int32_t count;
-                uint32_t indirect_code;
-                sp<IBinder> binder;
-
-                count = data.readInt32();
-                reply->writeInt32(m_id);
-                reply->writeInt32(count);
-                for (int i = 0; i < count; i++) {
-                    binder = data.readStrongBinder();
-                    if (binder == nullptr) {
-                        return BAD_VALUE;
-                    }
-                    indirect_code = data.readInt32();
-                    BinderLibTestBundle data2(&data);
-                    if (!data2.isValid()) {
-                        return BAD_VALUE;
-                    }
-                    BinderLibTestBundle reply2;
-                    binder->transact(indirect_code, data2, &reply2);
-                    reply2.appendTo(reply);
-                }
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_SET_ERROR_TRANSACTION:
-                reply->setError(data.readInt32());
-                return NO_ERROR;
-            case BINDER_LIB_TEST_GET_PTR_SIZE_TRANSACTION:
-                reply->writeInt32(sizeof(void *));
-                return NO_ERROR;
-            case BINDER_LIB_TEST_GET_STATUS_TRANSACTION:
-                return NO_ERROR;
-            case BINDER_LIB_TEST_ADD_STRONG_REF_TRANSACTION:
-                m_strongRef = data.readStrongBinder();
-                return NO_ERROR;
-            case BINDER_LIB_TEST_LINK_DEATH_TRANSACTION: {
-                int ret;
-                Parcel data2, reply2;
-                sp<TestDeathRecipient> testDeathRecipient = new TestDeathRecipient();
-                sp<IBinder> target;
-                sp<IBinder> callback;
-
-                target = data.readStrongBinder();
-                if (target == nullptr) {
-                    return BAD_VALUE;
-                }
-                callback = data.readStrongBinder();
-                if (callback == nullptr) {
-                    return BAD_VALUE;
-                }
-                ret = target->linkToDeath(testDeathRecipient);
-                if (ret == NO_ERROR)
-                    ret = testDeathRecipient->waitEvent(5);
-                data2.writeInt32(ret);
-                callback->transact(BINDER_LIB_TEST_CALL_BACK, data2, &reply2);
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_WRITE_FILE_TRANSACTION: {
-                int ret;
-                int32_t size;
-                const void *buf;
-                int fd;
-
-                fd = data.readFileDescriptor();
-                if (fd < 0) {
-                    return BAD_VALUE;
-                }
-                ret = data.readInt32(&size);
-                if (ret != NO_ERROR) {
-                    return ret;
-                }
-                buf = data.readInplace(size);
-                if (buf == nullptr) {
-                    return BAD_VALUE;
-                }
-                ret = write(fd, buf, size);
-                if (ret != size)
-                    return UNKNOWN_ERROR;
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_WRITE_PARCEL_FILE_DESCRIPTOR_TRANSACTION: {
-                int ret;
-                int32_t size;
-                const void *buf;
-                android::base::unique_fd fd;
-
-                ret = data.readUniqueParcelFileDescriptor(&fd);
-                if (ret != NO_ERROR) {
-                    return ret;
-                }
-                ret = data.readInt32(&size);
-                if (ret != NO_ERROR) {
-                    return ret;
-                }
-                buf = data.readInplace(size);
-                if (buf == NULL) {
-                    return BAD_VALUE;
-                }
-                ret = write(fd.get(), buf, size);
-                if (ret != size) return UNKNOWN_ERROR;
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_PROMOTE_WEAK_REF_TRANSACTION: {
-                int ret;
-                wp<IBinder> weak;
-                sp<IBinder> strong;
-                Parcel data2, reply2;
-                sp<IServiceManager> sm = defaultServiceManager();
-                sp<IBinder> server = sm->getService(binderLibTestServiceName);
-
-                weak = data.readWeakBinder();
-                if (weak == nullptr) {
-                    return BAD_VALUE;
-                }
-                strong = weak.promote();
-
-                ret = server->transact(BINDER_LIB_TEST_NOP_TRANSACTION, data2, &reply2);
-                if (ret != NO_ERROR)
-                    exit(EXIT_FAILURE);
-
-                if (strong == nullptr) {
-                    reply->setError(1);
-                }
-                return NO_ERROR;
-            }
-            case BINDER_LIB_TEST_DELAYED_EXIT_TRANSACTION:
-                alarm(10);
-                return NO_ERROR;
-            case BINDER_LIB_TEST_EXIT_TRANSACTION:
-                while (wait(nullptr) != -1 || errno != ECHILD)
-                    ;
-                exit(EXIT_SUCCESS);
-            case BINDER_LIB_TEST_CREATE_BINDER_TRANSACTION: {
-                bool strongRef = data.readBool();
-                sp<IBinder> binder = new BBinder();
-                if (strongRef) {
-                    reply->writeStrongBinder(binder);
-                } else {
-                    reply->writeWeakBinder(binder);
-                }
-                return NO_ERROR;
-            }
-            default:
-                return UNKNOWN_TRANSACTION;
-            };
-        }
-    private:
-        int32_t m_id;
-        int32_t m_nextServerId;
-        pthread_mutex_t m_serverWaitMutex;
-        pthread_cond_t m_serverWaitCond;
-        bool m_serverStartRequested;
-        sp<IBinder> m_serverStarted;
-        sp<IBinder> m_strongRef;
-        bool m_callbackPending;
-        sp<IBinder> m_callback;
-};
-
-int run_server(int index, int readypipefd, bool usePoll)
-{
-    binderLibTestServiceName += String16(binderserversuffix);
-
-    status_t ret;
-    sp<IServiceManager> sm = defaultServiceManager();
-    BinderLibTestService* testServicePtr;
-    {
-        sp<BinderLibTestService> testService = new BinderLibTestService(index);
-        /*
-         * We need this below, but can't hold a sp<> because it prevents the
-         * node from being cleaned up automatically. It's safe in this case
-         * because of how the tests are written.
-         */
-        testServicePtr = testService.get();
-
-        if (index == 0) {
-            ret = sm->addService(binderLibTestServiceName, testService);
-        } else {
-            sp<IBinder> server = sm->getService(binderLibTestServiceName);
-            Parcel data, reply;
-            data.writeInt32(index);
-            data.writeStrongBinder(testService);
-
-            ret = server->transact(BINDER_LIB_TEST_REGISTER_SERVER, data, &reply);
-        }
-    }
-    write(readypipefd, &ret, sizeof(ret));
-    close(readypipefd);
-    //printf("%s: ret %d\n", __func__, ret);
-    if (ret)
-        return 1;
-    //printf("%s: joinThreadPool\n", __func__);
-    if (usePoll) {
-        int fd;
-        struct epoll_event ev;
-        int epoll_fd;
-        IPCThreadState::self()->setupPolling(&fd);
-        if (fd < 0) {
-            return 1;
-        }
-        IPCThreadState::self()->flushCommands(); // flush BC_ENTER_LOOPER
-
-        epoll_fd = epoll_create1(0);
-        if (epoll_fd == -1) {
-            return 1;
-        }
-
-        ev.events = EPOLLIN;
-        if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &ev) == -1) {
-            return 1;
-        }
-
-        while (1) {
-             /*
-              * We simulate a single-threaded process using the binder poll
-              * interface; besides handling binder commands, it can also
-              * issue outgoing transactions, by storing a callback in
-              * m_callback and setting m_callbackPending.
-              *
-              * processPendingCall() will then issue that transaction.
-              */
-             struct epoll_event events[1];
-             int numEvents = epoll_wait(epoll_fd, events, 1, 1000);
-             if (numEvents < 0) {
-                 if (errno == EINTR) {
-                     continue;
-                 }
-                 return 1;
-             }
-             if (numEvents > 0) {
-                 IPCThreadState::self()->handlePolledCommands();
-                 IPCThreadState::self()->flushCommands(); // flush BC_FREE_BUFFER
-                 testServicePtr->processPendingCall();
-             }
-        }
-    } else {
-        ProcessState::self()->startThreadPool();
-        IPCThreadState::self()->joinThreadPool();
-    }
-    //printf("%s: joinThreadPool returned\n", __func__);
-    return 1; /* joinThreadPool should not return */
-}
-
-int main(int argc, char **argv) {
-    int ret;
-
-    if (argc == 4 && !strcmp(argv[1], "--servername")) {
-        binderservername = argv[2];
-    } else {
-        binderservername = argv[0];
-    }
-
-    if (argc == 6 && !strcmp(argv[1], binderserverarg)) {
-        binderserversuffix = argv[5];
-        return run_server(atoi(argv[2]), atoi(argv[3]), atoi(argv[4]) == 1);
-    }
-    binderserversuffix = new char[16];
-    snprintf(binderserversuffix, 16, "%d", getpid());
-    binderLibTestServiceName += String16(binderserversuffix);
-
-    ::testing::InitGoogleTest(&argc, argv);
-    binder_env = AddGlobalTestEnvironment(new BinderLibTestEnv());
-    ProcessState::self()->startThreadPool();
-    return RUN_ALL_TESTS();
-}
diff --git a/libs/binder/tests/binderSafeInterfaceTest.cpp b/libs/binder/tests/binderSafeInterfaceTest.cpp
deleted file mode 100644
index 6a16e2496d..0000000000
--- a/libs/binder/tests/binderSafeInterfaceTest.cpp
+++ /dev/null
@@ -1,819 +0,0 @@
-/*
- * Copyright 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <binder/SafeInterface.h>
-
-#include <binder/IInterface.h>
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
-#include <binder/Parcel.h>
-#include <binder/Parcelable.h>
-#include <binder/ProcessState.h>
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Weverything"
-#include <gtest/gtest.h>
-#pragma clang diagnostic pop
-
-#include <utils/LightRefBase.h>
-#include <utils/NativeHandle.h>
-
-#include <cutils/native_handle.h>
-
-#include <optional>
-
-#include <sys/eventfd.h>
-
-using namespace std::chrono_literals; // NOLINT - google-build-using-namespace
-
-namespace android {
-namespace tests {
-
-enum class TestEnum : uint32_t {
-    INVALID = 0,
-    INITIAL = 1,
-    FINAL = 2,
-};
-
-// This class serves two purposes:
-//   1) It ensures that the implementation doesn't require copying or moving the data (for
-//      efficiency purposes)
-//   2) It tests that Parcelables can be passed correctly
-class NoCopyNoMove : public Parcelable {
-public:
-    NoCopyNoMove() = default;
-    explicit NoCopyNoMove(int32_t value) : mValue(value) {}
-    ~NoCopyNoMove() override = default;
-
-    // Not copyable
-    NoCopyNoMove(const NoCopyNoMove&) = delete;
-    NoCopyNoMove& operator=(const NoCopyNoMove&) = delete;
-
-    // Not movable
-    NoCopyNoMove(NoCopyNoMove&&) = delete;
-    NoCopyNoMove& operator=(NoCopyNoMove&&) = delete;
-
-    // Parcelable interface
-    status_t writeToParcel(Parcel* parcel) const override { return parcel->writeInt32(mValue); }
-    status_t readFromParcel(const Parcel* parcel) override { return parcel->readInt32(&mValue); }
-
-    int32_t getValue() const { return mValue; }
-    void setValue(int32_t value) { mValue = value; }
-
-private:
-    int32_t mValue = 0;
-    uint8_t mPadding[4] = {}; // Avoids a warning from -Wpadded
-};
-
-struct TestFlattenable : Flattenable<TestFlattenable> {
-    TestFlattenable() = default;
-    explicit TestFlattenable(int32_t v) : value(v) {}
-
-    // Flattenable protocol
-    size_t getFlattenedSize() const { return sizeof(value); }
-    size_t getFdCount() const { return 0; }
-    status_t flatten(void*& buffer, size_t& size, int*& /*fds*/, size_t& /*count*/) const {
-        FlattenableUtils::write(buffer, size, value);
-        return NO_ERROR;
-    }
-    status_t unflatten(void const*& buffer, size_t& size, int const*& /*fds*/, size_t& /*count*/) {
-        FlattenableUtils::read(buffer, size, value);
-        return NO_ERROR;
-    }
-
-    int32_t value = 0;
-};
-
-struct TestLightFlattenable : LightFlattenablePod<TestLightFlattenable> {
-    TestLightFlattenable() = default;
-    explicit TestLightFlattenable(int32_t v) : value(v) {}
-    int32_t value = 0;
-};
-
-// It seems like this should be able to inherit from TestFlattenable (to avoid duplicating code),
-// but the SafeInterface logic can't easily be extended to find an indirect Flattenable<T>
-// base class
-class TestLightRefBaseFlattenable : public Flattenable<TestLightRefBaseFlattenable>,
-                                    public LightRefBase<TestLightRefBaseFlattenable> {
-public:
-    TestLightRefBaseFlattenable() = default;
-    explicit TestLightRefBaseFlattenable(int32_t v) : value(v) {}
-
-    // Flattenable protocol
-    size_t getFlattenedSize() const { return sizeof(value); }
-    size_t getFdCount() const { return 0; }
-    status_t flatten(void*& buffer, size_t& size, int*& /*fds*/, size_t& /*count*/) const {
-        FlattenableUtils::write(buffer, size, value);
-        return NO_ERROR;
-    }
-    status_t unflatten(void const*& buffer, size_t& size, int const*& /*fds*/, size_t& /*count*/) {
-        FlattenableUtils::read(buffer, size, value);
-        return NO_ERROR;
-    }
-
-    int32_t value = 0;
-};
-
-class TestParcelable : public Parcelable {
-public:
-    TestParcelable() = default;
-    explicit TestParcelable(int32_t value) : mValue(value) {}
-    TestParcelable(const TestParcelable& other) : TestParcelable(other.mValue) {}
-    TestParcelable(TestParcelable&& other) : TestParcelable(other.mValue) {}
-
-    // Parcelable interface
-    status_t writeToParcel(Parcel* parcel) const override { return parcel->writeInt32(mValue); }
-    status_t readFromParcel(const Parcel* parcel) override { return parcel->readInt32(&mValue); }
-
-    int32_t getValue() const { return mValue; }
-    void setValue(int32_t value) { mValue = value; }
-
-private:
-    int32_t mValue = 0;
-};
-
-class ExitOnDeath : public IBinder::DeathRecipient {
-public:
-    ~ExitOnDeath() override = default;
-
-    void binderDied(const wp<IBinder>& /*who*/) override {
-        ALOG(LOG_INFO, "ExitOnDeath", "Exiting");
-        exit(0);
-    }
-};
-
-// This callback class is used to test both one-way transactions and that sp<IInterface> can be
-// passed correctly
-class ICallback : public IInterface {
-public:
-    DECLARE_META_INTERFACE(Callback)
-
-    enum class Tag : uint32_t {
-        OnCallback = IBinder::FIRST_CALL_TRANSACTION,
-        Last,
-    };
-
-    virtual void onCallback(int32_t aPlusOne) = 0;
-};
-
-class BpCallback : public SafeBpInterface<ICallback> {
-public:
-    explicit BpCallback(const sp<IBinder>& impl) : SafeBpInterface<ICallback>(impl, getLogTag()) {}
-
-    void onCallback(int32_t aPlusOne) override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemoteAsync<decltype(&ICallback::onCallback)>(Tag::OnCallback, aPlusOne);
-    }
-
-private:
-    static constexpr const char* getLogTag() { return "BpCallback"; }
-};
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wexit-time-destructors"
-IMPLEMENT_META_INTERFACE(Callback, "android.gfx.tests.ICallback");
-#pragma clang diagnostic pop
-
-class BnCallback : public SafeBnInterface<ICallback> {
-public:
-    BnCallback() : SafeBnInterface("BnCallback") {}
-
-    status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply,
-                        uint32_t /*flags*/) override {
-        EXPECT_GE(code, IBinder::FIRST_CALL_TRANSACTION);
-        EXPECT_LT(code, static_cast<uint32_t>(ICallback::Tag::Last));
-        ICallback::Tag tag = static_cast<ICallback::Tag>(code);
-        switch (tag) {
-            case ICallback::Tag::OnCallback: {
-                return callLocalAsync(data, reply, &ICallback::onCallback);
-            }
-            case ICallback::Tag::Last:
-                // Should not be possible because of the asserts at the beginning of the method
-                [&]() { FAIL(); }();
-                return UNKNOWN_ERROR;
-        }
-    }
-};
-
-class ISafeInterfaceTest : public IInterface {
-public:
-    DECLARE_META_INTERFACE(SafeInterfaceTest)
-
-    enum class Tag : uint32_t {
-        SetDeathToken = IBinder::FIRST_CALL_TRANSACTION,
-        ReturnsNoMemory,
-        LogicalNot,
-        ModifyEnum,
-        IncrementFlattenable,
-        IncrementLightFlattenable,
-        IncrementLightRefBaseFlattenable,
-        IncrementNativeHandle,
-        IncrementNoCopyNoMove,
-        IncrementParcelableVector,
-        ToUpper,
-        CallMeBack,
-        IncrementInt32,
-        IncrementUint32,
-        IncrementInt64,
-        IncrementUint64,
-        IncrementTwo,
-        Last,
-    };
-
-    // This is primarily so that the remote service dies when the test does, but it also serves to
-    // test the handling of sp<IBinder> and non-const methods
-    virtual status_t setDeathToken(const sp<IBinder>& token) = 0;
-
-    // This is the most basic test since it doesn't require parceling any arguments
-    virtual status_t returnsNoMemory() const = 0;
-
-    // These are ordered according to their corresponding methods in SafeInterface::ParcelHandler
-    virtual status_t logicalNot(bool a, bool* notA) const = 0;
-    virtual status_t modifyEnum(TestEnum a, TestEnum* b) const = 0;
-    virtual status_t increment(const TestFlattenable& a, TestFlattenable* aPlusOne) const = 0;
-    virtual status_t increment(const TestLightFlattenable& a,
-                               TestLightFlattenable* aPlusOne) const = 0;
-    virtual status_t increment(const sp<TestLightRefBaseFlattenable>& a,
-                               sp<TestLightRefBaseFlattenable>* aPlusOne) const = 0;
-    virtual status_t increment(const sp<NativeHandle>& a, sp<NativeHandle>* aPlusOne) const = 0;
-    virtual status_t increment(const NoCopyNoMove& a, NoCopyNoMove* aPlusOne) const = 0;
-    virtual status_t increment(const std::vector<TestParcelable>& a,
-                               std::vector<TestParcelable>* aPlusOne) const = 0;
-    virtual status_t toUpper(const String8& str, String8* upperStr) const = 0;
-    // As mentioned above, sp<IBinder> is already tested by setDeathToken
-    virtual void callMeBack(const sp<ICallback>& callback, int32_t a) const = 0;
-    virtual status_t increment(int32_t a, int32_t* aPlusOne) const = 0;
-    virtual status_t increment(uint32_t a, uint32_t* aPlusOne) const = 0;
-    virtual status_t increment(int64_t a, int64_t* aPlusOne) const = 0;
-    virtual status_t increment(uint64_t a, uint64_t* aPlusOne) const = 0;
-
-    // This tests that input/output parameter interleaving works correctly
-    virtual status_t increment(int32_t a, int32_t* aPlusOne, int32_t b,
-                               int32_t* bPlusOne) const = 0;
-};
-
-class BpSafeInterfaceTest : public SafeBpInterface<ISafeInterfaceTest> {
-public:
-    explicit BpSafeInterfaceTest(const sp<IBinder>& impl)
-          : SafeBpInterface<ISafeInterfaceTest>(impl, getLogTag()) {}
-
-    status_t setDeathToken(const sp<IBinder>& token) override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemote<decltype(&ISafeInterfaceTest::setDeathToken)>(Tag::SetDeathToken, token);
-    }
-    status_t returnsNoMemory() const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemote<decltype(&ISafeInterfaceTest::returnsNoMemory)>(Tag::ReturnsNoMemory);
-    }
-    status_t logicalNot(bool a, bool* notA) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemote<decltype(&ISafeInterfaceTest::logicalNot)>(Tag::LogicalNot, a, notA);
-    }
-    status_t modifyEnum(TestEnum a, TestEnum* b) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemote<decltype(&ISafeInterfaceTest::modifyEnum)>(Tag::ModifyEnum, a, b);
-    }
-    status_t increment(const TestFlattenable& a, TestFlattenable* aPlusOne) const override {
-        using Signature =
-                status_t (ISafeInterfaceTest::*)(const TestFlattenable&, TestFlattenable*) const;
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemote<Signature>(Tag::IncrementFlattenable, a, aPlusOne);
-    }
-    status_t increment(const TestLightFlattenable& a,
-                       TestLightFlattenable* aPlusOne) const override {
-        using Signature = status_t (ISafeInterfaceTest::*)(const TestLightFlattenable&,
-                                                           TestLightFlattenable*) const;
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemote<Signature>(Tag::IncrementLightFlattenable, a, aPlusOne);
-    }
-    status_t increment(const sp<TestLightRefBaseFlattenable>& a,
-                       sp<TestLightRefBaseFlattenable>* aPlusOne) const override {
-        using Signature = status_t (ISafeInterfaceTest::*)(const sp<TestLightRefBaseFlattenable>&,
-                                                           sp<TestLightRefBaseFlattenable>*) const;
-        return callRemote<Signature>(Tag::IncrementLightRefBaseFlattenable, a, aPlusOne);
-    }
-    status_t increment(const sp<NativeHandle>& a, sp<NativeHandle>* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature =
-                status_t (ISafeInterfaceTest::*)(const sp<NativeHandle>&, sp<NativeHandle>*) const;
-        return callRemote<Signature>(Tag::IncrementNativeHandle, a, aPlusOne);
-    }
-    status_t increment(const NoCopyNoMove& a, NoCopyNoMove* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature = status_t (ISafeInterfaceTest::*)(const NoCopyNoMove& a,
-                                                           NoCopyNoMove* aPlusOne) const;
-        return callRemote<Signature>(Tag::IncrementNoCopyNoMove, a, aPlusOne);
-    }
-    status_t increment(const std::vector<TestParcelable>& a,
-                       std::vector<TestParcelable>* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature = status_t (ISafeInterfaceTest::*)(const std::vector<TestParcelable>&,
-                                                           std::vector<TestParcelable>*);
-        return callRemote<Signature>(Tag::IncrementParcelableVector, a, aPlusOne);
-    }
-    status_t toUpper(const String8& str, String8* upperStr) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemote<decltype(&ISafeInterfaceTest::toUpper)>(Tag::ToUpper, str, upperStr);
-    }
-    void callMeBack(const sp<ICallback>& callback, int32_t a) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return callRemoteAsync<decltype(&ISafeInterfaceTest::callMeBack)>(Tag::CallMeBack, callback,
-                                                                          a);
-    }
-    status_t increment(int32_t a, int32_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature = status_t (ISafeInterfaceTest::*)(int32_t, int32_t*) const;
-        return callRemote<Signature>(Tag::IncrementInt32, a, aPlusOne);
-    }
-    status_t increment(uint32_t a, uint32_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature = status_t (ISafeInterfaceTest::*)(uint32_t, uint32_t*) const;
-        return callRemote<Signature>(Tag::IncrementUint32, a, aPlusOne);
-    }
-    status_t increment(int64_t a, int64_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature = status_t (ISafeInterfaceTest::*)(int64_t, int64_t*) const;
-        return callRemote<Signature>(Tag::IncrementInt64, a, aPlusOne);
-    }
-    status_t increment(uint64_t a, uint64_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature = status_t (ISafeInterfaceTest::*)(uint64_t, uint64_t*) const;
-        return callRemote<Signature>(Tag::IncrementUint64, a, aPlusOne);
-    }
-    status_t increment(int32_t a, int32_t* aPlusOne, int32_t b, int32_t* bPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        using Signature =
-                status_t (ISafeInterfaceTest::*)(int32_t, int32_t*, int32_t, int32_t*) const;
-        return callRemote<Signature>(Tag::IncrementTwo, a, aPlusOne, b, bPlusOne);
-    }
-
-private:
-    static constexpr const char* getLogTag() { return "BpSafeInterfaceTest"; }
-};
-
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wexit-time-destructors"
-IMPLEMENT_META_INTERFACE(SafeInterfaceTest, "android.gfx.tests.ISafeInterfaceTest");
-
-static sp<IBinder::DeathRecipient> getDeathRecipient() {
-    static sp<IBinder::DeathRecipient> recipient = new ExitOnDeath;
-    return recipient;
-}
-#pragma clang diagnostic pop
-
-class BnSafeInterfaceTest : public SafeBnInterface<ISafeInterfaceTest> {
-public:
-    BnSafeInterfaceTest() : SafeBnInterface(getLogTag()) {}
-
-    status_t setDeathToken(const sp<IBinder>& token) override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        token->linkToDeath(getDeathRecipient());
-        return NO_ERROR;
-    }
-    status_t returnsNoMemory() const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        return NO_MEMORY;
-    }
-    status_t logicalNot(bool a, bool* notA) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *notA = !a;
-        return NO_ERROR;
-    }
-    status_t modifyEnum(TestEnum a, TestEnum* b) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *b = (a == TestEnum::INITIAL) ? TestEnum::FINAL : TestEnum::INVALID;
-        return NO_ERROR;
-    }
-    status_t increment(const TestFlattenable& a, TestFlattenable* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        aPlusOne->value = a.value + 1;
-        return NO_ERROR;
-    }
-    status_t increment(const TestLightFlattenable& a,
-                       TestLightFlattenable* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        aPlusOne->value = a.value + 1;
-        return NO_ERROR;
-    }
-    status_t increment(const sp<TestLightRefBaseFlattenable>& a,
-                       sp<TestLightRefBaseFlattenable>* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *aPlusOne = new TestLightRefBaseFlattenable(a->value + 1);
-        return NO_ERROR;
-    }
-    status_t increment(const sp<NativeHandle>& a, sp<NativeHandle>* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        native_handle* rawHandle = native_handle_create(1 /*numFds*/, 1 /*numInts*/);
-        if (rawHandle == nullptr) return NO_MEMORY;
-
-        // Copy the fd over directly
-        rawHandle->data[0] = dup(a->handle()->data[0]);
-
-        // Increment the int
-        rawHandle->data[1] = a->handle()->data[1] + 1;
-
-        // This cannot fail, as it is just the sp<NativeHandle> taking responsibility for closing
-        // the native_handle when it goes out of scope
-        *aPlusOne = NativeHandle::create(rawHandle, true);
-        return NO_ERROR;
-    }
-    status_t increment(const NoCopyNoMove& a, NoCopyNoMove* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        aPlusOne->setValue(a.getValue() + 1);
-        return NO_ERROR;
-    }
-    status_t increment(const std::vector<TestParcelable>& a,
-                       std::vector<TestParcelable>* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        aPlusOne->resize(a.size());
-        for (size_t i = 0; i < a.size(); ++i) {
-            (*aPlusOne)[i].setValue(a[i].getValue() + 1);
-        }
-        return NO_ERROR;
-    }
-    status_t toUpper(const String8& str, String8* upperStr) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *upperStr = str;
-        upperStr->toUpper();
-        return NO_ERROR;
-    }
-    void callMeBack(const sp<ICallback>& callback, int32_t a) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        callback->onCallback(a + 1);
-    }
-    status_t increment(int32_t a, int32_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *aPlusOne = a + 1;
-        return NO_ERROR;
-    }
-    status_t increment(uint32_t a, uint32_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *aPlusOne = a + 1;
-        return NO_ERROR;
-    }
-    status_t increment(int64_t a, int64_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *aPlusOne = a + 1;
-        return NO_ERROR;
-    }
-    status_t increment(uint64_t a, uint64_t* aPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *aPlusOne = a + 1;
-        return NO_ERROR;
-    }
-    status_t increment(int32_t a, int32_t* aPlusOne, int32_t b, int32_t* bPlusOne) const override {
-        ALOG(LOG_INFO, getLogTag(), "%s", __PRETTY_FUNCTION__);
-        *aPlusOne = a + 1;
-        *bPlusOne = b + 1;
-        return NO_ERROR;
-    }
-
-    // BnInterface
-    status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply,
-                        uint32_t /*flags*/) override {
-        EXPECT_GE(code, IBinder::FIRST_CALL_TRANSACTION);
-        EXPECT_LT(code, static_cast<uint32_t>(Tag::Last));
-        ISafeInterfaceTest::Tag tag = static_cast<ISafeInterfaceTest::Tag>(code);
-        switch (tag) {
-            case ISafeInterfaceTest::Tag::SetDeathToken: {
-                return callLocal(data, reply, &ISafeInterfaceTest::setDeathToken);
-            }
-            case ISafeInterfaceTest::Tag::ReturnsNoMemory: {
-                return callLocal(data, reply, &ISafeInterfaceTest::returnsNoMemory);
-            }
-            case ISafeInterfaceTest::Tag::LogicalNot: {
-                return callLocal(data, reply, &ISafeInterfaceTest::logicalNot);
-            }
-            case ISafeInterfaceTest::Tag::ModifyEnum: {
-                return callLocal(data, reply, &ISafeInterfaceTest::modifyEnum);
-            }
-            case ISafeInterfaceTest::Tag::IncrementFlattenable: {
-                using Signature = status_t (ISafeInterfaceTest::*)(const TestFlattenable& a,
-                                                                   TestFlattenable* aPlusOne) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementLightFlattenable: {
-                using Signature =
-                        status_t (ISafeInterfaceTest::*)(const TestLightFlattenable& a,
-                                                         TestLightFlattenable* aPlusOne) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementLightRefBaseFlattenable: {
-                using Signature =
-                        status_t (ISafeInterfaceTest::*)(const sp<TestLightRefBaseFlattenable>&,
-                                                         sp<TestLightRefBaseFlattenable>*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementNativeHandle: {
-                using Signature = status_t (ISafeInterfaceTest::*)(const sp<NativeHandle>&,
-                                                                   sp<NativeHandle>*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementNoCopyNoMove: {
-                using Signature = status_t (ISafeInterfaceTest::*)(const NoCopyNoMove& a,
-                                                                   NoCopyNoMove* aPlusOne) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementParcelableVector: {
-                using Signature =
-                        status_t (ISafeInterfaceTest::*)(const std::vector<TestParcelable>&,
-                                                         std::vector<TestParcelable>*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::ToUpper: {
-                return callLocal(data, reply, &ISafeInterfaceTest::toUpper);
-            }
-            case ISafeInterfaceTest::Tag::CallMeBack: {
-                return callLocalAsync(data, reply, &ISafeInterfaceTest::callMeBack);
-            }
-            case ISafeInterfaceTest::Tag::IncrementInt32: {
-                using Signature = status_t (ISafeInterfaceTest::*)(int32_t, int32_t*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementUint32: {
-                using Signature = status_t (ISafeInterfaceTest::*)(uint32_t, uint32_t*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementInt64: {
-                using Signature = status_t (ISafeInterfaceTest::*)(int64_t, int64_t*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementUint64: {
-                using Signature = status_t (ISafeInterfaceTest::*)(uint64_t, uint64_t*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::IncrementTwo: {
-                using Signature = status_t (ISafeInterfaceTest::*)(int32_t, int32_t*, int32_t,
-                                                                   int32_t*) const;
-                return callLocal<Signature>(data, reply, &ISafeInterfaceTest::increment);
-            }
-            case ISafeInterfaceTest::Tag::Last:
-                // Should not be possible because of the asserts at the beginning of the method
-                [&]() { FAIL(); }();
-                return UNKNOWN_ERROR;
-        }
-    }
-
-private:
-    static constexpr const char* getLogTag() { return "BnSafeInterfaceTest"; }
-};
-
-class SafeInterfaceTest : public ::testing::Test {
-public:
-    SafeInterfaceTest() : mSafeInterfaceTest(getRemoteService()) {
-        ProcessState::self()->startThreadPool();
-    }
-    ~SafeInterfaceTest() override = default;
-
-protected:
-    sp<ISafeInterfaceTest> mSafeInterfaceTest;
-
-private:
-    static constexpr const char* getLogTag() { return "SafeInterfaceTest"; }
-
-    sp<ISafeInterfaceTest> getRemoteService() {
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wexit-time-destructors"
-        static std::mutex sMutex;
-        static sp<ISafeInterfaceTest> sService;
-        static sp<IBinder> sDeathToken = new BBinder;
-#pragma clang diagnostic pop
-
-        std::unique_lock<decltype(sMutex)> lock;
-        if (sService == nullptr) {
-            ALOG(LOG_INFO, getLogTag(), "Forking remote process");
-            pid_t forkPid = fork();
-            EXPECT_NE(forkPid, -1);
-
-            const String16 serviceName("SafeInterfaceTest");
-
-            if (forkPid == 0) {
-                ALOG(LOG_INFO, getLogTag(), "Remote process checking in");
-                sp<ISafeInterfaceTest> nativeService = new BnSafeInterfaceTest;
-                defaultServiceManager()->addService(serviceName,
-                                                    IInterface::asBinder(nativeService));
-                ProcessState::self()->startThreadPool();
-                IPCThreadState::self()->joinThreadPool();
-                // We shouldn't get to this point
-                [&]() { FAIL(); }();
-            }
-
-            sp<IBinder> binder = defaultServiceManager()->getService(serviceName);
-            sService = interface_cast<ISafeInterfaceTest>(binder);
-            EXPECT_TRUE(sService != nullptr);
-
-            sService->setDeathToken(sDeathToken);
-        }
-
-        return sService;
-    }
-};
-
-TEST_F(SafeInterfaceTest, TestReturnsNoMemory) {
-    status_t result = mSafeInterfaceTest->returnsNoMemory();
-    ASSERT_EQ(NO_MEMORY, result);
-}
-
-TEST_F(SafeInterfaceTest, TestLogicalNot) {
-    const bool a = true;
-    bool notA = true;
-    status_t result = mSafeInterfaceTest->logicalNot(a, &notA);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(!a, notA);
-    // Test both since we don't want to accidentally catch a default false somewhere
-    const bool b = false;
-    bool notB = false;
-    result = mSafeInterfaceTest->logicalNot(b, &notB);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(!b, notB);
-}
-
-TEST_F(SafeInterfaceTest, TestModifyEnum) {
-    const TestEnum a = TestEnum::INITIAL;
-    TestEnum b = TestEnum::INVALID;
-    status_t result = mSafeInterfaceTest->modifyEnum(a, &b);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(TestEnum::FINAL, b);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementFlattenable) {
-    const TestFlattenable a{1};
-    TestFlattenable aPlusOne{0};
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a.value + 1, aPlusOne.value);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementLightFlattenable) {
-    const TestLightFlattenable a{1};
-    TestLightFlattenable aPlusOne{0};
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a.value + 1, aPlusOne.value);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementLightRefBaseFlattenable) {
-    sp<TestLightRefBaseFlattenable> a = new TestLightRefBaseFlattenable{1};
-    sp<TestLightRefBaseFlattenable> aPlusOne;
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_NE(nullptr, aPlusOne.get());
-    ASSERT_EQ(a->value + 1, aPlusOne->value);
-}
-
-namespace { // Anonymous namespace
-
-bool fdsAreEquivalent(int a, int b) {
-    struct stat statA {};
-    struct stat statB {};
-    if (fstat(a, &statA) != 0) return false;
-    if (fstat(b, &statB) != 0) return false;
-    return (statA.st_dev == statB.st_dev) && (statA.st_ino == statB.st_ino);
-}
-
-} // Anonymous namespace
-
-TEST_F(SafeInterfaceTest, TestIncrementNativeHandle) {
-    // Create an fd we can use to send and receive from the remote process
-    base::unique_fd eventFd{eventfd(0 /*initval*/, 0 /*flags*/)};
-    ASSERT_NE(-1, eventFd);
-
-    // Determine the maximum number of fds this process can have open
-    struct rlimit limit {};
-    ASSERT_EQ(0, getrlimit(RLIMIT_NOFILE, &limit));
-    uint32_t maxFds = static_cast<uint32_t>(limit.rlim_cur);
-
-    // Perform this test enough times to rule out fd leaks
-    for (uint32_t iter = 0; iter < (2 * maxFds); ++iter) {
-        native_handle* handle = native_handle_create(1 /*numFds*/, 1 /*numInts*/);
-        ASSERT_NE(nullptr, handle);
-        handle->data[0] = dup(eventFd.get());
-        handle->data[1] = 1;
-
-        // This cannot fail, as it is just the sp<NativeHandle> taking responsibility for closing
-        // the native_handle when it goes out of scope
-        sp<NativeHandle> a = NativeHandle::create(handle, true);
-
-        sp<NativeHandle> aPlusOne;
-        status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-        ASSERT_EQ(NO_ERROR, result);
-        ASSERT_TRUE(fdsAreEquivalent(a->handle()->data[0], aPlusOne->handle()->data[0]));
-        ASSERT_EQ(a->handle()->data[1] + 1, aPlusOne->handle()->data[1]);
-    }
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementNoCopyNoMove) {
-    const NoCopyNoMove a{1};
-    NoCopyNoMove aPlusOne{0};
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a.getValue() + 1, aPlusOne.getValue());
-}
-
-TEST_F(SafeInterfaceTest, TestIncremementParcelableVector) {
-    const std::vector<TestParcelable> a{TestParcelable{1}, TestParcelable{2}};
-    std::vector<TestParcelable> aPlusOne;
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(a.size(), aPlusOne.size());
-    for (size_t i = 0; i < a.size(); ++i) {
-        ASSERT_EQ(a[i].getValue() + 1, aPlusOne[i].getValue());
-    }
-}
-
-TEST_F(SafeInterfaceTest, TestToUpper) {
-    const String8 str{"Hello, world!"};
-    String8 upperStr;
-    status_t result = mSafeInterfaceTest->toUpper(str, &upperStr);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_TRUE(upperStr == String8{"HELLO, WORLD!"});
-}
-
-TEST_F(SafeInterfaceTest, TestCallMeBack) {
-    class CallbackReceiver : public BnCallback {
-    public:
-        void onCallback(int32_t aPlusOne) override {
-            ALOG(LOG_INFO, "CallbackReceiver", "%s", __PRETTY_FUNCTION__);
-            std::unique_lock<decltype(mMutex)> lock(mMutex);
-            mValue = aPlusOne;
-            mCondition.notify_one();
-        }
-
-        std::optional<int32_t> waitForCallback() {
-            std::unique_lock<decltype(mMutex)> lock(mMutex);
-            bool success =
-                    mCondition.wait_for(lock, 100ms, [&]() { return static_cast<bool>(mValue); });
-            return success ? mValue : std::nullopt;
-        }
-
-    private:
-        std::mutex mMutex;
-        std::condition_variable mCondition;
-        std::optional<int32_t> mValue;
-    };
-
-    sp<CallbackReceiver> receiver = new CallbackReceiver;
-    const int32_t a = 1;
-    mSafeInterfaceTest->callMeBack(receiver, a);
-    auto result = receiver->waitForCallback();
-    ASSERT_TRUE(result);
-    ASSERT_EQ(a + 1, *result);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementInt32) {
-    const int32_t a = 1;
-    int32_t aPlusOne = 0;
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a + 1, aPlusOne);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementUint32) {
-    const uint32_t a = 1;
-    uint32_t aPlusOne = 0;
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a + 1, aPlusOne);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementInt64) {
-    const int64_t a = 1;
-    int64_t aPlusOne = 0;
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a + 1, aPlusOne);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementUint64) {
-    const uint64_t a = 1;
-    uint64_t aPlusOne = 0;
-    status_t result = mSafeInterfaceTest->increment(a, &aPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a + 1, aPlusOne);
-}
-
-TEST_F(SafeInterfaceTest, TestIncrementTwo) {
-    const int32_t a = 1;
-    int32_t aPlusOne = 0;
-    const int32_t b = 2;
-    int32_t bPlusOne = 0;
-    status_t result = mSafeInterfaceTest->increment(1, &aPlusOne, 2, &bPlusOne);
-    ASSERT_EQ(NO_ERROR, result);
-    ASSERT_EQ(a + 1, aPlusOne);
-    ASSERT_EQ(b + 1, bPlusOne);
-}
-
-} // namespace tests
-} // namespace android
diff --git a/libs/binder/tests/binderTextOutputTest.cpp b/libs/binder/tests/binderTextOutputTest.cpp
deleted file mode 100644
index f6dd22d798..0000000000
--- a/libs/binder/tests/binderTextOutputTest.cpp
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <limits>
-#include <cstddef>
-
-#include "android-base/file.h"
-#include "android-base/test_utils.h"
-#include <gtest/gtest.h>
-
-#include <binder/Parcel.h>
-#include <binder/TextOutput.h>
-#include <binder/Debug.h>
-
-static void CheckMessage(const CapturedStderr& cap,
-                         const char* expected,
-                         bool singleline) {
-    std::string output;
-    ASSERT_EQ(0, lseek(cap.fd(), 0, SEEK_SET));
-    android::base::ReadFdToString(cap.fd(), &output);
-    if (singleline)
-        output.erase(std::remove(output.begin(), output.end(), '\n'));
-    ASSERT_STREQ(output.c_str(), expected);
-}
-
-#define CHECK_LOG_(input, expect, singleline)    \
-{                                                \
-    CapturedStderr cap;                          \
-    android::aerr << input << android::endl;     \
-    CheckMessage(cap, expect, singleline);       \
-}                                                \
-
-#define CHECK_VAL_(val, singleline)              \
-{                                                \
-    std::stringstream ss;                        \
-    ss << val;                                   \
-    std::string s = ss.str();                    \
-    CHECK_LOG_(val, s.c_str(), singleline);      \
-}                                                \
-
-#define CHECK_LOG(input, expect) CHECK_LOG_(input, expect, true)
-#define CHECK_VAL(val) CHECK_VAL_(val, true)
-
-TEST(TextOutput, HandlesStdEndl) {
-    CapturedStderr cap;
-    android::aerr << "foobar" << std::endl;
-    std::string output;
-    ASSERT_EQ(0, lseek(cap.fd(), 0, SEEK_SET));
-    android::base::ReadFdToString(cap.fd(), &output);
-    ASSERT_STREQ(output.c_str(), "foobar\n");
-}
-
-TEST(TextOutput, HandlesCEndl) {
-    CapturedStderr cap;
-    android::aerr << "foobar" << "\n";
-    std::string output;
-    ASSERT_EQ(0, lseek(cap.fd(), 0, SEEK_SET));
-    android::base::ReadFdToString(cap.fd(), &output);
-    ASSERT_STREQ(output.c_str(), "foobar\n");
-}
-
-TEST(TextOutput, HandlesAndroidEndl) {
-    CapturedStderr cap;
-    android::aerr << "foobar" << android::endl;
-    std::string output;
-    ASSERT_EQ(0, lseek(cap.fd(), 0, SEEK_SET));
-    android::base::ReadFdToString(cap.fd(), &output);
-    ASSERT_STREQ(output.c_str(), "foobar\n");
-}
-
-TEST(TextOutput, HandleEmptyString) {
-    CHECK_LOG("", "");
-}
-
-TEST(TextOutput, HandleString) {
-    CHECK_LOG("foobar", "foobar");
-}
-
-TEST(TextOutput, HandleNum) {
-    CHECK_LOG(12345, "12345");
-}
-
-TEST(TextOutput, HandleBool) {
-    CHECK_LOG(false, "false");
-}
-
-TEST(TextOutput, HandleChar) {
-    CHECK_LOG('T', "T");
-}
-
-TEST(TextOutput, HandleParcel) {
-    android::Parcel val;
-    CHECK_LOG(val, "Parcel(NULL)");
-}
-
-TEST(TextOutput, HandleHexDump) {
-    const char buf[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
-    android::HexDump val(buf, sizeof(buf));
-    CHECK_LOG(val, "03020100 07060504 0b0a0908 0f0e0d0c '................'");
-}
-
-TEST(TextOutput, HandleHexDumpCustom) {
-    const char buf[4] = {0x11,0x22,0x33,0x44};
-    android::HexDump val(buf, sizeof(buf), 4);
-    CHECK_LOG(val, "11 22 33 44 '.\"3D'");
-}
-
-TEST(TextOutput, HandleTypeCode) {
-    android::TypeCode val(1234);
-    CHECK_LOG(val, "'\\x04\\xd2'");
-}
-
-TEST(TextOutput, HandleCookie) {
-    int32_t val = 321; //0x141
-    CHECK_LOG((void*)(long)val, "0x141");
-}
-
-TEST(TextOutput, HandleString8) {
-    android::String8 val("foobar");
-    CHECK_LOG(val, "foobar");
-}
-
-TEST(TextOutput, HandleString16) {
-    android::String16 val("foobar");
-    CHECK_LOG(val, "foobar");
-}
-
-template <typename T>
-class TextTest : public testing::Test {};
-
-typedef testing::Types<short, unsigned short,
-                       int, unsigned int,
-                       long, unsigned long,
-                       long long, unsigned long long,
-                       float, double, long double> TestTypes;
-TYPED_TEST_CASE(TextTest, TestTypes);
-
-TYPED_TEST(TextTest, TextMax)
-{
-    TypeParam max = std::numeric_limits<TypeParam>::max();
-    CHECK_VAL(max);
-}
-
-TYPED_TEST(TextTest, TestMin)
-{
-    TypeParam min = std::numeric_limits<TypeParam>::min();
-    CHECK_VAL(min);
-}
-
-TYPED_TEST(TextTest, TestDenom)
-{
-    TypeParam min = std::numeric_limits<TypeParam>::denorm_min();
-    CHECK_VAL(min);
-}
-
-TYPED_TEST(TextTest, TestEpsilon)
-{
-    TypeParam eps = std::numeric_limits<TypeParam>::epsilon();
-    CHECK_VAL(eps);
-}
diff --git a/libs/binder/tests/binderThroughputTest.cpp b/libs/binder/tests/binderThroughputTest.cpp
deleted file mode 100644
index da7fc39a8f..0000000000
--- a/libs/binder/tests/binderThroughputTest.cpp
+++ /dev/null
@@ -1,400 +0,0 @@
-#include <binder/Binder.h>
-#include <binder/IBinder.h>
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
-#include <string>
-#include <cstring>
-#include <cstdlib>
-#include <cstdio>
-
-#include <iostream>
-#include <vector>
-#include <tuple>
-
-#include <unistd.h>
-#include <sys/wait.h>
-
-using namespace std;
-using namespace android;
-
-enum BinderWorkerServiceCode {
-    BINDER_NOP = IBinder::FIRST_CALL_TRANSACTION,
-};
-
-#define ASSERT_TRUE(cond) \
-do { \
-    if (!(cond)) {\
-       cerr << __func__ << ":" << __LINE__ << " condition:" << #cond << " failed\n" << endl; \
-       exit(EXIT_FAILURE); \
-    } \
-} while (0)
-
-class BinderWorkerService : public BBinder
-{
-public:
-    BinderWorkerService() {}
-    ~BinderWorkerService() {}
-    virtual status_t onTransact(uint32_t code,
-                                const Parcel& data, Parcel* reply,
-                                uint32_t flags = 0) {
-        (void)flags;
-        (void)data;
-        (void)reply;
-        switch (code) {
-        case BINDER_NOP:
-            return NO_ERROR;
-        default:
-            return UNKNOWN_TRANSACTION;
-        };
-    }
-};
-
-class Pipe {
-    int m_readFd;
-    int m_writeFd;
-    Pipe(int readFd, int writeFd) : m_readFd{readFd}, m_writeFd{writeFd} {}
-    Pipe(const Pipe &) = delete;
-    Pipe& operator=(const Pipe &) = delete;
-    Pipe& operator=(const Pipe &&) = delete;
-public:
-    Pipe(Pipe&& rval) noexcept {
-        m_readFd = rval.m_readFd;
-        m_writeFd = rval.m_writeFd;
-        rval.m_readFd = 0;
-        rval.m_writeFd = 0;
-    }
-    ~Pipe() {
-        if (m_readFd)
-            close(m_readFd);
-        if (m_writeFd)
-            close(m_writeFd);
-    }
-    void signal() {
-        bool val = true;
-        int error = write(m_writeFd, &val, sizeof(val));
-        ASSERT_TRUE(error >= 0);
-    };
-    void wait() {
-        bool val = false;
-        int error = read(m_readFd, &val, sizeof(val));
-        ASSERT_TRUE(error >= 0);
-    }
-    template <typename T> void send(const T& v) {
-        int error = write(m_writeFd, &v, sizeof(T));
-        ASSERT_TRUE(error >= 0);
-    }
-    template <typename T> void recv(T& v) {
-        int error = read(m_readFd, &v, sizeof(T));
-        ASSERT_TRUE(error >= 0);
-    }
-    static tuple<Pipe, Pipe> createPipePair() {
-        int a[2];
-        int b[2];
-
-        int error1 = pipe(a);
-        int error2 = pipe(b);
-        ASSERT_TRUE(error1 >= 0);
-        ASSERT_TRUE(error2 >= 0);
-
-        return make_tuple(Pipe(a[0], b[1]), Pipe(b[0], a[1]));
-    }
-};
-
-static const uint32_t num_buckets = 128;
-static uint64_t max_time_bucket = 50ull * 1000000;
-static uint64_t time_per_bucket = max_time_bucket / num_buckets;
-
-struct ProcResults {
-    uint64_t m_worst = 0;
-    uint32_t m_buckets[num_buckets] = {0};
-    uint64_t m_transactions = 0;
-    uint64_t m_long_transactions = 0;
-    uint64_t m_total_time = 0;
-    uint64_t m_best = max_time_bucket;
-
-    void add_time(uint64_t time) {
-        if (time > max_time_bucket) {
-            m_long_transactions++;
-        }
-        m_buckets[min(time, max_time_bucket-1) / time_per_bucket] += 1;
-        m_best = min(time, m_best);
-        m_worst = max(time, m_worst);
-        m_transactions += 1;
-        m_total_time += time;
-    }
-    static ProcResults combine(const ProcResults& a, const ProcResults& b) {
-        ProcResults ret;
-        for (int i = 0; i < num_buckets; i++) {
-            ret.m_buckets[i] = a.m_buckets[i] + b.m_buckets[i];
-        }
-        ret.m_worst = max(a.m_worst, b.m_worst);
-        ret.m_best = min(a.m_best, b.m_best);
-        ret.m_transactions = a.m_transactions + b.m_transactions;
-        ret.m_long_transactions = a.m_long_transactions + b.m_long_transactions;
-        ret.m_total_time = a.m_total_time + b.m_total_time;
-        return ret;
-    }
-    void dump() {
-        if (m_long_transactions > 0) {
-            cout << (double)m_long_transactions / m_transactions << "% of transactions took longer "
-                "than estimated max latency. Consider setting -m to be higher than "
-                 << m_worst / 1000 << " microseconds" << endl;
-        }
-
-        double best = (double)m_best / 1.0E6;
-        double worst = (double)m_worst / 1.0E6;
-        double average = (double)m_total_time / m_transactions / 1.0E6;
-        cout << "average:" << average << "ms worst:" << worst << "ms best:" << best << "ms" << endl;
-
-        uint64_t cur_total = 0;
-        float time_per_bucket_ms = time_per_bucket / 1.0E6;
-        for (int i = 0; i < num_buckets; i++) {
-            float cur_time = time_per_bucket_ms * i + 0.5f * time_per_bucket_ms;
-            if ((cur_total < 0.5f * m_transactions) && (cur_total + m_buckets[i] >= 0.5f * m_transactions)) {
-                cout << "50%: " << cur_time << " ";
-            }
-            if ((cur_total < 0.9f * m_transactions) && (cur_total + m_buckets[i] >= 0.9f * m_transactions)) {
-                cout << "90%: " << cur_time << " ";
-            }
-            if ((cur_total < 0.95f * m_transactions) && (cur_total + m_buckets[i] >= 0.95f * m_transactions)) {
-                cout << "95%: " << cur_time << " ";
-            }
-            if ((cur_total < 0.99f * m_transactions) && (cur_total + m_buckets[i] >= 0.99f * m_transactions)) {
-                cout << "99%: " << cur_time << " ";
-            }
-            cur_total += m_buckets[i];
-        }
-        cout << endl;
-    }
-};
-
-String16 generateServiceName(int num)
-{
-    char num_str[32];
-    snprintf(num_str, sizeof(num_str), "%d", num);
-    String16 serviceName = String16("binderWorker") + String16(num_str);
-    return serviceName;
-}
-
-void worker_fx(int num,
-               int worker_count,
-               int iterations,
-               int payload_size,
-               bool cs_pair,
-               Pipe p)
-{
-    // Create BinderWorkerService and for go.
-    ProcessState::self()->startThreadPool();
-    sp<IServiceManager> serviceMgr = defaultServiceManager();
-    sp<BinderWorkerService> service = new BinderWorkerService;
-    serviceMgr->addService(generateServiceName(num), service);
-
-    srand(num);
-    p.signal();
-    p.wait();
-
-    // If client/server pairs, then half the workers are
-    // servers and half are clients
-    int server_count = cs_pair ? worker_count / 2 : worker_count;
-
-    // Get references to other binder services.
-    cout << "Created BinderWorker" << num << endl;
-    (void)worker_count;
-    vector<sp<IBinder> > workers;
-    for (int i = 0; i < server_count; i++) {
-        if (num == i)
-            continue;
-        workers.push_back(serviceMgr->getService(generateServiceName(i)));
-    }
-
-    // Run the benchmark if client
-    ProcResults results;
-    chrono::time_point<chrono::high_resolution_clock> start, end;
-    for (int i = 0; (!cs_pair || num >= server_count) && i < iterations; i++) {
-        Parcel data, reply;
-        int target = cs_pair ? num % server_count : rand() % workers.size();
-        int sz = payload_size;
-
-        while (sz > sizeof(uint32_t)) {
-            data.writeInt32(0);
-            sz -= sizeof(uint32_t);
-        }
-        start = chrono::high_resolution_clock::now();
-        status_t ret = workers[target]->transact(BINDER_NOP, data, &reply);
-        end = chrono::high_resolution_clock::now();
-
-        uint64_t cur_time = uint64_t(chrono::duration_cast<chrono::nanoseconds>(end - start).count());
-        results.add_time(cur_time);
-
-        if (ret != NO_ERROR) {
-           cout << "thread " << num << " failed " << ret << "i : " << i << endl;
-           exit(EXIT_FAILURE);
-        }
-    }
-
-    // Signal completion to master and wait.
-    p.signal();
-    p.wait();
-
-    // Send results to master and wait for go to exit.
-    p.send(results);
-    p.wait();
-
-    exit(EXIT_SUCCESS);
-}
-
-Pipe make_worker(int num, int iterations, int worker_count, int payload_size, bool cs_pair)
-{
-    auto pipe_pair = Pipe::createPipePair();
-    pid_t pid = fork();
-    if (pid) {
-        /* parent */
-        return move(get<0>(pipe_pair));
-    } else {
-        /* child */
-        worker_fx(num, worker_count, iterations, payload_size, cs_pair, move(get<1>(pipe_pair)));
-        /* never get here */
-        return move(get<0>(pipe_pair));
-    }
-
-}
-
-void wait_all(vector<Pipe>& v)
-{
-    for (int i = 0; i < v.size(); i++) {
-        v[i].wait();
-    }
-}
-
-void signal_all(vector<Pipe>& v)
-{
-    for (int i = 0; i < v.size(); i++) {
-        v[i].signal();
-    }
-}
-
-void run_main(int iterations,
-              int workers,
-              int payload_size,
-              int cs_pair,
-              bool training_round=false)
-{
-    vector<Pipe> pipes;
-    // Create all the workers and wait for them to spawn.
-    for (int i = 0; i < workers; i++) {
-        pipes.push_back(make_worker(i, iterations, workers, payload_size, cs_pair));
-    }
-    wait_all(pipes);
-
-    // Run the workers and wait for completion.
-    chrono::time_point<chrono::high_resolution_clock> start, end;
-    cout << "waiting for workers to complete" << endl;
-    start = chrono::high_resolution_clock::now();
-    signal_all(pipes);
-    wait_all(pipes);
-    end = chrono::high_resolution_clock::now();
-
-    // Calculate overall throughput.
-    double iterations_per_sec = double(iterations * workers) / (chrono::duration_cast<chrono::nanoseconds>(end - start).count() / 1.0E9);
-    cout << "iterations per sec: " << iterations_per_sec << endl;
-
-    // Collect all results from the workers.
-    cout << "collecting results" << endl;
-    signal_all(pipes);
-    ProcResults tot_results;
-    for (int i = 0; i < workers; i++) {
-        ProcResults tmp_results;
-        pipes[i].recv(tmp_results);
-        tot_results = ProcResults::combine(tot_results, tmp_results);
-    }
-
-    // Kill all the workers.
-    cout << "killing workers" << endl;
-    signal_all(pipes);
-    for (int i = 0; i < workers; i++) {
-        int status;
-        wait(&status);
-        if (status != 0) {
-            cout << "nonzero child status" << status << endl;
-        }
-    }
-    if (training_round) {
-        // sets max_time_bucket to 2 * m_worst from the training round.
-        // Also needs to adjust time_per_bucket accordingly.
-        max_time_bucket = 2 * tot_results.m_worst;
-        time_per_bucket = max_time_bucket / num_buckets;
-        cout << "Max latency during training: " << tot_results.m_worst / 1.0E6 << "ms" << endl;
-    } else {
-            tot_results.dump();
-    }
-}
-
-int main(int argc, char *argv[])
-{
-    int workers = 2;
-    int iterations = 10000;
-    int payload_size = 0;
-    bool cs_pair = false;
-    bool training_round = false;
-    (void)argc;
-    (void)argv;
-
-    // Parse arguments.
-    for (int i = 1; i < argc; i++) {
-        if (string(argv[i]) == "--help") {
-            cout << "Usage: binderThroughputTest [OPTIONS]" << endl;
-            cout << "\t-i N    : Specify number of iterations." << endl;
-            cout << "\t-m N    : Specify expected max latency in microseconds." << endl;
-            cout << "\t-p      : Split workers into client/server pairs." << endl;
-            cout << "\t-s N    : Specify payload size." << endl;
-            cout << "\t-t N    : Run training round." << endl;
-            cout << "\t-w N    : Specify total number of workers." << endl;
-            return 0;
-        }
-        if (string(argv[i]) == "-w") {
-            workers = atoi(argv[i+1]);
-            i++;
-            continue;
-        }
-        if (string(argv[i]) == "-i") {
-            iterations = atoi(argv[i+1]);
-            i++;
-            continue;
-        }
-        if (string(argv[i]) == "-s") {
-            payload_size = atoi(argv[i+1]);
-            i++;
-        }
-        if (string(argv[i]) == "-p") {
-            // client/server pairs instead of spreading
-            // requests to all workers. If true, half
-            // the workers become clients and half servers
-            cs_pair = true;
-        }
-        if (string(argv[i]) == "-t") {
-            // Run one training round before actually collecting data
-            // to get an approximation of max latency.
-            training_round = true;
-        }
-        if (string(argv[i]) == "-m") {
-            // Caller specified the max latency in microseconds.
-            // No need to run training round in this case.
-            if (atoi(argv[i+1]) > 0) {
-                max_time_bucket = strtoull(argv[i+1], (char **)nullptr, 10) * 1000;
-                i++;
-            } else {
-                cout << "Max latency -m must be positive." << endl;
-                exit(EXIT_FAILURE);
-            }
-        }
-    }
-
-    if (training_round) {
-        cout << "Start training round" << endl;
-        run_main(iterations, workers, payload_size, cs_pair, training_round=true);
-        cout << "Completed training round" << endl << endl;
-    }
-
-    run_main(iterations, workers, payload_size, cs_pair);
-    return 0;
-}
diff --git a/libs/binder/tests/binderValueTypeTest.cpp b/libs/binder/tests/binderValueTypeTest.cpp
deleted file mode 100644
index c8f46977cd..0000000000
--- a/libs/binder/tests/binderValueTypeTest.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <limits>
-#include <cstddef>
-#include <vector>
-
-#include "android-base/file.h"
-#include "android-base/test_utils.h"
-#include <gtest/gtest.h>
-
-#include <binder/Parcel.h>
-#include <binder/Value.h>
-#include <binder/Debug.h>
-
-using ::android::binder::Value;
-using ::android::os::PersistableBundle;
-using ::android::String16;
-using ::std::vector;
-
-#define VALUE_TYPE_TEST(T, TYPENAME, VAL)         \
-    TEST(ValueType, Handles ## TYPENAME) {        \
-        T x = VAL;                                \
-        T y = T();                                \
-        Value value = VAL;                        \
-        ASSERT_FALSE(value.empty());              \
-        ASSERT_TRUE(value.is ## TYPENAME ());     \
-        ASSERT_TRUE(value.get ## TYPENAME (&y));  \
-        ASSERT_EQ(x, y);                          \
-        ASSERT_EQ(value, Value(y));               \
-        value.put ## TYPENAME (x);                \
-        ASSERT_EQ(value, Value(y));               \
-        value = Value();                          \
-        ASSERT_TRUE(value.empty());               \
-        ASSERT_NE(value, Value(y));               \
-        value = y;                                \
-        ASSERT_EQ(value, Value(x));               \
-    }
-
-#define VALUE_TYPE_VECTOR_TEST(T, TYPENAME, VAL)      \
-    TEST(ValueType, Handles ## TYPENAME ## Vector) {  \
-        vector<T> x;                                  \
-        vector<T> y;                                  \
-        x.push_back(VAL);                             \
-        x.push_back(T());                             \
-        Value value(x);                               \
-        ASSERT_FALSE(value.empty());                  \
-        ASSERT_TRUE(value.is ## TYPENAME ## Vector());    \
-        ASSERT_TRUE(value.get ## TYPENAME ## Vector(&y)); \
-        ASSERT_EQ(x, y);                              \
-        ASSERT_EQ(value, Value(y));                   \
-        value.put ## TYPENAME ## Vector(x);           \
-        ASSERT_EQ(value, Value(y));                   \
-        value = Value();                              \
-        ASSERT_TRUE(value.empty());                   \
-        ASSERT_NE(value, Value(y));                   \
-        value = y;                                    \
-        ASSERT_EQ(value, Value(x));                   \
-    }
-
-VALUE_TYPE_TEST(bool, Boolean, true)
-VALUE_TYPE_TEST(int32_t, Int, 31337)
-VALUE_TYPE_TEST(int64_t, Long, 13370133701337l)
-VALUE_TYPE_TEST(double, Double, 3.14159265358979323846)
-VALUE_TYPE_TEST(String16, String, String16("Lovely"))
-
-VALUE_TYPE_VECTOR_TEST(bool, Boolean, true)
-VALUE_TYPE_VECTOR_TEST(int32_t, Int, 31337)
-VALUE_TYPE_VECTOR_TEST(int64_t, Long, 13370133701337l)
-VALUE_TYPE_VECTOR_TEST(double, Double, 3.14159265358979323846)
-VALUE_TYPE_VECTOR_TEST(String16, String, String16("Lovely"))
-
-VALUE_TYPE_TEST(PersistableBundle, PersistableBundle, PersistableBundle())
-
-TEST(ValueType, HandlesClear) {
-    Value value;
-    ASSERT_TRUE(value.empty());
-    value.putInt(31337);
-    ASSERT_FALSE(value.empty());
-    value.clear();
-    ASSERT_TRUE(value.empty());
-}
-
-TEST(ValueType, HandlesSwap) {
-    Value value_a, value_b;
-    int32_t int_x;
-    value_a.putInt(31337);
-    ASSERT_FALSE(value_a.empty());
-    ASSERT_TRUE(value_b.empty());
-    value_a.swap(value_b);
-    ASSERT_FALSE(value_b.empty());
-    ASSERT_TRUE(value_a.empty());
-    ASSERT_TRUE(value_b.getInt(&int_x));
-    ASSERT_EQ(31337, int_x);
-}
diff --git a/libs/binder/tests/schd-dbg.cpp b/libs/binder/tests/schd-dbg.cpp
deleted file mode 100644
index 6cf7f36021..0000000000
--- a/libs/binder/tests/schd-dbg.cpp
+++ /dev/null
@@ -1,502 +0,0 @@
-#include <binder/Binder.h>
-#include <binder/IBinder.h>
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <string>
-
-#include <iomanip>
-#include <iostream>
-#include <tuple>
-#include <vector>
-
-#include <pthread.h>
-#include <sys/wait.h>
-#include <unistd.h>
-#include <fstream>
-
-using namespace std;
-using namespace android;
-
-enum BinderWorkerServiceCode {
-  BINDER_NOP = IBinder::FIRST_CALL_TRANSACTION,
-};
-
-#define ASSERT(cond)                                                \
-  do {                                                              \
-    if (!(cond)) {                                                  \
-      cerr << __func__ << ":" << __LINE__ << " condition:" << #cond \
-           << " failed\n"                                           \
-           << endl;                                                 \
-      exit(EXIT_FAILURE);                                           \
-    }                                                               \
-  } while (0)
-
-vector<sp<IBinder> > workers;
-
-// the ratio that the service is synced on the same cpu beyond
-// GOOD_SYNC_MIN is considered as good
-#define GOOD_SYNC_MIN (0.6)
-
-#define DUMP_PRESICION 2
-
-string trace_path = "/sys/kernel/debug/tracing";
-
-// the default value
-int no_process = 2;
-int iterations = 100;
-int payload_size = 16;
-int no_inherent = 0;
-int no_sync = 0;
-int verbose = 0;
-int trace;
-
-bool traceIsOn() {
-  fstream file;
-  file.open(trace_path + "/tracing_on", ios::in);
-  char on;
-  file >> on;
-  file.close();
-  return on == '1';
-}
-
-void traceStop() {
-  ofstream file;
-  file.open(trace_path + "/tracing_on", ios::out | ios::trunc);
-  file << '0' << endl;
-  file.close();
-}
-
-// the deadline latency that we are interested in
-uint64_t deadline_us = 2500;
-
-int thread_pri() {
-  struct sched_param param;
-  int policy;
-  ASSERT(!pthread_getschedparam(pthread_self(), &policy, &param));
-  return param.sched_priority;
-}
-
-void thread_dump(const char* prefix) {
-  struct sched_param param;
-  int policy;
-  if (!verbose) return;
-  cout << "--------------------------------------------------" << endl;
-  cout << setw(12) << left << prefix << " pid: " << getpid()
-       << " tid: " << gettid() << " cpu: " << sched_getcpu() << endl;
-  ASSERT(!pthread_getschedparam(pthread_self(), &policy, &param));
-  string s = (policy == SCHED_OTHER)
-                 ? "SCHED_OTHER"
-                 : (policy == SCHED_FIFO)
-                       ? "SCHED_FIFO"
-                       : (policy == SCHED_RR) ? "SCHED_RR" : "???";
-  cout << setw(12) << left << s << param.sched_priority << endl;
-  return;
-}
-
-class BinderWorkerService : public BBinder {
- public:
-  BinderWorkerService() {
-  }
-  ~BinderWorkerService() {
-  }
-  virtual status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply,
-                              uint32_t flags = 0) {
-    (void)flags;
-    (void)data;
-    (void)reply;
-    switch (code) {
-      // The transaction format is like
-      //
-      // data[in]:  int32: caller priority
-      //            int32: caller cpu
-      //
-      // reply[out]: int32: 1 if caller's priority != callee's priority
-      //             int32: 1 if caller's cpu != callee's cpu
-      //
-      // note the caller cpu read here is not always correct
-      // there're still chances that the caller got switched out
-      // right after it read the cpu number and still before the transaction.
-      case BINDER_NOP: {
-        thread_dump("binder");
-        int priority = thread_pri();
-        int priority_caller = data.readInt32();
-        int h = 0, s = 0;
-        if (priority_caller != priority) {
-          h++;
-          if (verbose) {
-            cout << "err priority_caller:" << priority_caller
-                 << ", priority:" << priority << endl;
-          }
-        }
-        if (priority == sched_get_priority_max(SCHED_FIFO)) {
-          int cpu = sched_getcpu();
-          int cpu_caller = data.readInt32();
-          if (cpu != cpu_caller) {
-            s++;
-          }
-        }
-        reply->writeInt32(h);
-        reply->writeInt32(s);
-        return NO_ERROR;
-      }
-      default:
-        return UNKNOWN_TRANSACTION;
-    };
-  }
-};
-
-class Pipe {
-  int m_readFd;
-  int m_writeFd;
-  Pipe(int readFd, int writeFd) : m_readFd{readFd}, m_writeFd{writeFd} {
-  }
-  Pipe(const Pipe&) = delete;
-  Pipe& operator=(const Pipe&) = delete;
-  Pipe& operator=(const Pipe&&) = delete;
-
- public:
-  Pipe(Pipe&& rval) noexcept {
-    m_readFd = rval.m_readFd;
-    m_writeFd = rval.m_writeFd;
-    rval.m_readFd = 0;
-    rval.m_writeFd = 0;
-  }
-  ~Pipe() {
-    if (m_readFd) close(m_readFd);
-    if (m_writeFd) close(m_writeFd);
-  }
-  void signal() {
-    bool val = true;
-    int error = write(m_writeFd, &val, sizeof(val));
-    ASSERT(error >= 0);
-  };
-  void wait() {
-    bool val = false;
-    int error = read(m_readFd, &val, sizeof(val));
-    ASSERT(error >= 0);
-  }
-  template <typename T>
-  void send(const T& v) {
-    int error = write(m_writeFd, &v, sizeof(T));
-    ASSERT(error >= 0);
-  }
-  template <typename T>
-  void recv(T& v) {
-    int error = read(m_readFd, &v, sizeof(T));
-    ASSERT(error >= 0);
-  }
-  static tuple<Pipe, Pipe> createPipePair() {
-    int a[2];
-    int b[2];
-
-    int error1 = pipe(a);
-    int error2 = pipe(b);
-    ASSERT(error1 >= 0);
-    ASSERT(error2 >= 0);
-
-    return make_tuple(Pipe(a[0], b[1]), Pipe(b[0], a[1]));
-  }
-};
-
-typedef chrono::time_point<chrono::high_resolution_clock> Tick;
-
-static inline Tick tickNow() {
-  return chrono::high_resolution_clock::now();
-}
-
-static inline uint64_t tickNano(Tick& sta, Tick& end) {
-  return uint64_t(chrono::duration_cast<chrono::nanoseconds>(end - sta).count());
-}
-
-struct Results {
-  uint64_t m_best = 0xffffffffffffffffULL;
-  uint64_t m_worst = 0;
-  uint64_t m_transactions = 0;
-  uint64_t m_total_time = 0;
-  uint64_t m_miss = 0;
-  bool tracing;
-  Results(bool _tracing) : tracing(_tracing) {
-  }
-  inline bool miss_deadline(uint64_t nano) {
-    return nano > deadline_us * 1000;
-  }
-  void add_time(uint64_t nano) {
-    m_best = min(nano, m_best);
-    m_worst = max(nano, m_worst);
-    m_transactions += 1;
-    m_total_time += nano;
-    if (miss_deadline(nano)) m_miss++;
-    if (miss_deadline(nano) && tracing) {
-      // There might be multiple process pair running the test concurrently
-      // each may execute following statements and only the first one actually
-      // stop the trace and any traceStop() afterthen has no effect.
-      traceStop();
-      cout << endl;
-      cout << "deadline triggered: halt & stop trace" << endl;
-      cout << "log:" + trace_path + "/trace" << endl;
-      cout << endl;
-      exit(1);
-    }
-  }
-  void dump() {
-    double best = (double)m_best / 1.0E6;
-    double worst = (double)m_worst / 1.0E6;
-    double average = (double)m_total_time / m_transactions / 1.0E6;
-    // FIXME: libjson?
-    int W = DUMP_PRESICION + 2;
-    cout << setprecision(DUMP_PRESICION) << "{ \"avg\":" << setw(W) << left
-         << average << ",\"wst\":" << setw(W) << left << worst
-         << ",\"bst\":" << setw(W) << left << best << ",\"miss\":" << left
-         << m_miss << ",\"meetR\":" << left << setprecision(DUMP_PRESICION + 3)
-         << (1.0 - (double)m_miss / m_transactions) << "}";
-  }
-};
-
-String16 generateServiceName(int num) {
-  char num_str[32];
-  snprintf(num_str, sizeof(num_str), "%d", num);
-  String16 serviceName = String16("binderWorker") + String16(num_str);
-  return serviceName;
-}
-
-static void parcel_fill(Parcel& data, int sz, int priority, int cpu) {
-  ASSERT(sz >= (int)sizeof(uint32_t) * 2);
-  data.writeInt32(priority);
-  data.writeInt32(cpu);
-  sz -= sizeof(uint32_t);
-  while (sz > (int)sizeof(uint32_t)) {
-    data.writeInt32(0);
-    sz -= sizeof(uint32_t);
-  }
-}
-
-typedef struct {
-  void* result;
-  int target;
-} thread_priv_t;
-
-static void* thread_start(void* p) {
-  thread_priv_t* priv = (thread_priv_t*)p;
-  int target = priv->target;
-  Results* results_fifo = (Results*)priv->result;
-  Parcel data, reply;
-  Tick sta, end;
-
-  parcel_fill(data, payload_size, thread_pri(), sched_getcpu());
-  thread_dump("fifo-caller");
-
-  sta = tickNow();
-  status_t ret = workers[target]->transact(BINDER_NOP, data, &reply);
-  end = tickNow();
-  results_fifo->add_time(tickNano(sta, end));
-
-  no_inherent += reply.readInt32();
-  no_sync += reply.readInt32();
-  return nullptr;
-}
-
-// create a fifo thread to transact and wait it to finished
-static void thread_transaction(int target, Results* results_fifo) {
-  thread_priv_t thread_priv;
-  void* dummy;
-  pthread_t thread;
-  pthread_attr_t attr;
-  struct sched_param param;
-  thread_priv.target = target;
-  thread_priv.result = results_fifo;
-  ASSERT(!pthread_attr_init(&attr));
-  ASSERT(!pthread_attr_setschedpolicy(&attr, SCHED_FIFO));
-  param.sched_priority = sched_get_priority_max(SCHED_FIFO);
-  ASSERT(!pthread_attr_setschedparam(&attr, &param));
-  ASSERT(!pthread_create(&thread, &attr, &thread_start, &thread_priv));
-  ASSERT(!pthread_join(thread, &dummy));
-}
-
-#define is_client(_num) ((_num) >= (no_process / 2))
-
-void worker_fx(int num, int no_process, int iterations, int payload_size,
-               Pipe p) {
-  int dummy;
-  Results results_other(false), results_fifo(trace);
-
-  // Create BinderWorkerService and for go.
-  ProcessState::self()->startThreadPool();
-  sp<IServiceManager> serviceMgr = defaultServiceManager();
-  sp<BinderWorkerService> service = new BinderWorkerService;
-  serviceMgr->addService(generateServiceName(num), service);
-  // init done
-  p.signal();
-  // wait for kick-off
-  p.wait();
-
-  // If client/server pairs, then half the workers are
-  // servers and half are clients
-  int server_count = no_process / 2;
-
-  for (int i = 0; i < server_count; i++) {
-    // self service is in-process so just skip
-    if (num == i) continue;
-    workers.push_back(serviceMgr->getService(generateServiceName(i)));
-  }
-
-  // Client for each pair iterates here
-  // each iterations contains exatcly 2 transactions
-  for (int i = 0; is_client(num) && i < iterations; i++) {
-    Parcel data, reply;
-    Tick sta, end;
-    // the target is paired to make it easier to diagnose
-    int target = num % server_count;
-
-    // 1. transaction by fifo thread
-    thread_transaction(target, &results_fifo);
-    parcel_fill(data, payload_size, thread_pri(), sched_getcpu());
-    thread_dump("other-caller");
-
-    // 2. transaction by other thread
-    sta = tickNow();
-    ASSERT(NO_ERROR == workers[target]->transact(BINDER_NOP, data, &reply));
-    end = tickNow();
-    results_other.add_time(tickNano(sta, end));
-
-    no_inherent += reply.readInt32();
-    no_sync += reply.readInt32();
-  }
-  // Signal completion to master and wait.
-  p.signal();
-  p.wait();
-
-  p.send(&dummy);
-  // wait for kill
-  p.wait();
-  // Client for each pair dump here
-  if (is_client(num)) {
-    int no_trans = iterations * 2;
-    double sync_ratio = (1.0 - (double)no_sync / no_trans);
-    // FIXME: libjson?
-    cout << "\"P" << (num - server_count) << "\":{\"SYNC\":\""
-         << ((sync_ratio > GOOD_SYNC_MIN) ? "GOOD" : "POOR") << "\","
-         << "\"S\":" << (no_trans - no_sync) << ",\"I\":" << no_trans << ","
-         << "\"R\":" << sync_ratio << "," << endl;
-
-    cout << "  \"other_ms\":";
-    results_other.dump();
-    cout << "," << endl;
-    cout << "  \"fifo_ms\": ";
-    results_fifo.dump();
-    cout << endl;
-    cout << "}," << endl;
-  }
-  exit(no_inherent);
-}
-
-Pipe make_process(int num, int iterations, int no_process, int payload_size) {
-  auto pipe_pair = Pipe::createPipePair();
-  pid_t pid = fork();
-  if (pid) {
-    // parent
-    return move(get<0>(pipe_pair));
-  } else {
-    // child
-    thread_dump(is_client(num) ? "client" : "server");
-    worker_fx(num, no_process, iterations, payload_size,
-              move(get<1>(pipe_pair)));
-    // never get here
-    return move(get<0>(pipe_pair));
-  }
-}
-
-void wait_all(vector<Pipe>& v) {
-  for (size_t i = 0; i < v.size(); i++) {
-    v[i].wait();
-  }
-}
-
-void signal_all(vector<Pipe>& v) {
-  for (size_t i = 0; i < v.size(); i++) {
-    v[i].signal();
-  }
-}
-
-// This test is modified from binderThroughputTest.cpp
-int main(int argc, char** argv) {
-  for (int i = 1; i < argc; i++) {
-    if (string(argv[i]) == "-i") {
-      iterations = atoi(argv[i + 1]);
-      i++;
-      continue;
-    }
-    if (string(argv[i]) == "-pair") {
-      no_process = 2 * atoi(argv[i + 1]);
-      i++;
-      continue;
-    }
-    if (string(argv[i]) == "-deadline_us") {
-      deadline_us = atoi(argv[i + 1]);
-      i++;
-      continue;
-    }
-    if (string(argv[i]) == "-v") {
-      verbose = 1;
-    }
-    // The -trace argument is used like that:
-    //
-    // First start trace with atrace command as usual
-    // >atrace --async_start sched freq
-    //
-    // then use schd-dbg with -trace arguments
-    //./schd-dbg -trace -deadline_us 2500
-    //
-    // This makes schd-dbg to stop trace once it detects a transaction
-    // duration over the deadline. By writing '0' to
-    // /sys/kernel/debug/tracing and halt the process. The tracelog is
-    // then available on /sys/kernel/debug/trace
-    if (string(argv[i]) == "-trace") {
-      trace = 1;
-    }
-  }
-  if (trace && !traceIsOn()) {
-    cout << "trace is not running" << endl;
-    cout << "check " << trace_path + "/tracing_on" << endl;
-    cout << "use atrace --async_start first" << endl;
-    exit(-1);
-  }
-  vector<Pipe> pipes;
-  thread_dump("main");
-  // FIXME: libjson?
-  cout << "{" << endl;
-  cout << "\"cfg\":{\"pair\":" << (no_process / 2)
-       << ",\"iterations\":" << iterations << ",\"deadline_us\":" << deadline_us
-       << "}," << endl;
-
-  // the main process fork 2 processes for each pairs
-  // 1 server + 1 client
-  // each has a pipe to communicate with
-  for (int i = 0; i < no_process; i++) {
-    pipes.push_back(make_process(i, iterations, no_process, payload_size));
-  }
-  // wait for init done
-  wait_all(pipes);
-  // kick-off iterations
-  signal_all(pipes);
-  // wait for completion
-  wait_all(pipes);
-  // start to send result
-  signal_all(pipes);
-  for (int i = 0; i < no_process; i++) {
-    int status;
-    // kill
-    pipes[i].signal();
-    wait(&status);
-    // the exit status is number of transactions without priority inheritance
-    // detected in the child process
-    no_inherent += status;
-  }
-  // FIXME: libjson?
-  cout << "\"inheritance\": " << (no_inherent == 0 ? "\"PASS\"" : "\"FAIL\"")
-       << endl;
-  cout << "}" << endl;
-  return -no_inherent;
-}
-- 
2.17.0

