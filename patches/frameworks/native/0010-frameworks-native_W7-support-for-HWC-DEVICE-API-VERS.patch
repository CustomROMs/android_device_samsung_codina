From c28b4e001089952d13e11dd6ccf5dd68f52b9033 Mon Sep 17 00:00:00 2001
From: Shilin Victor <radicaldreamer00001@gmail.com>
Date: Fri, 29 Mar 2019 22:51:46 +0300
Subject: [PATCH 10/30] 
 frameworks-native_W7-support-for-HWC-DEVICE-API-VERSION-1.patch

Change-Id: Iecd517b3ffea9eb4cf1fbf556593119378f2f37a
---
 include/ui/PixelFormat.h                           |  5 +-
 services/surfaceflinger/Android.mk                 |  7 ++-
 .../surfaceflinger/DisplayHardware/HWComposer.h    | 54 ++++++++++++++--------
 services/surfaceflinger/Layer.cpp                  |  5 +-
 services/surfaceflinger/LayerDim.cpp               |  2 +
 services/surfaceflinger/SurfaceFlinger.cpp         |  4 ++
 6 files changed, 55 insertions(+), 22 deletions(-)

diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index 90f57cd4b..23afe32f6 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -60,7 +60,10 @@ enum {
     PIXEL_FORMAT_BGRA_8888   = HAL_PIXEL_FORMAT_BGRA_8888,   // 4x8-bit BGRA
     PIXEL_FORMAT_RGBA_5551   = 6,                            // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = 7,                            // 16-bit ARGB
-
+#ifndef STE_HARDWARE
+    PIXEL_FORMAT_sRGB_A_8888 = HAL_PIXEL_FORMAT_sRGB_A_8888, // 4x8-bit sRGB + A
+    PIXEL_FORMAT_sRGB_X_8888 = HAL_PIXEL_FORMAT_sRGB_X_8888, // 4x8-bit sRGB, no A
+#endif
 #ifdef STE_HARDWARE
     // Added Support for YUV42XMBN,
     // Required for Copybit CC acceleration
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index 301356ec9..5959d9cdb 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -4,6 +4,7 @@ include $(CLEAR_VARS)
 LOCAL_CLANG := true
 
 LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
+
 LOCAL_SRC_FILES := \
     Client.cpp \
     DisplayDevice.cpp \
@@ -20,7 +21,6 @@ LOCAL_SRC_FILES := \
     SurfaceFlingerConsumer.cpp \
     Transform.cpp \
     DisplayHardware/FramebufferSurface.cpp \
-    DisplayHardware/HWComposer.cpp \
     DisplayHardware/PowerHAL.cpp \
     DisplayHardware/VirtualDisplaySurface.cpp \
     Effects/Daltonizer.cpp \
@@ -37,6 +37,11 @@ LOCAL_SRC_FILES := \
     RenderEngine/GLES11RenderEngine.cpp \
     RenderEngine/GLES20RenderEngine.cpp \
     DisplayUtils.cpp
+ifneq (,$(findstring TARGET_NEEDS_HWC_V0,$(LOCAL_CFLAGS)))
+LOCAL_SRC_FILES += DisplayHardware/HWComposer.cpp
+else
+LOCAL_SRC_FILES += DisplayHardware/HWComposer_v0.cpp
+endif
 
 LOCAL_CFLAGS := -DLOG_TAG=\"SurfaceFlinger\"
 
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.h b/services/surfaceflinger/DisplayHardware/HWComposer.h
index efdcd03a3..ef7ac5ec2 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.h
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.h
@@ -32,6 +32,8 @@
 #include <utils/Timers.h>
 #include <utils/Vector.h>
 
+#define MAX_LAYER_COUNT 32
+
 extern "C" int clock_nanosleep(clockid_t clock_id, int flags,
                            const struct timespec *request,
                            struct timespec *remain);
@@ -74,7 +76,7 @@ public:
             const sp<SurfaceFlinger>& flinger,
             EventHandler& handler);
 
-    virtual ~HWComposer();
+    ~HWComposer();
 
     status_t initCheck() const;
 
@@ -120,13 +122,20 @@ public:
     // does this display have layers handled by GLES
     bool hasGlesComposition(int32_t id) const;
 
-    // does this display support dim layer composition
-    bool hasDimComposition() const { return (mDimComp == 1); }
+#ifdef QCOM_BSP
+    // does this display have layers handled by BLIT HW
+    bool hasBlitComposition(int32_t id) const;
 
+    //GPUTiledRect : function to find out if DR can be used in GPU Comp.
+    bool canUseTiledDR(int32_t id, Rect& dr);
+#endif
     // get the releaseFence file descriptor for a display's framebuffer layer.
     // the release fence is only valid after commit()
     sp<Fence> getAndResetReleaseFence(int32_t id);
 
+    // is VDS solution enabled
+    inline bool isVDSEnabled() const { return mVDSEnabled; };
+
     // needed forward declarations
     class LayerListIterator;
 
@@ -168,20 +177,29 @@ public:
         virtual sp<Fence> getAndResetReleaseFence() = 0;
         virtual void setDefaultState() = 0;
         virtual void setSkip(bool skip) = 0;
-        virtual void setDim() = 0;
+/*
+#ifndef TARGET_NEEDS_HWC_V0
         virtual void setIsCursorLayerHint(bool isCursor = true) = 0;
+        virtual void setAnimating(bool animating) = 0;
+#endif
+*/
         virtual void setBlending(uint32_t blending) = 0;
         virtual void setTransform(uint32_t transform) = 0;
         virtual void setFrame(const Rect& frame) = 0;
         virtual void setCrop(const FloatRect& crop) = 0;
         virtual void setVisibleRegionScreen(const Region& reg) = 0;
-        virtual void setSurfaceDamage(const Region& reg) = 0;
+/*
+#ifndef TARGET_NEEDS_HWC_V0
         virtual void setSidebandStream(const sp<NativeHandle>& stream) = 0;
+#endif
+#ifdef QCOM_BSP
+        virtual void setDirtyRect(const Rect& dirtyRect) = 0;
+#endif
+*/
         virtual void setBuffer(const sp<GraphicBuffer>& buffer) = 0;
         virtual void setAcquireFenceFd(int fenceFd) = 0;
         virtual void setPlaneAlpha(uint8_t alpha) = 0;
         virtual void onDisplayed() = 0;
-        virtual void setAnimating(bool animating)= 0;
     };
 
     /*
@@ -254,7 +272,8 @@ public:
     // Events handling ---------------------------------------------------------
 
     enum {
-        EVENT_VSYNC = HWC_EVENT_VSYNC
+        EVENT_VSYNC = HWC_EVENT_VSYNC,
+        EVENT_ORIENTATION = HWC_EVENT_ORIENTATION
     };
 
     void eventControl(int disp, int event, int enabled);
@@ -264,8 +283,10 @@ public:
         uint32_t height;
         float xdpi;
         float ydpi;
+#ifdef QCOM_BSP
+        bool secure;
+#endif
         nsecs_t refresh;
-        int colorTransform;
     };
 
     // Query display parameters.  Pass in a display index (e.g.
@@ -274,6 +295,9 @@ public:
     sp<Fence> getDisplayFence(int disp) const;
     uint32_t getFormat(int disp) const;
     bool isConnected(int disp) const;
+#ifdef QCOM_BSP
+    bool isSecure(int disp) const;
+#endif
 
     // These return the values for the current config of a given display index.
     // To get the values for all configs, use getConfigs below.
@@ -311,14 +335,6 @@ public:
     // for debugging ----------------------------------------------------------
     void dump(String8& out) const;
 
-    /* ------------------------------------------------------------------------
-     * Extensions
-     */
-    virtual inline bool isVDSEnabled() const { return true; };
-    virtual inline bool isCompositionTypeBlit(const int32_t /*compType*/) const {
-            return false;
-    };
-
 private:
     void loadHwcModule();
     int loadFbHalModule();
@@ -372,8 +388,6 @@ private:
     // mLists[i>0] can be NULL. that display is to be ignored
     struct hwc_display_contents_1*  mLists[MAX_HWC_DISPLAYS];
     DisplayData                     mDisplayData[MAX_HWC_DISPLAYS];
-    // protect mDisplayData from races between prepare and dump
-    mutable Mutex mDisplayLock;
     size_t                          mNumDisplays;
 
     cb_context*                     mCBContext;
@@ -382,9 +396,11 @@ private:
     sp<VSyncThread>                 mVSyncThread;
     bool                            mDebugForceFakeVSync;
     BitSet32                        mAllocatedDisplayIDs;
-
+    bool                            mVDSEnabled;
     // protected by mLock
     mutable Mutex mLock;
+    // synchronization between Draw call and Dumpsys call
+    mutable Mutex mDrawLock;
     mutable nsecs_t mLastHwVSync[HWC_NUM_PHYSICAL_DISPLAY_TYPES];
 
     // thread-safe
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 6a9cdb7a4..12f591ea7 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -563,10 +563,13 @@ void Layer::setPerFrameData(const sp<const DisplayDevice>& hw,
     const Transform& tr = hw->getTransform();
     Region visible = tr.transform(visibleRegion.intersect(hw->getViewport()));
     layer.setVisibleRegionScreen(visible);
+#ifndef TARGET_NEEDS_HWC_V0
     layer.setSurfaceDamage(surfaceDamageRegion);
-
+#endif
     if (mSidebandStream.get()) {
+#ifndef TARGET_NEEDS_HWC_V0
         layer.setSidebandStream(mSidebandStream);
+#endif
     } else {
         // NOTE: buffer can be NULL if the client never drew into this
         // layer yet, or if we ran out of memory
diff --git a/services/surfaceflinger/LayerDim.cpp b/services/surfaceflinger/LayerDim.cpp
index 5afd291e7..6e5f395fe 100644
--- a/services/surfaceflinger/LayerDim.cpp
+++ b/services/surfaceflinger/LayerDim.cpp
@@ -63,9 +63,11 @@ void LayerDim::setPerFrameData(const sp<const DisplayDevice>& hw,
   HWComposer& hwc = mFlinger->getHwComposer();
 
   Layer::setPerFrameData(hw, layer);
+#ifndef TARGET_NEEDS_HWC_V0
   if (hwc.hasDimComposition()) {
     layer.setDim();
   }
+#endif
 }
 
 // ---------------------------------------------------------------------------
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 1289cf0bc..40b67eafc 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -683,7 +683,9 @@ status_t SurfaceFlinger::getDisplayConfigs(const sp<IBinder>& display,
         }
         info.fps = float(1e9 / hwConfig.refresh);
         info.appVsyncOffset = VSYNC_EVENT_PHASE_OFFSET_NS;
+#ifndef TARGET_NEEDS_HWC_V0
         info.colorTransform = hwConfig.colorTransform;
+#endif
 
         // This is how far in advance a buffer must be queued for
         // presentation at a given time.  If you want a buffer to appear
@@ -1277,8 +1279,10 @@ void SurfaceFlinger::setUpHWComposer() {
                 for (size_t i=0 ; cur!=end && i<count ; ++i, ++cur) {
                     const sp<Layer>& layer(currentLayers[i]);
                     if (layer->isPotentialCursor()) {
+#ifndef TARGET_NEEDS_HWC_V0
                         cur->setIsCursorLayerHint();
                         break;
+#endif
                     }
                 }
             }
-- 
2.11.0

