From 8406df05d54c6493692b5faced663f6044c0e9c2 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sun, 16 Sep 2018 18:28:25 +0300
Subject: [PATCH 33/42] =?UTF-8?q?=C2=AF=5F(=E3=83=84)=5F/=C2=AF?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: I717d8f8d316ee73ec0af7f13e31f33984e023384
---
 libs/gui/Android.bp                                |    2 -
 libs/gui/tests/Android.bp                          |   83 -
 libs/gui/tests/AndroidTest.xml                     |   26 -
 libs/gui/tests/BufferItemConsumer_test.cpp         |  206 ---
 libs/gui/tests/BufferQueue_test.cpp                | 1195 --------------
 libs/gui/tests/CpuConsumer_test.cpp                |  811 ----------
 libs/gui/tests/DisconnectWaiter.h                  |   80 -
 libs/gui/tests/DummyConsumer.h                     |   27 -
 libs/gui/tests/FillBuffer.cpp                      |  108 --
 libs/gui/tests/FillBuffer.h                        |   43 -
 libs/gui/tests/FrameWaiter.h                       |   52 -
 libs/gui/tests/GLTest.cpp                          |  341 ----
 libs/gui/tests/GLTest.h                            |   72 -
 libs/gui/tests/IGraphicBufferProducer_test.cpp     |  805 ----------
 libs/gui/tests/Malicious.cpp                       |  207 ---
 libs/gui/tests/MultiTextureConsumer_test.cpp       |  126 --
 libs/gui/tests/StreamSplitter_test.cpp             |  239 ---
 libs/gui/tests/SurfaceParcelable_test.cpp          |  168 --
 libs/gui/tests/SurfaceTextureClient_test.cpp       |  811 ----------
 libs/gui/tests/SurfaceTextureFBO.h                 |   75 -
 libs/gui/tests/SurfaceTextureFBO_test.cpp          |   91 --
 libs/gui/tests/SurfaceTextureGL.h                  |   74 -
 libs/gui/tests/SurfaceTextureGLThreadToGL.h        |  183 ---
 libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp |  194 ---
 libs/gui/tests/SurfaceTextureGLToGL.h              |   67 -
 libs/gui/tests/SurfaceTextureGLToGL_test.cpp       |  526 ------
 libs/gui/tests/SurfaceTextureGL_test.cpp           |  737 ---------
 libs/gui/tests/SurfaceTextureMultiContextGL.h      |   85 -
 .../tests/SurfaceTextureMultiContextGL_test.cpp    |  461 ------
 libs/gui/tests/Surface_test.cpp                    | 1667 --------------------
 libs/gui/tests/TextureRenderer.cpp                 |  117 --
 libs/gui/tests/TextureRenderer.h                   |   46 -
 libs/ui/tests/Android.bp                           |   36 -
 libs/ui/tests/GraphicBuffer_test.cpp               |   64 -
 libs/ui/tests/Region_test.cpp                      |  156 --
 libs/ui/tests/colorspace_test.cpp                  |  183 ---
 36 files changed, 10164 deletions(-)
 delete mode 100644 libs/gui/tests/Android.bp
 delete mode 100644 libs/gui/tests/AndroidTest.xml
 delete mode 100644 libs/gui/tests/BufferItemConsumer_test.cpp
 delete mode 100644 libs/gui/tests/BufferQueue_test.cpp
 delete mode 100644 libs/gui/tests/CpuConsumer_test.cpp
 delete mode 100644 libs/gui/tests/DisconnectWaiter.h
 delete mode 100644 libs/gui/tests/DummyConsumer.h
 delete mode 100644 libs/gui/tests/FillBuffer.cpp
 delete mode 100644 libs/gui/tests/FillBuffer.h
 delete mode 100644 libs/gui/tests/FrameWaiter.h
 delete mode 100644 libs/gui/tests/GLTest.cpp
 delete mode 100644 libs/gui/tests/GLTest.h
 delete mode 100644 libs/gui/tests/IGraphicBufferProducer_test.cpp
 delete mode 100644 libs/gui/tests/Malicious.cpp
 delete mode 100644 libs/gui/tests/MultiTextureConsumer_test.cpp
 delete mode 100644 libs/gui/tests/StreamSplitter_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceParcelable_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureClient_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureFBO.h
 delete mode 100644 libs/gui/tests/SurfaceTextureFBO_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureGLThreadToGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureGLToGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureGLToGL_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureGL_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureMultiContextGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp
 delete mode 100644 libs/gui/tests/Surface_test.cpp
 delete mode 100644 libs/gui/tests/TextureRenderer.cpp
 delete mode 100644 libs/gui/tests/TextureRenderer.h
 delete mode 100644 libs/ui/tests/Android.bp
 delete mode 100644 libs/ui/tests/GraphicBuffer_test.cpp
 delete mode 100644 libs/ui/tests/Region_test.cpp
 delete mode 100644 libs/ui/tests/colorspace_test.cpp

diff --git a/libs/gui/Android.bp b/libs/gui/Android.bp
index c9b52e211..b64dee39b 100644
--- a/libs/gui/Android.bp
+++ b/libs/gui/Android.bp
@@ -184,5 +184,3 @@ cc_library_shared {
         "include",
     ],
 }
-
-subdirs = ["tests"]
diff --git a/libs/gui/tests/Android.bp b/libs/gui/tests/Android.bp
deleted file mode 100644
index 01e90e0eb..000000000
--- a/libs/gui/tests/Android.bp
+++ /dev/null
@@ -1,83 +0,0 @@
-// Build the unit tests,
-
-// Build the binary to $(TARGET_OUT_DATA_NATIVE_TESTS)/$(LOCAL_MODULE)
-// to integrate with auto-test framework.
-cc_test {
-    name: "libgui_test",
-    test_suites: ["device-tests"],
-
-    clang: true,
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    srcs: [
-        "BufferItemConsumer_test.cpp",
-        "BufferQueue_test.cpp",
-        "CpuConsumer_test.cpp",
-        "FillBuffer.cpp",
-        "GLTest.cpp",
-        "IGraphicBufferProducer_test.cpp",
-        "Malicious.cpp",
-        "MultiTextureConsumer_test.cpp",
-        "StreamSplitter_test.cpp",
-        "SurfaceTextureClient_test.cpp",
-        "SurfaceTextureFBO_test.cpp",
-        "SurfaceTextureGLThreadToGL_test.cpp",
-        "SurfaceTextureGLToGL_test.cpp",
-        "SurfaceTextureGL_test.cpp",
-        "SurfaceTextureMultiContextGL_test.cpp",
-        "Surface_test.cpp",
-        "TextureRenderer.cpp",
-    ],
-
-    shared_libs: [
-        "android.hardware.configstore@1.0",
-        "android.hardware.configstore-utils",
-        "liblog",
-        "libEGL",
-        "libGLESv1_CM",
-        "libGLESv2",
-        "libbinder",
-        "libcutils",
-        "libgui",
-        "libhidlbase",
-        "libhidltransport",
-        "libui",
-        "libutils",
-        "libnativewindow"
-    ],
-}
-
-// Build a separate binary for each source file to $(TARGET_OUT_DATA_NATIVE_TESTS)/$(LOCAL_MODULE)
-cc_test {
-    name: "libgui_separate_binary_test",
-    test_suites: ["device-tests"],
-
-    clang: true,
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    test_per_src: true,
-    srcs: [
-        "SurfaceParcelable_test.cpp",
-    ],
-
-    shared_libs: [
-        "liblog",
-        "libbinder",
-        "libcutils",
-        "libgui",
-        "libui",
-        "libutils",
-        "libbufferhubqueue",  // TODO(b/70046255): Remove these once BufferHub is integrated into libgui.
-        "libpdx_default_transport",
-    ],
-
-    header_libs: [
-        "libdvr_headers",
-    ],
-}
diff --git a/libs/gui/tests/AndroidTest.xml b/libs/gui/tests/AndroidTest.xml
deleted file mode 100644
index c02e020be..000000000
--- a/libs/gui/tests/AndroidTest.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2017 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Config for libgui_test">
-    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
-        <option name="cleanup" value="true" />
-        <option name="push" value="libgui_test->/data/local/tmp/libgui_test" />
-    </target_preparer>
-    <option name="test-suite-tag" value="apct" />
-    <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp" />
-        <option name="module-name" value="libgui_test" />
-    </test>
-</configuration>
\ No newline at end of file
diff --git a/libs/gui/tests/BufferItemConsumer_test.cpp b/libs/gui/tests/BufferItemConsumer_test.cpp
deleted file mode 100644
index b87cbbdec..000000000
--- a/libs/gui/tests/BufferItemConsumer_test.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "BufferItemConsumer_test"
-//#define LOG_NDEBUG 0
-
-#include <gtest/gtest.h>
-#include <gui/BufferItemConsumer.h>
-#include <gui/IProducerListener.h>
-#include <gui/Surface.h>
-
-namespace android {
-
-static constexpr int kWidth = 100;
-static constexpr int kHeight = 100;
-static constexpr int kMaxLockedBuffers = 3;
-static constexpr int kFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-static constexpr int kFrameSleepUs = 30 * 1000;
-
-class BufferItemConsumerTest : public ::testing::Test {
-   protected:
-    struct BufferFreedListener
-        : public BufferItemConsumer::BufferFreedListener {
-        explicit BufferFreedListener(BufferItemConsumerTest* test)
-            : mTest(test) {}
-        void onBufferFreed(const wp<GraphicBuffer>& /* gBuffer */) override {
-            mTest->HandleBufferFreed();
-        }
-        BufferItemConsumerTest* mTest;
-    };
-
-    void SetUp() override {
-        BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-        mBIC =
-            new BufferItemConsumer(mConsumer, kFormat, kMaxLockedBuffers, true);
-        String8 name("BufferItemConsumer_Under_Test");
-        mBIC->setName(name);
-        mBFL = new BufferFreedListener(this);
-        mBIC->setBufferFreedListener(mBFL);
-
-        sp<IProducerListener> producerListener = new DummyProducerListener();
-        IGraphicBufferProducer::QueueBufferOutput bufferOutput;
-        ASSERT_EQ(NO_ERROR,
-                  mProducer->connect(producerListener, NATIVE_WINDOW_API_CPU,
-                                     true, &bufferOutput));
-        ASSERT_EQ(NO_ERROR,
-                  mProducer->setMaxDequeuedBufferCount(kMaxLockedBuffers));
-    }
-
-    int GetFreedBufferCount() {
-        std::lock_guard<std::mutex> lock(mMutex);
-        return mFreedBufferCount;
-    }
-
-    void HandleBufferFreed() {
-        std::lock_guard<std::mutex> lock(mMutex);
-        mFreedBufferCount++;
-        ALOGV("HandleBufferFreed, mFreedBufferCount=%d", mFreedBufferCount);
-    }
-
-    void DequeueBuffer(int* outSlot) {
-        ASSERT_NE(outSlot, nullptr);
-
-        int slot;
-        sp<Fence> outFence;
-        status_t ret = mProducer->dequeueBuffer(&slot, &outFence, kWidth, kHeight, 0, 0,
-                                                nullptr, nullptr);
-        ASSERT_GE(ret, 0);
-
-        ALOGV("dequeueBuffer: slot=%d", slot);
-        if (ret & IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) {
-            ret = mProducer->requestBuffer(slot, &mBuffers[slot]);
-            ASSERT_EQ(NO_ERROR, ret);
-        }
-        *outSlot = slot;
-    }
-
-    void QueueBuffer(int slot) {
-        ALOGV("enqueueBuffer: slot=%d", slot);
-        IGraphicBufferProducer::QueueBufferInput bufferInput(
-            0ULL, true, HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-        IGraphicBufferProducer::QueueBufferOutput bufferOutput;
-        status_t ret = mProducer->queueBuffer(slot, bufferInput, &bufferOutput);
-        ASSERT_EQ(NO_ERROR, ret);
-    }
-
-    void AcquireBuffer(int* outSlot) {
-        ASSERT_NE(outSlot, nullptr);
-        BufferItem buffer;
-        status_t ret = mBIC->acquireBuffer(&buffer, 0, false);
-        ASSERT_EQ(NO_ERROR, ret);
-
-        ALOGV("acquireBuffer: slot=%d", buffer.mSlot);
-        *outSlot = buffer.mSlot;
-    }
-
-    void ReleaseBuffer(int slot) {
-        ALOGV("releaseBuffer: slot=%d", slot);
-        BufferItem buffer;
-        buffer.mSlot = slot;
-        buffer.mGraphicBuffer = mBuffers[slot];
-        status_t ret = mBIC->releaseBuffer(buffer, Fence::NO_FENCE);
-        ASSERT_EQ(NO_ERROR, ret);
-    }
-
-
-    std::mutex mMutex;
-    int mFreedBufferCount{0};
-
-    sp<BufferItemConsumer> mBIC;
-    sp<BufferFreedListener> mBFL;
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-    sp<GraphicBuffer> mBuffers[BufferQueueDefs::NUM_BUFFER_SLOTS];
-};
-
-// Test that detaching buffer from consumer side triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_DetachBufferFromConsumer) {
-    int slot;
-    // Producer: generate a dummy buffer.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-
-    ASSERT_EQ(0, GetFreedBufferCount());
-    // Consumer: acquire the buffer and then detach it.
-    AcquireBuffer(&slot);
-    status_t ret = mBIC->detachBuffer(slot);
-    ASSERT_EQ(NO_ERROR, ret);
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-// Test that detaching buffer from producer side triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_DetachBufferFromProducer) {
-    int slot;
-    // Let buffer go through the cycle at least once.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-    AcquireBuffer(&slot);
-    ReleaseBuffer(slot);
-
-    ASSERT_EQ(0, GetFreedBufferCount());
-
-    // Producer: generate the buffer again.
-    DequeueBuffer(&slot);
-
-    // Producer: detach the buffer.
-    status_t ret = mProducer->detachBuffer(slot);
-    ASSERT_EQ(NO_ERROR, ret);
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-// Test that abandoning BufferItemConsumer triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_AbandonBufferItemConsumer) {
-    int slot;
-    // Let buffer go through the cycle at least once.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-    AcquireBuffer(&slot);
-    ReleaseBuffer(slot);
-
-    // Abandon the BufferItemConsumer.
-    mBIC->abandon();
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-// Test that delete BufferItemConsumer triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_DeleteBufferItemConsumer) {
-    int slot;
-    // Let buffer go through the cycle at least once.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-    AcquireBuffer(&slot);
-    ReleaseBuffer(slot);
-
-    // Delete the BufferItemConsumer.
-    mBIC.clear();
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-}  // namespace android
diff --git a/libs/gui/tests/BufferQueue_test.cpp b/libs/gui/tests/BufferQueue_test.cpp
deleted file mode 100644
index 9a208593a..000000000
--- a/libs/gui/tests/BufferQueue_test.cpp
+++ /dev/null
@@ -1,1195 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "BufferQueue_test"
-//#define LOG_NDEBUG 0
-
-#include "DummyConsumer.h"
-
-#include <gui/BufferItem.h>
-#include <gui/BufferQueue.h>
-#include <gui/IProducerListener.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
-#include <binder/ProcessState.h>
-
-#include <utils/String8.h>
-#include <utils/threads.h>
-
-#include <system/window.h>
-
-#include <gtest/gtest.h>
-
-#include <thread>
-
-using namespace std::chrono_literals;
-
-namespace android {
-
-class BufferQueueTest : public ::testing::Test {
-
-public:
-protected:
-    BufferQueueTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    ~BufferQueueTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    void GetMinUndequeuedBufferCount(int* bufferCount) {
-        ASSERT_TRUE(bufferCount != NULL);
-        ASSERT_EQ(OK, mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-                    bufferCount));
-        ASSERT_GE(*bufferCount, 0);
-    }
-
-    void createBufferQueue() {
-        BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-    }
-
-    void testBufferItem(const IGraphicBufferProducer::QueueBufferInput& input,
-            const BufferItem& item) {
-        int64_t timestamp;
-        bool isAutoTimestamp;
-        android_dataspace dataSpace;
-        Rect crop;
-        int scalingMode;
-        uint32_t transform;
-        sp<Fence> fence;
-
-        input.deflate(&timestamp, &isAutoTimestamp, &dataSpace, &crop,
-                &scalingMode, &transform, &fence, NULL);
-        ASSERT_EQ(timestamp, item.mTimestamp);
-        ASSERT_EQ(isAutoTimestamp, item.mIsAutoTimestamp);
-        ASSERT_EQ(dataSpace, item.mDataSpace);
-        ASSERT_EQ(crop, item.mCrop);
-        ASSERT_EQ(static_cast<uint32_t>(scalingMode), item.mScalingMode);
-        ASSERT_EQ(transform, item.mTransform);
-        ASSERT_EQ(fence, item.mFence);
-    }
-
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-};
-
-static const uint32_t TEST_DATA = 0x12345678u;
-
-// XXX: Tests that fork a process to hold the BufferQueue must run before tests
-// that use a local BufferQueue, or else Binder will get unhappy
-//
-// In one instance this was a crash in the createBufferQueue where the
-// binder call to create a buffer allocator apparently got garbage back.
-// See b/36592665.
-TEST_F(BufferQueueTest, DISABLED_BufferQueueInAnotherProcess) {
-    const String16 PRODUCER_NAME = String16("BQTestProducer");
-    const String16 CONSUMER_NAME = String16("BQTestConsumer");
-
-    pid_t forkPid = fork();
-    ASSERT_NE(forkPid, -1);
-
-    if (forkPid == 0) {
-        // Child process
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        sp<IServiceManager> serviceManager = defaultServiceManager();
-        serviceManager->addService(PRODUCER_NAME, IInterface::asBinder(producer));
-        serviceManager->addService(CONSUMER_NAME, IInterface::asBinder(consumer));
-        ProcessState::self()->startThreadPool();
-        IPCThreadState::self()->joinThreadPool();
-        LOG_ALWAYS_FATAL("Shouldn't be here");
-    }
-
-    sp<IServiceManager> serviceManager = defaultServiceManager();
-    sp<IBinder> binderProducer =
-        serviceManager->getService(PRODUCER_NAME);
-    mProducer = interface_cast<IGraphicBufferProducer>(binderProducer);
-    EXPECT_TRUE(mProducer != NULL);
-    sp<IBinder> binderConsumer =
-        serviceManager->getService(CONSUMER_NAME);
-    mConsumer = interface_cast<IGraphicBufferConsumer>(binderConsumer);
-    EXPECT_TRUE(mConsumer != NULL);
-
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK,
-            mProducer->connect(NULL, NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-}
-
-TEST_F(BufferQueueTest, AcquireBuffer_ExceedsMaxAcquireCount_Fails) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-    IGraphicBufferProducer::QueueBufferOutput qbo;
-    mProducer->connect(new DummyProducerListener, NATIVE_WINDOW_API_CPU, false,
-            &qbo);
-    mProducer->setMaxDequeuedBufferCount(3);
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buf;
-    IGraphicBufferProducer::QueueBufferInput qbi(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item;
-
-    for (int i = 0; i < 2; i++) {
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                           nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    }
-
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-
-    // Acquire the third buffer, which should fail.
-    ASSERT_EQ(INVALID_OPERATION, mConsumer->acquireBuffer(&item, 0));
-}
-
-TEST_F(BufferQueueTest, SetMaxAcquiredBufferCountWithIllegalValues_ReturnsError) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    EXPECT_EQ(OK, mConsumer->setMaxBufferCount(10));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(10));
-
-    IGraphicBufferProducer::QueueBufferOutput qbo;
-    mProducer->connect(new DummyProducerListener, NATIVE_WINDOW_API_CPU, false,
-            &qbo);
-    mProducer->setMaxDequeuedBufferCount(3);
-
-    int minBufferCount;
-    ASSERT_NO_FATAL_FAILURE(GetMinUndequeuedBufferCount(&minBufferCount));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(
-                minBufferCount - 1));
-
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(0));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(-3));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(
-            BufferQueue::MAX_MAX_ACQUIRED_BUFFERS+1));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(100));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buf;
-    IGraphicBufferProducer::QueueBufferInput qbi(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item;
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(3));
-    for (int i = 0; i < 3; i++) {
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                           nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    }
-
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(2));
-}
-
-TEST_F(BufferQueueTest, SetMaxAcquiredBufferCountWithLegalValues_Succeeds) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    IGraphicBufferProducer::QueueBufferOutput qbo;
-    mProducer->connect(new DummyProducerListener, NATIVE_WINDOW_API_CPU, false,
-            &qbo);
-    mProducer->setMaxDequeuedBufferCount(2);
-
-    int minBufferCount;
-    ASSERT_NO_FATAL_FAILURE(GetMinUndequeuedBufferCount(&minBufferCount));
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(1));
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(2));
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(minBufferCount));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buf;
-    IGraphicBufferProducer::QueueBufferInput qbi(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item;
-
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(3));
-
-    for (int i = 0; i < 2; i++) {
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                           nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    }
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(
-            BufferQueue::MAX_MAX_ACQUIRED_BUFFERS));
-}
-
-TEST_F(BufferQueueTest, SetMaxBufferCountWithLegalValues_Succeeds) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    // Test shared buffer mode
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(1));
-}
-
-TEST_F(BufferQueueTest, SetMaxBufferCountWithIllegalValues_ReturnsError) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxBufferCount(0));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxBufferCount(
-            BufferQueue::NUM_BUFFER_SLOTS + 1));
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(5));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxBufferCount(3));
-}
-
-TEST_F(BufferQueueTest, DetachAndReattachOnProducerSide) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(-1)); // Index too low
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(
-                BufferQueueDefs::NUM_BUFFER_SLOTS)); // Index too high
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(0)); // Not dequeued
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(slot)); // Not requested
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    ASSERT_EQ(OK, mProducer->detachBuffer(slot));
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(slot)); // Not dequeued
-
-    sp<GraphicBuffer> safeToClobberBuffer;
-    // Can no longer request buffer from this slot
-    ASSERT_EQ(BAD_VALUE, mProducer->requestBuffer(slot, &safeToClobberBuffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    int newSlot;
-    ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(NULL, safeToClobberBuffer));
-    ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(&newSlot, NULL));
-
-    ASSERT_EQ(OK, mProducer->attachBuffer(&newSlot, buffer));
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(newSlot, input, &output));
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-}
-
-TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(-1)); // Index too low
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(
-            BufferQueueDefs::NUM_BUFFER_SLOTS)); // Index too high
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(0)); // Not acquired
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-
-    ASSERT_EQ(OK, mConsumer->detachBuffer(item.mSlot));
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(item.mSlot)); // Not acquired
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(
-            GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-
-    int newSlot;
-    sp<GraphicBuffer> safeToClobberBuffer;
-    ASSERT_EQ(BAD_VALUE, mConsumer->attachBuffer(NULL, safeToClobberBuffer));
-    ASSERT_EQ(BAD_VALUE, mConsumer->attachBuffer(&newSlot, NULL));
-    ASSERT_EQ(OK, mConsumer->attachBuffer(&newSlot, item.mGraphicBuffer));
-
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(newSlot, 0, EGL_NO_DISPLAY,
-            EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, buffer->unlock());
-}
-
-TEST_F(BufferQueueTest, MoveFromConsumerToProducer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-    ASSERT_EQ(OK, mConsumer->detachBuffer(item.mSlot));
-
-    int newSlot;
-    ASSERT_EQ(OK, mProducer->attachBuffer(&newSlot, item.mGraphicBuffer));
-    ASSERT_EQ(OK, mProducer->queueBuffer(newSlot, input, &output));
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-}
-
-TEST_F(BufferQueueTest, TestDisallowingAllocation) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    static const uint32_t WIDTH = 320;
-    static const uint32_t HEIGHT = 240;
-
-    ASSERT_EQ(OK, mConsumer->setDefaultBufferSize(WIDTH, HEIGHT));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    // This should return an error since it would require an allocation
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-    ASSERT_EQ(WOULD_BLOCK,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-
-    // This should succeed, now that we've lifted the prohibition
-    ASSERT_EQ(OK, mProducer->allowAllocation(true));
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-
-    // Release the previous buffer back to the BufferQueue
-    mProducer->cancelBuffer(slot, fence);
-
-    // This should fail since we're requesting a different size
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-    ASSERT_EQ(WOULD_BLOCK,
-              mProducer->dequeueBuffer(&slot, &fence, WIDTH * 2, HEIGHT * 2, 0,
-                                       GRALLOC_USAGE_SW_WRITE_OFTEN, nullptr, nullptr));
-}
-
-TEST_F(BufferQueueTest, TestGenerationNumbers) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    ASSERT_EQ(OK, mProducer->setGenerationNumber(1));
-
-    // Get one buffer to play with
-    int slot;
-    sp<Fence> fence;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    // Ensure that the generation number we set propagates to allocated buffers
-    ASSERT_EQ(1U, buffer->getGenerationNumber());
-
-    ASSERT_EQ(OK, mProducer->detachBuffer(slot));
-
-    ASSERT_EQ(OK, mProducer->setGenerationNumber(2));
-
-    // These should fail, since we've changed the generation number on the queue
-    int outSlot;
-    ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(&outSlot, buffer));
-    ASSERT_EQ(BAD_VALUE, mConsumer->attachBuffer(&outSlot, buffer));
-
-    buffer->setGenerationNumber(2);
-
-    // This should succeed now that we've changed the buffer's generation number
-    ASSERT_EQ(OK, mProducer->attachBuffer(&outSlot, buffer));
-
-    ASSERT_EQ(OK, mProducer->detachBuffer(outSlot));
-
-    // This should also succeed with the new generation number
-    ASSERT_EQ(OK, mConsumer->attachBuffer(&outSlot, buffer));
-}
-
-TEST_F(BufferQueueTest, TestSharedBufferModeWithoutAutoRefresh) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    ASSERT_EQ(OK, mProducer->setSharedBufferMode(true));
-
-    // Get a buffer
-    int sharedSlot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&sharedSlot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(sharedSlot, &buffer));
-
-    // Queue the buffer
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-
-    // Repeatedly queue and dequeue a buffer from the producer side, it should
-    // always return the same one. And we won't run out of buffers because it's
-    // always the same one and because async mode gets enabled.
-    int slot;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(sharedSlot, slot);
-        ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-    }
-
-    // acquire the buffer
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(sharedSlot, item.mSlot);
-    testBufferItem(input, item);
-    ASSERT_EQ(true, item.mQueuedBuffer);
-    ASSERT_EQ(false, item.mAutoRefresh);
-
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // attempt to acquire a second time should return no buffer available
-    ASSERT_EQ(IGraphicBufferConsumer::NO_BUFFER_AVAILABLE,
-            mConsumer->acquireBuffer(&item, 0));
-}
-
-TEST_F(BufferQueueTest, TestSharedBufferModeWithAutoRefresh) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    ASSERT_EQ(OK, mProducer->setSharedBufferMode(true));
-    ASSERT_EQ(OK, mProducer->setAutoRefresh(true));
-
-    // Get a buffer
-    int sharedSlot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&sharedSlot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(sharedSlot, &buffer));
-
-    // Queue the buffer
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-
-    // Repeatedly acquire and release a buffer from the consumer side, it should
-    // always return the same one.
-    BufferItem item;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(sharedSlot, item.mSlot);
-        testBufferItem(input, item);
-        ASSERT_EQ(i == 0, item.mQueuedBuffer);
-        ASSERT_EQ(true, item.mAutoRefresh);
-
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    }
-
-    // Repeatedly queue and dequeue a buffer from the producer side, it should
-    // always return the same one.
-    int slot;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(sharedSlot, slot);
-        ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-    }
-
-    // Repeatedly acquire and release a buffer from the consumer side, it should
-    // always return the same one. First grabbing them from the queue and then
-    // when the queue is empty, returning the shared buffer.
-    for (int i = 0; i < 10; i++) {
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(sharedSlot, item.mSlot);
-        ASSERT_EQ(0, item.mTimestamp);
-        ASSERT_EQ(false, item.mIsAutoTimestamp);
-        ASSERT_EQ(HAL_DATASPACE_UNKNOWN, item.mDataSpace);
-        ASSERT_EQ(Rect(0, 0, 1, 1), item.mCrop);
-        ASSERT_EQ(NATIVE_WINDOW_SCALING_MODE_FREEZE, item.mScalingMode);
-        ASSERT_EQ(0u, item.mTransform);
-        ASSERT_EQ(Fence::NO_FENCE, item.mFence);
-        ASSERT_EQ(i == 0, item.mQueuedBuffer);
-        ASSERT_EQ(true, item.mAutoRefresh);
-
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    }
-}
-
-TEST_F(BufferQueueTest, TestSharedBufferModeUsingAlreadyDequeuedBuffer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    // Dequeue a buffer
-    int sharedSlot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&sharedSlot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(sharedSlot, &buffer));
-
-    // Enable shared buffer mode
-    ASSERT_EQ(OK, mProducer->setSharedBufferMode(true));
-
-    // Queue the buffer
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-
-    // Repeatedly queue and dequeue a buffer from the producer side, it should
-    // always return the same one. And we won't run out of buffers because it's
-    // always the same one and because async mode gets enabled.
-    int slot;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(sharedSlot, slot);
-        ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-    }
-
-    // acquire the buffer
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(sharedSlot, item.mSlot);
-    testBufferItem(input, item);
-    ASSERT_EQ(true, item.mQueuedBuffer);
-    ASSERT_EQ(false, item.mAutoRefresh);
-
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // attempt to acquire a second time should return no buffer available
-    ASSERT_EQ(IGraphicBufferConsumer::NO_BUFFER_AVAILABLE,
-            mConsumer->acquireBuffer(&item, 0));
-}
-
-TEST_F(BufferQueueTest, TestTimeouts) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    // Fill up the queue. Since the controlledByApp flags are set to true, this
-    // queue should be in non-blocking mode, and we should be recycling the same
-    // two buffers
-    for (int i = 0; i < 5; ++i) {
-        int slot = BufferQueue::INVALID_BUFFER_SLOT;
-        sp<Fence> fence = Fence::NO_FENCE;
-        auto result = mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr);
-        if (i < 2) {
-            ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                    result);
-        } else {
-            ASSERT_EQ(OK, result);
-        }
-        sp<GraphicBuffer> buffer;
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-        IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-                HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-                NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-        IGraphicBufferProducer::QueueBufferOutput output{};
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    }
-
-    const auto TIMEOUT = ms2ns(250);
-    mProducer->setDequeueTimeout(TIMEOUT);
-
-    // Setting a timeout will change the BufferQueue into blocking mode (with
-    // one droppable buffer in the queue and one free from the previous
-    // dequeue/queues), so dequeue and queue two more buffers: one to replace
-    // the current droppable buffer, and a second to max out the buffer count
-    sp<GraphicBuffer> buffer; // Save a buffer to attach later
-    for (int i = 0; i < 2; ++i) {
-        int slot = BufferQueue::INVALID_BUFFER_SLOT;
-        sp<Fence> fence = Fence::NO_FENCE;
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-        IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-                HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-                NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    }
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    auto startTime = systemTime();
-    ASSERT_EQ(TIMED_OUT, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_GE(systemTime() - startTime, TIMEOUT);
-
-    // We're technically attaching the same buffer multiple times (since we
-    // queued it previously), but that doesn't matter for this test
-    startTime = systemTime();
-    ASSERT_EQ(TIMED_OUT, mProducer->attachBuffer(&slot, buffer));
-    ASSERT_GE(systemTime() - startTime, TIMEOUT);
-}
-
-TEST_F(BufferQueueTest, CanAttachWhileDisallowingAllocation) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> sourceFence;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &sourceFence, 0, 0, 0, 0, nullptr, nullptr));
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    ASSERT_EQ(OK, mProducer->detachBuffer(slot));
-
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-
-    slot = BufferQueue::INVALID_BUFFER_SLOT;
-    ASSERT_EQ(OK, mProducer->attachBuffer(&slot, buffer));
-}
-
-TEST_F(BufferQueueTest, CanRetrieveLastQueuedBuffer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    // Dequeue and queue the first buffer, storing the handle
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    sp<GraphicBuffer> firstBuffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &firstBuffer));
-
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Dequeue a second buffer
-    slot = BufferQueue::INVALID_BUFFER_SLOT;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    sp<GraphicBuffer> secondBuffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &secondBuffer));
-
-    // Ensure it's a new buffer
-    ASSERT_NE(firstBuffer->getNativeBuffer()->handle,
-            secondBuffer->getNativeBuffer()->handle);
-
-    // Queue the second buffer
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Acquire and release both buffers
-    for (size_t i = 0; i < 2; ++i) {
-        BufferItem item;
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    }
-
-    // Make sure we got the second buffer back
-    sp<GraphicBuffer> returnedBuffer;
-    sp<Fence> returnedFence;
-    float transform[16];
-    ASSERT_EQ(OK,
-            mProducer->getLastQueuedBuffer(&returnedBuffer, &returnedFence,
-            transform));
-    ASSERT_EQ(secondBuffer->getNativeBuffer()->handle,
-            returnedBuffer->getNativeBuffer()->handle);
-}
-
-TEST_F(BufferQueueTest, TestOccupancyHistory) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item{};
-
-    // Preallocate, dequeue, request, and cancel 3 buffers so we don't get
-    // BUFFER_NEEDS_REALLOCATION below
-    int slots[3] = {};
-    mProducer->setMaxDequeuedBufferCount(3);
-    for (size_t i = 0; i < 3; ++i) {
-        status_t result =
-                mProducer->dequeueBuffer(&slots[i], &fence, 0, 0, 0, 0, nullptr, nullptr);
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-        ASSERT_EQ(OK, mProducer->requestBuffer(slots[i], &buffer));
-    }
-    for (size_t i = 0; i < 3; ++i) {
-        ASSERT_EQ(OK, mProducer->cancelBuffer(slots[i], Fence::NO_FENCE));
-    }
-
-    // Create 3 segments
-
-    // The first segment is a two-buffer segment, so we only put one buffer into
-    // the queue at a time
-    for (size_t i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-        std::this_thread::sleep_for(16ms);
-    }
-
-    // Sleep between segments
-    std::this_thread::sleep_for(500ms);
-
-    // The second segment is a double-buffer segment. It starts the same as the
-    // two-buffer segment, but then at the end, we put two buffers in the queue
-    // at the same time before draining it.
-    for (size_t i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-        std::this_thread::sleep_for(16ms);
-    }
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    std::this_thread::sleep_for(16ms);
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Sleep between segments
-    std::this_thread::sleep_for(500ms);
-
-    // The third segment is a triple-buffer segment, so the queue is switching
-    // between one buffer and two buffers deep.
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    for (size_t i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-        std::this_thread::sleep_for(16ms);
-    }
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Now we read the segments
-    std::vector<OccupancyTracker::Segment> history;
-    ASSERT_EQ(OK, mConsumer->getOccupancyHistory(false, &history));
-
-    // Since we didn't force a flush, we should only get the first two segments
-    // (since the third segment hasn't been closed out by the appearance of a
-    // new segment yet)
-    ASSERT_EQ(2u, history.size());
-
-    // The first segment (which will be history[1], since the newest segment
-    // should be at the front of the vector) should be a two-buffer segment,
-    // which implies that the occupancy average should be between 0 and 1, and
-    // usedThirdBuffer should be false
-    const auto& firstSegment = history[1];
-    ASSERT_EQ(5u, firstSegment.numFrames);
-    ASSERT_LT(0, firstSegment.occupancyAverage);
-    ASSERT_GT(1, firstSegment.occupancyAverage);
-    ASSERT_EQ(false, firstSegment.usedThirdBuffer);
-
-    // The second segment should be a double-buffered segment, which implies that
-    // the occupancy average should be between 0 and 1, but usedThirdBuffer
-    // should be true
-    const auto& secondSegment = history[0];
-    ASSERT_EQ(7u, secondSegment.numFrames);
-    ASSERT_LT(0, secondSegment.occupancyAverage);
-    ASSERT_GT(1, secondSegment.occupancyAverage);
-    ASSERT_EQ(true, secondSegment.usedThirdBuffer);
-
-    // If we read the segments again without flushing, we shouldn't get any new
-    // segments
-    ASSERT_EQ(OK, mConsumer->getOccupancyHistory(false, &history));
-    ASSERT_EQ(0u, history.size());
-
-    // Read the segments again, this time forcing a flush so we get the third
-    // segment
-    ASSERT_EQ(OK, mConsumer->getOccupancyHistory(true, &history));
-    ASSERT_EQ(1u, history.size());
-
-    // This segment should be a triple-buffered segment, which implies that the
-    // occupancy average should be between 1 and 2, and usedThirdBuffer should
-    // be true
-    const auto& thirdSegment = history[0];
-    ASSERT_EQ(6u, thirdSegment.numFrames);
-    ASSERT_LT(1, thirdSegment.occupancyAverage);
-    ASSERT_GT(2, thirdSegment.occupancyAverage);
-    ASSERT_EQ(true, thirdSegment.usedThirdBuffer);
-}
-
-TEST_F(BufferQueueTest, TestDiscardFreeBuffers) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item{};
-
-    // Preallocate, dequeue, request, and cancel 4 buffers so we don't get
-    // BUFFER_NEEDS_REALLOCATION below
-    int slots[4] = {};
-    mProducer->setMaxDequeuedBufferCount(4);
-    for (size_t i = 0; i < 4; ++i) {
-        status_t result =
-                mProducer->dequeueBuffer(&slots[i], &fence, 0, 0, 0, 0, nullptr, nullptr);
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-        ASSERT_EQ(OK, mProducer->requestBuffer(slots[i], &buffer));
-    }
-    for (size_t i = 0; i < 4; ++i) {
-        ASSERT_EQ(OK, mProducer->cancelBuffer(slots[i], Fence::NO_FENCE));
-    }
-
-    // Get buffers in all states: dequeued, filled, acquired, free
-
-    // Fill 3 buffers
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    // Dequeue 1 buffer
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-
-    // Acquire and free 1 buffer
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    // Acquire 1 buffer, leaving 1 filled buffer in queue
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-
-    // Now discard the free buffers
-    ASSERT_EQ(OK, mConsumer->discardFreeBuffers());
-
-    // Check no free buffers in dump
-    String8 dumpString;
-    mConsumer->dumpState(String8{}, &dumpString);
-
-    // Parse the dump to ensure that all buffer slots that are FREE also
-    // have a null GraphicBuffer
-    // Fragile - assumes the following format for the dump for a buffer entry:
-    // ":%p\][^:]*state=FREE" where %p is the buffer pointer in hex.
-    ssize_t idx = dumpString.find("state=FREE");
-    while (idx != -1) {
-        ssize_t bufferPtrIdx = idx - 1;
-        while (bufferPtrIdx > 0) {
-            if (dumpString[bufferPtrIdx] == ':') {
-                bufferPtrIdx++;
-                break;
-            }
-            bufferPtrIdx--;
-        }
-        ASSERT_GT(bufferPtrIdx, 0) << "Can't parse queue dump to validate";
-        ssize_t nullPtrIdx = dumpString.find("0x0]", bufferPtrIdx);
-        ASSERT_EQ(bufferPtrIdx, nullPtrIdx) << "Free buffer not discarded";
-        idx = dumpString.find("FREE", idx + 1);
-    }
-}
-
-TEST_F(BufferQueueTest, TestBufferReplacedInQueueBuffer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-    ASSERT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(1));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item{};
-
-    // Preallocate, dequeue, request, and cancel 2 buffers so we don't get
-    // BUFFER_NEEDS_REALLOCATION below
-    int slots[2] = {};
-    ASSERT_EQ(OK, mProducer->setMaxDequeuedBufferCount(2));
-    for (size_t i = 0; i < 2; ++i) {
-        status_t result =
-                mProducer->dequeueBuffer(&slots[i], &fence, 0, 0, 0, 0, nullptr, nullptr);
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-        ASSERT_EQ(OK, mProducer->requestBuffer(slots[i], &buffer));
-    }
-    for (size_t i = 0; i < 2; ++i) {
-        ASSERT_EQ(OK, mProducer->cancelBuffer(slots[i], Fence::NO_FENCE));
-    }
-
-    // Fill 2 buffers without consumer consuming them. Verify that all
-    // queued buffer returns proper bufferReplaced flag
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(false, output.bufferReplaced);
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(true, output.bufferReplaced);
-}
-
-TEST_F(BufferQueueTest, TestStaleBufferHandleSentAfterDisconnect) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<IProducerListener> dummyListener(new DummyProducerListener);
-    ASSERT_EQ(OK, mProducer->connect(dummyListener, NATIVE_WINDOW_API_CPU,
-            true, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-            HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-
-    // Dequeue, request, and queue one buffer
-    status_t result = mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr);
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Acquire and release the buffer. Upon acquiring, the buffer handle should
-    // be non-null since this is the first time we've acquired this slot.
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(slot, item.mSlot);
-    ASSERT_NE(nullptr, item.mGraphicBuffer.get());
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Dequeue and queue the buffer again
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Acquire and release the buffer again. Upon acquiring, the buffer handle
-    // should be null since this is not the first time we've acquired this slot.
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(slot, item.mSlot);
-    ASSERT_EQ(nullptr, item.mGraphicBuffer.get());
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Dequeue and queue the buffer again
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Disconnect the producer end. This should clear all of the slots and mark
-    // the buffer in the queue as stale.
-    ASSERT_EQ(OK, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-
-    // Acquire the buffer again. Upon acquiring, the buffer handle should not be
-    // null since the queued buffer should have been marked as stale, which
-    // should trigger the BufferQueue to resend the buffer handle.
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(slot, item.mSlot);
-    ASSERT_NE(nullptr, item.mGraphicBuffer.get());
-}
-
-TEST_F(BufferQueueTest, TestProducerConnectDisconnect) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<IProducerListener> dummyListener(new DummyProducerListener);
-    ASSERT_EQ(NO_INIT, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, mProducer->connect(
-            dummyListener, NATIVE_WINDOW_API_CPU, true, &output));
-    ASSERT_EQ(BAD_VALUE, mProducer->connect(
-            dummyListener, NATIVE_WINDOW_API_MEDIA, true, &output));
-
-    ASSERT_EQ(BAD_VALUE, mProducer->disconnect(NATIVE_WINDOW_API_MEDIA));
-    ASSERT_EQ(OK, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_INIT, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/CpuConsumer_test.cpp b/libs/gui/tests/CpuConsumer_test.cpp
deleted file mode 100644
index 36be7d936..000000000
--- a/libs/gui/tests/CpuConsumer_test.cpp
+++ /dev/null
@@ -1,811 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "CpuConsumer_test"
-//#define LOG_NDEBUG 0
-//#define LOG_NNDEBUG 0
-
-#ifdef LOG_NNDEBUG
-#define ALOGVV(...) ALOGV(__VA_ARGS__)
-#else
-#define ALOGVV(...) ((void)0)
-#endif
-
-#include <gtest/gtest.h>
-#include <gui/CpuConsumer.h>
-#include <gui/Surface.h>
-#include <ui/GraphicBuffer.h>
-#include <utils/String8.h>
-#include <utils/Thread.h>
-#include <utils/Mutex.h>
-#include <utils/Condition.h>
-
-#include <thread>
-#include <vector>
-#define CPU_CONSUMER_TEST_FORMAT_RAW 0
-#define CPU_CONSUMER_TEST_FORMAT_Y8 0
-#define CPU_CONSUMER_TEST_FORMAT_Y16 0
-#define CPU_CONSUMER_TEST_FORMAT_RGBA_8888 1
-
-namespace android {
-
-struct CpuConsumerTestParams {
-    uint32_t width;
-    uint32_t height;
-    int maxLockedBuffers;
-    PixelFormat format;
-};
-
-::std::ostream& operator<<(::std::ostream& os, const CpuConsumerTestParams& p) {
-    return os << "[ (" << p.width << ", " << p.height << "), B:"
-              << p.maxLockedBuffers << ", F:0x"
-              << ::std::hex << p.format << "]";
-}
-
-class CpuConsumerTest : public ::testing::TestWithParam<CpuConsumerTestParams> {
-protected:
-
-    virtual void SetUp() {
-        const ::testing::TestInfo* const test_info =
-                ::testing::UnitTest::GetInstance()->current_test_info();
-        CpuConsumerTestParams params = GetParam();
-        ALOGV("** Starting test %s (%d x %d, %d, 0x%x)",
-                test_info->name(),
-                params.width, params.height,
-                params.maxLockedBuffers, params.format);
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        mCC = new CpuConsumer(consumer, params.maxLockedBuffers);
-        String8 name("CpuConsumer_Under_Test");
-        mCC->setName(name);
-        mSTC = new Surface(producer);
-        mANW = mSTC;
-    }
-
-    virtual void TearDown() {
-        mANW.clear();
-        mSTC.clear();
-        mCC.clear();
-    }
-
-    class FrameWaiter : public CpuConsumer::FrameAvailableListener {
-    public:
-        FrameWaiter():
-                mPendingFrames(0) {
-        }
-
-        void waitForFrame() {
-            Mutex::Autolock lock(mMutex);
-            while (mPendingFrames == 0) {
-                mCondition.wait(mMutex);
-            }
-            mPendingFrames--;
-        }
-
-        virtual void onFrameAvailable(const BufferItem&) {
-            Mutex::Autolock lock(mMutex);
-            mPendingFrames++;
-            mCondition.signal();
-        }
-
-        int mPendingFrames;
-        Mutex mMutex;
-        Condition mCondition;
-    };
-
-    // Note that SurfaceTexture will lose the notifications
-    // onBuffersReleased and onFrameAvailable as there is currently
-    // no way to forward the events.  This DisconnectWaiter will not let the
-    // disconnect finish until finishDisconnect() is called.  It will
-    // also block until a disconnect is called
-    class DisconnectWaiter : public BufferQueue::ConsumerListener {
-    public:
-        DisconnectWaiter () :
-            mWaitForDisconnect(false),
-            mPendingFrames(0) {
-        }
-
-        void waitForFrame() {
-            Mutex::Autolock lock(mMutex);
-            while (mPendingFrames == 0) {
-                mFrameCondition.wait(mMutex);
-            }
-            mPendingFrames--;
-        }
-
-        virtual void onFrameAvailable(const BufferItem&) {
-            Mutex::Autolock lock(mMutex);
-            mPendingFrames++;
-            mFrameCondition.signal();
-        }
-
-        virtual void onBuffersReleased() {
-            Mutex::Autolock lock(mMutex);
-            while (!mWaitForDisconnect) {
-                mDisconnectCondition.wait(mMutex);
-            }
-        }
-
-        void finishDisconnect() {
-            Mutex::Autolock lock(mMutex);
-            mWaitForDisconnect = true;
-            mDisconnectCondition.signal();
-        }
-
-    private:
-        Mutex mMutex;
-
-        bool mWaitForDisconnect;
-        Condition mDisconnectCondition;
-
-        int mPendingFrames;
-        Condition mFrameCondition;
-    };
-
-    sp<CpuConsumer> mCC;
-    sp<Surface> mSTC;
-    sp<ANativeWindow> mANW;
-};
-
-#define ASSERT_NO_ERROR(err, msg) \
-    ASSERT_EQ(NO_ERROR, err) << (msg) << strerror(-(err))
-
-void checkPixel(const CpuConsumer::LockedBuffer &buf,
-        uint32_t x, uint32_t y, uint32_t r, uint32_t g=0, uint32_t b=0) {
-    // Ignores components that don't exist for given pixel
-    switch(buf.format) {
-        case HAL_PIXEL_FORMAT_RAW16: {
-            String8 msg;
-            uint16_t *bPtr = (uint16_t*)buf.data;
-            bPtr += y * buf.stride + x;
-            // GRBG Bayer mosaic; only check the matching channel
-            switch( ((y & 1) << 1) | (x & 1) ) {
-                case 0: // G
-                case 3: // G
-                    EXPECT_EQ(g, *bPtr);
-                    break;
-                case 1: // R
-                    EXPECT_EQ(r, *bPtr);
-                    break;
-                case 2: // B
-                    EXPECT_EQ(b, *bPtr);
-                    break;
-            }
-            break;
-        }
-        // ignores g,b
-        case HAL_PIXEL_FORMAT_Y8: {
-            uint8_t *bPtr = (uint8_t*)buf.data;
-            bPtr += y * buf.stride + x;
-            EXPECT_EQ(r, *bPtr) << "at x = " << x << " y = " << y;
-            break;
-        }
-        // ignores g,b
-        case HAL_PIXEL_FORMAT_Y16: {
-            // stride is in pixels, not in bytes
-            uint16_t *bPtr = ((uint16_t*)buf.data) + y * buf.stride + x;
-
-            EXPECT_EQ(r, *bPtr) << "at x = " << x << " y = " << y;
-            break;
-        }
-        case HAL_PIXEL_FORMAT_RGBA_8888: {
-            const int bytesPerPixel = 4;
-            uint8_t *bPtr = (uint8_t*)buf.data;
-            bPtr += (y * buf.stride + x) * bytesPerPixel;
-
-            EXPECT_EQ(r, bPtr[0]) << "at x = " << x << " y = " << y;
-            EXPECT_EQ(g, bPtr[1]) << "at x = " << x << " y = " << y;
-            EXPECT_EQ(b, bPtr[2]) << "at x = " << x << " y = " << y;
-            break;
-        }
-        default: {
-            ADD_FAILURE() << "Unknown format for check:" << buf.format;
-            break;
-        }
-    }
-}
-
-// Fill a YV12 buffer with a multi-colored checkerboard pattern
-void fillYV12Buffer(uint8_t* buf, int w, int h, int stride);
-
-// Fill a Y8/Y16 buffer with a multi-colored checkerboard pattern
-template <typename T> // T == uint8_t or uint16_t
-void fillGreyscaleBuffer(T* buf, int w, int h, int stride, int bpp) {
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-    const int yuvTexOffsetY = 0;
-
-    ASSERT_TRUE(bpp == 8 || bpp == 16);
-    ASSERT_TRUE(sizeof(T)*8 == bpp);
-
-    // stride is in pixels, not in bytes
-    int yuvTexStrideY = stride;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            int parityX = (x / blockWidth) & 1;
-            int parityY = (y / blockHeight) & 1;
-            T intensity = (parityX ^ parityY) ? 63 : 191;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = intensity;
-        }
-    }
-}
-
-inline uint8_t chooseColorRgba8888(int blockX, int blockY, uint8_t channel) {
-    const int colorVariations = 3;
-    uint8_t color = ((blockX % colorVariations) + (blockY % colorVariations))
-                        % (colorVariations) == channel ? 191: 63;
-
-    return color;
-}
-
-// Fill a RGBA8888 buffer with a multi-colored checkerboard pattern
-void fillRgba8888Buffer(uint8_t* buf, int w, int h, int stride)
-{
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-    const int bytesPerPixel = 4;
-
-    // stride is in pixels, not in bytes
-    for (int x = 0; x < w; ++x) {
-        for (int y = 0; y < h; ++y) {
-            int blockX = (x / blockWidth);
-            int blockY = (y / blockHeight);
-
-            uint8_t r = chooseColorRgba8888(blockX, blockY, 0);
-            uint8_t g = chooseColorRgba8888(blockX, blockY, 1);
-            uint8_t b = chooseColorRgba8888(blockX, blockY, 2);
-
-            buf[(y*stride + x)*bytesPerPixel + 0] = r;
-            buf[(y*stride + x)*bytesPerPixel + 1] = g;
-            buf[(y*stride + x)*bytesPerPixel + 2] = b;
-            buf[(y*stride + x)*bytesPerPixel + 3] = 255;
-        }
-    }
-}
-
-// Fill a RAW sensor buffer with a multi-colored checkerboard pattern.
-// Assumes GRBG mosaic ordering. Result should be a grid in a 2x2 pattern
-// of [ R, B; G, W]
-void fillBayerRawBuffer(uint8_t* buf, int w, int h, int stride) {
-    ALOGVV("fillBayerRawBuffer: %p with %d x %d, stride %d", buf, w, h ,stride);
-    // Blocks need to be even-width/height, aim for 8-wide otherwise
-    const int blockWidth = (w > 16 ? w / 8 : 2) & ~0x1;
-    const int blockHeight = (h > 16 ? h / 8 : 2) & ~0x1;
-    for (int y = 0; y < h; y+=2) {
-        uint16_t *bPtr1 = ((uint16_t*)buf) + stride*y;
-        uint16_t *bPtr2 = bPtr1 + stride;
-        for (int x = 0; x < w; x+=2) {
-            int blockX = (x / blockWidth ) & 1;
-            int blockY = (y / blockHeight) & 1;
-            unsigned short r = (blockX == blockY) ? 1000 : 200;
-            unsigned short g = blockY ? 1000: 200;
-            unsigned short b = blockX ? 1000: 200;
-            // GR row
-            *bPtr1++ = g;
-            *bPtr1++ = r;
-            // BG row
-            *bPtr2++ = b;
-            *bPtr2++ = g;
-        }
-    }
-
-}
-
-template<typename T> // uint8_t or uint16_t
-void checkGreyscaleBuffer(const CpuConsumer::LockedBuffer &buf) {
-    uint32_t w = buf.width;
-    uint32_t h = buf.height;
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-
-    // Top-left square is bright
-    checkPixel(buf, 0, 0, 191);
-    checkPixel(buf, 1, 0, 191);
-    checkPixel(buf, 0, 1, 191);
-    checkPixel(buf, 1, 1, 191);
-
-    // One-right square is dark
-    checkPixel(buf, blockWidth,     0, 63);
-    checkPixel(buf, blockWidth + 1, 0, 63);
-    checkPixel(buf, blockWidth,     1, 63);
-    checkPixel(buf, blockWidth + 1, 1, 63);
-
-    // One-down square is dark
-    checkPixel(buf, 0, blockHeight, 63);
-    checkPixel(buf, 1, blockHeight, 63);
-    checkPixel(buf, 0, blockHeight + 1, 63);
-    checkPixel(buf, 1, blockHeight + 1, 63);
-
-    // One-diag square is bright
-    checkPixel(buf, blockWidth,     blockHeight, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight, 191);
-    checkPixel(buf, blockWidth,     blockHeight + 1, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight + 1, 191);
-
-    // Test bottom-right pixel
-    const int maxBlockX = ((w-1 + (blockWidth-1)) / blockWidth) & 0x1;
-    const int maxBlockY = ((h-1 + (blockHeight-1)) / blockHeight) & 0x1;
-    uint32_t pixelValue = ((maxBlockX % 2) == (maxBlockY % 2)) ? 191 : 63;
-    checkPixel(buf, w-1, h-1, pixelValue);
-}
-
-void checkRgba8888Buffer(const CpuConsumer::LockedBuffer &buf) {
-    uint32_t w = buf.width;
-    uint32_t h = buf.height;
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-
-    // Top-left square is bright red
-    checkPixel(buf, 0, 0, 191, 63, 63);
-    checkPixel(buf, 1, 0, 191, 63, 63);
-    checkPixel(buf, 0, 1, 191, 63, 63);
-    checkPixel(buf, 1, 1, 191, 63, 63);
-
-    // One-right square is bright green
-    checkPixel(buf, blockWidth,     0, 63, 191, 63);
-    checkPixel(buf, blockWidth + 1, 0, 63, 191, 63);
-    checkPixel(buf, blockWidth,     1, 63, 191, 63);
-    checkPixel(buf, blockWidth + 1, 1, 63, 191, 63);
-
-    // One-down square is bright green
-    checkPixel(buf, 0, blockHeight, 63, 191, 63);
-    checkPixel(buf, 1, blockHeight, 63, 191, 63);
-    checkPixel(buf, 0, blockHeight + 1, 63, 191, 63);
-    checkPixel(buf, 1, blockHeight + 1, 63, 191, 63);
-
-    // One-diag square is bright blue
-    checkPixel(buf, blockWidth,     blockHeight, 63, 63, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight, 63, 63, 191);
-    checkPixel(buf, blockWidth,     blockHeight + 1, 63, 63, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight + 1, 63, 63, 191);
-
-    // Test bottom-right pixel
-    {
-        const int maxBlockX = ((w-1) / blockWidth);
-        const int maxBlockY = ((h-1) / blockHeight);
-        uint8_t r = chooseColorRgba8888(maxBlockX, maxBlockY, 0);
-        uint8_t g = chooseColorRgba8888(maxBlockX, maxBlockY, 1);
-        uint8_t b = chooseColorRgba8888(maxBlockX, maxBlockY, 2);
-        checkPixel(buf, w-1, h-1, r, g, b);
-    }
-}
-
-void checkBayerRawBuffer(const CpuConsumer::LockedBuffer &buf) {
-    uint32_t w = buf.width;
-    uint32_t h = buf.height;
-    const int blockWidth = (w > 16 ? w / 8 : 2) & ~0x1;
-    const int blockHeight = (h > 16 ? h / 8 : 2) & ~0x1;
-
-    // Top-left square is red
-    checkPixel(buf, 0, 0, 1000, 200, 200);
-    checkPixel(buf, 1, 0, 1000, 200, 200);
-    checkPixel(buf, 0, 1, 1000, 200, 200);
-    checkPixel(buf, 1, 1, 1000, 200, 200);
-
-    // One-right square is blue
-    checkPixel(buf, blockWidth,     0, 200, 200, 1000);
-    checkPixel(buf, blockWidth + 1, 0, 200, 200, 1000);
-    checkPixel(buf, blockWidth,     1, 200, 200, 1000);
-    checkPixel(buf, blockWidth + 1, 1, 200, 200, 1000);
-
-    // One-down square is green
-    checkPixel(buf, 0, blockHeight, 200, 1000, 200);
-    checkPixel(buf, 1, blockHeight, 200, 1000, 200);
-    checkPixel(buf, 0, blockHeight + 1, 200, 1000, 200);
-    checkPixel(buf, 1, blockHeight + 1, 200, 1000, 200);
-
-    // One-diag square is white
-    checkPixel(buf, blockWidth,     blockHeight, 1000, 1000, 1000);
-    checkPixel(buf, blockWidth + 1, blockHeight, 1000, 1000, 1000);
-    checkPixel(buf, blockWidth,     blockHeight + 1, 1000, 1000, 1000);
-    checkPixel(buf, blockWidth + 1, blockHeight + 1, 1000, 1000, 1000);
-
-    // Test bottom-right pixel
-    const int maxBlockX = ((w-1) / blockWidth) & 0x1;
-    const int maxBlockY = ((w-1) / blockHeight) & 0x1;
-    unsigned short maxR = (maxBlockX == maxBlockY) ? 1000 : 200;
-    unsigned short maxG = maxBlockY ? 1000: 200;
-    unsigned short maxB = maxBlockX ? 1000: 200;
-    checkPixel(buf, w-1, h-1, maxR, maxG, maxB);
-}
-
-void checkAnyBuffer(const CpuConsumer::LockedBuffer &buf, int format) {
-    switch (format) {
-        case HAL_PIXEL_FORMAT_RAW16:
-            checkBayerRawBuffer(buf);
-            break;
-        case HAL_PIXEL_FORMAT_Y8:
-            checkGreyscaleBuffer<uint8_t>(buf);
-            break;
-        case HAL_PIXEL_FORMAT_Y16:
-            checkGreyscaleBuffer<uint16_t>(buf);
-            break;
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-            checkRgba8888Buffer(buf);
-            break;
-    }
-}
-
-// Configures the ANativeWindow producer-side interface based on test parameters
-void configureANW(const sp<ANativeWindow>& anw,
-        const CpuConsumerTestParams& params,
-        int maxBufferSlack) {
-    status_t err;
-    err = native_window_api_connect(anw.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_NO_ERROR(err, "connect error: ");
-
-    err = native_window_set_buffers_dimensions(anw.get(),
-            params.width, params.height);
-    ASSERT_NO_ERROR(err, "set_buffers_dimensions error: ");
-
-    err = native_window_set_buffers_format(anw.get(), params.format);
-    ASSERT_NO_ERROR(err, "set_buffers_format error: ");
-
-    err = native_window_set_usage(anw.get(),
-            GRALLOC_USAGE_SW_WRITE_OFTEN);
-    ASSERT_NO_ERROR(err, "set_usage error: ");
-
-    int minUndequeuedBuffers;
-    err = anw.get()->query(anw.get(),
-            NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-            &minUndequeuedBuffers);
-    ASSERT_NO_ERROR(err, "query error: ");
-
-    ALOGVV("Setting buffer count to %d",
-            maxBufferSlack + 1 + minUndequeuedBuffers);
-    err = native_window_set_buffer_count(anw.get(),
-            maxBufferSlack + 1 + minUndequeuedBuffers);
-    ASSERT_NO_ERROR(err, "set_buffer_count error: ");
-
-}
-
-// Produce one frame of image data; assumes format and resolution configuration
-// is already done.
-void produceOneFrame(const sp<ANativeWindow>& anw,
-        const CpuConsumerTestParams& params,
-        int64_t timestamp, uint32_t *stride) {
-    status_t err;
-    ANativeWindowBuffer* anb;
-    ALOGVV("Dequeue buffer from %p", anw.get());
-    err = native_window_dequeue_buffer_and_wait(anw.get(), &anb);
-    ASSERT_NO_ERROR(err, "dequeueBuffer error: ");
-
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    *stride = buf->getStride();
-    uint8_t* img = NULL;
-
-    ALOGVV("Lock buffer from %p for write", anw.get());
-    err = buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    ASSERT_NO_ERROR(err, "lock error: ");
-
-    switch (params.format) {
-        case HAL_PIXEL_FORMAT_YV12:
-            fillYV12Buffer(img, params.width, params.height, *stride);
-            break;
-        case HAL_PIXEL_FORMAT_RAW16:
-            fillBayerRawBuffer(img, params.width, params.height, buf->getStride());
-            break;
-        case HAL_PIXEL_FORMAT_Y8:
-            fillGreyscaleBuffer<uint8_t>(img, params.width, params.height,
-                                         buf->getStride(), /*bpp*/8);
-            break;
-        case HAL_PIXEL_FORMAT_Y16:
-            fillGreyscaleBuffer<uint16_t>((uint16_t*)img, params.width,
-                                          params.height, buf->getStride(),
-                                          /*bpp*/16);
-            break;
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-            fillRgba8888Buffer(img, params.width, params.height, buf->getStride());
-            break;
-        default:
-            FAIL() << "Unknown pixel format under test!";
-            break;
-    }
-    ALOGVV("Unlock buffer from %p", anw.get());
-    err = buf->unlock();
-    ASSERT_NO_ERROR(err, "unlock error: ");
-
-    ALOGVV("Set timestamp to %p", anw.get());
-    err = native_window_set_buffers_timestamp(anw.get(), timestamp);
-    ASSERT_NO_ERROR(err, "set_buffers_timestamp error: ");
-
-    ALOGVV("Queue buffer to %p", anw.get());
-    err = anw->queueBuffer(anw.get(), buf->getNativeBuffer(), -1);
-    ASSERT_NO_ERROR(err, "queueBuffer error:");
-};
-
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
-// supported on all devices.
-TEST_P(CpuConsumerTest, FromCpuSingle) {
-    status_t err;
-    CpuConsumerTestParams params = GetParam();
-
-    // Set up
-
-    ASSERT_NO_FATAL_FAILURE(configureANW(mANW, params, 1));
-
-    // Produce
-
-    const int64_t time = 12345678L;
-    uint32_t stride;
-    ASSERT_NO_FATAL_FAILURE(produceOneFrame(mANW, params, time,
-                    &stride));
-
-    // Consume
-
-    CpuConsumer::LockedBuffer b;
-    err = mCC->lockNextBuffer(&b);
-    ASSERT_NO_ERROR(err, "getNextBuffer error: ");
-
-    ASSERT_TRUE(b.data != NULL);
-    EXPECT_EQ(params.width,  b.width);
-    EXPECT_EQ(params.height, b.height);
-    EXPECT_EQ(params.format, b.format);
-    EXPECT_EQ(stride, b.stride);
-    EXPECT_EQ(time, b.timestamp);
-
-    checkAnyBuffer(b, GetParam().format);
-    mCC->unlockBuffer(b);
-}
-
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
-// supported on all devices.
-TEST_P(CpuConsumerTest, FromCpuManyInQueue) {
-    status_t err;
-    CpuConsumerTestParams params = GetParam();
-
-    const int numInQueue = 5;
-    // Set up
-
-    ASSERT_NO_FATAL_FAILURE(configureANW(mANW, params, numInQueue));
-
-    // Produce
-
-    const int64_t time[numInQueue] = { 1L, 2L, 3L, 4L, 5L};
-    uint32_t stride[numInQueue];
-
-    for (int i = 0; i < numInQueue; i++) {
-        ALOGV("Producing frame %d", i);
-        ASSERT_NO_FATAL_FAILURE(produceOneFrame(mANW, params, time[i],
-                        &stride[i]));
-    }
-
-    // Consume
-
-    for (int i = 0; i < numInQueue; i++) {
-        ALOGV("Consuming frame %d", i);
-        CpuConsumer::LockedBuffer b;
-        err = mCC->lockNextBuffer(&b);
-        ASSERT_NO_ERROR(err, "getNextBuffer error: ");
-
-        ASSERT_TRUE(b.data != NULL);
-        EXPECT_EQ(params.width,  b.width);
-        EXPECT_EQ(params.height, b.height);
-        EXPECT_EQ(params.format, b.format);
-        EXPECT_EQ(stride[i], b.stride);
-        EXPECT_EQ(time[i], b.timestamp);
-
-        checkAnyBuffer(b, GetParam().format);
-
-        mCC->unlockBuffer(b);
-    }
-}
-
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
-// supported on all devices.
-TEST_P(CpuConsumerTest, FromCpuLockMax) {
-    status_t err;
-    CpuConsumerTestParams params = GetParam();
-
-    // Set up
-
-    ASSERT_NO_FATAL_FAILURE(configureANW(mANW, params, params.maxLockedBuffers + 1));
-
-    // Produce
-
-    const int64_t time = 1234L;
-    uint32_t stride;
-
-    for (int i = 0; i < params.maxLockedBuffers + 1; i++) {
-        ALOGV("Producing frame %d", i);
-        ASSERT_NO_FATAL_FAILURE(produceOneFrame(mANW, params, time,
-                        &stride));
-    }
-
-    // Consume
-
-    std::vector<CpuConsumer::LockedBuffer> b(params.maxLockedBuffers);
-    for (int i = 0; i < params.maxLockedBuffers; i++) {
-        ALOGV("Locking frame %d", i);
-        err = mCC->lockNextBuffer(&b[i]);
-        ASSERT_NO_ERROR(err, "getNextBuffer error: ");
-
-        ASSERT_TRUE(b[i].data != NULL);
-        EXPECT_EQ(params.width,  b[i].width);
-        EXPECT_EQ(params.height, b[i].height);
-        EXPECT_EQ(params.format, b[i].format);
-        EXPECT_EQ(stride, b[i].stride);
-        EXPECT_EQ(time, b[i].timestamp);
-
-        checkAnyBuffer(b[i], GetParam().format);
-    }
-
-    ALOGV("Locking frame %d (too many)", params.maxLockedBuffers);
-    CpuConsumer::LockedBuffer bTooMuch;
-    err = mCC->lockNextBuffer(&bTooMuch);
-    ASSERT_TRUE(err == NOT_ENOUGH_DATA) << "Allowing too many locks";
-
-    ALOGV("Unlocking frame 0");
-    err = mCC->unlockBuffer(b[0]);
-    ASSERT_NO_ERROR(err, "Could not unlock buffer 0: ");
-
-    ALOGV("Locking frame %d (should work now)", params.maxLockedBuffers);
-    err = mCC->lockNextBuffer(&bTooMuch);
-    ASSERT_NO_ERROR(err, "Did not allow new lock after unlock");
-
-    ASSERT_TRUE(bTooMuch.data != NULL);
-    EXPECT_EQ(params.width,  bTooMuch.width);
-    EXPECT_EQ(params.height, bTooMuch.height);
-    EXPECT_EQ(params.format, bTooMuch.format);
-    EXPECT_EQ(stride, bTooMuch.stride);
-    EXPECT_EQ(time, bTooMuch.timestamp);
-
-    checkAnyBuffer(bTooMuch, GetParam().format);
-
-    ALOGV("Unlocking extra buffer");
-    err = mCC->unlockBuffer(bTooMuch);
-    ASSERT_NO_ERROR(err, "Could not unlock extra buffer: ");
-
-    ALOGV("Locking frame %d (no more available)", params.maxLockedBuffers + 1);
-    err = mCC->lockNextBuffer(&b[0]);
-    ASSERT_EQ(BAD_VALUE, err) << "Not out of buffers somehow";
-
-    for (int i = 1; i < params.maxLockedBuffers; i++) {
-        mCC->unlockBuffer(b[i]);
-    }
-}
-
-TEST_P(CpuConsumerTest, FromCpuInvalid) {
-    status_t err = mCC->lockNextBuffer(nullptr);
-    ASSERT_EQ(BAD_VALUE, err) << "lockNextBuffer did not fail";
-
-    CpuConsumer::LockedBuffer b;
-    err = mCC->unlockBuffer(b);
-    ASSERT_EQ(BAD_VALUE, err) << "unlockBuffer did not fail";
-}
-
-TEST_P(CpuConsumerTest, FromCpuMultiThread) {
-    CpuConsumerTestParams params = GetParam();
-    ASSERT_NO_FATAL_FAILURE(configureANW(mANW, params, params.maxLockedBuffers + 1));
-
-    for (int i = 0; i < 10; i++) {
-        std::atomic<int> threadReadyCount(0);
-        auto lockAndUnlock = [&]() {
-            threadReadyCount++;
-            // busy wait
-            while (threadReadyCount < params.maxLockedBuffers + 1);
-
-            CpuConsumer::LockedBuffer b;
-            status_t err = mCC->lockNextBuffer(&b);
-            if (err == NO_ERROR) {
-                usleep(1000);
-                err = mCC->unlockBuffer(b);
-                ASSERT_NO_ERROR(err, "Could not unlock buffer: ");
-            } else if (err == NOT_ENOUGH_DATA) {
-                // there are params.maxLockedBuffers+1 threads so one of the
-                // threads might get this error
-            } else {
-                FAIL() << "Could not lock buffer";
-            }
-        };
-
-        // produce buffers
-        for (int j = 0; j < params.maxLockedBuffers + 1; j++) {
-            const int64_t time = 1234L;
-            uint32_t stride;
-            ASSERT_NO_FATAL_FAILURE(produceOneFrame(mANW, params, time, &stride));
-        }
-
-        // spawn threads
-        std::vector<std::thread> threads;
-        for (int j = 0; j < params.maxLockedBuffers + 1; j++) {
-            threads.push_back(std::thread(lockAndUnlock));
-        }
-
-        // join threads
-        for (auto& thread : threads) {
-            thread.join();
-        }
-
-        // we produced N+1 buffers, but the threads might only consume N
-        CpuConsumer::LockedBuffer b;
-        if (mCC->lockNextBuffer(&b) == NO_ERROR) {
-            mCC->unlockBuffer(b);
-        }
-
-        if (HasFatalFailure()) {
-            break;
-        }
-    }
-}
-
-CpuConsumerTestParams y8TestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_Y8},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_Y8},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_Y8},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_Y8},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_Y8},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_Y8},
-};
-
-CpuConsumerTestParams y16TestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_Y16},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_Y16},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_Y16},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_Y16},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_Y16},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_Y16},
-};
-
-CpuConsumerTestParams rawTestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_RAW16},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_RAW16},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_RAW16},
-};
-
-CpuConsumerTestParams rgba8888TestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_RGBA_8888},
-};
-
-#if CPU_CONSUMER_TEST_FORMAT_Y8
-INSTANTIATE_TEST_CASE_P(Y8Tests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(y8TestSets));
-#endif
-
-#if CPU_CONSUMER_TEST_FORMAT_Y16
-INSTANTIATE_TEST_CASE_P(Y16Tests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(y16TestSets));
-#endif
-
-#if CPU_CONSUMER_TEST_FORMAT_RAW
-INSTANTIATE_TEST_CASE_P(RawTests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(rawTestSets));
-#endif
-
-#if CPU_CONSUMER_TEST_FORMAT_RGBA_8888
-INSTANTIATE_TEST_CASE_P(Rgba8888Tests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(rgba8888TestSets));
-#endif
-
-
-
-} // namespace android
diff --git a/libs/gui/tests/DisconnectWaiter.h b/libs/gui/tests/DisconnectWaiter.h
deleted file mode 100644
index 6e6915b29..000000000
--- a/libs/gui/tests/DisconnectWaiter.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_DISCONNECT_WAITER_H
-#define ANDROID_DISCONNECT_WAITER_H
-
-#include <gui/IConsumerListener.h>
-
-#include <utils/Condition.h>
-#include <utils/Mutex.h>
-
-namespace android {
-
-// Note that GLConsumer will lose the notifications
-// onBuffersReleased and onFrameAvailable as there is currently
-// no way to forward the events.  This DisconnectWaiter will not let the
-// disconnect finish until finishDisconnect() is called.  It will
-// also block until a disconnect is called
-class DisconnectWaiter : public BnConsumerListener {
-public:
-    DisconnectWaiter () :
-        mWaitForDisconnect(false),
-        mPendingFrames(0) {
-    }
-
-    void waitForFrame() {
-        Mutex::Autolock lock(mMutex);
-        while (mPendingFrames == 0) {
-            mFrameCondition.wait(mMutex);
-        }
-        mPendingFrames--;
-    }
-
-    virtual void onFrameAvailable(const BufferItem& /* item */) {
-        Mutex::Autolock lock(mMutex);
-        mPendingFrames++;
-        mFrameCondition.signal();
-    }
-
-    virtual void onBuffersReleased() {
-        Mutex::Autolock lock(mMutex);
-        while (!mWaitForDisconnect) {
-            mDisconnectCondition.wait(mMutex);
-        }
-    }
-
-    virtual void onSidebandStreamChanged() {}
-
-    void finishDisconnect() {
-        Mutex::Autolock lock(mMutex);
-        mWaitForDisconnect = true;
-        mDisconnectCondition.signal();
-    }
-
-private:
-    Mutex mMutex;
-
-    bool mWaitForDisconnect;
-    Condition mDisconnectCondition;
-
-    int mPendingFrames;
-    Condition mFrameCondition;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/DummyConsumer.h b/libs/gui/tests/DummyConsumer.h
deleted file mode 100644
index 502bdf981..000000000
--- a/libs/gui/tests/DummyConsumer.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gui/IConsumerListener.h>
-
-namespace android {
-
-struct DummyConsumer : public BnConsumerListener {
-    void onFrameAvailable(const BufferItem& /* item */) override {}
-    void onBuffersReleased() override {}
-    void onSidebandStreamChanged() override {}
-};
-
-} // namespace android
diff --git a/libs/gui/tests/FillBuffer.cpp b/libs/gui/tests/FillBuffer.cpp
deleted file mode 100644
index ccd674fcb..000000000
--- a/libs/gui/tests/FillBuffer.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "FillBuffer.h"
-
-#include <ui/GraphicBuffer.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-void fillYV12Buffer(uint8_t* buf, int w, int h, int stride) {
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-    const int yuvTexOffsetY = 0;
-    int yuvTexStrideY = stride;
-    int yuvTexOffsetV = yuvTexStrideY * h;
-    int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf;
-    int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * h/2;
-    int yuvTexStrideU = yuvTexStrideV;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            int parityX = (x / blockWidth) & 1;
-            int parityY = (y / blockHeight) & 1;
-            unsigned char intensity = (parityX ^ parityY) ? 63 : 191;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = intensity;
-            if (x < w / 2 && y < h / 2) {
-                buf[yuvTexOffsetU + (y * yuvTexStrideU) + x] = intensity;
-                if (x * 2 < w / 2 && y * 2 < h / 2) {
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 1] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 1] =
-                        intensity;
-                }
-            }
-        }
-    }
-}
-
-void fillYV12BufferRect(uint8_t* buf, int w, int h, int stride,
-        const android_native_rect_t& rect) {
-    const int yuvTexOffsetY = 0;
-    int yuvTexStrideY = stride;
-    int yuvTexOffsetV = yuvTexStrideY * h;
-    int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf;
-    int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * h/2;
-    int yuvTexStrideU = yuvTexStrideV;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            bool inside = rect.left <= x && x < rect.right &&
-                    rect.top <= y && y < rect.bottom;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = inside ? 240 : 64;
-            if (x < w / 2 && y < h / 2) {
-                bool inside = rect.left <= 2*x && 2*x < rect.right &&
-                        rect.top <= 2*y && 2*y < rect.bottom;
-                buf[yuvTexOffsetU + (y * yuvTexStrideU) + x] = 16;
-                buf[yuvTexOffsetV + (y * yuvTexStrideV) + x] =
-                        inside ? 16 : 255;
-            }
-        }
-    }
-}
-
-void fillRGBA8Buffer(uint8_t* buf, int w, int h, int stride) {
-    const size_t PIXEL_SIZE = 4;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            off_t offset = (y * stride + x) * PIXEL_SIZE;
-            for (int c = 0; c < 4; c++) {
-                int parityX = (x / (1 << (c+2))) & 1;
-                int parityY = (y / (1 << (c+2))) & 1;
-                buf[offset + c] = (parityX ^ parityY) ? 231 : 35;
-            }
-        }
-    }
-}
-
-void produceOneRGBA8Frame(const sp<ANativeWindow>& anw) {
-    android_native_buffer_t* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(anw.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    uint8_t* img = NULL;
-    ASSERT_EQ(NO_ERROR, buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN,
-            (void**)(&img)));
-    fillRGBA8Buffer(img, buf->getWidth(), buf->getHeight(), buf->getStride());
-    ASSERT_EQ(NO_ERROR, buf->unlock());
-    ASSERT_EQ(NO_ERROR, anw->queueBuffer(anw.get(), buf->getNativeBuffer(),
-            -1));
-}
-} // namespace android
diff --git a/libs/gui/tests/FillBuffer.h b/libs/gui/tests/FillBuffer.h
deleted file mode 100644
index b58417931..000000000
--- a/libs/gui/tests/FillBuffer.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_FILL_BUFFER_H
-#define ANDROID_FILL_BUFFER_H
-
-#include <system/window.h>
-#include <utils/StrongPointer.h>
-
-namespace android {
-
-// Fill a YV12 buffer with a multi-colored checkerboard pattern
-void fillYV12Buffer(uint8_t* buf, int w, int h, int stride);
-
-// Fill a YV12 buffer with red outside a given rectangle and green inside it.
-void fillYV12BufferRect(uint8_t* buf, int w, int h, int stride,
-        const android_native_rect_t& rect);
-
-void fillRGBA8Buffer(uint8_t* buf, int w, int h, int stride);
-
-// Produce a single RGBA8 frame by filling a buffer with a checkerboard pattern
-// using the CPU.  This assumes that the ANativeWindow is already configured to
-// allow this to be done (e.g. the format is set to RGBA8).
-//
-// Calls to this function should be wrapped in an ASSERT_NO_FATAL_FAILURE().
-void produceOneRGBA8Frame(const sp<ANativeWindow>& anw);
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/FrameWaiter.h b/libs/gui/tests/FrameWaiter.h
deleted file mode 100644
index f78fa001c..000000000
--- a/libs/gui/tests/FrameWaiter.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_FRAME_WAITER_H
-#define ANDROID_FRAME_WAITER_H
-
-#include <gui/GLConsumer.h>
-
-namespace android {
-
-class FrameWaiter : public GLConsumer::FrameAvailableListener {
-public:
-    FrameWaiter():
-            mPendingFrames(0) {
-    }
-
-    void waitForFrame() {
-        Mutex::Autolock lock(mMutex);
-        while (mPendingFrames == 0) {
-            mCondition.wait(mMutex);
-        }
-        mPendingFrames--;
-    }
-
-    virtual void onFrameAvailable(const BufferItem& /* item */) {
-        Mutex::Autolock lock(mMutex);
-        mPendingFrames++;
-        mCondition.signal();
-    }
-
-private:
-    int mPendingFrames;
-    Mutex mMutex;
-    Condition mCondition;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/GLTest.cpp b/libs/gui/tests/GLTest.cpp
deleted file mode 100644
index a91552f7f..000000000
--- a/libs/gui/tests/GLTest.cpp
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "GLTest.h"
-
-#include <gui/Surface.h>
-
-#include <GLES2/gl2.h>
-
-namespace android {
-
-using Transaction = SurfaceComposerClient::Transaction;
-
-static int abs(int value) {
-    return value > 0 ? value : -value;
-}
-
-void GLTest::SetUp() {
-    const ::testing::TestInfo* const testInfo =
-        ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGV("Begin test: %s.%s", testInfo->test_case_name(), testInfo->name());
-
-    mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    RecordProperty("EglVersionMajor", majorVersion);
-    RecordProperty("EglVersionMinor", minorVersion);
-
-    EGLint numConfigs = 0;
-    EXPECT_TRUE(eglChooseConfig(mEglDisplay, getConfigAttribs(), &mGlConfig, 1,
-            &numConfigs));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    char* displaySecsEnv = getenv("GLTEST_DISPLAY_SECS");
-    if (displaySecsEnv != NULL) {
-        mDisplaySecs = atoi(displaySecsEnv);
-        if (mDisplaySecs < 0) {
-            mDisplaySecs = 0;
-        }
-    } else {
-        mDisplaySecs = 0;
-    }
-
-    if (mDisplaySecs > 0) {
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        mSurfaceControl = mComposerClient->createSurface(
-                String8("Test Surface"), getSurfaceWidth(), getSurfaceHeight(),
-                PIXEL_FORMAT_RGB_888, 0);
-
-        ASSERT_TRUE(mSurfaceControl != NULL);
-        ASSERT_TRUE(mSurfaceControl->isValid());
-
-        Transaction t;
-        ASSERT_EQ(NO_ERROR, t.setLayer(mSurfaceControl, 0x7FFFFFFF)
-                .show(mSurfaceControl)
-                .apply());
-
-        sp<ANativeWindow> window = mSurfaceControl->getSurface();
-        mEglSurface = createWindowSurface(mEglDisplay, mGlConfig, window);
-    } else {
-        EGLint pbufferAttribs[] = {
-            EGL_WIDTH, getSurfaceWidth(),
-            EGL_HEIGHT, getSurfaceHeight(),
-            EGL_NONE };
-
-        mEglSurface = eglCreatePbufferSurface(mEglDisplay, mGlConfig,
-                pbufferAttribs);
-    }
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_SURFACE, mEglSurface);
-
-    mEglContext = eglCreateContext(mEglDisplay, mGlConfig, EGL_NO_CONTEXT,
-            getContextAttribs());
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_CONTEXT, mEglContext);
-
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLint w, h;
-    EXPECT_TRUE(eglQuerySurface(mEglDisplay, mEglSurface, EGL_WIDTH, &w));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    EXPECT_TRUE(eglQuerySurface(mEglDisplay, mEglSurface, EGL_HEIGHT, &h));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    RecordProperty("EglSurfaceWidth", w);
-    RecordProperty("EglSurfaceHeight", h);
-
-    glViewport(0, 0, w, h);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-}
-
-void GLTest::TearDown() {
-    // Display the result
-    if (mDisplaySecs > 0 && mEglSurface != EGL_NO_SURFACE) {
-        eglSwapBuffers(mEglDisplay, mEglSurface);
-        sleep(mDisplaySecs);
-    }
-
-    if (mComposerClient != NULL) {
-        mComposerClient->dispose();
-    }
-    if (mEglContext != EGL_NO_CONTEXT) {
-        eglDestroyContext(mEglDisplay, mEglContext);
-    }
-    if (mEglSurface != EGL_NO_SURFACE) {
-        eglDestroySurface(mEglDisplay, mEglSurface);
-    }
-    if (mEglDisplay != EGL_NO_DISPLAY) {
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                EGL_NO_CONTEXT);
-        eglTerminate(mEglDisplay);
-    }
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    const ::testing::TestInfo* const testInfo =
-        ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGV("End test:   %s.%s", testInfo->test_case_name(), testInfo->name());
-}
-
-EGLint const* GLTest::getConfigAttribs() {
-    static const EGLint sDefaultConfigAttribs[] = {
-        EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE, 8,
-        EGL_GREEN_SIZE, 8,
-        EGL_BLUE_SIZE, 8,
-        EGL_ALPHA_SIZE, 8,
-        EGL_DEPTH_SIZE, 16,
-        EGL_STENCIL_SIZE, 8,
-        EGL_NONE };
-
-    return sDefaultConfigAttribs;
-}
-
-EGLint const* GLTest::getContextAttribs() {
-    static const EGLint sDefaultContextAttribs[] = {
-        EGL_CONTEXT_CLIENT_VERSION, 2,
-        EGL_NONE };
-
-    return sDefaultContextAttribs;
-}
-
-EGLint GLTest::getSurfaceWidth() {
-    return 512;
-}
-
-EGLint GLTest::getSurfaceHeight() {
-    return 512;
-}
-
-EGLSurface GLTest::createWindowSurface(EGLDisplay display, EGLConfig config,
-                                       sp<ANativeWindow>& window) const {
-    return eglCreateWindowSurface(display, config, window.get(), NULL);
-}
-
-::testing::AssertionResult GLTest::checkPixel(int x, int y,
-        int r, int g, int b, int a, int tolerance) {
-    GLubyte pixel[4];
-    String8 msg;
-    glReadPixels(x, y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, pixel);
-    GLenum err = glGetError();
-    if (err != GL_NO_ERROR) {
-        msg += String8::format("error reading pixel: %#x", err);
-        while ((err = glGetError()) != GL_NO_ERROR) {
-            msg += String8::format(", %#x", err);
-        }
-        return ::testing::AssertionFailure(::testing::Message(msg.string()));
-    }
-    if (r >= 0 && abs(r - int(pixel[0])) > tolerance) {
-        msg += String8::format("r(%d isn't %d)", pixel[0], r);
-    }
-    if (g >= 0 && abs(g - int(pixel[1])) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("g(%d isn't %d)", pixel[1], g);
-    }
-    if (b >= 0 && abs(b - int(pixel[2])) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("b(%d isn't %d)", pixel[2], b);
-    }
-    if (a >= 0 && abs(a - int(pixel[3])) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("a(%d isn't %d)", pixel[3], a);
-    }
-    if (!msg.isEmpty()) {
-        return ::testing::AssertionFailure(::testing::Message(msg.string()));
-    } else {
-        return ::testing::AssertionSuccess();
-    }
-}
-
-::testing::AssertionResult GLTest::assertRectEq(const Rect &r1, const Rect &r2,
-                                                int tolerance) {
-    String8 msg;
-
-    if (abs(r1.left - r2.left) > tolerance) {
-        msg += String8::format("left(%d isn't %d)", r1.left, r2.left);
-    }
-    if (abs(r1.top - r2.top) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("top(%d isn't %d)", r1.top, r2.top);
-    }
-    if (abs(r1.right - r2.right) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("right(%d isn't %d)", r1.right, r2.right);
-    }
-    if (abs(r1.bottom - r2.bottom) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("bottom(%d isn't %d)", r1.bottom, r2.bottom);
-    }
-    if (!msg.isEmpty()) {
-        msg += String8::format(" R1: [%d %d %d %d] R2: [%d %d %d %d]",
-                               r1.left, r1.top, r1.right, r1.bottom,
-                               r2.left, r2.top, r2.right, r2.bottom);
-        fprintf(stderr, "assertRectEq: %s\n", msg.string());
-        return ::testing::AssertionFailure(::testing::Message(msg.string()));
-    } else {
-        return ::testing::AssertionSuccess();
-    }
-}
-
-void GLTest::loadShader(GLenum shaderType, const char* pSource,
-        GLuint* outShader) {
-    GLuint shader = glCreateShader(shaderType);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        glCompileShader(shader);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    printf("Shader compile log:\n%s\n", buf);
-                    free(buf);
-                    FAIL();
-                }
-            } else {
-                char* buf = (char*) malloc(0x1000);
-                if (buf) {
-                    glGetShaderInfoLog(shader, 0x1000, NULL, buf);
-                    printf("Shader compile log:\n%s\n", buf);
-                    free(buf);
-                    FAIL();
-                }
-            }
-            glDeleteShader(shader);
-            shader = 0;
-        }
-    }
-    ASSERT_TRUE(shader != 0);
-    *outShader = shader;
-}
-
-void GLTest::createProgram(const char* pVertexSource,
-        const char* pFragmentSource, GLuint* outPgm) {
-    GLuint vertexShader, fragmentShader;
-    {
-        SCOPED_TRACE("compiling vertex shader");
-        ASSERT_NO_FATAL_FAILURE(loadShader(GL_VERTEX_SHADER, pVertexSource,
-                &vertexShader));
-    }
-    {
-        SCOPED_TRACE("compiling fragment shader");
-        ASSERT_NO_FATAL_FAILURE(loadShader(GL_FRAGMENT_SHADER, pFragmentSource,
-                &fragmentShader));
-    }
-
-    GLuint program = glCreateProgram();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    if (program) {
-        glAttachShader(program, vertexShader);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        glAttachShader(program, fragmentShader);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    printf("Program link log:\n%s\n", buf);
-                    free(buf);
-                    FAIL();
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    glDeleteShader(vertexShader);
-    glDeleteShader(fragmentShader);
-    ASSERT_TRUE(program != 0);
-    *outPgm = program;
-}
-
-} // namespace android
diff --git a/libs/gui/tests/GLTest.h b/libs/gui/tests/GLTest.h
deleted file mode 100644
index f0d27a8a3..000000000
--- a/libs/gui/tests/GLTest.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_GL_TEST_H
-#define ANDROID_GL_TEST_H
-
-#include <gtest/gtest.h>
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-
-namespace android {
-
-class GLTest : public ::testing::Test {
-public:
-    static void loadShader(GLenum shaderType, const char* pSource,
-            GLuint* outShader);
-    static void createProgram(const char* pVertexSource,
-            const char* pFragmentSource, GLuint* outPgm);
-
-protected:
-    GLTest() :
-            mDisplaySecs(0),
-            mEglDisplay(EGL_NO_DISPLAY),
-            mEglSurface(EGL_NO_SURFACE),
-            mEglContext(EGL_NO_CONTEXT),
-            mGlConfig(NULL) {
-    }
-
-    virtual void SetUp();
-    virtual void TearDown();
-
-    virtual EGLint const* getConfigAttribs();
-    virtual EGLint const* getContextAttribs();
-    virtual EGLint getSurfaceWidth();
-    virtual EGLint getSurfaceHeight();
-    virtual EGLSurface createWindowSurface(EGLDisplay display, EGLConfig config,
-                                           sp<ANativeWindow>& window) const;
-
-    ::testing::AssertionResult checkPixel(int x, int y,
-            int r, int g, int b, int a, int tolerance = 2);
-    ::testing::AssertionResult assertRectEq(const Rect &r1, const Rect &r2,
-            int tolerance = 1);
-
-    int mDisplaySecs;
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mSurfaceControl;
-
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurface;
-    EGLContext mEglContext;
-    EGLConfig  mGlConfig;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/IGraphicBufferProducer_test.cpp b/libs/gui/tests/IGraphicBufferProducer_test.cpp
deleted file mode 100644
index a35cf1117..000000000
--- a/libs/gui/tests/IGraphicBufferProducer_test.cpp
+++ /dev/null
@@ -1,805 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "IGraphicBufferProducer_test"
-//#define LOG_NDEBUG 0
-
-#include "DummyConsumer.h"
-
-#include <gtest/gtest.h>
-
-#include <utils/String8.h>
-#include <utils/threads.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <gui/BufferQueue.h>
-#include <gui/IProducerListener.h>
-
-#include <system/window.h>
-
-#include <vector>
-
-#define ASSERT_OK(x) ASSERT_EQ(OK, (x))
-#define EXPECT_OK(x) EXPECT_EQ(OK, (x))
-
-#define TEST_TOKEN ((IProducerListener*)(NULL))
-#define TEST_API NATIVE_WINDOW_API_CPU
-#define TEST_API_OTHER NATIVE_WINDOW_API_EGL // valid API that's not TEST_API
-#define TEST_CONTROLLED_BY_APP false
-#define TEST_PRODUCER_USAGE_BITS (0)
-
-#ifndef USE_BUFFER_HUB_AS_BUFFER_QUEUE
-#define USE_BUFFER_HUB_AS_BUFFER_QUEUE 0
-#endif
-
-namespace android {
-
-namespace {
-    // Default dimensions before setDefaultBufferSize is called
-    const uint32_t DEFAULT_WIDTH = 1;
-    const uint32_t DEFAULT_HEIGHT = 1;
-
-    // Default format before setDefaultBufferFormat is called
-    const PixelFormat DEFAULT_FORMAT = HAL_PIXEL_FORMAT_RGBA_8888;
-
-    // Default transform hint before setTransformHint is called
-    const uint32_t DEFAULT_TRANSFORM_HINT = 0;
-
-    // TODO: Make these constants in header
-    const int DEFAULT_CONSUMER_USAGE_BITS = 0;
-
-    // Parameters for a generic "valid" input for queueBuffer.
-    const int64_t QUEUE_BUFFER_INPUT_TIMESTAMP = 1384888611;
-    const bool QUEUE_BUFFER_INPUT_IS_AUTO_TIMESTAMP = false;
-    const android_dataspace QUEUE_BUFFER_INPUT_DATASPACE = HAL_DATASPACE_UNKNOWN;
-    const Rect QUEUE_BUFFER_INPUT_RECT = Rect(DEFAULT_WIDTH, DEFAULT_HEIGHT);
-    const int QUEUE_BUFFER_INPUT_SCALING_MODE = 0;
-    const int QUEUE_BUFFER_INPUT_TRANSFORM = 0;
-    const sp<Fence> QUEUE_BUFFER_INPUT_FENCE = Fence::NO_FENCE;
-
-    // Enums to control which IGraphicBufferProducer backend to test.
-    enum IGraphicBufferProducerTestCode {
-        USE_BUFFER_QUEUE_PRODUCER = 0,
-        USE_BUFFER_HUB_PRODUCER,
-    };
-}; // namespace anonymous
-
-class IGraphicBufferProducerTest : public ::testing::TestWithParam<uint32_t> {
-protected:
-
-    IGraphicBufferProducerTest() {}
-
-    virtual void SetUp() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-
-        mDC = new DummyConsumer;
-
-        switch (GetParam()) {
-            case USE_BUFFER_QUEUE_PRODUCER: {
-                BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-                break;
-            }
-            case USE_BUFFER_HUB_PRODUCER: {
-                BufferQueue::createBufferHubQueue(&mProducer, &mConsumer);
-                break;
-            }
-            default: {
-                // Should never reach here.
-                LOG_ALWAYS_FATAL("Invalid test params: %u", GetParam());
-                break;
-            }
-        }
-
-        // Test check: Can't connect producer if no consumer yet
-        if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-            // TODO(b/73267953): Make BufferHub honor producer and consumer connection.
-            ASSERT_EQ(NO_INIT, TryConnectProducer());
-        }
-
-        // Must connect consumer before producer connects will succeed.
-        ASSERT_OK(mConsumer->consumerConnect(mDC, /*controlledByApp*/false));
-    }
-
-    virtual void TearDown() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    status_t TryConnectProducer() {
-        IGraphicBufferProducer::QueueBufferOutput output;
-        return mProducer->connect(TEST_TOKEN,
-                                  TEST_API,
-                                  TEST_CONTROLLED_BY_APP,
-                                  &output);
-        // TODO: use params to vary token, api, producercontrolledbyapp, etc
-    }
-
-    // Connect to a producer in a 'correct' fashion.
-    //   Precondition: Consumer is connected.
-    void ConnectProducer() {
-        ASSERT_OK(TryConnectProducer());
-    }
-
-    // Create a generic "valid" input for queueBuffer
-    // -- uses the default buffer format, width, etc.
-    static IGraphicBufferProducer::QueueBufferInput CreateBufferInput() {
-        return QueueBufferInputBuilder().build();
-    }
-
-    // Builder pattern to slightly vary *almost* correct input
-    // -- avoids copying and pasting
-    struct QueueBufferInputBuilder {
-        QueueBufferInputBuilder() {
-           timestamp = QUEUE_BUFFER_INPUT_TIMESTAMP;
-           isAutoTimestamp = QUEUE_BUFFER_INPUT_IS_AUTO_TIMESTAMP;
-           dataSpace = QUEUE_BUFFER_INPUT_DATASPACE;
-           crop = QUEUE_BUFFER_INPUT_RECT;
-           scalingMode = QUEUE_BUFFER_INPUT_SCALING_MODE;
-           transform = QUEUE_BUFFER_INPUT_TRANSFORM;
-           fence = QUEUE_BUFFER_INPUT_FENCE;
-        }
-
-        IGraphicBufferProducer::QueueBufferInput build() {
-            return IGraphicBufferProducer::QueueBufferInput(
-                    timestamp,
-                    isAutoTimestamp,
-                    dataSpace,
-                    crop,
-                    scalingMode,
-                    transform,
-                    fence);
-        }
-
-        QueueBufferInputBuilder& setTimestamp(int64_t timestamp) {
-            this->timestamp = timestamp;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setIsAutoTimestamp(bool isAutoTimestamp) {
-            this->isAutoTimestamp = isAutoTimestamp;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setDataSpace(android_dataspace dataSpace) {
-            this->dataSpace = dataSpace;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setCrop(Rect crop) {
-            this->crop = crop;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setScalingMode(int scalingMode) {
-            this->scalingMode = scalingMode;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setTransform(uint32_t transform) {
-            this->transform = transform;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setFence(sp<Fence> fence) {
-            this->fence = fence;
-            return *this;
-        }
-
-    private:
-        int64_t timestamp;
-        bool isAutoTimestamp;
-        android_dataspace dataSpace;
-        Rect crop;
-        int scalingMode;
-        uint32_t transform;
-        sp<Fence> fence;
-    }; // struct QueueBufferInputBuilder
-
-    // To easily store dequeueBuffer results into containers
-    struct DequeueBufferResult {
-        int slot;
-        sp<Fence> fence;
-    };
-
-    status_t dequeueBuffer(uint32_t w, uint32_t h, uint32_t format, uint32_t usage, DequeueBufferResult* result) {
-        return mProducer->dequeueBuffer(&result->slot, &result->fence, w, h, format, usage,
-                                        nullptr, nullptr);
-    }
-
-    void setupDequeueRequestBuffer(int *slot, sp<Fence> *fence,
-            sp<GraphicBuffer> *buffer)
-    {
-        ASSERT_TRUE(slot != NULL);
-        ASSERT_TRUE(fence != NULL);
-        ASSERT_TRUE(buffer != NULL);
-
-        ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(slot, fence, DEFAULT_WIDTH, DEFAULT_HEIGHT,
-                                                    DEFAULT_FORMAT, TEST_PRODUCER_USAGE_BITS,
-                                                    nullptr, nullptr)));
-
-        EXPECT_LE(0, *slot);
-        EXPECT_GT(BufferQueue::NUM_BUFFER_SLOTS, *slot);
-
-        // Request the buffer (pre-requisite for queueing)
-        ASSERT_OK(mProducer->requestBuffer(*slot, buffer));
-    }
-
-private: // hide from test body
-    sp<DummyConsumer> mDC;
-
-protected: // accessible from test body
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-};
-
-TEST_P(IGraphicBufferProducerTest, ConnectFirst_ReturnsError) {
-    IGraphicBufferProducer::QueueBufferOutput output;
-
-    // NULL output returns BAD_VALUE
-    EXPECT_EQ(BAD_VALUE, mProducer->connect(TEST_TOKEN,
-                                            TEST_API,
-                                            TEST_CONTROLLED_BY_APP,
-                                            /*output*/NULL));
-
-    // Invalid API returns bad value
-    EXPECT_EQ(BAD_VALUE, mProducer->connect(TEST_TOKEN,
-                                            /*api*/0xDEADBEEF,
-                                            TEST_CONTROLLED_BY_APP,
-                                            &output));
-
-    // TODO: get a token from a dead process somehow
-}
-
-TEST_P(IGraphicBufferProducerTest, ConnectAgain_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // Can't connect when there is already a producer connected
-    IGraphicBufferProducer::QueueBufferOutput output;
-    EXPECT_EQ(BAD_VALUE, mProducer->connect(TEST_TOKEN,
-                                            TEST_API,
-                                            TEST_CONTROLLED_BY_APP,
-                                            &output));
-
-    ASSERT_OK(mConsumer->consumerDisconnect());
-    // Can't connect when IGBP is abandoned
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/73267953): Make BufferHub honor producer and consumer connection.
-        EXPECT_EQ(NO_INIT, mProducer->connect(TEST_TOKEN,
-                                              TEST_API,
-                                              TEST_CONTROLLED_BY_APP,
-                                              &output));
-    }
-}
-
-TEST_P(IGraphicBufferProducerTest, Disconnect_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-}
-
-
-TEST_P(IGraphicBufferProducerTest, Disconnect_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // Must disconnect with same API number
-    ASSERT_EQ(BAD_VALUE, mProducer->disconnect(TEST_API_OTHER));
-    // API must not be out of range
-    ASSERT_EQ(BAD_VALUE, mProducer->disconnect(/*api*/0xDEADBEEF));
-
-    // TODO: somehow kill mProducer so that this returns DEAD_OBJECT
-}
-
-TEST_P(IGraphicBufferProducerTest, Query_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int32_t value = -1;
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_WIDTH, &value));
-    EXPECT_EQ(DEFAULT_WIDTH, static_cast<uint32_t>(value));
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_HEIGHT, &value));
-    EXPECT_EQ(DEFAULT_HEIGHT, static_cast<uint32_t>(value));
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_FORMAT, &value));
-    EXPECT_EQ(DEFAULT_FORMAT, value);
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS, &value));
-    EXPECT_LE(0, value);
-    EXPECT_GE(BufferQueue::NUM_BUFFER_SLOTS, value);
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND, &value));
-    EXPECT_FALSE(value); // Can't run behind when we haven't touched the queue
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_CONSUMER_USAGE_BITS, &value));
-    EXPECT_EQ(DEFAULT_CONSUMER_USAGE_BITS, value);
-
-}
-
-TEST_P(IGraphicBufferProducerTest, Query_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // One past the end of the last 'query' enum value. Update this if we add more enums.
-    const int NATIVE_WINDOW_QUERY_LAST_OFF_BY_ONE = NATIVE_WINDOW_BUFFER_AGE + 1;
-
-    int value;
-    // What was out of range
-    EXPECT_EQ(BAD_VALUE, mProducer->query(/*what*/-1, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(/*what*/0xDEADBEEF, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_QUERY_LAST_OFF_BY_ONE, &value));
-
-    // Some enums from window.h are 'invalid'
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_CONCRETE_TYPE, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_DEFAULT_WIDTH, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_DEFAULT_HEIGHT, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_TRANSFORM_HINT, &value));
-    // TODO: Consider documented the above enums as unsupported or make a new enum for IGBP
-
-    // Value was NULL
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_FORMAT, /*value*/NULL));
-
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // BQ was abandoned
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/73267953): Make BufferHub honor producer and consumer connection.
-        EXPECT_EQ(NO_INIT, mProducer->query(NATIVE_WINDOW_FORMAT, &value));
-    }
-
-    // TODO: other things in window.h that are supported by Surface::query
-    // but not by BufferQueue::query
-}
-
-// TODO: queue under more complicated situations not involving just a single buffer
-TEST_P(IGraphicBufferProducerTest, Queue_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)));
-
-    EXPECT_LE(0, dequeuedSlot);
-    EXPECT_GT(BufferQueue::NUM_BUFFER_SLOTS, dequeuedSlot);
-
-    // Request the buffer (pre-requisite for queueing)
-    sp<GraphicBuffer> dequeuedBuffer;
-    ASSERT_OK(mProducer->requestBuffer(dequeuedSlot, &dequeuedBuffer));
-
-    // A generic "valid" input
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-
-    // Queue the buffer back into the BQ
-    ASSERT_OK(mProducer->queueBuffer(dequeuedSlot, input, &output));
-
-    {
-        EXPECT_EQ(DEFAULT_WIDTH, output.width);
-        EXPECT_EQ(DEFAULT_HEIGHT, output.height);
-        EXPECT_EQ(DEFAULT_TRANSFORM_HINT, output.transformHint);
-
-        // Since queueBuffer was called exactly once
-        if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-            // TODO(b/70041889): BufferHubProducer need to support metadata: numPendingBuffers
-            EXPECT_EQ(1u, output.numPendingBuffers);
-            // TODO(b/70041952): BufferHubProducer need to support metadata: nextFrameNumber
-            EXPECT_EQ(2u, output.nextFrameNumber);
-        }
-    }
-
-    // Buffer was not in the dequeued state
-    EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-}
-
-TEST_P(IGraphicBufferProducerTest, Queue_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // Invalid slot number
-    {
-        // A generic "valid" input
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(/*slot*/-1, input, &output));
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(/*slot*/0xDEADBEEF, input, &output));
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(BufferQueue::NUM_BUFFER_SLOTS,
-                                                    input, &output));
-    }
-
-    // Slot was not in the dequeued state (all slots start out in Free state)
-    {
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(/*slot*/0, input, &output));
-    }
-
-    // Put the slot into the "dequeued" state for the rest of the test
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)));
-
-    // Slot was enqueued without requesting a buffer
-    {
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Request the buffer so that the rest of the tests don't fail on earlier checks.
-    sp<GraphicBuffer> dequeuedBuffer;
-    ASSERT_OK(mProducer->requestBuffer(dequeuedSlot, &dequeuedBuffer));
-
-    // Fence was NULL
-    {
-        sp<Fence> nullFence = NULL;
-
-        IGraphicBufferProducer::QueueBufferInput input =
-                QueueBufferInputBuilder().setFence(nullFence).build();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Scaling mode was unknown
-    {
-        IGraphicBufferProducer::QueueBufferInput input =
-                QueueBufferInputBuilder().setScalingMode(-1).build();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-
-        input = QueueBufferInputBuilder().setScalingMode(0xDEADBEEF).build();
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Crop rect is out of bounds of the buffer dimensions
-    {
-        IGraphicBufferProducer::QueueBufferInput input =
-                QueueBufferInputBuilder().setCrop(Rect(DEFAULT_WIDTH + 1, DEFAULT_HEIGHT + 1))
-                .build();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Abandon the buffer queue so that the last test fails
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // The buffer queue has been abandoned.
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        // TODO(b/73267953): Make BufferHub honor producer and consumer connection.
-        EXPECT_EQ(NO_INIT, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-}
-
-TEST_P(IGraphicBufferProducerTest, CancelBuffer_DoesntCrash) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)));
-
-    // No return code, but at least test that it doesn't blow up...
-    // TODO: add a return code
-    mProducer->cancelBuffer(dequeuedSlot, dequeuedFence);
-}
-
-TEST_P(IGraphicBufferProducerTest, SetMaxDequeuedBufferCount_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    int minUndequeuedBuffers;
-    ASSERT_OK(mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-            &minUndequeuedBuffers));
-
-    const int minBuffers = 1;
-    const int maxBuffers = BufferQueue::NUM_BUFFER_SLOTS - minUndequeuedBuffers;
-
-    ASSERT_OK(mProducer->setAsyncMode(false)) << "async mode: " << false;
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(minBuffers))
-            << "bufferCount: " << minBuffers;
-
-    // Should now be able to dequeue up to minBuffers times
-    DequeueBufferResult result;
-    for (int i = 0; i < minBuffers; ++i) {
-
-        EXPECT_EQ(OK, ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                (dequeueBuffer(DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                              TEST_PRODUCER_USAGE_BITS, &result)))
-                << "iteration: " << i << ", slot: " << result.slot;
-    }
-
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(maxBuffers));
-
-    // queue the first buffer to enable max dequeued buffer count checking
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<GraphicBuffer> buffer;
-    ASSERT_OK(mProducer->requestBuffer(result.slot, &buffer));
-    ASSERT_OK(mProducer->queueBuffer(result.slot, input, &output));
-
-
-    // Should now be able to dequeue up to maxBuffers times
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-    for (int i = 0; i < maxBuffers; ++i) {
-        EXPECT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "iteration: " << i << ", slot: " << dequeuedSlot;
-    }
-
-    // Cancel a buffer, so we can decrease the buffer count
-    ASSERT_OK(mProducer->cancelBuffer(dequeuedSlot, dequeuedFence));
-
-    // Should now be able to decrease the max dequeued count by 1
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(maxBuffers-1));
-}
-
-TEST_P(IGraphicBufferProducerTest, SetMaxDequeuedBufferCount_Fails) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    int minUndequeuedBuffers;
-    ASSERT_OK(mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-                               &minUndequeuedBuffers));
-
-    const int minBuffers = 1;
-    const int maxBuffers = BufferQueue::NUM_BUFFER_SLOTS - minUndequeuedBuffers;
-
-    ASSERT_OK(mProducer->setAsyncMode(false)) << "async mode: " << false;
-    // Buffer count was out of range
-    EXPECT_EQ(BAD_VALUE, mProducer->setMaxDequeuedBufferCount(0))
-            << "bufferCount: " << 0;
-    EXPECT_EQ(BAD_VALUE, mProducer->setMaxDequeuedBufferCount(maxBuffers + 1))
-            << "bufferCount: " << maxBuffers + 1;
-
-    // Set max dequeue count to 2
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(2));
-    // Dequeue 2 buffers
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-    for (int i = 0; i < 2; i++) {
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "slot: " << dequeuedSlot;
-    }
-
-    // Client has too many buffers dequeued
-    EXPECT_EQ(BAD_VALUE, mProducer->setMaxDequeuedBufferCount(1))
-            << "bufferCount: " << minBuffers;
-
-    // Abandon buffer queue
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // Fail because the buffer queue was abandoned
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/73267953): Make BufferHub honor producer and consumer connection.
-        EXPECT_EQ(NO_INIT, mProducer->setMaxDequeuedBufferCount(minBuffers))
-                << "bufferCount: " << minBuffers;
-    }
-}
-
-TEST_P(IGraphicBufferProducerTest, SetAsyncMode_Succeeds) {
-    if (GetParam() == USE_BUFFER_HUB_PRODUCER) {
-        // TODO(b/36724099): Add support for BufferHubProducer::setAsyncMode(true)
-        return;
-    }
-
-    ASSERT_OK(mConsumer->setMaxAcquiredBufferCount(1)) << "maxAcquire: " << 1;
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    ASSERT_OK(mProducer->setAsyncMode(true)) << "async mode: " << true;
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(1)) << "maxDequeue: " << 1;
-
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<GraphicBuffer> dequeuedBuffer;
-
-    // Should now be able to queue/dequeue as many buffers as we want without
-    // blocking
-    for (int i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "slot : " << dequeuedSlot;
-        ASSERT_OK(mProducer->requestBuffer(dequeuedSlot, &dequeuedBuffer));
-        ASSERT_OK(mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-}
-
-TEST_P(IGraphicBufferProducerTest, SetAsyncMode_Fails) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    // Prerequisite to fail out a valid setBufferCount call
-    {
-        int dequeuedSlot = -1;
-        sp<Fence> dequeuedFence;
-
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "slot: " << dequeuedSlot;
-    }
-
-    // Abandon buffer queue
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // Fail because the buffer queue was abandoned
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/36724099): Make BufferHub honor producer and consumer connection.
-        EXPECT_EQ(NO_INIT, mProducer->setAsyncMode(false)) << "asyncMode: " << false;
-    }
-}
-
-TEST_P(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_dequeueBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-
-    ASSERT_EQ(NO_INIT,
-              mProducer->dequeueBuffer(&slot, &fence, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                       TEST_PRODUCER_USAGE_BITS, nullptr, nullptr));
-}
-
-TEST_P(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_detachNextBuffer) {
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/38137191): Implement BufferHubProducer::detachBuffer
-        ASSERT_EQ(NO_INIT, mProducer->detachNextBuffer(&buffer, &fence));
-    }
-}
-
-TEST_P(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_requestBuffer) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int slot = -1;
-    sp<Fence> fence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&slot, &fence, DEFAULT_WIDTH, DEFAULT_HEIGHT,
-                                                DEFAULT_FORMAT, TEST_PRODUCER_USAGE_BITS,
-                                                nullptr, nullptr)));
-
-    EXPECT_LE(0, slot);
-    EXPECT_GT(BufferQueue::NUM_BUFFER_SLOTS, slot);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    sp<GraphicBuffer> buffer;
-
-    ASSERT_EQ(NO_INIT, mProducer->requestBuffer(slot, &buffer));
-}
-
-
-TEST_P(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_detachBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/38137191): Implement BufferHubProducer::detachBuffer
-        ASSERT_EQ(NO_INIT, mProducer->detachBuffer(slot));
-    }
-}
-
-TEST_P(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_queueBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    // A generic "valid" input
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-
-    ASSERT_EQ(NO_INIT, mProducer->queueBuffer(slot, input, &output));
-}
-
-TEST_P(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_cancelBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    ASSERT_EQ(NO_INIT, mProducer->cancelBuffer(slot, fence));
-}
-
-TEST_P(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_attachBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/38137191): Implement BufferHubProducer::detachBuffer
-        ASSERT_OK(mProducer->detachBuffer(slot));
-    }
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    if (GetParam() == USE_BUFFER_QUEUE_PRODUCER) {
-        // TODO(b/69981968): Implement BufferHubProducer::attachBuffer
-        ASSERT_EQ(NO_INIT, mProducer->attachBuffer(&slot, buffer));
-    }
-}
-
-#if USE_BUFFER_HUB_AS_BUFFER_QUEUE
-INSTANTIATE_TEST_CASE_P(IGraphicBufferProducerBackends, IGraphicBufferProducerTest,
-                        ::testing::Values(USE_BUFFER_QUEUE_PRODUCER, USE_BUFFER_HUB_PRODUCER));
-#else
-// TODO(b/70046255): Remove the #ifdef here and always tests both backends once BufferHubQueue can
-// pass all existing libgui tests.
-INSTANTIATE_TEST_CASE_P(IGraphicBufferProducerBackends, IGraphicBufferProducerTest,
-                        ::testing::Values(USE_BUFFER_QUEUE_PRODUCER));
-#endif
-
-} // namespace android
diff --git a/libs/gui/tests/Malicious.cpp b/libs/gui/tests/Malicious.cpp
deleted file mode 100644
index bb6b8a59f..000000000
--- a/libs/gui/tests/Malicious.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gui/BufferQueue.h>
-#include <gui/IProducerListener.h>
-#include <gui/Surface.h>
-
-#include <android/native_window.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-namespace test {
-
-class ProxyBQP : public BnGraphicBufferProducer {
-public:
-    ProxyBQP(const sp<IGraphicBufferProducer>& producer) : mProducer(producer) {}
-
-    // Pass through calls to mProducer
-    status_t requestBuffer(int slot, sp<GraphicBuffer>* buf) override {
-        return mProducer->requestBuffer(slot, buf);
-    }
-    status_t setMaxDequeuedBufferCount(int maxDequeuedBuffers) override {
-        return mProducer->setMaxDequeuedBufferCount(maxDequeuedBuffers);
-    }
-    status_t setAsyncMode(bool async) override { return mProducer->setAsyncMode(async); }
-    status_t dequeueBuffer(int* slot, sp<Fence>* fence, uint32_t w, uint32_t h, PixelFormat format,
-                           uint64_t usage, uint64_t* outBufferAge,
-                           FrameEventHistoryDelta* outTimestamps) override {
-        return mProducer->dequeueBuffer(slot, fence, w, h, format, usage, outBufferAge,
-                                        outTimestamps);
-    }
-    status_t detachBuffer(int slot) override { return mProducer->detachBuffer(slot); }
-    status_t detachNextBuffer(sp<GraphicBuffer>* outBuffer, sp<Fence>* outFence) override {
-        return mProducer->detachNextBuffer(outBuffer, outFence);
-    }
-    status_t attachBuffer(int* outSlot, const sp<GraphicBuffer>& buffer) override {
-        return mProducer->attachBuffer(outSlot, buffer);
-    }
-    status_t queueBuffer(int slot, const QueueBufferInput& input,
-                         QueueBufferOutput* output) override {
-        return mProducer->queueBuffer(slot, input, output);
-    }
-    status_t cancelBuffer(int slot, const sp<Fence>& fence) override {
-        return mProducer->cancelBuffer(slot, fence);
-    }
-    int query(int what, int* value) override { return mProducer->query(what, value); }
-    status_t connect(const sp<IProducerListener>& listener, int api, bool producerControlledByApp,
-                     QueueBufferOutput* output) override {
-        return mProducer->connect(listener, api, producerControlledByApp, output);
-    }
-    status_t disconnect(int api, DisconnectMode mode) override {
-        return mProducer->disconnect(api, mode);
-    }
-    status_t setSidebandStream(const sp<NativeHandle>& stream) override {
-        return mProducer->setSidebandStream(stream);
-    }
-    void allocateBuffers(uint32_t width, uint32_t height, PixelFormat format,
-                         uint64_t usage) override {
-        mProducer->allocateBuffers(width, height, format, usage);
-    }
-    status_t allowAllocation(bool allow) override { return mProducer->allowAllocation(allow); }
-    status_t setGenerationNumber(uint32_t generationNumber) override {
-        return mProducer->setGenerationNumber(generationNumber);
-    }
-    String8 getConsumerName() const override { return mProducer->getConsumerName(); }
-    status_t setSharedBufferMode(bool sharedBufferMode) override {
-        return mProducer->setSharedBufferMode(sharedBufferMode);
-    }
-    status_t setAutoRefresh(bool autoRefresh) override {
-        return mProducer->setAutoRefresh(autoRefresh);
-    }
-    status_t setDequeueTimeout(nsecs_t timeout) override {
-        return mProducer->setDequeueTimeout(timeout);
-    }
-    status_t getLastQueuedBuffer(sp<GraphicBuffer>* outBuffer, sp<Fence>* outFence,
-                                 float outTransformMatrix[16]) override {
-        return mProducer->getLastQueuedBuffer(outBuffer, outFence, outTransformMatrix);
-    }
-    void getFrameTimestamps(FrameEventHistoryDelta*) override {}
-    status_t getUniqueId(uint64_t* outId) const override { return mProducer->getUniqueId(outId); }
-    status_t getConsumerUsage(uint64_t* outUsage) const override {
-        return mProducer->getConsumerUsage(outUsage);
-    }
-
-protected:
-    sp<IGraphicBufferProducer> mProducer;
-};
-
-class MaliciousBQP : public ProxyBQP {
-public:
-    MaliciousBQP(const sp<IGraphicBufferProducer>& producer) : ProxyBQP(producer) {}
-
-    void beMalicious(int32_t value) { mMaliciousValue = value; }
-
-    void setExpectedSlot(int32_t slot) { mExpectedSlot = slot; }
-
-    // Override dequeueBuffer, optionally corrupting the returned slot number
-    status_t dequeueBuffer(int* buf, sp<Fence>* fence, uint32_t width, uint32_t height,
-                           PixelFormat format, uint64_t usage, uint64_t* outBufferAge,
-                           FrameEventHistoryDelta* outTimestamps) override {
-        EXPECT_EQ(BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(buf, fence, width, height, format, usage, outBufferAge,
-                                           outTimestamps));
-        EXPECT_EQ(mExpectedSlot, *buf);
-        if (mMaliciousValue != 0) {
-            *buf = mMaliciousValue;
-            return NO_ERROR;
-        } else {
-            return BUFFER_NEEDS_REALLOCATION;
-        }
-    }
-
-private:
-    int32_t mMaliciousValue = 0;
-    int32_t mExpectedSlot = 0;
-};
-
-class DummyListener : public BnConsumerListener {
-public:
-    void onFrameAvailable(const BufferItem&) override {}
-    void onBuffersReleased() override {}
-    void onSidebandStreamChanged() override {}
-};
-
-sp<MaliciousBQP> getMaliciousBQP() {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<IConsumerListener> listener = new DummyListener;
-    consumer->consumerConnect(listener, false);
-
-    sp<MaliciousBQP> malicious = new MaliciousBQP(producer);
-    return malicious;
-}
-
-TEST(Malicious, Bug36991414Max) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(std::numeric_limits<int32_t>::max());
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-TEST(Malicious, Bug36991414Min) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(std::numeric_limits<int32_t>::min());
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-TEST(Malicious, Bug36991414NegativeOne) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(-1);
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-TEST(Malicious, Bug36991414NumSlots) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(BufferQueueDefs::NUM_BUFFER_SLOTS);
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-} // namespace test
-} // namespace android
diff --git a/libs/gui/tests/MultiTextureConsumer_test.cpp b/libs/gui/tests/MultiTextureConsumer_test.cpp
deleted file mode 100644
index 3a25ac59c..000000000
--- a/libs/gui/tests/MultiTextureConsumer_test.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "MultiTextureConsumer_test"
-//#define LOG_NDEBUG 0
-
-#include "GLTest.h"
-
-#include <gui/GLConsumer.h>
-#include <gui/Surface.h>
-
-#include <android/native_window.h>
-
-#include <GLES/glext.h>
-
-namespace android {
-
-class MultiTextureConsumerTest : public GLTest {
-protected:
-    enum { TEX_ID = 123 };
-
-    virtual void SetUp() {
-        GLTest::SetUp();
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        mGlConsumer = new GLConsumer(consumer, TEX_ID,
-                GLConsumer::TEXTURE_EXTERNAL, true, false);
-        mSurface = new Surface(producer);
-        mANW = mSurface.get();
-
-    }
-    virtual void TearDown() {
-        GLTest::TearDown();
-    }
-    virtual EGLint const* getContextAttribs() {
-        return NULL;
-    }
-    virtual EGLint const* getConfigAttribs() {
-        static EGLint sDefaultConfigAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-            EGL_RED_SIZE, 8,
-            EGL_GREEN_SIZE, 8,
-            EGL_BLUE_SIZE, 8,
-            EGL_ALPHA_SIZE, 8,
-            EGL_NONE };
-
-        return sDefaultConfigAttribs;
-    }
-    sp<GLConsumer> mGlConsumer;
-    sp<Surface> mSurface;
-    ANativeWindow* mANW;
-};
-
-TEST_F(MultiTextureConsumerTest, EGLImageTargetWorks) {
-    ANativeWindow_Buffer buffer;
-
-    ASSERT_EQ(native_window_set_usage(mANW, GRALLOC_USAGE_SW_WRITE_OFTEN), NO_ERROR);
-    ASSERT_EQ(native_window_set_buffers_format(mANW, HAL_PIXEL_FORMAT_RGBA_8888), NO_ERROR);
-
-    glShadeModel(GL_FLAT);
-    glDisable(GL_DITHER);
-    glDisable(GL_CULL_FACE);
-    glViewport(0, 0, getSurfaceWidth(), getSurfaceHeight());
-    glOrthof(0, getSurfaceWidth(), 0, getSurfaceHeight(), 0, 1);
-    glEnableClientState(GL_VERTEX_ARRAY);
-    glColor4f(1, 1, 1, 1);
-
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, TEX_ID);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-
-    uint32_t texel = 0x80808080;
-    glBindTexture(GL_TEXTURE_2D, TEX_ID+1);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, &texel);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_2D, TEX_ID+1);
-    glEnable(GL_TEXTURE_2D);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, TEX_ID);
-    glEnable(GL_TEXTURE_EXTERNAL_OES);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-
-    glClear(GL_COLOR_BUFFER_BIT);
-    for (int i=0 ; i<8 ; i++) {
-        mSurface->lock(&buffer, NULL);
-        memset(buffer.bits, (i&7) * 0x20, buffer.stride * buffer.height * 4);
-        mSurface->unlockAndPost();
-
-        mGlConsumer->updateTexImage();
-
-        GLfloat vertices[][2] = { {i*16.0f, 0}, {(i+1)*16.0f, 0}, {(i+1)*16.0f, 16.0f}, {i*16.0f, 16.0f} };
-        glVertexPointer(2, GL_FLOAT, 0, vertices);
-        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    }
-
-    for (int i=0 ; i<8 ; i++) {
-        EXPECT_TRUE(checkPixel(i*16 + 8,  8, i*16, i*16, i*16, i*16, 0));
-    }
-}
-
-} // namespace android
diff --git a/libs/gui/tests/StreamSplitter_test.cpp b/libs/gui/tests/StreamSplitter_test.cpp
deleted file mode 100644
index ad6e05168..000000000
--- a/libs/gui/tests/StreamSplitter_test.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "StreamSplitter_test"
-//#define LOG_NDEBUG 0
-
-#include <gui/BufferItem.h>
-#include <gui/BufferQueue.h>
-#include <gui/IConsumerListener.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/StreamSplitter.h>
-#include <private/gui/ComposerService.h>
-
-#include <system/window.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-class StreamSplitterTest : public ::testing::Test {
-
-protected:
-    StreamSplitterTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    ~StreamSplitterTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-};
-
-struct DummyListener : public BnConsumerListener {
-    virtual void onFrameAvailable(const BufferItem& /* item */) {}
-    virtual void onBuffersReleased() {}
-    virtual void onSidebandStreamChanged() {}
-};
-
-static const uint32_t TEST_DATA = 0x12345678u;
-
-TEST_F(StreamSplitterTest, OneInputOneOutput) {
-    sp<IGraphicBufferProducer> inputProducer;
-    sp<IGraphicBufferConsumer> inputConsumer;
-    BufferQueue::createBufferQueue(&inputProducer, &inputConsumer);
-
-    sp<IGraphicBufferProducer> outputProducer;
-    sp<IGraphicBufferConsumer> outputConsumer;
-    BufferQueue::createBufferQueue(&outputProducer, &outputConsumer);
-    ASSERT_EQ(OK, outputConsumer->consumerConnect(new DummyListener, false));
-
-    sp<StreamSplitter> splitter;
-    status_t status = StreamSplitter::createSplitter(inputConsumer, &splitter);
-    ASSERT_EQ(OK, status);
-    ASSERT_EQ(OK, splitter->addOutput(outputProducer));
-
-    // Never allow the output BufferQueue to allocate a buffer
-    ASSERT_EQ(OK, outputProducer->allowAllocation(false));
-
-    IGraphicBufferProducer::QueueBufferOutput qbOutput;
-    ASSERT_EQ(OK, inputProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &qbOutput));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-    ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
-
-    // Now that we have dequeued/allocated one buffer, prevent any further
-    // allocations
-    ASSERT_EQ(OK, inputProducer->allowAllocation(false));
-
-    BufferItem item;
-    ASSERT_EQ(OK, outputConsumer->acquireBuffer(&item, 0));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-
-    ASSERT_EQ(OK, outputConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // This should succeed even with allocation disabled since it will have
-    // received the buffer back from the output BufferQueue
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-}
-
-TEST_F(StreamSplitterTest, OneInputMultipleOutputs) {
-    const int NUM_OUTPUTS = 4;
-
-    sp<IGraphicBufferProducer> inputProducer;
-    sp<IGraphicBufferConsumer> inputConsumer;
-    BufferQueue::createBufferQueue(&inputProducer, &inputConsumer);
-
-    sp<IGraphicBufferProducer> outputProducers[NUM_OUTPUTS] = {};
-    sp<IGraphicBufferConsumer> outputConsumers[NUM_OUTPUTS] = {};
-    for (int output = 0; output < NUM_OUTPUTS; ++output) {
-        BufferQueue::createBufferQueue(&outputProducers[output],
-                &outputConsumers[output]);
-        ASSERT_EQ(OK, outputConsumers[output]->consumerConnect(
-                    new DummyListener, false));
-    }
-
-    sp<StreamSplitter> splitter;
-    status_t status = StreamSplitter::createSplitter(inputConsumer, &splitter);
-    ASSERT_EQ(OK, status);
-    for (int output = 0; output < NUM_OUTPUTS; ++output) {
-        ASSERT_EQ(OK, splitter->addOutput(outputProducers[output]));
-
-        // Never allow the output BufferQueues to allocate a buffer
-        ASSERT_EQ(OK, outputProducers[output]->allowAllocation(false));
-    }
-
-    IGraphicBufferProducer::QueueBufferOutput qbOutput;
-    ASSERT_EQ(OK, inputProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &qbOutput));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-    ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
-
-    // Now that we have dequeued/allocated one buffer, prevent any further
-    // allocations
-    ASSERT_EQ(OK, inputProducer->allowAllocation(false));
-
-    for (int output = 0; output < NUM_OUTPUTS; ++output) {
-        BufferItem item;
-        ASSERT_EQ(OK, outputConsumers[output]->acquireBuffer(&item, 0));
-
-        uint32_t* dataOut;
-        ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-                    reinterpret_cast<void**>(&dataOut)));
-        ASSERT_EQ(*dataOut, TEST_DATA);
-        ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-
-        ASSERT_EQ(OK, outputConsumers[output]->releaseBuffer(item.mSlot,
-                    item.mFrameNumber, EGL_NO_DISPLAY, EGL_NO_SYNC_KHR,
-                    Fence::NO_FENCE));
-    }
-
-    // This should succeed even with allocation disabled since it will have
-    // received the buffer back from the output BufferQueues
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-}
-
-TEST_F(StreamSplitterTest, OutputAbandonment) {
-    sp<IGraphicBufferProducer> inputProducer;
-    sp<IGraphicBufferConsumer> inputConsumer;
-    BufferQueue::createBufferQueue(&inputProducer, &inputConsumer);
-
-    sp<IGraphicBufferProducer> outputProducer;
-    sp<IGraphicBufferConsumer> outputConsumer;
-    BufferQueue::createBufferQueue(&outputProducer, &outputConsumer);
-    ASSERT_EQ(OK, outputConsumer->consumerConnect(new DummyListener, false));
-
-    sp<StreamSplitter> splitter;
-    status_t status = StreamSplitter::createSplitter(inputConsumer, &splitter);
-    ASSERT_EQ(OK, status);
-    ASSERT_EQ(OK, splitter->addOutput(outputProducer));
-
-    IGraphicBufferProducer::QueueBufferOutput qbOutput;
-    ASSERT_EQ(OK, inputProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &qbOutput));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-    ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
-
-    // Abandon the output
-    outputConsumer->consumerDisconnect();
-
-    IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
-
-    // Input should be abandoned
-    ASSERT_EQ(NO_INIT,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceParcelable_test.cpp b/libs/gui/tests/SurfaceParcelable_test.cpp
deleted file mode 100644
index 686dc82f3..000000000
--- a/libs/gui/tests/SurfaceParcelable_test.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceParcelable_test"
-
-#include <gtest/gtest.h>
-
-#include <binder/IServiceManager.h>
-#include <binder/ProcessState.h>
-#include <gui/BufferHubProducer.h>
-#include <gui/BufferQueue.h>
-#include <gui/view/Surface.h>
-#include <utils/Log.h>
-
-namespace android {
-
-static const String16 kTestServiceName = String16("SurfaceParcelableTestService");
-static const String16 kSurfaceName = String16("TEST_SURFACE");
-static const uint32_t kBufferWidth = 100;
-static const uint32_t kBufferHeight = 1;
-static const uint32_t kBufferFormat = HAL_PIXEL_FORMAT_BLOB;
-
-enum SurfaceParcelableTestServiceCode {
-    CREATE_BUFFER_QUEUE_SURFACE = IBinder::FIRST_CALL_TRANSACTION,
-    CREATE_BUFFER_HUB_SURFACE,
-};
-
-class SurfaceParcelableTestService : public BBinder {
-public:
-    SurfaceParcelableTestService() {
-        // BufferQueue
-        BufferQueue::createBufferQueue(&mBufferQueueProducer, &mBufferQueueConsumer);
-
-        // BufferHub
-        dvr::ProducerQueueConfigBuilder configBuilder;
-        mProducerQueue = dvr::ProducerQueue::Create(configBuilder.SetDefaultWidth(kBufferWidth)
-                                                            .SetDefaultHeight(kBufferHeight)
-                                                            .SetDefaultFormat(kBufferFormat)
-                                                            .Build(),
-                                                    dvr::UsagePolicy{});
-        mBufferHubProducer = BufferHubProducer::Create(mProducerQueue);
-    }
-
-    ~SurfaceParcelableTestService() = default;
-
-    virtual status_t onTransact(uint32_t code, const Parcel& /*data*/, Parcel* reply,
-                                uint32_t /*flags*/ = 0) {
-        switch (code) {
-            case CREATE_BUFFER_QUEUE_SURFACE: {
-                view::Surface surfaceShim;
-                surfaceShim.name = kSurfaceName;
-                surfaceShim.graphicBufferProducer = mBufferQueueProducer;
-                return surfaceShim.writeToParcel(reply);
-            }
-            case CREATE_BUFFER_HUB_SURFACE: {
-                view::Surface surfaceShim;
-                surfaceShim.name = kSurfaceName;
-                surfaceShim.graphicBufferProducer = mBufferHubProducer;
-                return surfaceShim.writeToParcel(reply);
-            }
-            default:
-                return UNKNOWN_TRANSACTION;
-        };
-    }
-
-protected:
-    sp<IGraphicBufferProducer> mBufferQueueProducer;
-    sp<IGraphicBufferConsumer> mBufferQueueConsumer;
-
-    std::shared_ptr<dvr::ProducerQueue> mProducerQueue;
-    sp<IGraphicBufferProducer> mBufferHubProducer;
-};
-
-static int runBinderServer() {
-    ProcessState::self()->startThreadPool();
-
-    sp<IServiceManager> sm = defaultServiceManager();
-    sp<SurfaceParcelableTestService> service = new SurfaceParcelableTestService;
-    sm->addService(kTestServiceName, service, false);
-
-    ALOGI("Binder server running...");
-
-    while (true) {
-        int stat, retval;
-        retval = wait(&stat);
-        if (retval == -1 && errno == ECHILD) {
-            break;
-        }
-    }
-
-    ALOGI("Binder server exiting...");
-    return 0;
-}
-
-class SurfaceParcelableTest : public ::testing::TestWithParam<uint32_t> {
-protected:
-    virtual void SetUp() {
-        mService = defaultServiceManager()->getService(kTestServiceName);
-        if (mService == nullptr) {
-            ALOGE("Failed to connect to the test service.");
-            return;
-        }
-
-        ALOGI("Binder service is ready for client.");
-    }
-
-    status_t GetSurface(view::Surface* surfaceShim) {
-        ALOGI("...Test: %d", GetParam());
-
-        uint32_t opCode = GetParam();
-        Parcel data;
-        Parcel reply;
-        status_t error = mService->transact(opCode, data, &reply);
-        if (error != NO_ERROR) {
-            ALOGE("Failed to get surface over binder, error=%d.", error);
-            return error;
-        }
-
-        error = surfaceShim->readFromParcel(&reply);
-        if (error != NO_ERROR) {
-            ALOGE("Failed to get surface from parcel, error=%d.", error);
-            return error;
-        }
-
-        return NO_ERROR;
-    }
-
-private:
-    sp<IBinder> mService;
-};
-
-TEST_P(SurfaceParcelableTest, SendOverBinder) {
-    view::Surface surfaceShim;
-    EXPECT_EQ(GetSurface(&surfaceShim), NO_ERROR);
-    EXPECT_EQ(surfaceShim.name, kSurfaceName);
-    EXPECT_FALSE(surfaceShim.graphicBufferProducer == nullptr);
-}
-
-INSTANTIATE_TEST_CASE_P(SurfaceBackends, SurfaceParcelableTest,
-                        ::testing::Values(CREATE_BUFFER_QUEUE_SURFACE, CREATE_BUFFER_HUB_SURFACE));
-
-} // namespace android
-
-int main(int argc, char** argv) {
-    pid_t pid = fork();
-    if (pid == 0) {
-        android::ProcessState::self()->startThreadPool();
-        ::testing::InitGoogleTest(&argc, argv);
-        return RUN_ALL_TESTS();
-
-    } else {
-        ALOGI("Test process pid: %d.", pid);
-        return android::runBinderServer();
-    }
-}
diff --git a/libs/gui/tests/SurfaceTextureClient_test.cpp b/libs/gui/tests/SurfaceTextureClient_test.cpp
deleted file mode 100644
index d5b2f004e..000000000
--- a/libs/gui/tests/SurfaceTextureClient_test.cpp
+++ /dev/null
@@ -1,811 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureClient_test"
-//#define LOG_NDEBUG 0
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-
-#include <gtest/gtest.h>
-#include <gui/GLConsumer.h>
-#include <gui/Surface.h>
-#include <gui/BufferQueue.h>
-#include <system/graphics.h>
-#include <utils/Log.h>
-#include <utils/Thread.h>
-
-extern "C" EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name);
-#define CROP_EXT_STR "EGL_ANDROID_image_crop"
-
-namespace android {
-
-class SurfaceTextureClientTest : public ::testing::Test {
-protected:
-    SurfaceTextureClientTest():
-            mEglDisplay(EGL_NO_DISPLAY),
-            mEglSurface(EGL_NO_SURFACE),
-            mEglContext(EGL_NO_CONTEXT),
-            mEglConfig(NULL) {
-    }
-
-    virtual void SetUp() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        mST = new GLConsumer(consumer, 123, GLConsumer::TEXTURE_EXTERNAL, true,
-                false);
-        mSTC = new Surface(producer);
-        mANW = mSTC;
-
-        // We need a valid GL context so we can test updateTexImage()
-        // This initializes EGL and create a dummy GL context with a
-        // pbuffer render target.
-        mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-
-        EGLint majorVersion, minorVersion;
-        EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        EGLConfig myConfig;
-        EGLint numConfigs = 0;
-        EXPECT_TRUE(eglChooseConfig(mEglDisplay, getConfigAttribs(),
-                &myConfig, 1, &numConfigs));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        mEglConfig = myConfig;
-        EGLint pbufferAttribs[] = {
-            EGL_WIDTH, 16,
-            EGL_HEIGHT, 16,
-            EGL_NONE };
-        mEglSurface = eglCreatePbufferSurface(mEglDisplay, myConfig, pbufferAttribs);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_SURFACE, mEglSurface);
-
-        mEglContext = eglCreateContext(mEglDisplay, myConfig, EGL_NO_CONTEXT, 0);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mEglContext);
-
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    }
-
-    virtual void TearDown() {
-        mST.clear();
-        mSTC.clear();
-        mANW.clear();
-
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-        eglDestroyContext(mEglDisplay, mEglContext);
-        eglDestroySurface(mEglDisplay, mEglSurface);
-        eglTerminate(mEglDisplay);
-
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    virtual EGLint const* getConfigAttribs() {
-        static EGLint sDefaultConfigAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_PBUFFER_BIT | EGL_WINDOW_BIT,
-            EGL_NONE
-        };
-
-        return sDefaultConfigAttribs;
-    }
-
-    sp<GLConsumer> mST;
-    sp<Surface> mSTC;
-    sp<ANativeWindow> mANW;
-
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurface;
-    EGLContext mEglContext;
-    EGLConfig  mEglConfig;
-};
-
-TEST_F(SurfaceTextureClientTest, GetISurfaceTextureIsNotNull) {
-    sp<IGraphicBufferProducer> ist(mSTC->getIGraphicBufferProducer());
-    ASSERT_TRUE(ist != NULL);
-}
-
-TEST_F(SurfaceTextureClientTest, QueuesToWindowCompositorIsFalse) {
-    int result = -123;
-    int err = mANW->query(mANW.get(), NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,
-            &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(0, result);
-}
-
-TEST_F(SurfaceTextureClientTest, ConcreteTypeIsSurfaceTextureClient) {
-    int result = -123;
-    int err = mANW->query(mANW.get(), NATIVE_WINDOW_CONCRETE_TYPE, &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(NATIVE_WINDOW_SURFACE, result);
-}
-
-TEST_F(SurfaceTextureClientTest, EglCreateWindowSurfaceSucceeds) {
-    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_DISPLAY, dpy);
-
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EXPECT_TRUE(eglInitialize(dpy, &majorVersion, &minorVersion));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLConfig myConfig = {0};
-    EGLint numConfigs = 0;
-    EGLint configAttribs[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE, 8,
-        EGL_GREEN_SIZE, 8,
-        EGL_BLUE_SIZE, 8,
-        EGL_ALPHA_SIZE, 8,
-        EGL_DEPTH_SIZE, 16,
-        EGL_STENCIL_SIZE, 8,
-        EGL_NONE };
-    EXPECT_TRUE(eglChooseConfig(dpy, configAttribs, &myConfig, 1,
-            &numConfigs));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLSurface eglSurface = eglCreateWindowSurface(dpy, myConfig, mANW.get(),
-            NULL);
-    EXPECT_NE(EGL_NO_SURFACE, eglSurface);
-    EXPECT_EQ(EGL_SUCCESS, eglGetError());
-
-    if (eglSurface != EGL_NO_SURFACE) {
-        eglDestroySurface(dpy, eglSurface);
-    }
-
-    eglTerminate(dpy);
-}
-
-TEST_F(SurfaceTextureClientTest, EglSwapBuffersAbandonErrorIsEglBadSurface) {
-
-    EGLSurface eglSurface = eglCreateWindowSurface(mEglDisplay, mEglConfig, mANW.get(), NULL);
-    EXPECT_NE(EGL_NO_SURFACE, eglSurface);
-    EXPECT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLBoolean success = eglMakeCurrent(mEglDisplay, eglSurface, eglSurface, mEglContext);
-    EXPECT_TRUE(success);
-
-    glClear(GL_COLOR_BUFFER_BIT);
-    success = eglSwapBuffers(mEglDisplay, eglSurface);
-    EXPECT_TRUE(success);
-
-    mST->abandon();
-
-    glClear(GL_COLOR_BUFFER_BIT);
-    success = eglSwapBuffers(mEglDisplay, eglSurface);
-    EXPECT_FALSE(success);
-    EXPECT_EQ(EGL_BAD_SURFACE, eglGetError());
-
-    success = eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext);
-    ASSERT_TRUE(success);
-
-    if (eglSurface != EGL_NO_SURFACE) {
-        eglDestroySurface(mEglDisplay, eglSurface);
-    }
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometryInvalidSizesFail) {
-    EXPECT_GT(OK, native_window_set_buffers_dimensions(mANW.get(),  0,  8));
-    EXPECT_GT(OK, native_window_set_buffers_dimensions(mANW.get(),  8,  0));
-}
-
-TEST_F(SurfaceTextureClientTest, DefaultGeometryValues) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometryCanBeSet) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometryDefaultSizeSetFormat) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometrySetSizeDefaultFormat) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometrySizeCanBeUnset) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometrySizeCanBeChangedWithoutFormat) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSetDefaultSize) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    sp<GLConsumer> st(mST);
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, st->setDefaultBufferSize(16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSetDefaultSizeAfterDequeue) {
-    ANativeWindowBuffer* buf[2];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, mST->setDefaultBufferSize(16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_EQ(16, buf[0]->width);
-    EXPECT_EQ(16, buf[1]->width);
-    EXPECT_EQ(8, buf[0]->height);
-    EXPECT_EQ(8, buf[1]->height);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSetDefaultSizeVsGeometry) {
-    ANativeWindowBuffer* buf[2];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    EXPECT_EQ(OK, mST->setDefaultBufferSize(16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_EQ(16, buf[0]->width);
-    EXPECT_EQ(16, buf[1]->width);
-    EXPECT_EQ(8, buf[0]->height);
-    EXPECT_EQ(8, buf[1]->height);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 12, 24));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_EQ(12, buf[0]->width);
-    EXPECT_EQ(12, buf[1]->width);
-    EXPECT_EQ(24, buf[0]->height);
-    EXPECT_EQ(24, buf[1]->height);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureTooManyUpdateTexImage) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, mANW->setSwapInterval(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(OK, mST->updateTexImage());
-
-    ASSERT_EQ(OK, mANW->setSwapInterval(mANW.get(), 1));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(OK, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeSlowRetire) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_NE(buf[1], buf[2]);
-    EXPECT_NE(buf[2], buf[0]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[0]);
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[2]);
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeFastRetire) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_NE(buf[1], buf[2]);
-    EXPECT_NE(buf[2], buf[0]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[0]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[2]);
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeDQQR) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[0]);
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    EXPECT_NE(buf[1], buf[2]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[2]);
-}
-
-// XXX: We currently have no hardware that properly handles dequeuing the
-// buffer that is currently bound to the texture.
-TEST_F(SurfaceTextureClientTest, DISABLED_SurfaceTextureSyncModeDequeueCurrent) {
-    android_native_buffer_t* buf[3];
-    android_native_buffer_t* firstBuf;
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &firstBuf));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), firstBuf, -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), firstBuf);
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_NE(buf[1], buf[2]);
-    EXPECT_NE(buf[2], buf[0]);
-    EXPECT_EQ(firstBuf, buf[2]);
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeMinUndequeued) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-
-    // We should be able to dequeue all the buffers before we've queued mANWy.
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[2], -1));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-
-    // Once we've queued a buffer, however we should not be able to dequeue more
-    // than (buffer-count - MIN_UNDEQUEUED_BUFFERS), which is 2 in this case.
-    EXPECT_EQ(INVALID_OPERATION,
-            native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[2], -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SetCropCropsCrop) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    android_native_rect_t rect = {-2, -13, 40, 18};
-    native_window_set_crop(mANW.get(), &rect);
-
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 4, 4));
-
-    android_native_buffer_t* buf;
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf, -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    Rect crop = mST->getCurrentCrop();
-    EXPECT_EQ(0, crop.left);
-    EXPECT_EQ(0, crop.top);
-    EXPECT_EQ(4, crop.right);
-    EXPECT_EQ(4, crop.bottom);
-}
-
-// XXX: This is not expected to pass until the synchronization hacks are removed
-// from the SurfaceTexture class.
-TEST_F(SurfaceTextureClientTest, DISABLED_SurfaceTextureSyncModeWaitRetire) {
-    class MyThread : public Thread {
-        sp<GLConsumer> mST;
-        EGLContext ctx;
-        EGLSurface sur;
-        EGLDisplay dpy;
-        bool mBufferRetired;
-        Mutex mLock;
-        virtual bool threadLoop() {
-            eglMakeCurrent(dpy, sur, sur, ctx);
-            usleep(20000);
-            Mutex::Autolock _l(mLock);
-            mST->updateTexImage();
-            mBufferRetired = true;
-            eglMakeCurrent(dpy, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-            return false;
-        }
-    public:
-        explicit MyThread(const sp<GLConsumer>& mST)
-            : mST(mST), mBufferRetired(false) {
-            ctx = eglGetCurrentContext();
-            sur = eglGetCurrentSurface(EGL_DRAW);
-            dpy = eglGetCurrentDisplay();
-            eglMakeCurrent(dpy, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-        }
-        ~MyThread() {
-            eglMakeCurrent(dpy, sur, sur, ctx);
-        }
-        void bufferDequeued() {
-            Mutex::Autolock _l(mLock);
-            EXPECT_EQ(true, mBufferRetired);
-        }
-    };
-
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-    // dequeue/queue/update so we have a current buffer
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    mST->updateTexImage();
-
-    MyThread* thread = new MyThread(mST);
-    sp<Thread> threadBase(thread);
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    thread->run("MyThread");
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    //ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    //ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    thread->bufferDequeued();
-    thread->requestExitAndWait();
-}
-
-TEST_F(SurfaceTextureClientTest, GetTransformMatrixReturnsVerticalFlip) {
-    android_native_buffer_t* buf[3];
-    float mtx[16] = {};
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-    mST->getTransformMatrix(mtx);
-
-    EXPECT_EQ(1.f, mtx[0]);
-    EXPECT_EQ(0.f, mtx[1]);
-    EXPECT_EQ(0.f, mtx[2]);
-    EXPECT_EQ(0.f, mtx[3]);
-
-    EXPECT_EQ(0.f, mtx[4]);
-    EXPECT_EQ(-1.f, mtx[5]);
-    EXPECT_EQ(0.f, mtx[6]);
-    EXPECT_EQ(0.f, mtx[7]);
-
-    EXPECT_EQ(0.f, mtx[8]);
-    EXPECT_EQ(0.f, mtx[9]);
-    EXPECT_EQ(1.f, mtx[10]);
-    EXPECT_EQ(0.f, mtx[11]);
-
-    EXPECT_EQ(0.f, mtx[12]);
-    EXPECT_EQ(1.f, mtx[13]);
-    EXPECT_EQ(0.f, mtx[14]);
-    EXPECT_EQ(1.f, mtx[15]);
-}
-
-TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffers) {
-    android_native_buffer_t* buf[3];
-    float mtx[16] = {};
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 6)); // frees buffers
-    mST->getTransformMatrix(mtx);
-
-    EXPECT_EQ(1.f, mtx[0]);
-    EXPECT_EQ(0.f, mtx[1]);
-    EXPECT_EQ(0.f, mtx[2]);
-    EXPECT_EQ(0.f, mtx[3]);
-
-    EXPECT_EQ(0.f, mtx[4]);
-    EXPECT_EQ(-1.f, mtx[5]);
-    EXPECT_EQ(0.f, mtx[6]);
-    EXPECT_EQ(0.f, mtx[7]);
-
-    EXPECT_EQ(0.f, mtx[8]);
-    EXPECT_EQ(0.f, mtx[9]);
-    EXPECT_EQ(1.f, mtx[10]);
-    EXPECT_EQ(0.f, mtx[11]);
-
-    EXPECT_EQ(0.f, mtx[12]);
-    EXPECT_EQ(1.f, mtx[13]);
-    EXPECT_EQ(0.f, mtx[14]);
-    EXPECT_EQ(1.f, mtx[15]);
-}
-
-TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffersWithCrop) {
-    // Query to see if the image crop extension exists
-    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    const char* exts = eglQueryStringImplementationANDROID(dpy, EGL_EXTENSIONS);
-    size_t cropExtLen = strlen(CROP_EXT_STR);
-    size_t extsLen = strlen(exts);
-    bool equal = !strcmp(CROP_EXT_STR, exts);
-    bool atStart = !strncmp(CROP_EXT_STR " ", exts, cropExtLen+1);
-    bool atEnd = (cropExtLen+1) < extsLen &&
-            !strcmp(" " CROP_EXT_STR, exts + extsLen - (cropExtLen+1));
-    bool inMiddle = strstr(exts, " " CROP_EXT_STR " ");
-    bool hasEglAndroidImageCrop = equal || atStart || atEnd || inMiddle;
-
-    android_native_buffer_t* buf[3];
-    float mtx[16] = {};
-    android_native_rect_t crop;
-    crop.left = 0;
-    crop.top = 0;
-    crop.right = 5;
-    crop.bottom = 5;
-
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 8, 8));
-    ASSERT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &crop));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 6)); // frees buffers
-    mST->getTransformMatrix(mtx);
-
-    // If the egl image crop extension is not present, this accounts for the
-    // .5 texel shrink for each edge that's included in the transform matrix
-    // to avoid texturing outside the crop region. Otherwise the crop is not
-    // included in the transform matrix.
-    EXPECT_EQ(hasEglAndroidImageCrop ? 1 : 0.5, mtx[0]);
-    EXPECT_EQ(0.f, mtx[1]);
-    EXPECT_EQ(0.f, mtx[2]);
-    EXPECT_EQ(0.f, mtx[3]);
-
-    EXPECT_EQ(0.f, mtx[4]);
-    EXPECT_EQ(hasEglAndroidImageCrop ? -1 : -0.5, mtx[5]);
-    EXPECT_EQ(0.f, mtx[6]);
-    EXPECT_EQ(0.f, mtx[7]);
-
-    EXPECT_EQ(0.f, mtx[8]);
-    EXPECT_EQ(0.f, mtx[9]);
-    EXPECT_EQ(1.f, mtx[10]);
-    EXPECT_EQ(0.f, mtx[11]);
-
-    EXPECT_EQ(hasEglAndroidImageCrop ? 0 : 0.0625f, mtx[12]);
-    EXPECT_EQ(hasEglAndroidImageCrop ? 1 : 0.5625f, mtx[13]);
-    EXPECT_EQ(0.f, mtx[14]);
-    EXPECT_EQ(1.f, mtx[15]);
-}
-
-// This test verifies that the buffer format can be queried immediately after
-// it is set.
-TEST_F(SurfaceTextureClientTest, QueryFormatAfterSettingWorks) {
-    sp<ANativeWindow> anw(mSTC);
-    int fmts[] = {
-        // RGBA_8888 should not come first, as it's the default
-        HAL_PIXEL_FORMAT_RGBX_8888,
-        HAL_PIXEL_FORMAT_RGBA_8888,
-        HAL_PIXEL_FORMAT_RGB_888,
-        HAL_PIXEL_FORMAT_RGB_565,
-        HAL_PIXEL_FORMAT_BGRA_8888,
-        HAL_PIXEL_FORMAT_YV12,
-    };
-
-    const int numFmts = (sizeof(fmts) / sizeof(fmts[0]));
-    for (int i = 0; i < numFmts; i++) {
-      int fmt = -1;
-      ASSERT_EQ(OK, native_window_set_buffers_dimensions(anw.get(), 0, 0));
-      ASSERT_EQ(OK, native_window_set_buffers_format(anw.get(), fmts[i]));
-      ASSERT_EQ(OK, anw->query(anw.get(), NATIVE_WINDOW_FORMAT, &fmt));
-      EXPECT_EQ(fmts[i], fmt);
-    }
-}
-
-class MultiSurfaceTextureClientTest : public ::testing::Test {
-
-public:
-    MultiSurfaceTextureClientTest() :
-            mEglDisplay(EGL_NO_DISPLAY),
-            mEglContext(EGL_NO_CONTEXT) {
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            mEglSurfaces[i] = EGL_NO_CONTEXT;
-        }
-    }
-
-protected:
-
-    enum { NUM_SURFACE_TEXTURES = 32 };
-
-    virtual void SetUp() {
-        mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-
-        EGLint majorVersion, minorVersion;
-        EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        EGLConfig myConfig;
-        EGLint numConfigs = 0;
-        EGLint configAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_NONE
-        };
-        EXPECT_TRUE(eglChooseConfig(mEglDisplay, configAttribs, &myConfig, 1,
-                &numConfigs));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        mEglContext = eglCreateContext(mEglDisplay, myConfig, EGL_NO_CONTEXT,
-                0);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mEglContext);
-
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            sp<IGraphicBufferProducer> producer;
-            sp<IGraphicBufferConsumer> consumer;
-            BufferQueue::createBufferQueue(&producer, &consumer);
-            sp<GLConsumer> st(new GLConsumer(consumer, i,
-                    GLConsumer::TEXTURE_EXTERNAL, true, false));
-            sp<Surface> stc(new Surface(producer));
-            mEglSurfaces[i] = eglCreateWindowSurface(mEglDisplay, myConfig,
-                    static_cast<ANativeWindow*>(stc.get()), NULL);
-            ASSERT_EQ(EGL_SUCCESS, eglGetError());
-            ASSERT_NE(EGL_NO_SURFACE, mEglSurfaces[i]);
-        }
-    }
-
-    virtual void TearDown() {
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                EGL_NO_CONTEXT);
-
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            if (mEglSurfaces[i] != EGL_NO_SURFACE) {
-                eglDestroySurface(mEglDisplay, mEglSurfaces[i]);
-            }
-        }
-
-        if (mEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mEglContext);
-        }
-
-        if (mEglDisplay != EGL_NO_DISPLAY) {
-            eglTerminate(mEglDisplay);
-        }
-    }
-
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurfaces[NUM_SURFACE_TEXTURES];
-    EGLContext mEglContext;
-};
-
-// XXX: This test is disabled because it causes a hang on some devices.  See bug
-// 5015672.
-TEST_F(MultiSurfaceTextureClientTest, DISABLED_MakeCurrentBetweenSurfacesWorks) {
-    for (int iter = 0; iter < 8; iter++) {
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            eglMakeCurrent(mEglDisplay, mEglSurfaces[i], mEglSurfaces[i],
-                    mEglContext);
-            glClear(GL_COLOR_BUFFER_BIT);
-            eglSwapBuffers(mEglDisplay, mEglSurfaces[i]);
-        }
-    }
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureFBO.h b/libs/gui/tests/SurfaceTextureFBO.h
deleted file mode 100644
index 7f1ae84c4..000000000
--- a/libs/gui/tests/SurfaceTextureFBO.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_FBO_H
-#define ANDROID_SURFACE_TEXTURE_FBO_H
-
-#include "SurfaceTextureGL.h"
-
-#include <GLES2/gl2.h>
-
-namespace android {
-
-class SurfaceTextureFBOTest : public SurfaceTextureGLTest {
-protected:
-    virtual void SetUp() {
-        SurfaceTextureGLTest::SetUp();
-
-        glGenFramebuffers(1, &mFbo);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-        glGenTextures(1, &mFboTex);
-        glBindTexture(GL_TEXTURE_2D, mFboTex);
-        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, getSurfaceWidth(),
-                getSurfaceHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
-        glBindTexture(GL_TEXTURE_2D, 0);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-        glBindFramebuffer(GL_FRAMEBUFFER, mFbo);
-        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                GL_TEXTURE_2D, mFboTex, 0);
-        glBindFramebuffer(GL_FRAMEBUFFER, 0);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    }
-
-    virtual void TearDown() {
-        SurfaceTextureGLTest::TearDown();
-
-        glDeleteTextures(1, &mFboTex);
-        glDeleteFramebuffers(1, &mFbo);
-    }
-
-    GLuint mFbo;
-    GLuint mFboTex;
-};
-
-void fillRGBA8BufferSolid(uint8_t* buf, int w, int h, int stride,
-        uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
-    const size_t PIXEL_SIZE = 4;
-    for (int y = 0; y < h; y++) {
-        for (int x = 0; x < w; x++) {
-            off_t offset = (y * stride + x) * PIXEL_SIZE;
-            buf[offset + 0] = r;
-            buf[offset + 1] = g;
-            buf[offset + 2] = b;
-            buf[offset + 3] = a;
-        }
-    }
-}
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureFBO_test.cpp b/libs/gui/tests/SurfaceTextureFBO_test.cpp
deleted file mode 100644
index 0134273a0..000000000
--- a/libs/gui/tests/SurfaceTextureFBO_test.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureFBO_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureFBO.h"
-
-namespace android {
-
-// This test is intended to verify that proper synchronization is done when
-// rendering into an FBO.
-TEST_F(SurfaceTextureFBOTest, BlitFromCpuFilledBufferToFbo) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    android_native_buffer_t* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    // Fill the buffer with green
-    uint8_t* img = NULL;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    fillRGBA8BufferSolid(img, texWidth, texHeight, buf->getStride(), 0, 255,
-            0, 255);
-    buf->unlock();
-    ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
-            -1));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glBindFramebuffer(GL_FRAMEBUFFER, mFbo);
-    drawTexture();
-    glBindFramebuffer(GL_FRAMEBUFFER, 0);
-
-    for (int i = 0; i < 4; i++) {
-        SCOPED_TRACE(String8::format("frame %d", i).string());
-
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-                &anb));
-        ASSERT_TRUE(anb != NULL);
-
-        buf = GraphicBuffer::from(anb);
-
-        // Fill the buffer with red
-        ASSERT_EQ(NO_ERROR, buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN,
-                (void**)(&img)));
-        fillRGBA8BufferSolid(img, texWidth, texHeight, buf->getStride(), 255, 0,
-                0, 255);
-        ASSERT_EQ(NO_ERROR, buf->unlock());
-        ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(),
-                buf->getNativeBuffer(), -1));
-
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-        drawTexture();
-
-        EXPECT_TRUE(checkPixel( 24, 39, 255, 0, 0, 255));
-    }
-
-    glBindFramebuffer(GL_FRAMEBUFFER, mFbo);
-
-    EXPECT_TRUE(checkPixel( 24, 39, 0, 255, 0, 255));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureGL.h b/libs/gui/tests/SurfaceTextureGL.h
deleted file mode 100644
index 53eb68cad..000000000
--- a/libs/gui/tests/SurfaceTextureGL.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_GL_H
-#define ANDROID_SURFACE_TEXTURE_GL_H
-
-#include "GLTest.h"
-
-#include "FrameWaiter.h"
-#include "TextureRenderer.h"
-
-#include <gui/GLConsumer.h>
-#include <gui/Surface.h>
-
-namespace android {
-
-class FrameWaiter;
-class GLConsumer;
-class TextureRenderer;
-
-class SurfaceTextureGLTest : public GLTest {
-protected:
-    enum { TEX_ID = 123 };
-
-    void SetUp() {
-        GLTest::SetUp();
-        sp<IGraphicBufferProducer> producer;
-        BufferQueue::createBufferQueue(&producer, &mConsumer);
-        mST = new GLConsumer(mConsumer, TEX_ID, GLConsumer::TEXTURE_EXTERNAL,
-                true, false);
-        mSTC = new Surface(producer);
-        mANW = mSTC;
-        mTextureRenderer = new TextureRenderer(TEX_ID, mST);
-        ASSERT_NO_FATAL_FAILURE(mTextureRenderer->SetUp());
-        mFW = new FrameWaiter;
-        mST->setFrameAvailableListener(mFW);
-    }
-
-    void TearDown() {
-        mTextureRenderer.clear();
-        mANW.clear();
-        mSTC.clear();
-        mST.clear();
-        GLTest::TearDown();
-    }
-
-    void drawTexture() {
-        mTextureRenderer->drawTexture();
-    }
-
-    sp<IGraphicBufferConsumer> mConsumer;
-    sp<GLConsumer> mST;
-    sp<Surface> mSTC;
-    sp<ANativeWindow> mANW;
-    sp<TextureRenderer> mTextureRenderer;
-    sp<FrameWaiter> mFW;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureGLThreadToGL.h b/libs/gui/tests/SurfaceTextureGLThreadToGL.h
deleted file mode 100644
index 2ce20eb2b..000000000
--- a/libs/gui/tests/SurfaceTextureGLThreadToGL.h
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_GL_THREAD_TO_GL_H
-#define ANDROID_SURFACE_TEXTURE_GL_THREAD_TO_GL_H
-
-#include "SurfaceTextureGLToGL.h"
-
-namespace android {
-
-/*
- * This test fixture is for testing GL -> GL texture streaming from one thread
- * to another.  It contains functionality to create a producer thread that will
- * perform GL rendering to an ANativeWindow that feeds frames to a
- * GLConsumer.  Additionally it supports interlocking the producer and
- * consumer threads so that a specific sequence of calls can be
- * deterministically created by the test.
- *
- * The intended usage is as follows:
- *
- * TEST_F(...) {
- *     class PT : public ProducerThread {
- *         virtual void render() {
- *             ...
- *             swapBuffers();
- *         }
- *     };
- *
- *     runProducerThread(new PT());
- *
- *     // The order of these calls will vary from test to test and may include
- *     // multiple frames and additional operations (e.g. GL rendering from the
- *     // texture).
- *     fc->waitForFrame();
- *     mST->updateTexImage();
- *     fc->finishFrame();
- * }
- *
- */
-class SurfaceTextureGLThreadToGLTest : public SurfaceTextureGLToGLTest {
-protected:
-
-    // ProducerThread is an abstract base class to simplify the creation of
-    // OpenGL ES frame producer threads.
-    class ProducerThread : public Thread {
-    public:
-        virtual ~ProducerThread() {
-        }
-
-        void setEglObjects(EGLDisplay producerEglDisplay,
-                EGLSurface producerEglSurface,
-                EGLContext producerEglContext) {
-            mProducerEglDisplay = producerEglDisplay;
-            mProducerEglSurface = producerEglSurface;
-            mProducerEglContext = producerEglContext;
-        }
-
-        virtual bool threadLoop() {
-            eglMakeCurrent(mProducerEglDisplay, mProducerEglSurface,
-                    mProducerEglSurface, mProducerEglContext);
-            render();
-            eglMakeCurrent(mProducerEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                    EGL_NO_CONTEXT);
-            return false;
-        }
-
-    protected:
-        virtual void render() = 0;
-
-        void swapBuffers() {
-            eglSwapBuffers(mProducerEglDisplay, mProducerEglSurface);
-        }
-
-        EGLDisplay mProducerEglDisplay;
-        EGLSurface mProducerEglSurface;
-        EGLContext mProducerEglContext;
-    };
-
-    // FrameCondition is a utility class for interlocking between the producer
-    // and consumer threads.  The FrameCondition object should be created and
-    // destroyed in the consumer thread only.  The consumer thread should set
-    // the FrameCondition as the FrameAvailableListener of the GLConsumer,
-    // and should call both waitForFrame and finishFrame once for each expected
-    // frame.
-    //
-    // This interlocking relies on the fact that onFrameAvailable gets called
-    // synchronously from GLConsumer::queueBuffer.
-    class FrameCondition : public GLConsumer::FrameAvailableListener {
-    public:
-        FrameCondition():
-                mFrameAvailable(false),
-                mFrameFinished(false) {
-        }
-
-        // waitForFrame waits for the next frame to arrive.  This should be
-        // called from the consumer thread once for every frame expected by the
-        // test.
-        void waitForFrame() {
-            Mutex::Autolock lock(mMutex);
-            ALOGV("+waitForFrame");
-            while (!mFrameAvailable) {
-                mFrameAvailableCondition.wait(mMutex);
-            }
-            mFrameAvailable = false;
-            ALOGV("-waitForFrame");
-        }
-
-        // Allow the producer to return from its swapBuffers call and continue
-        // on to produce the next frame.  This should be called by the consumer
-        // thread once for every frame expected by the test.
-        void finishFrame() {
-            Mutex::Autolock lock(mMutex);
-            ALOGV("+finishFrame");
-            mFrameFinished = true;
-            mFrameFinishCondition.signal();
-            ALOGV("-finishFrame");
-        }
-
-        // This should be called by GLConsumer on the producer thread.
-        virtual void onFrameAvailable(const BufferItem& /* item */) {
-            Mutex::Autolock lock(mMutex);
-            ALOGV("+onFrameAvailable");
-            mFrameAvailable = true;
-            mFrameAvailableCondition.signal();
-            while (!mFrameFinished) {
-                mFrameFinishCondition.wait(mMutex);
-            }
-            mFrameFinished = false;
-            ALOGV("-onFrameAvailable");
-        }
-
-    protected:
-        bool mFrameAvailable;
-        bool mFrameFinished;
-
-        Mutex mMutex;
-        Condition mFrameAvailableCondition;
-        Condition mFrameFinishCondition;
-    };
-
-    virtual void SetUp() {
-        SurfaceTextureGLToGLTest::SetUp();
-        mFC = new FrameCondition();
-        mST->setFrameAvailableListener(mFC);
-    }
-
-    virtual void TearDown() {
-        if (mProducerThread != NULL) {
-            mProducerThread->requestExitAndWait();
-        }
-        mProducerThread.clear();
-        mFC.clear();
-        SurfaceTextureGLToGLTest::TearDown();
-    }
-
-    void runProducerThread(const sp<ProducerThread> producerThread) {
-        ASSERT_TRUE(mProducerThread == NULL);
-        mProducerThread = producerThread;
-        producerThread->setEglObjects(mEglDisplay, mProducerEglSurface,
-                mProducerEglContext);
-        producerThread->run("ProducerThread");
-    }
-
-    sp<ProducerThread> mProducerThread;
-    sp<FrameCondition> mFC;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp b/libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp
deleted file mode 100644
index c4d0aaa4b..000000000
--- a/libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureGLThreadToGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureGLThreadToGL.h"
-
-namespace android {
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        UpdateTexImageBeforeFrameFinishedCompletes) {
-    class PT : public ProducerThread {
-        virtual void render() {
-            glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-            glClear(GL_COLOR_BUFFER_BIT);
-            swapBuffers();
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    mFC->waitForFrame();
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    mFC->finishFrame();
-
-    // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-}
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        UpdateTexImageAfterFrameFinishedCompletes) {
-    class PT : public ProducerThread {
-        virtual void render() {
-            glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-            glClear(GL_COLOR_BUFFER_BIT);
-            swapBuffers();
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    mFC->waitForFrame();
-    mFC->finishFrame();
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-}
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        RepeatedUpdateTexImageBeforeFrameFinishedCompletes) {
-    enum { NUM_ITERATIONS = 1024 };
-
-    class PT : public ProducerThread {
-        virtual void render() {
-            for (int i = 0; i < NUM_ITERATIONS; i++) {
-                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-                glClear(GL_COLOR_BUFFER_BIT);
-                ALOGV("+swapBuffers");
-                swapBuffers();
-                ALOGV("-swapBuffers");
-            }
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    for (int i = 0; i < NUM_ITERATIONS; i++) {
-        mFC->waitForFrame();
-        ALOGV("+updateTexImage");
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        ALOGV("-updateTexImage");
-        mFC->finishFrame();
-
-        // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-    }
-}
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        RepeatedUpdateTexImageAfterFrameFinishedCompletes) {
-    enum { NUM_ITERATIONS = 1024 };
-
-    class PT : public ProducerThread {
-        virtual void render() {
-            for (int i = 0; i < NUM_ITERATIONS; i++) {
-                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-                glClear(GL_COLOR_BUFFER_BIT);
-                ALOGV("+swapBuffers");
-                swapBuffers();
-                ALOGV("-swapBuffers");
-            }
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    for (int i = 0; i < NUM_ITERATIONS; i++) {
-        mFC->waitForFrame();
-        mFC->finishFrame();
-        ALOGV("+updateTexImage");
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        ALOGV("-updateTexImage");
-
-        // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-    }
-}
-
-// XXX: This test is disabled because it is currently hanging on some devices.
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        DISABLED_RepeatedSwapBuffersWhileDequeueStalledCompletes) {
-    enum { NUM_ITERATIONS = 64 };
-
-    class PT : public ProducerThread {
-        virtual void render() {
-            for (int i = 0; i < NUM_ITERATIONS; i++) {
-                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-                glClear(GL_COLOR_BUFFER_BIT);
-                ALOGV("+swapBuffers");
-                swapBuffers();
-                ALOGV("-swapBuffers");
-            }
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    // Allow three frames to be rendered and queued before starting the
-    // rendering in this thread.  For the latter two frames we don't call
-    // updateTexImage so the next dequeue from the producer thread will block
-    // waiting for a frame to become available.
-    mFC->waitForFrame();
-    mFC->finishFrame();
-
-    // We must call updateTexImage to consume the first frame so that the
-    // SurfaceTexture is able to reduce the buffer count to 2.  This is because
-    // the GL driver may dequeue a buffer when the EGLSurface is created, and
-    // that happens before we call setDefaultMaxBufferCount.  It's possible that the
-    // driver does not dequeue a buffer at EGLSurface creation time, so we
-    // cannot rely on this to cause the second dequeueBuffer call to block.
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    mFC->waitForFrame();
-    mFC->finishFrame();
-    mFC->waitForFrame();
-    mFC->finishFrame();
-
-    // Sleep for 100ms to allow the producer thread's dequeueBuffer call to
-    // block waiting for a buffer to become available.
-    usleep(100000);
-
-    // Render and present a number of images.  This thread should not be blocked
-    // by the fact that the producer thread is blocking in dequeue.
-    for (int i = 0; i < NUM_ITERATIONS; i++) {
-        glClear(GL_COLOR_BUFFER_BIT);
-        eglSwapBuffers(mEglDisplay, mEglSurface);
-    }
-
-    // Consume the two pending buffers to unblock the producer thread.
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // Consume the remaining buffers from the producer thread.
-    for (int i = 0; i < NUM_ITERATIONS-3; i++) {
-        mFC->waitForFrame();
-        mFC->finishFrame();
-        ALOGV("+updateTexImage");
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        ALOGV("-updateTexImage");
-    }
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureGLToGL.h b/libs/gui/tests/SurfaceTextureGLToGL.h
deleted file mode 100644
index 5d43a4889..000000000
--- a/libs/gui/tests/SurfaceTextureGLToGL.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_GL_TO_GL_H
-#define ANDROID_SURFACE_TEXTURE_GL_TO_GL_H
-
-#include "SurfaceTextureGL.h"
-
-namespace android {
-
-/*
- * This test fixture is for testing GL -> GL texture streaming.  It creates an
- * EGLSurface and an EGLContext for the image producer to use.
- */
-class SurfaceTextureGLToGLTest : public SurfaceTextureGLTest {
-protected:
-    SurfaceTextureGLToGLTest():
-            mProducerEglSurface(EGL_NO_SURFACE),
-            mProducerEglContext(EGL_NO_CONTEXT) {
-    }
-
-    virtual void SetUp() {
-        SurfaceTextureGLTest::SetUp();
-    }
-
-    void SetUpWindowAndContext() {
-        mProducerEglSurface = eglCreateWindowSurface(mEglDisplay, mGlConfig,
-                mANW.get(), NULL);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_SURFACE, mProducerEglSurface);
-
-        mProducerEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-                EGL_NO_CONTEXT, getContextAttribs());
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mProducerEglContext);
-    }
-
-    virtual void TearDown() {
-        if (mProducerEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mProducerEglContext);
-        }
-        if (mProducerEglSurface != EGL_NO_SURFACE) {
-            eglDestroySurface(mEglDisplay, mProducerEglSurface);
-        }
-        SurfaceTextureGLTest::TearDown();
-    }
-
-    EGLSurface mProducerEglSurface;
-    EGLContext mProducerEglContext;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureGLToGL_test.cpp b/libs/gui/tests/SurfaceTextureGLToGL_test.cpp
deleted file mode 100644
index c28b4d141..000000000
--- a/libs/gui/tests/SurfaceTextureGLToGL_test.cpp
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureGLToGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureGLToGL.h"
-
-namespace android {
-
-TEST_F(SurfaceTextureGLToGLTest, TransformHintGetsRespected) {
-    const uint32_t texWidth = 32;
-    const uint32_t texHeight = 64;
-
-    mST->setDefaultBufferSize(texWidth, texHeight);
-    mST->setTransformHint(NATIVE_WINDOW_TRANSFORM_ROT_90);
-
-    // This test requires 3 buffers to avoid deadlock because we're
-    // both producer and consumer, and only using one thread. Set max dequeued
-    // to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Start a buffer with our chosen size and transform hint moving
-    // through the system.
-    glClear(GL_COLOR_BUFFER_BIT);  // give the driver something to do
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();  // consume it
-    // Swap again.
-    glClear(GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();
-
-    // The current buffer should either show the effects of the transform
-    // hint (in the form of an inverse transform), or show that the
-    // transform hint has been ignored.
-    sp<GraphicBuffer> buf = mST->getCurrentBuffer();
-    if (mST->getCurrentTransform() == NATIVE_WINDOW_TRANSFORM_ROT_270) {
-        ASSERT_EQ(texWidth, buf->getHeight());
-        ASSERT_EQ(texHeight, buf->getWidth());
-    } else {
-        ASSERT_EQ(texWidth, buf->getWidth());
-        ASSERT_EQ(texHeight, buf->getHeight());
-    }
-
-    // Reset the transform hint and confirm that it takes.
-    mST->setTransformHint(0);
-    glClear(GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();
-    glClear(GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();
-
-    buf = mST->getCurrentBuffer();
-    ASSERT_EQ((uint32_t) 0, mST->getCurrentTransform());
-    ASSERT_EQ(texWidth, buf->getWidth());
-    ASSERT_EQ(texHeight, buf->getHeight());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromGLFilledRGBABufferPow2) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    mST->setDefaultBufferSize(texWidth, texHeight);
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(4, 4, 4, 4);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glScissor(24, 48, 4, 4);
-    glClearColor(0.0, 1.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glScissor(37, 17, 4, 4);
-    glClearColor(0.0, 0.0, 1.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 63, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 63, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel( 4,  7, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel(25, 51,   0, 255,   0, 255));
-    EXPECT_TRUE(checkPixel(40, 19,   0,   0, 255, 255));
-    EXPECT_TRUE(checkPixel(29, 51, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 5, 32, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(13,  8, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(46,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(30, 33, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 6, 52, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(55, 33, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(16, 29, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 1, 30, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(41, 37, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(46, 29, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(15, 25, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 3, 52, 153, 153, 153, 153));
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglDestroySurfaceUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffers[2];
-
-    // This test requires async mode to run on a single thread.
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    EXPECT_TRUE(eglSwapInterval(mEglDisplay, 0));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    for (int i = 0; i < 2; i++) {
-        // Produce a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-                mProducerEglSurface, mProducerEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        glClear(GL_COLOR_BUFFER_BIT);
-        eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-        // Consume a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mFW->waitForFrame();
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        buffers[i] = mST->getCurrentBuffer();
-    }
-
-    // Destroy the GL texture object to release its ref on buffers[2].
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // Destroy the EGLSurface
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-
-    // This test should have the only reference to buffer 0.
-    EXPECT_EQ(1, buffers[0]->getStrongCount());
-
-    // The GLConsumer should hold one reference to buffer 1 in its
-    // mCurrentTextureImage member and another reference in mEglSlots. The third
-    // reference is in this test.
-    EXPECT_EQ(3, buffers[1]->getStrongCount());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglDestroySurfaceAfterAbandonUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffers[3];
-
-    // This test requires async mode to run on a single thread.
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    EXPECT_TRUE(eglSwapInterval(mEglDisplay, 0));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    for (int i = 0; i < 3; i++) {
-        // Produce a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-                mProducerEglSurface, mProducerEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        glClear(GL_COLOR_BUFFER_BIT);
-        EXPECT_TRUE(eglSwapBuffers(mEglDisplay, mProducerEglSurface));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        // Consume a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mFW->waitForFrame();
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        buffers[i] = mST->getCurrentBuffer();
-    }
-
-    // Abandon the GLConsumer, releasing the ref that the GLConsumer has
-    // on buffers[2].
-    mST->abandon();
-
-    // Destroy the GL texture object to release its ref on buffers[2].
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // Destroy the EGLSurface.
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-
-    EXPECT_EQ(1, buffers[1]->getStrongCount());
-
-    // Depending on how lazily the GL driver dequeues buffers, we may end up
-    // with either two or three total buffers.  If there are three, each entry
-    // of the buffers array will be unique and there should only be one
-    // reference (the one in this test). If there are two the first and last
-    // element in the array will be equal meaning that buffer representing both
-    // 0 and 2 will have two references (one for 0 and one for 2).
-    if (buffers[2] != buffers[0]) {
-        EXPECT_EQ(1, buffers[0]->getStrongCount());
-        EXPECT_EQ(1, buffers[2]->getStrongCount());
-    } else {
-        EXPECT_EQ(2, buffers[0]->getStrongCount());
-    }
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglMakeCurrentBeforeConsumerDeathUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffer;
-
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-
-    // Produce a frame
-    glClear(GL_COLOR_BUFFER_BIT);
-    EXPECT_TRUE(eglSwapBuffers(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Destroy the EGLSurface.
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-    mSTC.clear();
-    mANW.clear();
-    mTextureRenderer.clear();
-
-    // Consume a frame
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    buffer = mST->getCurrentBuffer();
-
-    // Destroy the GL texture object to release its ref
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // make un-current, all references to buffer should be gone
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE,
-            EGL_NO_SURFACE, EGL_NO_CONTEXT));
-
-    // Destroy consumer
-    mST.clear();
-
-    EXPECT_EQ(1, buffer->getStrongCount());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglMakeCurrentAfterConsumerDeathUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffer;
-
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-
-    // Produce a frame
-    glClear(GL_COLOR_BUFFER_BIT);
-    EXPECT_TRUE(eglSwapBuffers(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Destroy the EGLSurface.
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-    mSTC.clear();
-    mANW.clear();
-    mTextureRenderer.clear();
-
-    // Consume a frame
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    buffer = mST->getCurrentBuffer();
-
-    // Destroy the GL texture object to release its ref
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // Destroy consumer
-    mST.clear();
-
-    // make un-current, all references to buffer should be gone
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE,
-            EGL_NO_SURFACE, EGL_NO_CONTEXT));
-
-    EXPECT_EQ(1, buffer->getStrongCount());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromUserSizedGLFilledBuffer) {
-    enum { texWidth = 64 };
-    enum { texHeight = 64 };
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Set the user buffer size.
-    native_window_set_buffers_user_dimensions(mANW.get(), texWidth, texHeight);
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(4, 4, 1, 1);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 63, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 63, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel( 4,  4, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel( 5,  5, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 3,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(45, 52, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(12, 36, 153, 153, 153, 153));
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromPreRotatedUserSizedGLFilledBuffer) {
-    enum { texWidth = 64 };
-    enum { texHeight = 16 };
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Set the transform hint.
-    mST->setTransformHint(NATIVE_WINDOW_TRANSFORM_ROT_90);
-
-    // Set the user buffer size.
-    native_window_set_buffers_user_dimensions(mANW.get(), texWidth, texHeight);
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size and the
-    // new rotation hint.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(24, 4, 1, 1);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 15, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 15, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel(24,  4, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel(25,  5, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(23,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(45, 13, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(12,  8, 153, 153, 153, 153));
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromPreRotatedGLFilledBuffer) {
-    enum { texWidth = 64 };
-    enum { texHeight = 16 };
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Set the transform hint.
-    mST->setTransformHint(NATIVE_WINDOW_TRANSFORM_ROT_90);
-
-    // Set the default buffer size.
-    mST->setDefaultBufferSize(texWidth, texHeight);
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size and the
-    // new rotation hint.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(24, 4, 1, 1);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 15, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 15, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel(24,  4, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel(25,  5, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(23,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(45, 13, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(12,  8, 153, 153, 153, 153));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureGL_test.cpp b/libs/gui/tests/SurfaceTextureGL_test.cpp
deleted file mode 100644
index 56392867e..000000000
--- a/libs/gui/tests/SurfaceTextureGL_test.cpp
+++ /dev/null
@@ -1,737 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureGL.h"
-
-#include "DisconnectWaiter.h"
-#include "FillBuffer.h"
-
-namespace android {
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferNpot) {
-    const int texWidth = 64;
-    const int texHeight = 66;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ANativeWindowBuffer* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    // Fill the buffer with the a checkerboard pattern
-    uint8_t* img = NULL;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    fillYV12Buffer(img, texWidth, texHeight, buf->getStride());
-    buf->unlock();
-    ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
-            -1));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(63,  0,   0, 133,   0, 255, 3));
-    EXPECT_TRUE(checkPixel(63, 65,   0, 133,   0, 255, 3));
-    EXPECT_TRUE(checkPixel( 0, 65, 255, 127, 255, 255, 3));
-
-    EXPECT_TRUE(checkPixel(22, 44, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(45, 52, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(52, 51,  98, 255,  73, 255, 3));
-    EXPECT_TRUE(checkPixel( 7, 31, 155,   0, 118, 255, 3));
-    EXPECT_TRUE(checkPixel(31,  9, 107,  24,  87, 255, 3));
-    EXPECT_TRUE(checkPixel(29, 35, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(36, 22, 155,  29,   0, 255, 3));
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferPow2) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ANativeWindowBuffer* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    // Fill the buffer with the a checkerboard pattern
-    uint8_t* img = NULL;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    fillYV12Buffer(img, texWidth, texHeight, buf->getStride());
-    buf->unlock();
-    ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
-            -1));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0,   0, 133,   0, 255));
-    EXPECT_TRUE(checkPixel(63,  0, 255, 127, 255, 255));
-    EXPECT_TRUE(checkPixel(63, 63,   0, 133,   0, 255));
-    EXPECT_TRUE(checkPixel( 0, 63, 255, 127, 255, 255));
-
-    EXPECT_TRUE(checkPixel(22, 19, 100, 255,  74, 255, 3));
-    EXPECT_TRUE(checkPixel(45, 11, 100, 255,  74, 255, 3));
-    EXPECT_TRUE(checkPixel(52, 12, 155,   0, 181, 255, 3));
-    EXPECT_TRUE(checkPixel( 7, 32, 150, 237, 170, 255, 3));
-    EXPECT_TRUE(checkPixel(31, 54,   0,  71, 117, 255, 3));
-    EXPECT_TRUE(checkPixel(29, 28,   0, 133,   0, 255, 3));
-    EXPECT_TRUE(checkPixel(36, 41, 100, 232, 255, 255, 3));
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferWithCrop) {
-    const int texWidth = 64;
-    const int texHeight = 66;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    android_native_rect_t crops[] = {
-        {4, 6, 22, 36},
-        {0, 6, 22, 36},
-        {4, 0, 22, 36},
-        {4, 6, texWidth, 36},
-        {4, 6, 22, texHeight},
-    };
-
-    for (int i = 0; i < 5; i++) {
-        const android_native_rect_t& crop(crops[i]);
-        SCOPED_TRACE(String8::format("rect{ l: %d t: %d r: %d b: %d }",
-                crop.left, crop.top, crop.right, crop.bottom).string());
-
-        ASSERT_EQ(NO_ERROR, native_window_set_crop(mANW.get(), &crop));
-
-        ANativeWindowBuffer* anb;
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-                &anb));
-        ASSERT_TRUE(anb != NULL);
-
-        sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-        uint8_t* img = NULL;
-        buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-        fillYV12BufferRect(img, texWidth, texHeight, buf->getStride(), crop);
-        buf->unlock();
-        ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(),
-                buf->getNativeBuffer(), -1));
-
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-        glClearColor(0.2, 0.2, 0.2, 0.2);
-        glClear(GL_COLOR_BUFFER_BIT);
-
-        glViewport(0, 0, 64, 64);
-        drawTexture();
-
-        EXPECT_TRUE(checkPixel( 0,  0,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(63,  0,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(63, 63,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel( 0, 63,  82, 255,  35, 255));
-
-        EXPECT_TRUE(checkPixel(25, 14,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(35, 31,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(57,  6,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel( 5, 42,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(32, 33,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(16, 26,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(46, 51,  82, 255,  35, 255));
-    }
-}
-
-// This test is intended to catch synchronization bugs between the CPU-written
-// and GPU-read buffers.
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BuffersRepeatedly) {
-    enum { texWidth = 16 };
-    enum { texHeight = 16 };
-    enum { numFrames = 1024 };
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    struct TestPixel {
-        int x;
-        int y;
-    };
-    const TestPixel testPixels[] = {
-        {  4, 11 },
-        { 12, 14 },
-        {  7,  2 },
-    };
-    enum {numTestPixels = sizeof(testPixels) / sizeof(testPixels[0])};
-
-    class ProducerThread : public Thread {
-    public:
-        ProducerThread(const sp<ANativeWindow>& anw,
-                const TestPixel* testPixels):
-                mANW(anw),
-                mTestPixels(testPixels) {
-        }
-
-        virtual ~ProducerThread() {
-        }
-
-        virtual bool threadLoop() {
-            for (int i = 0; i < numFrames; i++) {
-                ANativeWindowBuffer* anb;
-                if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                        &anb) != NO_ERROR) {
-                    return false;
-                }
-                if (anb == NULL) {
-                    return false;
-                }
-
-                sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-                const int yuvTexOffsetY = 0;
-                int stride = buf->getStride();
-                int yuvTexStrideY = stride;
-                int yuvTexOffsetV = yuvTexStrideY * texHeight;
-                int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf;
-                int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * texHeight/2;
-                int yuvTexStrideU = yuvTexStrideV;
-
-                uint8_t* img = NULL;
-                buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-
-                // Gray out all the test pixels first, so we're more likely to
-                // see a failure if GL is still texturing from the buffer we
-                // just dequeued.
-                for (int j = 0; j < numTestPixels; j++) {
-                    int x = mTestPixels[j].x;
-                    int y = mTestPixels[j].y;
-                    uint8_t value = 128;
-                    img[y*stride + x] = value;
-                }
-
-                // Fill the buffer with gray.
-                for (int y = 0; y < texHeight; y++) {
-                    for (int x = 0; x < texWidth; x++) {
-                        img[yuvTexOffsetY + y*yuvTexStrideY + x] = 128;
-                        img[yuvTexOffsetU + (y/2)*yuvTexStrideU + x/2] = 128;
-                        img[yuvTexOffsetV + (y/2)*yuvTexStrideV + x/2] = 128;
-                    }
-                }
-
-                // Set the test pixels to either white or black.
-                for (int j = 0; j < numTestPixels; j++) {
-                    int x = mTestPixels[j].x;
-                    int y = mTestPixels[j].y;
-                    uint8_t value = 0;
-                    if (j == (i % numTestPixels)) {
-                        value = 255;
-                    }
-                    img[y*stride + x] = value;
-                }
-
-                buf->unlock();
-                if (mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(), -1)
-                        != NO_ERROR) {
-                    return false;
-                }
-            }
-            return false;
-        }
-
-        sp<ANativeWindow> mANW;
-        const TestPixel* mTestPixels;
-    };
-
-    sp<Thread> pt(new ProducerThread(mANW, testPixels));
-    pt->run("ProducerThread");
-
-    glViewport(0, 0, texWidth, texHeight);
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    // We wait for the first two frames up front so that the producer will be
-    // likely to dequeue the buffer that's currently being textured from.
-    mFW->waitForFrame();
-    mFW->waitForFrame();
-
-    for (int i = 0; i < numFrames; i++) {
-        SCOPED_TRACE(String8::format("frame %d", i).string());
-
-        // We must wait for each frame to come in because if we ever do an
-        // updateTexImage call that doesn't consume a newly available buffer
-        // then the producer and consumer will get out of sync, which will cause
-        // a deadlock.
-        if (i > 1) {
-            mFW->waitForFrame();
-        }
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        drawTexture();
-
-        for (int j = 0; j < numTestPixels; j++) {
-            int x = testPixels[j].x;
-            int y = testPixels[j].y;
-            if (j == (i % numTestPixels)) {
-                // We must y-invert the texture coords
-                EXPECT_TRUE(checkPixel(x, texHeight-y-1, 255, 255, 255, 255));
-            } else {
-                // We must y-invert the texture coords
-                EXPECT_TRUE(checkPixel(x, texHeight-y-1, 0, 0, 0, 255));
-            }
-        }
-    }
-
-    pt->requestExitAndWait();
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledRGBABufferNpot) {
-    const int texWidth = 64;
-    const int texHeight = 66;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(63,  0, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(63, 65, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel( 0, 65,  35,  35,  35,  35));
-
-    EXPECT_TRUE(checkPixel(15, 10,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(23, 65, 231,  35, 231,  35));
-    EXPECT_TRUE(checkPixel(19, 40,  35, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(38, 30, 231,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(42, 54,  35,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(37, 34,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(31,  8, 231,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(37, 47, 231,  35, 231, 231));
-    EXPECT_TRUE(checkPixel(25, 38,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(49,  6,  35, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(54, 50,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(27, 26, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(10,  6,  35,  35, 231, 231));
-    EXPECT_TRUE(checkPixel(29,  4,  35,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(55, 28,  35,  35, 231,  35));
-    EXPECT_TRUE(checkPixel(58, 55,  35,  35, 231, 231));
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledRGBABufferPow2) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(63,  0,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(63, 63, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel( 0, 63,  35,  35,  35,  35));
-
-    EXPECT_TRUE(checkPixel(12, 46, 231, 231, 231,  35));
-    EXPECT_TRUE(checkPixel(16,  1, 231, 231,  35, 231));
-    EXPECT_TRUE(checkPixel(21, 12, 231,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(26, 51, 231,  35, 231,  35));
-    EXPECT_TRUE(checkPixel( 5, 32,  35, 231, 231,  35));
-    EXPECT_TRUE(checkPixel(13,  8,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(46,  3,  35,  35, 231,  35));
-    EXPECT_TRUE(checkPixel(30, 33,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel( 6, 52, 231, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(55, 33,  35, 231,  35, 231));
-    EXPECT_TRUE(checkPixel(16, 29,  35,  35, 231, 231));
-    EXPECT_TRUE(checkPixel( 1, 30,  35,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(41, 37,  35,  35, 231, 231));
-    EXPECT_TRUE(checkPixel(46, 29, 231, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(15, 25,  35, 231,  35, 231));
-    EXPECT_TRUE(checkPixel( 3, 52,  35, 231,  35,  35));
-}
-
-// Tests if GLConsumer and BufferQueue are robust enough
-// to handle a special case where updateTexImage is called
-// in the middle of disconnect.  This ordering is enforced
-// by blocking in the disconnect callback.
-TEST_F(SurfaceTextureGLTest, DisconnectStressTest) {
-
-    class ProducerThread : public Thread {
-    public:
-        explicit ProducerThread(const sp<ANativeWindow>& anw):
-                mANW(anw) {
-        }
-
-        virtual ~ProducerThread() {
-        }
-
-        virtual bool threadLoop() {
-            ANativeWindowBuffer* anb;
-
-            if (native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU) !=
-                    NO_ERROR) {
-                return false;
-            }
-
-            for (int numFrames =0 ; numFrames < 2; numFrames ++) {
-
-                if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                        &anb) != NO_ERROR) {
-                    return false;
-                }
-                if (anb == NULL) {
-                    return false;
-                }
-                if (mANW->queueBuffer(mANW.get(), anb, -1)
-                        != NO_ERROR) {
-                    return false;
-                }
-            }
-
-            if (native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU)
-                    != NO_ERROR) {
-                return false;
-            }
-
-            return false;
-        }
-
-    private:
-        sp<ANativeWindow> mANW;
-    };
-
-    sp<DisconnectWaiter> dw(new DisconnectWaiter());
-    mConsumer->consumerConnect(dw, false);
-
-
-    sp<Thread> pt(new ProducerThread(mANW));
-    pt->run("ProducerThread");
-
-    // eat a frame so GLConsumer will own an at least one slot
-    dw->waitForFrame();
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    dw->waitForFrame();
-    // Could fail here as GLConsumer thinks it still owns the slot
-    // but bufferQueue has released all slots
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    dw->finishDisconnect();
-}
-
-
-// This test ensures that the GLConsumer clears the mCurrentTexture
-// when it is disconnected and reconnected.  Otherwise it will
-// attempt to release a buffer that it does not owned
-TEST_F(SurfaceTextureGLTest, DisconnectClearsCurrentTexture) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    ANativeWindowBuffer *anb;
-
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-
-    EXPECT_EQ(OK,mST->updateTexImage());
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    ASSERT_EQ(OK, native_window_api_disconnect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-
-    // Will fail here if mCurrentTexture is not cleared properly
-    mFW->waitForFrame();
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    ASSERT_EQ(OK, native_window_api_disconnect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-}
-
-TEST_F(SurfaceTextureGLTest, ScaleToWindowMode) {
-    ASSERT_EQ(OK, native_window_set_scaling_mode(mANW.get(),
-        NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW));
-
-    // The producer image size
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 512, 512));
-
-    // The consumer image size (16 x 9) ratio
-    mST->setDefaultBufferSize(1280, 720);
-
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    ANativeWindowBuffer *anb;
-
-    android_native_rect_t odd = {23, 78, 123, 477};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &odd));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    Rect r = mST->getCurrentCrop();
-    assertRectEq(Rect(23, 78, 123, 477), r);
-
-    ASSERT_EQ(OK, native_window_api_disconnect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-}
-
-// This test ensures the scaling mode does the right thing
-// ie NATIVE_WINDOW_SCALING_MODE_CROP should crop
-// the image such that it has the same aspect ratio as the
-// default buffer size
-TEST_F(SurfaceTextureGLTest, CroppedScalingMode) {
-    ASSERT_EQ(OK, native_window_set_scaling_mode(mANW.get(),
-        NATIVE_WINDOW_SCALING_MODE_SCALE_CROP));
-
-    // The producer image size
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 512, 512));
-
-    // The consumer image size (16 x 9) ratio
-    mST->setDefaultBufferSize(1280, 720);
-
-    native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU);
-
-    ANativeWindowBuffer *anb;
-
-    // The crop is in the shape of (320, 180) === 16 x 9
-    android_native_rect_t standard = {10, 20, 330, 200};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &standard));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    Rect r = mST->getCurrentCrop();
-    // crop should be the same as crop (same aspect ratio)
-    assertRectEq(Rect(10, 20, 330, 200), r);
-
-    // make this wider then desired aspect 239 x 100 (2.39:1)
-    android_native_rect_t wide = {20, 30, 259, 130};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &wide));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    r = mST->getCurrentCrop();
-    // crop should be the same height, but have cropped left and right borders
-    // offset is 30.6 px L+, R-
-    assertRectEq(Rect(51, 30, 228, 130), r);
-
-    // This image is taller then desired aspect 400 x 300 (4:3)
-    android_native_rect_t narrow = {0, 0, 400, 300};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &narrow));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    r = mST->getCurrentCrop();
-    // crop should be the same width, but have cropped top and bottom borders
-    // offset is 37.5 px
-    assertRectEq(Rect(0, 37, 400, 262), r);
-
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-}
-
-TEST_F(SurfaceTextureGLTest, AbandonUnblocksDequeueBuffer) {
-    class ProducerThread : public Thread {
-    public:
-        explicit ProducerThread(const sp<ANativeWindow>& anw):
-                mANW(anw),
-                mDequeueError(NO_ERROR) {
-        }
-
-        virtual ~ProducerThread() {
-        }
-
-        virtual bool threadLoop() {
-            Mutex::Autolock lock(mMutex);
-            ANativeWindowBuffer* anb;
-
-            if (native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU) !=
-                    NO_ERROR) {
-                return false;
-            }
-
-            // Frame 1
-            if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                    &anb) != NO_ERROR) {
-                return false;
-            }
-            if (anb == NULL) {
-                return false;
-            }
-            if (mANW->queueBuffer(mANW.get(), anb, -1)
-                    != NO_ERROR) {
-                return false;
-            }
-
-            // Frame 2
-            if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                    &anb) != NO_ERROR) {
-                return false;
-            }
-            if (anb == NULL) {
-                return false;
-            }
-            if (mANW->queueBuffer(mANW.get(), anb, -1)
-                    != NO_ERROR) {
-                return false;
-            }
-
-            // Frame 3 - error expected
-            mDequeueError = native_window_dequeue_buffer_and_wait(mANW.get(),
-                &anb);
-            return false;
-        }
-
-        status_t getDequeueError() {
-            Mutex::Autolock lock(mMutex);
-            return mDequeueError;
-        }
-
-    private:
-        sp<ANativeWindow> mANW;
-        status_t mDequeueError;
-        Mutex mMutex;
-    };
-
-    sp<Thread> pt(new ProducerThread(mANW));
-    pt->run("ProducerThread");
-
-    mFW->waitForFrame();
-    mFW->waitForFrame();
-
-    // Sleep for 100ms to allow the producer thread's dequeueBuffer call to
-    // block waiting for a buffer to become available.
-    usleep(100000);
-
-    mST->abandon();
-
-    pt->requestExitAndWait();
-    ASSERT_EQ(NO_INIT,
-            reinterpret_cast<ProducerThread*>(pt.get())->getDequeueError());
-}
-
-TEST_F(SurfaceTextureGLTest, InvalidWidthOrHeightFails) {
-    int texHeight = 16;
-    ANativeWindowBuffer* anb;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    GLint maxTextureSize;
-    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxTextureSize);
-
-    // make sure it works with small textures
-    mST->setDefaultBufferSize(16, texHeight);
-    EXPECT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    EXPECT_EQ(16, anb->width);
-    EXPECT_EQ(texHeight, anb->height);
-    EXPECT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), anb, -1));
-    EXPECT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // make sure it works with GL_MAX_TEXTURE_SIZE
-    mST->setDefaultBufferSize(maxTextureSize, texHeight);
-    EXPECT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    EXPECT_EQ(maxTextureSize, anb->width);
-    EXPECT_EQ(texHeight, anb->height);
-    EXPECT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), anb, -1));
-    EXPECT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // make sure it fails with GL_MAX_TEXTURE_SIZE+1
-    mST->setDefaultBufferSize(maxTextureSize+1, texHeight);
-    EXPECT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    EXPECT_EQ(maxTextureSize+1, anb->width);
-    EXPECT_EQ(texHeight, anb->height);
-    EXPECT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), anb, -1));
-    ASSERT_NE(NO_ERROR, mST->updateTexImage());
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureMultiContextGL.h b/libs/gui/tests/SurfaceTextureMultiContextGL.h
deleted file mode 100644
index 3cca035f2..000000000
--- a/libs/gui/tests/SurfaceTextureMultiContextGL.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_MULTI_CONTEXT_GL_H
-#define ANDROID_SURFACE_TEXTURE_MULTI_CONTEXT_GL_H
-
-#include "SurfaceTextureGL.h"
-
-namespace android {
-
-class SurfaceTextureMultiContextGLTest : public SurfaceTextureGLTest {
-protected:
-    enum { SECOND_TEX_ID = 123 };
-    enum { THIRD_TEX_ID = 456 };
-
-    SurfaceTextureMultiContextGLTest():
-            mSecondEglContext(EGL_NO_CONTEXT),
-            mThirdEglContext(EGL_NO_CONTEXT) {
-    }
-
-    virtual void SetUp() {
-        SurfaceTextureGLTest::SetUp();
-
-        // Set up the secondary context and texture renderer.
-        mSecondEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-                EGL_NO_CONTEXT, getContextAttribs());
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mSecondEglContext);
-
-        ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mSecondEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mSecondTextureRenderer = new TextureRenderer(SECOND_TEX_ID, mST);
-        ASSERT_NO_FATAL_FAILURE(mSecondTextureRenderer->SetUp());
-
-        // Set up the tertiary context and texture renderer.
-        mThirdEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-                EGL_NO_CONTEXT, getContextAttribs());
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mThirdEglContext);
-
-        ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mThirdEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mThirdTextureRenderer = new TextureRenderer(THIRD_TEX_ID, mST);
-        ASSERT_NO_FATAL_FAILURE(mThirdTextureRenderer->SetUp());
-
-        // Switch back to the primary context to start the tests.
-        ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mEglContext));
-    }
-
-    virtual void TearDown() {
-        if (mThirdEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mThirdEglContext);
-        }
-        if (mSecondEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mSecondEglContext);
-        }
-        SurfaceTextureGLTest::TearDown();
-    }
-
-    EGLContext mSecondEglContext;
-    sp<TextureRenderer> mSecondTextureRenderer;
-
-    EGLContext mThirdEglContext;
-    sp<TextureRenderer> mThirdTextureRenderer;
-};
-
-}
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp b/libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp
deleted file mode 100644
index 5b02dcf53..000000000
--- a/libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp
+++ /dev/null
@@ -1,461 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureMultiContextGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureMultiContextGL.h"
-
-#include "FillBuffer.h"
-
-#include <GLES/glext.h>
-
-namespace android {
-
-TEST_F(SurfaceTextureMultiContextGLTest, UpdateFromMultipleContextsFails) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Attempt to latch the texture on the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_EQ(INVALID_OPERATION, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextSucceeds) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Check that the GL texture was deleted.
-    EXPECT_EQ(GL_FALSE, glIsTexture(TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        DetachFromContextSucceedsAfterProducerDisconnect) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Check that the GL texture was deleted.
-    EXPECT_EQ(GL_FALSE, glIsTexture(TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWhenAbandoned) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Attempt to detach from the primary context.
-    mST->abandon();
-    ASSERT_EQ(NO_INIT, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWhenDetached) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attempt to detach from the primary context again.
-    ASSERT_EQ(INVALID_OPERATION, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWithNoDisplay) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Make there be no current display.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-            EGL_NO_CONTEXT));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Attempt to detach from the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWithNoContext) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Make current context be incorrect.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Attempt to detach from the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, UpdateTexImageFailsWhenDetached) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attempt to latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(INVALID_OPERATION, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextSucceeds) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(SECOND_TEX_ID, texBinding);
-
-    // Try to use the texture from the secondary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mSecondTextureRenderer->drawTexture();
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextSucceedsAfterProducerDisconnect) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(SECOND_TEX_ID, texBinding);
-
-    // Try to use the texture from the secondary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mSecondTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextSucceedsBeforeUpdateTexImage) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(SECOND_TEX_ID, texBinding);
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Try to use the texture from the secondary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mSecondTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextFailsWhenAbandoned) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attempt to attach to the secondary context.
-    mST->abandon();
-
-    // Attempt to attach to the primary context.
-    ASSERT_EQ(NO_INIT, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextFailsWhenAttached) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Attempt to attach to the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextFailsWhenAttachedBeforeUpdateTexImage) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Attempt to attach to the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextFailsWithNoDisplay) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Make there be no current display.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-            EGL_NO_CONTEXT));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Attempt to attach with no context current.
-    ASSERT_EQ(INVALID_OPERATION, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextSucceedsTwice) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Detach from the secondary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the tertiary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mThirdEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(THIRD_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(THIRD_TEX_ID, texBinding);
-
-    // Try to use the texture from the tertiary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mThirdTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextSucceedsTwiceBeforeUpdateTexImage) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Detach from the secondary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the tertiary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mThirdEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(THIRD_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(THIRD_TEX_ID, texBinding);
-
-    // Latch the texture contents on the tertiary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Try to use the texture from the tertiary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mThirdTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        UpdateTexImageSucceedsForBufferConsumedBeforeDetach) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-
-    // produce two frames and consume them both on the primary context
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // produce one more frame
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context and attach to the secondary context
-    ASSERT_EQ(OK, mST->detachFromContext());
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Consume final frame on secondary context
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-       AttachAfterDisplayTerminatedSucceeds) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-
-    // produce two frames and consume them both on the primary context
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // produce one more frame
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->releaseTexImage());
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Terminate and then initialize the display. All contexts, surfaces
-    // and images are invalid at this point.
-    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-    EGLint majorVersion = 0;
-    EGLint minorVersion = 0;
-    EXPECT_TRUE(eglTerminate(display));
-    EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // The surface is invalid so create it again.
-    EGLint pbufferAttribs[] = {
-        EGL_WIDTH, 64,
-        EGL_HEIGHT, 64,
-        EGL_NONE };
-    mEglSurface = eglCreatePbufferSurface(mEglDisplay, mGlConfig,
-            pbufferAttribs);
-
-    // The second context is invalid so create it again.
-    mSecondEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-            EGL_NO_CONTEXT, getContextAttribs());
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_CONTEXT, mSecondEglContext);
-
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Now attach to and consume final frame on secondary context.
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-}
-
-
-} // namespace android
diff --git a/libs/gui/tests/Surface_test.cpp b/libs/gui/tests/Surface_test.cpp
deleted file mode 100644
index 2c02ba657..000000000
--- a/libs/gui/tests/Surface_test.cpp
+++ /dev/null
@@ -1,1667 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "DummyConsumer.h"
-
-#include <gtest/gtest.h>
-
-#include <android/hardware/configstore/1.0/ISurfaceFlingerConfigs.h>
-#include <binder/ProcessState.h>
-#include <configstore/Utils.h>
-#include <cutils/properties.h>
-#include <inttypes.h>
-#include <gui/BufferItemConsumer.h>
-#include <gui/IDisplayEventConnection.h>
-#include <gui/IProducerListener.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-#include <private/gui/ComposerService.h>
-#include <ui/Rect.h>
-#include <utils/String8.h>
-
-#include <limits>
-#include <thread>
-
-namespace android {
-
-using namespace std::chrono_literals;
-// retrieve wide-color and hdr settings from configstore
-using namespace android::hardware::configstore;
-using namespace android::hardware::configstore::V1_0;
-using ui::ColorMode;
-
-using Transaction = SurfaceComposerClient::Transaction;
-
-static bool hasWideColorDisplay =
-        getBool<ISurfaceFlingerConfigs, &ISurfaceFlingerConfigs::hasWideColorDisplay>(false);
-
-static bool hasHdrDisplay =
-        getBool<ISurfaceFlingerConfigs, &ISurfaceFlingerConfigs::hasHDRDisplay>(false);
-
-class FakeSurfaceComposer;
-class FakeProducerFrameEventHistory;
-
-static constexpr uint64_t NO_FRAME_INDEX = std::numeric_limits<uint64_t>::max();
-
-class SurfaceTest : public ::testing::Test {
-protected:
-    SurfaceTest() {
-        ProcessState::self()->startThreadPool();
-    }
-
-    virtual void SetUp() {
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        // TODO(brianderson): The following sometimes fails and is a source of
-        //   test flakiness.
-        mSurfaceControl = mComposerClient->createSurface(
-                String8("Test Surface"), 32, 32, PIXEL_FORMAT_RGBA_8888, 0);
-
-        ASSERT_TRUE(mSurfaceControl != NULL);
-        ASSERT_TRUE(mSurfaceControl->isValid());
-
-        Transaction t;
-        ASSERT_EQ(NO_ERROR, t.setLayer(mSurfaceControl, 0x7fffffff)
-                .show(mSurfaceControl)
-                .apply());
-
-        mSurface = mSurfaceControl->getSurface();
-        ASSERT_TRUE(mSurface != NULL);
-    }
-
-    virtual void TearDown() {
-        mComposerClient->dispose();
-    }
-
-    sp<Surface> mSurface;
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mSurfaceControl;
-};
-
-TEST_F(SurfaceTest, CreateSurfaceReturnsErrorBadClient) {
-    mComposerClient->dispose();
-    ASSERT_EQ(NO_INIT, mComposerClient->initCheck());
-
-    sp<SurfaceControl> sc;
-    status_t err = mComposerClient->createSurfaceChecked(
-            String8("Test Surface"), 32, 32, PIXEL_FORMAT_RGBA_8888, &sc, 0);
-    ASSERT_EQ(NO_INIT, err);
-}
-
-TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenVisible) {
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,
-            &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(1, result);
-}
-
-TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenPurgatorized) {
-    mSurfaceControl.clear();
-    // Wait for the async clean-up to complete.
-    std::this_thread::sleep_for(50ms);
-
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,
-            &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(1, result);
-}
-
-// This test probably doesn't belong here.
-TEST_F(SurfaceTest, ScreenshotsOfProtectedBuffersSucceed) {
-    sp<ANativeWindow> anw(mSurface);
-
-    // Verify the screenshot works with no protected buffers.
-    sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-    sp<IBinder> display(sf->getBuiltInDisplay(
-            ISurfaceComposer::eDisplayIdMain));
-    sp<GraphicBuffer> outBuffer;
-    ASSERT_EQ(NO_ERROR, sf->captureScreen(display, &outBuffer, Rect(),
-            64, 64, 0, 0x7fffffff, false));
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(anw.get(),
-            NATIVE_WINDOW_API_CPU));
-    // Set the PROTECTED usage bit and verify that the screenshot fails.  Note
-    // that we need to dequeue a buffer in order for it to actually get
-    // allocated in SurfaceFlinger.
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(anw.get(),
-            GRALLOC_USAGE_PROTECTED));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffer_count(anw.get(), 3));
-    ANativeWindowBuffer* buf = 0;
-
-    status_t err = native_window_dequeue_buffer_and_wait(anw.get(), &buf);
-    if (err) {
-        // we could fail if GRALLOC_USAGE_PROTECTED is not supported.
-        // that's okay as long as this is the reason for the failure.
-        // try again without the GRALLOC_USAGE_PROTECTED bit.
-        ASSERT_EQ(NO_ERROR, native_window_set_usage(anw.get(), 0));
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(anw.get(),
-                &buf));
-        return;
-    }
-    ASSERT_EQ(NO_ERROR, anw->cancelBuffer(anw.get(), buf, -1));
-
-    for (int i = 0; i < 4; i++) {
-        // Loop to make sure SurfaceFlinger has retired a protected buffer.
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(anw.get(),
-                &buf));
-        ASSERT_EQ(NO_ERROR, anw->queueBuffer(anw.get(), buf, -1));
-    }
-    ASSERT_EQ(NO_ERROR, sf->captureScreen(display, &outBuffer, Rect(),
-            64, 64, 0, 0x7fffffff, false));
-}
-
-TEST_F(SurfaceTest, ConcreteTypeIsSurface) {
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_CONCRETE_TYPE, &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(NATIVE_WINDOW_SURFACE, result);
-}
-
-TEST_F(SurfaceTest, LayerCountIsOne) {
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_LAYER_COUNT, &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(1, result);
-}
-
-TEST_F(SurfaceTest, QueryConsumerUsage) {
-    const int TEST_USAGE_FLAGS =
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_HW_RENDER;
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<BufferItemConsumer> c = new BufferItemConsumer(consumer,
-            TEST_USAGE_FLAGS);
-    sp<Surface> s = new Surface(producer);
-
-    sp<ANativeWindow> anw(s);
-
-    int flags = -1;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_CONSUMER_USAGE_BITS, &flags);
-
-    ASSERT_EQ(NO_ERROR, err);
-    ASSERT_EQ(TEST_USAGE_FLAGS, flags);
-}
-
-TEST_F(SurfaceTest, QueryDefaultBuffersDataSpace) {
-    const android_dataspace TEST_DATASPACE = HAL_DATASPACE_SRGB;
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-
-    cpuConsumer->setDefaultBufferDataSpace(TEST_DATASPACE);
-
-    sp<Surface> s = new Surface(producer);
-
-    sp<ANativeWindow> anw(s);
-
-    android_dataspace dataSpace;
-
-    int err = anw->query(anw.get(), NATIVE_WINDOW_DEFAULT_DATASPACE,
-            reinterpret_cast<int*>(&dataSpace));
-
-    ASSERT_EQ(NO_ERROR, err);
-    ASSERT_EQ(TEST_DATASPACE, dataSpace);
-}
-
-TEST_F(SurfaceTest, SettingGenerationNumber) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-
-    // Allocate a buffer with a generation number of 0
-    ANativeWindowBuffer* buffer;
-    int fenceFd;
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(window.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fenceFd));
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffer, fenceFd));
-
-    // Detach the buffer and check its generation number
-    sp<GraphicBuffer> graphicBuffer;
-    sp<Fence> fence;
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&graphicBuffer, &fence));
-    ASSERT_EQ(0U, graphicBuffer->getGenerationNumber());
-
-    ASSERT_EQ(NO_ERROR, surface->setGenerationNumber(1));
-    buffer = static_cast<ANativeWindowBuffer*>(graphicBuffer.get());
-
-    // This should change the generation number of the GraphicBuffer
-    ASSERT_EQ(NO_ERROR, surface->attachBuffer(buffer));
-
-    // Check that the new generation number sticks with the buffer
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffer, -1));
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fenceFd));
-    graphicBuffer = static_cast<GraphicBuffer*>(buffer);
-    ASSERT_EQ(1U, graphicBuffer->getGenerationNumber());
-}
-
-TEST_F(SurfaceTest, GetConsumerName) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    native_window_api_connect(window.get(), NATIVE_WINDOW_API_CPU);
-
-    EXPECT_STREQ("TestConsumer", surface->getConsumerName().string());
-}
-
-TEST_F(SurfaceTest, GetWideColorSupport) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    native_window_api_connect(window.get(), NATIVE_WINDOW_API_CPU);
-
-    bool supported;
-    surface->getWideColorSupport(&supported);
-
-    // NOTE: This test assumes that device that supports
-    // wide-color (as indicated by BoardConfig) must also
-    // have a wide-color primary display.
-    // That assumption allows this test to cover devices
-    // that advertised a wide-color color mode without
-    // actually supporting wide-color to pass this test
-    // as well as the case of a device that does support
-    // wide-color (via BoardConfig) and has a wide-color
-    // primary display.
-    // NOT covered at this time is a device that supports
-    // wide color in the BoardConfig but does not support
-    // a wide-color color mode on the primary display.
-    ASSERT_EQ(hasWideColorDisplay, supported);
-}
-
-TEST_F(SurfaceTest, GetHdrSupport) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    native_window_api_connect(window.get(), NATIVE_WINDOW_API_CPU);
-
-    bool supported;
-    status_t result = surface->getHdrSupport(&supported);
-    ASSERT_EQ(NO_ERROR, result);
-
-    // NOTE: This is not a CTS test.
-    // This test verifies that when the BoardConfig TARGET_HAS_HDR_DISPLAY
-    // is TRUE, getHdrSupport is also true.
-    // TODO: Add check for an HDR color mode on the primary display.
-    ASSERT_EQ(hasHdrDisplay, supported);
-}
-
-TEST_F(SurfaceTest, SetHdrMetadata) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    native_window_api_connect(window.get(), NATIVE_WINDOW_API_CPU);
-
-    bool supported;
-    status_t result = surface->getHdrSupport(&supported);
-    ASSERT_EQ(NO_ERROR, result);
-
-    if (!hasHdrDisplay || !supported) {
-        return;
-    }
-    const android_smpte2086_metadata smpte2086 = {
-        {0.680, 0.320},
-        {0.265, 0.690},
-        {0.150, 0.060},
-        {0.3127, 0.3290},
-        100.0,
-        0.1,
-    };
-    const android_cta861_3_metadata cta861_3 = {
-        78.0,
-        62.0,
-    };
-    int error = native_window_set_buffers_smpte2086_metadata(window.get(), &smpte2086);
-    ASSERT_EQ(error, NO_ERROR);
-    error = native_window_set_buffers_cta861_3_metadata(window.get(), &cta861_3);
-    ASSERT_EQ(error, NO_ERROR);
-}
-
-TEST_F(SurfaceTest, DynamicSetBufferCount) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(window.get(),
-            NATIVE_WINDOW_API_CPU));
-    native_window_set_buffer_count(window.get(), 4);
-
-    int fence;
-    ANativeWindowBuffer* buffer;
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fence));
-    native_window_set_buffer_count(window.get(), 3);
-    ASSERT_EQ(NO_ERROR, window->queueBuffer(window.get(), buffer, fence));
-    native_window_set_buffer_count(window.get(), 2);
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fence));
-    ASSERT_EQ(NO_ERROR, window->queueBuffer(window.get(), buffer, fence));
-}
-
-TEST_F(SurfaceTest, GetAndFlushRemovedBuffers) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    sp<DummyProducerListener> listener = new DummyProducerListener();
-    ASSERT_EQ(OK, surface->connect(
-            NATIVE_WINDOW_API_CPU,
-            /*listener*/listener,
-            /*reportBufferRemoval*/true));
-    const int BUFFER_COUNT = 4;
-    ASSERT_EQ(NO_ERROR, native_window_set_buffer_count(window.get(), BUFFER_COUNT));
-
-    sp<GraphicBuffer> detachedBuffer;
-    sp<Fence> outFence;
-    int fences[BUFFER_COUNT];
-    ANativeWindowBuffer* buffers[BUFFER_COUNT];
-    // Allocate buffers because detachNextBuffer requires allocated buffers
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffers[i], &fences[i]));
-    }
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffers[i], fences[i]));
-    }
-
-    // Test detached buffer is correctly reported
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    std::vector<sp<GraphicBuffer>> removedBuffers;
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(1u, removedBuffers.size());
-    ASSERT_EQ(detachedBuffer->handle, removedBuffers.at(0)->handle);
-    // Test the list is flushed one getAndFlushRemovedBuffers returns
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(0u, removedBuffers.size());
-
-
-    // Test removed buffer list is cleanup after next dequeueBuffer call
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffers[0], &fences[0]));
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(0u, removedBuffers.size());
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffers[0], fences[0]));
-
-    // Test removed buffer list is cleanup after next detachNextBuffer call
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(1u, removedBuffers.size());
-    ASSERT_EQ(detachedBuffer->handle, removedBuffers.at(0)->handle);
-
-    // Re-allocate buffers since all buffers are detached up to now
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffers[i], &fences[i]));
-    }
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffers[i], fences[i]));
-    }
-
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(NO_ERROR, surface->attachBuffer(detachedBuffer.get()));
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    // Depends on which slot GraphicBufferProducer impl pick, the attach call might
-    // get 0 or 1 buffer removed.
-    ASSERT_LE(removedBuffers.size(), 1u);
-}
-
-TEST_F(SurfaceTest, TestGetLastDequeueStartTime) {
-    sp<ANativeWindow> anw(mSurface);
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(anw.get(), NATIVE_WINDOW_API_CPU));
-
-    ANativeWindowBuffer* buffer = nullptr;
-    int32_t fenceFd = -1;
-
-    nsecs_t before = systemTime(CLOCK_MONOTONIC);
-    anw->dequeueBuffer(anw.get(), &buffer, &fenceFd);
-    nsecs_t after = systemTime(CLOCK_MONOTONIC);
-
-    nsecs_t lastDequeueTime = mSurface->getLastDequeueStartTime();
-    ASSERT_LE(before, lastDequeueTime);
-    ASSERT_GE(after, lastDequeueTime);
-}
-
-class FakeConsumer : public BnConsumerListener {
-public:
-    void onFrameAvailable(const BufferItem& /*item*/) override {}
-    void onBuffersReleased() override {}
-    void onSidebandStreamChanged() override {}
-
-    void addAndGetFrameTimestamps(
-            const NewFrameEventsEntry* newTimestamps,
-            FrameEventHistoryDelta* outDelta) override {
-        if (newTimestamps) {
-            if (mGetFrameTimestampsEnabled) {
-                EXPECT_GT(mNewFrameEntryOverride.frameNumber, 0u) <<
-                        "Test should set mNewFrameEntryOverride before queuing "
-                        "a frame.";
-                EXPECT_EQ(newTimestamps->frameNumber,
-                        mNewFrameEntryOverride.frameNumber) <<
-                        "Test attempting to add NewFrameEntryOverride with "
-                        "incorrect frame number.";
-                mFrameEventHistory.addQueue(mNewFrameEntryOverride);
-                mNewFrameEntryOverride.frameNumber = 0;
-            }
-            mAddFrameTimestampsCount++;
-            mLastAddedFrameNumber = newTimestamps->frameNumber;
-        }
-        if (outDelta) {
-            mFrameEventHistory.getAndResetDelta(outDelta);
-            mGetFrameTimestampsCount++;
-        }
-        mAddAndGetFrameTimestampsCallCount++;
-    }
-
-    bool mGetFrameTimestampsEnabled = false;
-
-    ConsumerFrameEventHistory mFrameEventHistory;
-    int mAddAndGetFrameTimestampsCallCount = 0;
-    int mAddFrameTimestampsCount = 0;
-    int mGetFrameTimestampsCount = 0;
-    uint64_t mLastAddedFrameNumber = NO_FRAME_INDEX;
-
-    NewFrameEventsEntry mNewFrameEntryOverride = { 0, 0, 0, nullptr };
-};
-
-
-class FakeSurfaceComposer : public ISurfaceComposer{
-public:
-    ~FakeSurfaceComposer() override {}
-
-    void setSupportsPresent(bool supportsPresent) {
-        mSupportsPresent = supportsPresent;
-    }
-
-    sp<ISurfaceComposerClient> createConnection() override { return nullptr; }
-    sp<ISurfaceComposerClient> createScopedConnection(
-            const sp<IGraphicBufferProducer>& /* parent */) override {
-        return nullptr;
-    }
-    sp<IDisplayEventConnection> createDisplayEventConnection(ISurfaceComposer::VsyncSource)
-            override {
-        return nullptr;
-    }
-    sp<IBinder> createDisplay(const String8& /*displayName*/,
-            bool /*secure*/) override { return nullptr; }
-    void destroyDisplay(const sp<IBinder>& /*display */) override {}
-    sp<IBinder> getBuiltInDisplay(int32_t /*id*/) override { return nullptr; }
-    void setTransactionState(const Vector<ComposerState>& /*state*/,
-            const Vector<DisplayState>& /*displays*/, uint32_t /*flags*/)
-            override {}
-    void bootFinished() override {}
-    bool authenticateSurfaceTexture(
-            const sp<IGraphicBufferProducer>& /*surface*/) const override {
-        return false;
-    }
-
-    status_t getSupportedFrameTimestamps(std::vector<FrameEvent>* outSupported)
-            const override {
-        *outSupported = {
-                FrameEvent::REQUESTED_PRESENT,
-                FrameEvent::ACQUIRE,
-                FrameEvent::LATCH,
-                FrameEvent::FIRST_REFRESH_START,
-                FrameEvent::LAST_REFRESH_START,
-                FrameEvent::GPU_COMPOSITION_DONE,
-                FrameEvent::DEQUEUE_READY,
-                FrameEvent::RELEASE
-        };
-        if (mSupportsPresent) {
-            outSupported->push_back(
-                        FrameEvent::DISPLAY_PRESENT);
-        }
-        return NO_ERROR;
-    }
-
-    void setPowerMode(const sp<IBinder>& /*display*/, int /*mode*/) override {}
-    status_t getDisplayConfigs(const sp<IBinder>& /*display*/,
-            Vector<DisplayInfo>* /*configs*/) override { return NO_ERROR; }
-    status_t getDisplayStats(const sp<IBinder>& /*display*/,
-            DisplayStatInfo* /*stats*/) override { return NO_ERROR; }
-    int getActiveConfig(const sp<IBinder>& /*display*/) override { return 0; }
-    status_t setActiveConfig(const sp<IBinder>& /*display*/, int /*id*/)
-            override {
-        return NO_ERROR;
-    }
-    status_t getDisplayColorModes(const sp<IBinder>& /*display*/,
-            Vector<ColorMode>* /*outColorModes*/) override {
-        return NO_ERROR;
-    }
-    ColorMode getActiveColorMode(const sp<IBinder>& /*display*/)
-            override {
-        return ColorMode::NATIVE;
-    }
-    status_t setActiveColorMode(const sp<IBinder>& /*display*/,
-        ColorMode /*colorMode*/) override { return NO_ERROR; }
-    status_t captureScreen(const sp<IBinder>& /*display*/,
-            sp<GraphicBuffer>* /*outBuffer*/,
-            Rect /*sourceCrop*/, uint32_t /*reqWidth*/, uint32_t /*reqHeight*/,
-            int32_t /*minLayerZ*/, int32_t /*maxLayerZ*/,
-            bool /*useIdentityTransform*/,
-            Rotation /*rotation*/) override { return NO_ERROR; }
-    virtual status_t captureLayers(const sp<IBinder>& /*parentHandle*/,
-                                   sp<GraphicBuffer>* /*outBuffer*/, const Rect& /*sourceCrop*/,
-                                   float /*frameScale*/, bool /*childrenOnly*/) override {
-        return NO_ERROR;
-    }
-    status_t clearAnimationFrameStats() override { return NO_ERROR; }
-    status_t getAnimationFrameStats(FrameStats* /*outStats*/) const override {
-        return NO_ERROR;
-    }
-    status_t getHdrCapabilities(const sp<IBinder>& /*display*/,
-            HdrCapabilities* /*outCapabilities*/) const override {
-        return NO_ERROR;
-    }
-    status_t enableVSyncInjections(bool /*enable*/) override {
-        return NO_ERROR;
-    }
-    status_t injectVSync(nsecs_t /*when*/) override { return NO_ERROR; }
-    status_t getLayerDebugInfo(std::vector<LayerDebugInfo>* /*layers*/) const override {
-        return NO_ERROR;
-    }
-
-protected:
-    IBinder* onAsBinder() override { return nullptr; }
-
-private:
-    bool mSupportsPresent{true};
-};
-
-class FakeProducerFrameEventHistory : public ProducerFrameEventHistory {
-public:
-    FakeProducerFrameEventHistory(FenceToFenceTimeMap* fenceMap)
-        : mFenceMap(fenceMap) {}
-
-    ~FakeProducerFrameEventHistory() {}
-
-    void updateAcquireFence(uint64_t frameNumber,
-            std::shared_ptr<FenceTime>&& acquire) override {
-        // Verify the acquire fence being added isn't the one from the consumer.
-        EXPECT_NE(mConsumerAcquireFence, acquire);
-        // Override the fence, so we can verify this was called by the
-        // producer after the frame is queued.
-        ProducerFrameEventHistory::updateAcquireFence(frameNumber,
-                std::shared_ptr<FenceTime>(mAcquireFenceOverride));
-    }
-
-    void setAcquireFenceOverride(
-            const std::shared_ptr<FenceTime>& acquireFenceOverride,
-            const std::shared_ptr<FenceTime>& consumerAcquireFence) {
-        mAcquireFenceOverride = acquireFenceOverride;
-        mConsumerAcquireFence = consumerAcquireFence;
-    }
-
-protected:
-    std::shared_ptr<FenceTime> createFenceTime(const sp<Fence>& fence)
-            const override {
-        return mFenceMap->createFenceTimeForTest(fence);
-    }
-
-    FenceToFenceTimeMap* mFenceMap{nullptr};
-
-    std::shared_ptr<FenceTime> mAcquireFenceOverride{FenceTime::NO_FENCE};
-    std::shared_ptr<FenceTime> mConsumerAcquireFence{FenceTime::NO_FENCE};
-};
-
-
-class TestSurface : public Surface {
-public:
-    TestSurface(const sp<IGraphicBufferProducer>& bufferProducer,
-            FenceToFenceTimeMap* fenceMap)
-        : Surface(bufferProducer),
-          mFakeSurfaceComposer(new FakeSurfaceComposer) {
-        mFakeFrameEventHistory = new FakeProducerFrameEventHistory(fenceMap);
-        mFrameEventHistory.reset(mFakeFrameEventHistory);
-    }
-
-    ~TestSurface() override {}
-
-    sp<ISurfaceComposer> composerService() const override {
-        return mFakeSurfaceComposer;
-    }
-
-    nsecs_t now() const override {
-        return mNow;
-    }
-
-    void setNow(nsecs_t now) {
-        mNow = now;
-    }
-
-public:
-    sp<FakeSurfaceComposer> mFakeSurfaceComposer;
-    nsecs_t mNow = 0;
-
-    // mFrameEventHistory owns the instance of FakeProducerFrameEventHistory,
-    // but this raw pointer gives access to test functionality.
-    FakeProducerFrameEventHistory* mFakeFrameEventHistory;
-};
-
-
-class GetFrameTimestampsTest : public ::testing::Test {
-protected:
-    struct FenceAndFenceTime {
-        explicit FenceAndFenceTime(FenceToFenceTimeMap& fenceMap)
-           : mFence(new Fence),
-             mFenceTime(fenceMap.createFenceTimeForTest(mFence)) {}
-        sp<Fence> mFence { nullptr };
-        std::shared_ptr<FenceTime> mFenceTime { nullptr };
-    };
-
-    struct RefreshEvents {
-        RefreshEvents(FenceToFenceTimeMap& fenceMap, nsecs_t refreshStart)
-          : mFenceMap(fenceMap),
-            kCompositorTiming(
-                {refreshStart, refreshStart + 1, refreshStart + 2 }),
-            kStartTime(refreshStart + 3),
-            kGpuCompositionDoneTime(refreshStart + 4),
-            kPresentTime(refreshStart + 5) {}
-
-        void signalPostCompositeFences() {
-            mFenceMap.signalAllForTest(
-                        mGpuCompositionDone.mFence, kGpuCompositionDoneTime);
-            mFenceMap.signalAllForTest(mPresent.mFence, kPresentTime);
-        }
-
-        FenceToFenceTimeMap& mFenceMap;
-
-        FenceAndFenceTime mGpuCompositionDone { mFenceMap };
-        FenceAndFenceTime mPresent { mFenceMap };
-
-        const CompositorTiming kCompositorTiming;
-
-        const nsecs_t kStartTime;
-        const nsecs_t kGpuCompositionDoneTime;
-        const nsecs_t kPresentTime;
-    };
-
-    struct FrameEvents {
-        FrameEvents(FenceToFenceTimeMap& fenceMap, nsecs_t frameStartTime)
-            : mFenceMap(fenceMap),
-              kPostedTime(frameStartTime + 100),
-              kRequestedPresentTime(frameStartTime + 200),
-              kProducerAcquireTime(frameStartTime + 300),
-              kConsumerAcquireTime(frameStartTime + 301),
-              kLatchTime(frameStartTime + 500),
-              kDequeueReadyTime(frameStartTime + 600),
-              kReleaseTime(frameStartTime + 700),
-              mRefreshes {
-                    { mFenceMap, frameStartTime + 410 },
-                    { mFenceMap, frameStartTime + 420 },
-                    { mFenceMap, frameStartTime + 430 } } {}
-
-        void signalQueueFences() {
-            mFenceMap.signalAllForTest(
-                        mAcquireConsumer.mFence, kConsumerAcquireTime);
-            mFenceMap.signalAllForTest(
-                        mAcquireProducer.mFence, kProducerAcquireTime);
-        }
-
-        void signalRefreshFences() {
-            for (auto& re : mRefreshes) {
-                re.signalPostCompositeFences();
-            }
-        }
-
-        void signalReleaseFences() {
-            mFenceMap.signalAllForTest(mRelease.mFence, kReleaseTime);
-        }
-
-        FenceToFenceTimeMap& mFenceMap;
-
-        FenceAndFenceTime mAcquireConsumer { mFenceMap };
-        FenceAndFenceTime mAcquireProducer { mFenceMap };
-        FenceAndFenceTime mRelease { mFenceMap };
-
-        const nsecs_t kPostedTime;
-        const nsecs_t kRequestedPresentTime;
-        const nsecs_t kProducerAcquireTime;
-        const nsecs_t kConsumerAcquireTime;
-        const nsecs_t kLatchTime;
-        const nsecs_t kDequeueReadyTime;
-        const nsecs_t kReleaseTime;
-
-        RefreshEvents mRefreshes[3];
-    };
-
-    GetFrameTimestampsTest() {}
-
-    virtual void SetUp() {
-        BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-        mFakeConsumer = new FakeConsumer;
-        mCfeh = &mFakeConsumer->mFrameEventHistory;
-        mConsumer->consumerConnect(mFakeConsumer, false);
-        mConsumer->setConsumerName(String8("TestConsumer"));
-        mSurface = new TestSurface(mProducer, &mFenceMap);
-        mWindow = mSurface;
-
-        ASSERT_EQ(NO_ERROR, native_window_api_connect(mWindow.get(),
-                NATIVE_WINDOW_API_CPU));
-        native_window_set_buffer_count(mWindow.get(), 4);
-    }
-
-    void disableFrameTimestamps() {
-        mFakeConsumer->mGetFrameTimestampsEnabled = false;
-        native_window_enable_frame_timestamps(mWindow.get(), 0);
-        mFrameTimestampsEnabled = false;
-    }
-
-    void enableFrameTimestamps() {
-        mFakeConsumer->mGetFrameTimestampsEnabled = true;
-        native_window_enable_frame_timestamps(mWindow.get(), 1);
-        mFrameTimestampsEnabled = true;
-    }
-
-    int getAllFrameTimestamps(uint64_t frameId) {
-        return native_window_get_frame_timestamps(mWindow.get(), frameId,
-                &outRequestedPresentTime, &outAcquireTime, &outLatchTime,
-                &outFirstRefreshStartTime, &outLastRefreshStartTime,
-                &outGpuCompositionDoneTime, &outDisplayPresentTime,
-                &outDequeueReadyTime, &outReleaseTime);
-    }
-
-    void resetTimestamps() {
-        outRequestedPresentTime = -1;
-        outAcquireTime = -1;
-        outLatchTime = -1;
-        outFirstRefreshStartTime = -1;
-        outLastRefreshStartTime = -1;
-        outGpuCompositionDoneTime = -1;
-        outDisplayPresentTime = -1;
-        outDequeueReadyTime = -1;
-        outReleaseTime = -1;
-    }
-
-    uint64_t getNextFrameId() {
-        uint64_t frameId = -1;
-        int status = native_window_get_next_frame_id(mWindow.get(), &frameId);
-        EXPECT_EQ(status, NO_ERROR);
-        return frameId;
-    }
-
-    void dequeueAndQueue(uint64_t frameIndex) {
-        int fence = -1;
-        ANativeWindowBuffer* buffer = nullptr;
-        ASSERT_EQ(NO_ERROR,
-                mWindow->dequeueBuffer(mWindow.get(), &buffer, &fence));
-
-        int oldAddFrameTimestampsCount =
-                mFakeConsumer->mAddFrameTimestampsCount;
-
-        FrameEvents* frame = &mFrames[frameIndex];
-        uint64_t frameNumber = frameIndex + 1;
-
-        NewFrameEventsEntry fe;
-        fe.frameNumber = frameNumber;
-        fe.postedTime = frame->kPostedTime;
-        fe.requestedPresentTime = frame->kRequestedPresentTime;
-        fe.acquireFence = frame->mAcquireConsumer.mFenceTime;
-        mFakeConsumer->mNewFrameEntryOverride = fe;
-
-        mSurface->mFakeFrameEventHistory->setAcquireFenceOverride(
-                    frame->mAcquireProducer.mFenceTime,
-                    frame->mAcquireConsumer.mFenceTime);
-
-        ASSERT_EQ(NO_ERROR, mWindow->queueBuffer(mWindow.get(), buffer, fence));
-
-        EXPECT_EQ(frameNumber, mFakeConsumer->mLastAddedFrameNumber);
-
-        EXPECT_EQ(
-                oldAddFrameTimestampsCount + (mFrameTimestampsEnabled ? 1 : 0),
-                mFakeConsumer->mAddFrameTimestampsCount);
-    }
-
-    void addFrameEvents(
-            bool gpuComposited, uint64_t iOldFrame, int64_t iNewFrame) {
-        FrameEvents* oldFrame =
-                (iOldFrame == NO_FRAME_INDEX) ? nullptr : &mFrames[iOldFrame];
-        FrameEvents* newFrame = &mFrames[iNewFrame];
-
-        uint64_t nOldFrame = (iOldFrame == NO_FRAME_INDEX) ? 0 : iOldFrame + 1;
-        uint64_t nNewFrame = iNewFrame + 1;
-
-        // Latch, Composite, and Release the frames in a plausible order.
-        // Note: The timestamps won't necessarily match the order, but
-        // that's okay for the purposes of this test.
-        std::shared_ptr<FenceTime> gpuDoneFenceTime = FenceTime::NO_FENCE;
-
-        // Composite the previous frame one more time, which helps verify
-        // LastRefresh is updated properly.
-        if (oldFrame != nullptr) {
-            mCfeh->addPreComposition(nOldFrame,
-                                     oldFrame->mRefreshes[2].kStartTime);
-            gpuDoneFenceTime = gpuComposited ?
-                    oldFrame->mRefreshes[2].mGpuCompositionDone.mFenceTime :
-                    FenceTime::NO_FENCE;
-            mCfeh->addPostComposition(nOldFrame, gpuDoneFenceTime,
-                    oldFrame->mRefreshes[2].mPresent.mFenceTime,
-                    oldFrame->mRefreshes[2].kCompositorTiming);
-        }
-
-        // Latch the new frame.
-        mCfeh->addLatch(nNewFrame, newFrame->kLatchTime);
-
-        mCfeh->addPreComposition(nNewFrame, newFrame->mRefreshes[0].kStartTime);
-        gpuDoneFenceTime = gpuComposited ?
-                newFrame->mRefreshes[0].mGpuCompositionDone.mFenceTime :
-                FenceTime::NO_FENCE;
-        // HWC2 releases the previous buffer after a new latch just before
-        // calling postComposition.
-        if (oldFrame != nullptr) {
-            mCfeh->addRelease(nOldFrame, oldFrame->kDequeueReadyTime,
-                    std::shared_ptr<FenceTime>(oldFrame->mRelease.mFenceTime));
-        }
-        mCfeh->addPostComposition(nNewFrame, gpuDoneFenceTime,
-                newFrame->mRefreshes[0].mPresent.mFenceTime,
-                newFrame->mRefreshes[0].kCompositorTiming);
-
-        mCfeh->addPreComposition(nNewFrame, newFrame->mRefreshes[1].kStartTime);
-        gpuDoneFenceTime = gpuComposited ?
-                newFrame->mRefreshes[1].mGpuCompositionDone.mFenceTime :
-                FenceTime::NO_FENCE;
-        mCfeh->addPostComposition(nNewFrame, gpuDoneFenceTime,
-                newFrame->mRefreshes[1].mPresent.mFenceTime,
-                newFrame->mRefreshes[1].kCompositorTiming);
-    }
-
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-    sp<FakeConsumer> mFakeConsumer;
-    ConsumerFrameEventHistory* mCfeh;
-    sp<TestSurface> mSurface;
-    sp<ANativeWindow> mWindow;
-
-    FenceToFenceTimeMap mFenceMap;
-
-    bool mFrameTimestampsEnabled = false;
-
-    int64_t outRequestedPresentTime = -1;
-    int64_t outAcquireTime = -1;
-    int64_t outLatchTime = -1;
-    int64_t outFirstRefreshStartTime = -1;
-    int64_t outLastRefreshStartTime = -1;
-    int64_t outGpuCompositionDoneTime = -1;
-    int64_t outDisplayPresentTime = -1;
-    int64_t outDequeueReadyTime = -1;
-    int64_t outReleaseTime = -1;
-
-    FrameEvents mFrames[3] {
-        { mFenceMap, 1000 }, { mFenceMap, 2000 }, { mFenceMap, 3000 } };
-};
-
-
-// This test verifies that the frame timestamps are not retrieved when not
-// explicitly enabled via native_window_enable_frame_timestamps.
-// We want to check this to make sure there's no overhead for users
-// that don't need the timestamp information.
-TEST_F(GetFrameTimestampsTest, DefaultDisabled) {
-    int fence;
-    ANativeWindowBuffer* buffer;
-
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    const uint64_t fId = getNextFrameId();
-
-    // Verify the producer doesn't get frame timestamps piggybacked on dequeue.
-    ASSERT_EQ(NO_ERROR, mWindow->dequeueBuffer(mWindow.get(), &buffer, &fence));
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify the producer doesn't get frame timestamps piggybacked on queue.
-    // It is okay that frame timestamps are added in the consumer since it is
-    // still needed for SurfaceFlinger dumps.
-    ASSERT_EQ(NO_ERROR, mWindow->queueBuffer(mWindow.get(), buffer, fence));
-    EXPECT_EQ(1, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify attempts to get frame timestamps fail.
-    int result = getAllFrameTimestamps(fId);
-    EXPECT_EQ(INVALID_OPERATION, result);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify compositor timing query fails.
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(INVALID_OPERATION, result);
-}
-
-// This test verifies that the frame timestamps are retrieved if explicitly
-// enabled via native_window_enable_frame_timestamps.
-TEST_F(GetFrameTimestampsTest, EnabledSimple) {
-    CompositorTiming initialCompositorTiming {
-        1000000000, // 1s deadline
-        16666667, // 16ms interval
-        50000000, // 50ms present latency
-    };
-    mCfeh->initializeCompositorTiming(initialCompositorTiming);
-
-    enableFrameTimestamps();
-
-    // Verify the compositor timing query gets the initial compositor values
-    // after timststamps are enabled; even before the first frame is queued
-    // or dequeued.
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-    mSurface->setNow(initialCompositorTiming.deadline - 1);
-    int result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    EXPECT_EQ(initialCompositorTiming.interval, compositeInterval);
-    EXPECT_EQ(initialCompositorTiming.presentLatency,
-              compositeToPresentLatency);
-
-    int fence;
-    ANativeWindowBuffer* buffer;
-
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(1, mFakeConsumer->mGetFrameTimestampsCount);
-
-    const uint64_t fId1 = getNextFrameId();
-
-    // Verify getFrameTimestamps is piggybacked on dequeue.
-    ASSERT_EQ(NO_ERROR, mWindow->dequeueBuffer(mWindow.get(), &buffer, &fence));
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(2, mFakeConsumer->mGetFrameTimestampsCount);
-
-    NewFrameEventsEntry f1;
-    f1.frameNumber = 1;
-    f1.postedTime = mFrames[0].kPostedTime;
-    f1.requestedPresentTime = mFrames[0].kRequestedPresentTime;
-    f1.acquireFence = mFrames[0].mAcquireConsumer.mFenceTime;
-    mSurface->mFakeFrameEventHistory->setAcquireFenceOverride(
-            mFrames[0].mAcquireProducer.mFenceTime,
-            mFrames[0].mAcquireConsumer.mFenceTime);
-    mFakeConsumer->mNewFrameEntryOverride = f1;
-    mFrames[0].signalQueueFences();
-
-    // Verify getFrameTimestamps is piggybacked on queue.
-    ASSERT_EQ(NO_ERROR, mWindow->queueBuffer(mWindow.get(), buffer, fence));
-    EXPECT_EQ(1, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(1u, mFakeConsumer->mLastAddedFrameNumber);
-    EXPECT_EQ(3, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify queries for timestamps that the producer doesn't know about
-    // triggers a call to see if the consumer has any new timestamps.
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(4, mFakeConsumer->mGetFrameTimestampsCount);
-}
-
-TEST_F(GetFrameTimestampsTest, QueryPresentSupported) {
-    bool displayPresentSupported = true;
-    mSurface->mFakeSurfaceComposer->setSupportsPresent(displayPresentSupported);
-
-    // Verify supported bits are forwarded.
-    int supportsPresent = -1;
-    mWindow.get()->query(mWindow.get(),
-            NATIVE_WINDOW_FRAME_TIMESTAMPS_SUPPORTS_PRESENT, &supportsPresent);
-    EXPECT_EQ(displayPresentSupported, supportsPresent);
-}
-
-TEST_F(GetFrameTimestampsTest, QueryPresentNotSupported) {
-    bool displayPresentSupported = false;
-    mSurface->mFakeSurfaceComposer->setSupportsPresent(displayPresentSupported);
-
-    // Verify supported bits are forwarded.
-    int supportsPresent = -1;
-    mWindow.get()->query(mWindow.get(),
-            NATIVE_WINDOW_FRAME_TIMESTAMPS_SUPPORTS_PRESENT, &supportsPresent);
-    EXPECT_EQ(displayPresentSupported, supportsPresent);
-}
-
-TEST_F(GetFrameTimestampsTest, SnapToNextTickBasic) {
-    nsecs_t phase = 4000;
-    nsecs_t interval = 1000;
-
-    // Timestamp in previous interval.
-    nsecs_t timestamp = 3500;
-    EXPECT_EQ(4000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp in next interval.
-    timestamp = 4500;
-    EXPECT_EQ(5000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp multiple intervals before.
-    timestamp = 2500;
-    EXPECT_EQ(3000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp multiple intervals after.
-    timestamp = 6500;
-    EXPECT_EQ(7000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp on previous interval.
-    timestamp = 3000;
-    EXPECT_EQ(3000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp on next interval.
-    timestamp = 5000;
-    EXPECT_EQ(5000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp equal to phase.
-    timestamp = 4000;
-    EXPECT_EQ(4000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-}
-
-// int(big_timestamp / interval) < 0, which can cause a crash or invalid result
-// if the number of intervals elapsed is internally stored in an int.
-TEST_F(GetFrameTimestampsTest, SnapToNextTickOverflow) {
-      nsecs_t phase = 0;
-      nsecs_t interval = 4000;
-      nsecs_t big_timestamp = 8635916564000;
-      int32_t intervals = big_timestamp / interval;
-
-      EXPECT_LT(intervals, 0);
-      EXPECT_EQ(8635916564000, ProducerFrameEventHistory::snapToNextTick(
-            big_timestamp, phase, interval));
-      EXPECT_EQ(8635916564000, ProducerFrameEventHistory::snapToNextTick(
-            big_timestamp, big_timestamp, interval));
-}
-
-// This verifies the compositor timing is updated by refresh events
-// and piggy backed on a queue, dequeue, and enabling of timestamps..
-TEST_F(GetFrameTimestampsTest, CompositorTimingUpdatesBasic) {
-    CompositorTiming initialCompositorTiming {
-        1000000000, // 1s deadline
-        16666667, // 16ms interval
-        50000000, // 50ms present latency
-    };
-    mCfeh->initializeCompositorTiming(initialCompositorTiming);
-
-    enableFrameTimestamps();
-
-    // We get the initial values before any frames are submitted.
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-    mSurface->setNow(initialCompositorTiming.deadline - 1);
-    int result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    EXPECT_EQ(initialCompositorTiming.interval, compositeInterval);
-    EXPECT_EQ(initialCompositorTiming.presentLatency,
-              compositeToPresentLatency);
-
-    dequeueAndQueue(0);
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-
-    // Still get the initial values because the frame events for frame 0
-    // didn't get a chance to piggyback on a queue or dequeue yet.
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    EXPECT_EQ(initialCompositorTiming.interval, compositeInterval);
-    EXPECT_EQ(initialCompositorTiming.presentLatency,
-              compositeToPresentLatency);
-
-    dequeueAndQueue(1);
-    addFrameEvents(true, 0, 1);
-
-    // Now expect the composite values associated with frame 1.
-    mSurface->setNow(mFrames[0].mRefreshes[1].kCompositorTiming.deadline);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].mRefreshes[1].kCompositorTiming.deadline,
-            compositeDeadline);
-    EXPECT_EQ(mFrames[0].mRefreshes[1].kCompositorTiming.interval,
-            compositeInterval);
-    EXPECT_EQ(mFrames[0].mRefreshes[1].kCompositorTiming.presentLatency,
-            compositeToPresentLatency);
-
-    dequeueAndQueue(2);
-    addFrameEvents(true, 1, 2);
-
-    // Now expect the composite values associated with frame 2.
-    mSurface->setNow(mFrames[1].mRefreshes[1].kCompositorTiming.deadline);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kCompositorTiming.deadline,
-            compositeDeadline);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kCompositorTiming.interval,
-            compositeInterval);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kCompositorTiming.presentLatency,
-            compositeToPresentLatency);
-
-    // Re-enabling frame timestamps should get the latest values.
-    disableFrameTimestamps();
-    enableFrameTimestamps();
-
-    // Now expect the composite values associated with frame 3.
-    mSurface->setNow(mFrames[2].mRefreshes[1].kCompositorTiming.deadline);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[2].mRefreshes[1].kCompositorTiming.deadline,
-            compositeDeadline);
-    EXPECT_EQ(mFrames[2].mRefreshes[1].kCompositorTiming.interval,
-            compositeInterval);
-    EXPECT_EQ(mFrames[2].mRefreshes[1].kCompositorTiming.presentLatency,
-            compositeToPresentLatency);
-}
-
-// This verifies the compositor deadline properly snaps to the the next
-// deadline based on the current time.
-TEST_F(GetFrameTimestampsTest, CompositorTimingDeadlineSnaps) {
-    CompositorTiming initialCompositorTiming {
-        1000000000, // 1s deadline
-        16666667, // 16ms interval
-        50000000, // 50ms present latency
-    };
-    mCfeh->initializeCompositorTiming(initialCompositorTiming);
-
-    enableFrameTimestamps();
-
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-
-    // A "now" just before the deadline snaps to the deadline.
-    mSurface->setNow(initialCompositorTiming.deadline - 1);
-    int result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    nsecs_t expectedDeadline = initialCompositorTiming.deadline;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    dequeueAndQueue(0);
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-
-    // A "now" just after the deadline snaps properly.
-    mSurface->setNow(initialCompositorTiming.deadline + 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            initialCompositorTiming.deadline +initialCompositorTiming.interval;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    dequeueAndQueue(1);
-    addFrameEvents(true, 0, 1);
-
-    // A "now" just after the next interval snaps properly.
-    mSurface->setNow(
-            mFrames[0].mRefreshes[1].kCompositorTiming.deadline +
-            mFrames[0].mRefreshes[1].kCompositorTiming.interval + 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            mFrames[0].mRefreshes[1].kCompositorTiming.deadline +
-            mFrames[0].mRefreshes[1].kCompositorTiming.interval * 2;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    dequeueAndQueue(2);
-    addFrameEvents(true, 1, 2);
-
-    // A "now" over 1 interval before the deadline snaps properly.
-    mSurface->setNow(
-            mFrames[1].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[1].mRefreshes[1].kCompositorTiming.interval - 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            mFrames[1].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[1].mRefreshes[1].kCompositorTiming.interval;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    // Re-enabling frame timestamps should get the latest values.
-    disableFrameTimestamps();
-    enableFrameTimestamps();
-
-    // A "now" over 2 intervals before the deadline snaps properly.
-    mSurface->setNow(
-            mFrames[2].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[2].mRefreshes[1].kCompositorTiming.interval * 2 - 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            mFrames[2].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[2].mRefreshes[1].kCompositorTiming.interval * 2;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-}
-
-// This verifies the timestamps recorded in the consumer's
-// FrameTimestampsHistory are properly retrieved by the producer for the
-// correct frames.
-TEST_F(GetFrameTimestampsTest, TimestampsAssociatedWithCorrectFrame) {
-    enableFrameTimestamps();
-
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-    mFrames[0].signalRefreshFences();
-    addFrameEvents(true, 0, 1);
-    mFrames[0].signalReleaseFences();
-    mFrames[1].signalRefreshFences();
-
-    // Verify timestamps are correct for frame 1.
-    resetTimestamps();
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kGpuCompositionDoneTime,
-            outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(mFrames[0].kReleaseTime, outReleaseTime);
-
-    // Verify timestamps are correct for frame 2.
-    resetTimestamps();
-    result = getAllFrameTimestamps(fId2);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[1].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[1].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kGpuCompositionDoneTime,
-            outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-}
-
-// This test verifies the acquire fence recorded by the consumer is not sent
-// back to the producer and the producer saves its own fence.
-TEST_F(GetFrameTimestampsTest, QueueTimestampsNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-
-    // Verify queue-related timestamps for f1 are available immediately in the
-    // producer without asking the consumer again, even before signaling the
-    // acquire fence.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = native_window_get_frame_timestamps(mWindow.get(), fId1,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outAcquireTime);
-
-    // Signal acquire fences. Verify a sync call still isn't necessary.
-    mFrames[0].signalQueueFences();
-
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = native_window_get_frame_timestamps(mWindow.get(), fId1,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-
-    // Dequeue and queue frame 2.
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-
-    // Verify queue-related timestamps for f2 are available immediately in the
-    // producer without asking the consumer again, even before signaling the
-    // acquire fence.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = native_window_get_frame_timestamps(mWindow.get(), fId2,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outAcquireTime);
-
-    // Signal acquire fences. Verify a sync call still isn't necessary.
-    mFrames[1].signalQueueFences();
-
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = native_window_get_frame_timestamps(mWindow.get(), fId2,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[1].kProducerAcquireTime, outAcquireTime);
-}
-
-TEST_F(GetFrameTimestampsTest, ZeroRequestedTimestampsNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-    mFrames[0].signalRefreshFences();
-    addFrameEvents(true, 0, 1);
-    mFrames[0].signalReleaseFences();
-    mFrames[1].signalRefreshFences();
-
-    // Verify a request for no timestamps doesn't result in a sync call.
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = native_window_get_frame_timestamps(mWindow.get(), fId2,
-            nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
-            nullptr, nullptr);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-}
-
-// This test verifies that fences can signal and update timestamps producer
-// side without an additional sync call to the consumer.
-TEST_F(GetFrameTimestampsTest, FencesInProducerNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-    addFrameEvents(true, 0, 1);
-
-    // Verify available timestamps are correct for frame 1, before any
-    // fence has been signaled.
-    // Note: A sync call is necessary here since the events triggered by
-    // addFrameEvents didn't get to piggyback on the earlier queues/dequeues.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount + 1, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    // Verify available timestamps are correct for frame 1 again, before any
-    // fence has been signaled.
-    // This time a sync call should not be necessary.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    // Signal the fences for frame 1.
-    mFrames[0].signalRefreshFences();
-    mFrames[0].signalReleaseFences();
-
-    // Verify all timestamps are available without a sync call.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kGpuCompositionDoneTime,
-            outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(mFrames[0].kReleaseTime, outReleaseTime);
-}
-
-// This test verifies that if the frame wasn't GPU composited but has a refresh
-// event a sync call isn't made to get the GPU composite done time since it will
-// never exist.
-TEST_F(GetFrameTimestampsTest, NoGpuNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(false, NO_FRAME_INDEX, 0);
-    addFrameEvents(false, 0, 1);
-
-    // Verify available timestamps are correct for frame 1, before any
-    // fence has been signaled.
-    // Note: A sync call is necessary here since the events triggered by
-    // addFrameEvents didn't get to piggyback on the earlier queues/dequeues.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount + 1, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    // Signal the fences for frame 1.
-    mFrames[0].signalRefreshFences();
-    mFrames[0].signalReleaseFences();
-
-    // Verify all timestamps, except GPU composition, are available without a
-    // sync call.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(mFrames[0].kReleaseTime, outReleaseTime);
-}
-
-// This test verifies that if the certain timestamps can't possibly exist for
-// the most recent frame, then a sync call is not done.
-TEST_F(GetFrameTimestampsTest, NoReleaseNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(false, NO_FRAME_INDEX, 0);
-    addFrameEvents(false, 0, 1);
-
-    // Verify available timestamps are correct for frame 1, before any
-    // fence has been signaled.
-    // Note: A sync call is necessary here since the events triggered by
-    // addFrameEvents didn't get to piggyback on the earlier queues/dequeues.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount + 1, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    mFrames[0].signalRefreshFences();
-    mFrames[0].signalReleaseFences();
-    mFrames[1].signalRefreshFences();
-
-    // Verify querying for all timestmaps of f2 does not do a sync call. Even
-    // though the lastRefresh, dequeueReady, and release times aren't
-    // available, a sync call should not occur because it's not possible for f2
-    // to encounter the final value for those events until another frame is
-    // queued.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId2);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[1].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[1].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-}
-
-// This test verifies there are no sync calls for present times
-// when they aren't supported and that an error is returned.
-
-TEST_F(GetFrameTimestampsTest, PresentUnsupportedNoSync) {
-    enableFrameTimestamps();
-    mSurface->mFakeSurfaceComposer->setSupportsPresent(false);
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-
-    // Verify a query for the Present times do not trigger a sync call if they
-    // are not supported.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = native_window_get_frame_timestamps(mWindow.get(), fId1,
-            nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
-            &outDisplayPresentTime, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(BAD_VALUE, result);
-    EXPECT_EQ(-1, outDisplayPresentTime);
-}
-
-} // namespace android
diff --git a/libs/gui/tests/TextureRenderer.cpp b/libs/gui/tests/TextureRenderer.cpp
deleted file mode 100644
index e822e6eaf..000000000
--- a/libs/gui/tests/TextureRenderer.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "TextureRenderer.h"
-
-#include "GLTest.h"
-
-#include <gui/GLConsumer.h>
-
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-TextureRenderer::TextureRenderer(GLuint texName,
-        const sp<GLConsumer>& st) : mTexName(texName), mST(st), mPgm(0),
-        mPositionHandle(-1), mTexSamplerHandle(-1), mTexMatrixHandle(-1) {
-}
-
-void TextureRenderer::SetUp() {
-    const char vsrc[] =
-        "attribute vec4 vPosition;\n"
-        "varying vec2 texCoords;\n"
-        "uniform mat4 texMatrix;\n"
-        "void main() {\n"
-        "  vec2 vTexCoords = 0.5 * (vPosition.xy + vec2(1.0, 1.0));\n"
-        "  texCoords = (texMatrix * vec4(vTexCoords, 0.0, 1.0)).xy;\n"
-        "  gl_Position = vPosition;\n"
-        "}\n";
-
-    const char fsrc[] =
-        "#extension GL_OES_EGL_image_external : require\n"
-        "precision mediump float;\n"
-        "uniform samplerExternalOES texSampler;\n"
-        "varying vec2 texCoords;\n"
-        "void main() {\n"
-        "  gl_FragColor = texture2D(texSampler, texCoords);\n"
-        "}\n";
-
-    {
-        SCOPED_TRACE("creating shader program");
-        ASSERT_NO_FATAL_FAILURE(GLTest::createProgram(vsrc, fsrc, &mPgm));
-    }
-
-    mPositionHandle = glGetAttribLocation(mPgm, "vPosition");
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_NE(-1, mPositionHandle);
-    mTexSamplerHandle = glGetUniformLocation(mPgm, "texSampler");
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_NE(-1, mTexSamplerHandle);
-    mTexMatrixHandle = glGetUniformLocation(mPgm, "texMatrix");
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_NE(-1, mTexMatrixHandle);
-}
-
-// drawTexture draws the GLConsumer over the entire GL viewport.
-void TextureRenderer::drawTexture() {
-    static const GLfloat triangleVertices[] = {
-        -1.0f, 1.0f,
-        -1.0f, -1.0f,
-        1.0f, -1.0f,
-        1.0f, 1.0f,
-    };
-
-    glVertexAttribPointer(mPositionHandle, 2, GL_FLOAT, GL_FALSE, 0,
-            triangleVertices);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glEnableVertexAttribArray(mPositionHandle);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-    glUseProgram(mPgm);
-    glUniform1i(mTexSamplerHandle, 0);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTexName);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-    // XXX: These calls are not needed for GL_TEXTURE_EXTERNAL_OES as
-    // they're setting the defautls for that target, but when hacking
-    // things to use GL_TEXTURE_2D they are needed to achieve the same
-    // behavior.
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER,
-            GL_LINEAR);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER,
-            GL_LINEAR);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S,
-            GL_CLAMP_TO_EDGE);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T,
-            GL_CLAMP_TO_EDGE);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-    GLfloat texMatrix[16];
-    mST->getTransformMatrix(texMatrix);
-    glUniformMatrix4fv(mTexMatrixHandle, 1, GL_FALSE, texMatrix);
-
-    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-}
-
-} // namespace android
diff --git a/libs/gui/tests/TextureRenderer.h b/libs/gui/tests/TextureRenderer.h
deleted file mode 100644
index 37b2b47b4..000000000
--- a/libs/gui/tests/TextureRenderer.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_TEXTURE_RENDERER_H
-#define ANDROID_TEXTURE_RENDERER_H
-
-#include <GLES/gl.h>
-
-#include <utils/RefBase.h>
-
-namespace android {
-
-class GLConsumer;
-
-class TextureRenderer : public RefBase {
-public:
-    TextureRenderer(GLuint texName, const sp<GLConsumer>& st);
-
-    void SetUp();
-    void drawTexture();
-
-private:
-    GLuint mTexName;
-    sp<GLConsumer> mST;
-    GLuint mPgm;
-    GLint mPositionHandle;
-    GLint mTexSamplerHandle;
-    GLint mTexMatrixHandle;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/ui/tests/Android.bp b/libs/ui/tests/Android.bp
deleted file mode 100644
index aef6428cc..000000000
--- a/libs/ui/tests/Android.bp
+++ /dev/null
@@ -1,36 +0,0 @@
-//
-// Copyright (C) 2014 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-cc_test {
-    name: "Region_test",
-    shared_libs: ["libui"],
-    srcs: ["Region_test.cpp"],
-    cflags: ["-Wall", "-Werror"],
-}
-
-cc_test {
-    name: "colorspace_test",
-    shared_libs: ["libui"],
-    srcs: ["colorspace_test.cpp"],
-    cflags: ["-Wall", "-Werror"],
-}
-
-cc_test {
-    name: "GraphicBuffer_test",
-    shared_libs: ["libpdx_default_transport", "libui", "libutils"],
-    srcs: ["GraphicBuffer_test.cpp"],
-    cflags: ["-Wall", "-Werror"],
-}
diff --git a/libs/ui/tests/GraphicBuffer_test.cpp b/libs/ui/tests/GraphicBuffer_test.cpp
deleted file mode 100644
index eb679ac23..000000000
--- a/libs/ui/tests/GraphicBuffer_test.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "GraphicBufferTest"
-
-#include <ui/DetachedBufferHandle.h>
-#include <ui/GraphicBuffer.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-namespace {
-
-constexpr uint32_t kTestWidth = 1024;
-constexpr uint32_t kTestHeight = 1;
-constexpr uint32_t kTestFormat = HAL_PIXEL_FORMAT_BLOB;
-constexpr uint32_t kTestLayerCount = 1;
-constexpr uint64_t kTestUsage = GraphicBuffer::USAGE_SW_WRITE_OFTEN;
-
-} // namespace
-
-class GraphicBufferTest : public testing::Test {};
-
-TEST_F(GraphicBufferTest, DetachedBuffer) {
-    sp<GraphicBuffer> buffer(
-            new GraphicBuffer(kTestWidth, kTestHeight, kTestFormat, kTestLayerCount, kTestUsage));
-
-    // Currently a newly allocated GraphicBuffer is in legacy mode, i.e. not associated with
-    // BufferHub. But this may change in the future.
-    EXPECT_FALSE(buffer->isDetachedBuffer());
-
-    pdx::LocalChannelHandle channel{nullptr, 1234};
-    EXPECT_TRUE(channel.valid());
-
-    std::unique_ptr<DetachedBufferHandle> handle = DetachedBufferHandle::Create(std::move(channel));
-    EXPECT_FALSE(channel.valid());
-    EXPECT_TRUE(handle->isValid());
-    EXPECT_TRUE(handle->handle().valid());
-
-    buffer->setDetachedBufferHandle(std::move(handle));
-    EXPECT_TRUE(handle == nullptr);
-    EXPECT_TRUE(buffer->isDetachedBuffer());
-
-    handle = buffer->takeDetachedBufferHandle();
-    EXPECT_TRUE(handle != nullptr);
-    EXPECT_TRUE(handle->isValid());
-    EXPECT_FALSE(buffer->isDetachedBuffer());
-}
-
-} // namespace android
diff --git a/libs/ui/tests/Region_test.cpp b/libs/ui/tests/Region_test.cpp
deleted file mode 100644
index b104a4636..000000000
--- a/libs/ui/tests/Region_test.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "RegionTest"
-
-#include <stdlib.h>
-#include <ui/Region.h>
-#include <ui/Rect.h>
-#include <gtest/gtest.h>
-
-namespace android {
-
-class RegionTest : public testing::Test {
-protected:
-    void checkVertTJunction(const Rect* lhs, const Rect* rhs) {
-        EXPECT_FALSE((rhs->right > lhs->left && rhs->right < lhs->right) ||
-                (rhs->left > lhs->left && rhs->left < lhs->right));
-    }
-
-    void verifyNoTJunctions(const Region& r) {
-        for (const Rect* current = r.begin(); current < r.end(); current++) {
-            for (const Rect* other = current - 1; other >= r.begin(); other--) {
-                if (other->bottom < current->top) break;
-                if (other->bottom != current->top) continue;
-                checkVertTJunction(current, other);
-            }
-            for (const Rect* other = current + 1; other < r.end(); other++) {
-                if (other->top > current->bottom) break;
-                if (other->top != current->bottom) continue;
-                checkVertTJunction(current, other);
-            }
-        }
-    }
-
-    void checkTJunctionFreeFromRegion(const Region& original, int expectedCount = -1) {
-        Region modified = Region::createTJunctionFreeRegion(original);
-        verifyNoTJunctions(modified);
-        if (expectedCount != -1) {
-            EXPECT_EQ(modified.end() - modified.begin(), expectedCount);
-        }
-        EXPECT_TRUE((original ^ modified).isEmpty());
-    }
-};
-
-TEST_F(RegionTest, MinimalDivision_TJunction) {
-    Region r;
-     // | x |
-     // |xxx|
-    r.clear();
-    r.orSelf(Rect(1, 0, 2, 1));
-    r.orSelf(Rect(0, 1, 3, 2));
-    checkTJunctionFreeFromRegion(r, 4);
-
-     // | x |
-     // |   |
-     // |xxx|
-    r.clear();
-    r.orSelf(Rect(1, 0, 2, 1));
-    r.orSelf(Rect(0, 2, 3, 3));
-    checkTJunctionFreeFromRegion(r, 2);
-}
-
-TEST_F(RegionTest, Trivial_TJunction) {
-    Region r;
-    checkTJunctionFreeFromRegion(r);
-
-    r.orSelf(Rect(100, 100, 500, 500));
-    checkTJunctionFreeFromRegion(r);
-}
-
-TEST_F(RegionTest, Simple_TJunction) {
-    Region r;
-     // | x  |
-     // |xxxx|
-     // |xxxx|
-     // |xxxx|
-    r.clear();
-    r.orSelf(Rect(1, 0, 2, 1));
-    r.orSelf(Rect(0, 1, 3, 3));
-    checkTJunctionFreeFromRegion(r);
-
-     // | x |
-     // |xx |
-     // |xxx|
-    r.clear();
-    r.orSelf(Rect(2,0,4,2));
-    r.orSelf(Rect(0,2,4,4));
-    r.orSelf(Rect(0,4,6,6));
-    checkTJunctionFreeFromRegion(r);
-
-     // |x x|
-     // |xxx|
-     // |x x|
-    r.clear();
-    r.orSelf(Rect(0,0,2,6));
-    r.orSelf(Rect(4,0,6,6));
-    r.orSelf(Rect(0,2,6,4));
-    checkTJunctionFreeFromRegion(r);
-
-     // |xxx|
-     // | x |
-     // | x |
-    r.clear();
-    r.orSelf(Rect(0,0,6,2));
-    r.orSelf(Rect(2,2,4,6));
-    checkTJunctionFreeFromRegion(r);
-}
-
-TEST_F(RegionTest, Bigger_TJunction) {
-    Region r;
-     // |xxxx   |
-     // | xxxx  |
-     // |  xxxx |
-     // |   xxxx|
-    for (int i = 0; i < 4; i++) {
-        r.orSelf(Rect(i,i,i+4,i+1));
-    }
-    checkTJunctionFreeFromRegion(r, 16);
-}
-
-#define ITER_MAX 1000
-#define X_MAX 8
-#define Y_MAX 8
-
-TEST_F(RegionTest, Random_TJunction) {
-    Region r;
-    srandom(12345);
-
-    for (int iter = 0; iter < ITER_MAX; iter++) {
-        r.clear();
-        for (int i = 0; i < X_MAX; i++) {
-            for (int j = 0; j < Y_MAX; j++) {
-                if (random() % 2) {
-                    r.orSelf(Rect(i, j, i + 1, j + 1));
-                }
-            }
-        }
-        checkTJunctionFreeFromRegion(r);
-    }
-}
-
-}; // namespace android
-
diff --git a/libs/ui/tests/colorspace_test.cpp b/libs/ui/tests/colorspace_test.cpp
deleted file mode 100644
index 0a4873c8d..000000000
--- a/libs/ui/tests/colorspace_test.cpp
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "ColorSpaceTest"
-
-#include <math.h>
-#include <stdlib.h>
-
-#include <ui/ColorSpace.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-class ColorSpaceTest : public testing::Test {
-protected:
-};
-
-TEST_F(ColorSpaceTest, XYZ) {
-    mat3 sRGBToXYZ(transpose(mat3{
-        0.412391f, 0.357584f, 0.180481f,
-        0.212639f, 0.715169f, 0.072192f,
-        0.019331f, 0.119195f, 0.950532f
-    }));
-
-    mat3 XYZtoSRGB(inverse(sRGBToXYZ));
-
-    ColorSpace sRGB("sRGB", sRGBToXYZ);
-
-    EXPECT_EQ(sRGBToXYZ, sRGB.getRGBtoXYZ());
-    EXPECT_EQ(XYZtoSRGB, sRGB.getXYZtoRGB());
-}
-
-TEST_F(ColorSpaceTest, XYZPrimaries) {
-    mat3 sRGBToXYZ(transpose(mat3{
-        0.412391f, 0.357584f, 0.180481f,
-        0.212639f, 0.715169f, 0.072192f,
-        0.019331f, 0.119195f, 0.950532f
-    }));
-
-    ColorSpace sRGB("sRGB", sRGBToXYZ);
-
-    EXPECT_NEAR(0.640f, sRGB.getPrimaries()[0].x, 1e-5f);
-    EXPECT_NEAR(0.330f, sRGB.getPrimaries()[0].y, 1e-5f);
-
-    EXPECT_NEAR(0.300f, sRGB.getPrimaries()[1].x, 1e-5f);
-    EXPECT_NEAR(0.600f, sRGB.getPrimaries()[1].y, 1e-5f);
-
-    EXPECT_NEAR(0.150f, sRGB.getPrimaries()[2].x, 1e-5f);
-    EXPECT_NEAR(0.060f, sRGB.getPrimaries()[2].y, 1e-5f);
-}
-
-TEST_F(ColorSpaceTest, XYZWhitePoint) {
-    mat3 sRGBToXYZ(transpose(mat3{
-        0.412391f, 0.357584f, 0.180481f,
-        0.212639f, 0.715169f, 0.072192f,
-        0.019331f, 0.119195f, 0.950532f
-    }));
-
-    ColorSpace sRGB("sRGB", sRGBToXYZ);
-
-    EXPECT_NEAR(0.3127f, sRGB.getWhitePoint().x, 1e-5f);
-    EXPECT_NEAR(0.3290f, sRGB.getWhitePoint().y, 1e-5f);
-}
-
-TEST_F(ColorSpaceTest, XYZFromPrimaries) {
-    mat3 sRGBToXYZ(transpose(mat3{
-        0.412391f, 0.357584f, 0.180481f,
-        0.212639f, 0.715169f, 0.072192f,
-        0.019331f, 0.119195f, 0.950532f
-    }));
-
-    ColorSpace sRGB1("sRGB", sRGBToXYZ);
-    ColorSpace sRGB2(
-          "sRGB",
-          {{float2{0.640f, 0.330f}, {0.300f, 0.600f}, {0.150f, 0.060f}}},
-          {0.3127f, 0.3290f}
-    );
-
-    for (size_t i = 0; i < 3; i++) {
-        for (size_t j= 0; j < 3; j++) {
-            ASSERT_NEAR(sRGB1.getRGBtoXYZ()[i][j], sRGB2.getRGBtoXYZ()[i][j], 1e-5f);
-        }
-    }
-
-    for (size_t i = 0; i < 3; i++) {
-        for (size_t j= 0; j < 3; j++) {
-            ASSERT_NEAR(sRGB2.getXYZtoRGB()[i][j], sRGB2.getXYZtoRGB()[i][j], 1e-5f);
-        }
-    }
-}
-
-TEST_F(ColorSpaceTest, TransferFunctions) {
-    ColorSpace sRGB = ColorSpace::sRGB();
-
-    EXPECT_NEAR(0.0f, sRGB.getEOTF()(0.0f), 1e-6f);
-    EXPECT_NEAR(0.0f, sRGB.getOETF()(0.0f), 1e-6f);
-    EXPECT_NEAR(1.0f, sRGB.getEOTF()(1.0f), 1e-6f);
-    EXPECT_NEAR(1.0f, sRGB.getOETF()(1.0f), 1e-6f);
-
-    for (float v = 0.0f; v <= 0.5f; v += 1e-3f) {
-        ASSERT_TRUE(v >= sRGB.getEOTF()(v));
-        ASSERT_TRUE(v <= sRGB.getOETF()(v));
-    }
-
-    float previousEOTF = std::numeric_limits<float>::lowest();
-    float previousOETF = std::numeric_limits<float>::lowest();
-    for (float v = 0.0f; v <= 1.0f; v += 1e-3f) {
-        ASSERT_TRUE(previousEOTF < sRGB.getEOTF()(v));
-        previousEOTF = sRGB.getEOTF()(v);
-        ASSERT_TRUE(previousOETF < sRGB.getOETF()(v));
-        previousOETF = sRGB.getOETF()(v);
-    }
-
-    ColorSpace sRGB2(
-          "sRGB",
-          {{float2{0.640f, 0.330f}, {0.300f, 0.600f}, {0.150f, 0.060f}}},
-          {0.3127f, 0.3290f}
-          // linear transfer functions
-    );
-    for (float v = 0.0f; v <= 1.0f; v += 1e-3f) {
-        ASSERT_EQ(v, sRGB2.getEOTF()(v));
-        ASSERT_EQ(v, sRGB2.getOETF()(v));
-    }
-}
-
-TEST_F(ColorSpaceTest, Clamping) {
-    // Pick a color outside of sRGB
-    float3 c(ColorSpace::BT2020().rgbToXYZ(float3{0, 1, 0}));
-
-    // The color will be clamped
-    float3 sRGB(ColorSpace::sRGB().xyzToRGB(c));
-    EXPECT_TRUE(sRGB > float3{0.0} && sRGB < float3{1.0});
-
-    // The color will not be clamped
-    float3 extendedSRGB(ColorSpace::linearExtendedSRGB().xyzToRGB(c));
-    EXPECT_TRUE(extendedSRGB.g > 1.0f);
-}
-
-TEST_F(ColorSpaceTest, Connect) {
-    // No chromatic adaptation
-    auto r = ColorSpaceConnector(ColorSpace::sRGB(), ColorSpace::AdobeRGB())
-            .transform({1.0f, 0.5f, 0.0f});
-    EXPECT_TRUE(all(lessThan(abs(r - float3{0.8912f, 0.4962f, 0.1164f}), float3{1e-4f})));
-
-    // Test with chromatic adaptation
-    r = ColorSpaceConnector(ColorSpace::sRGB(), ColorSpace::ProPhotoRGB())
-            .transform({1.0f, 0.0f, 0.0f});
-    EXPECT_TRUE(all(lessThan(abs(r - float3{0.70226f, 0.2757f, 0.1036f}), float3{1e-4f})));
-}
-
-TEST_F(ColorSpaceTest, LUT) {
-    auto lut = ColorSpace::createLUT(17, ColorSpace::sRGB(), ColorSpace::AdobeRGB());
-    EXPECT_TRUE(lut != nullptr);
-
-    // {1.0f, 0.5f, 0.0f}
-    auto r = lut.get()[0 * 17 * 17 + 8 * 17 + 16];
-    EXPECT_TRUE(all(lessThan(abs(r - float3{0.8912f, 0.4962f, 0.1164f}), float3{1e-4f})));
-
-    // {1.0f, 1.0f, 0.5f}
-    r = lut.get()[8 * 17 * 17 + 0 * 17 + 16]; // y (G) is flipped
-    EXPECT_TRUE(all(lessThan(abs(r - float3{1.0f, 1.0f, 0.5290f}), float3{1e-4f})));
-
-    // {1.0f, 1.0f, 1.0f}
-    r = lut.get()[16 * 17 * 17 + 0 * 17 + 16]; // y (G) is flipped
-    EXPECT_TRUE(all(lessThan(abs(r - float3{1.0f, 1.0f, 1.0f}), float3{1e-4f})));
-
-}
-
-}; // namespace android
-- 
2.11.0

