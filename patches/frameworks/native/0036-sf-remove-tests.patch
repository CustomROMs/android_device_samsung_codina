From 2d5a0310de5e139841978e96a8a904ad028dee10 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 17 Sep 2018 16:32:02 +0300
Subject: [PATCH 36/49] sf: remove tests

Change-Id: I881f16c13f9c54299eaa111a1dc0496ed37407fb
---
 services/surfaceflinger/Android.bp                 |    1 -
 services/surfaceflinger/tests/Android.bp           |   52 -
 services/surfaceflinger/tests/AndroidTest.xml      |   26 -
 services/surfaceflinger/tests/Stress_test.cpp      |  112 -
 .../tests/SurfaceFlinger_test.filter               |    5 -
 .../tests/SurfaceInterceptor_test.cpp              |  872 ----
 services/surfaceflinger/tests/Transaction_test.cpp | 2693 -----------
 services/surfaceflinger/tests/fakehwc/Android.bp   |   41 -
 .../tests/fakehwc/FakeComposerClient.cpp           |  619 ---
 .../tests/fakehwc/FakeComposerClient.h             |  164 -
 .../tests/fakehwc/FakeComposerService.cpp          |   56 -
 .../tests/fakehwc/FakeComposerService.h            |   40 -
 .../tests/fakehwc/FakeComposerUtils.cpp            |  183 -
 .../tests/fakehwc/FakeComposerUtils.h              |  122 -
 .../surfaceflinger/tests/fakehwc/RenderState.h     |   44 -
 .../tests/fakehwc/SFFakeHwc_test.cpp               | 1424 ------
 services/surfaceflinger/tests/hwc2/Android.bp      |   56 -
 services/surfaceflinger/tests/hwc2/Hwc2Test.cpp    | 4772 --------------------
 .../surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp   |  791 ----
 .../surfaceflinger/tests/hwc2/Hwc2TestBuffer.h     |  108 -
 .../tests/hwc2/Hwc2TestClientTarget.cpp            |  102 -
 .../tests/hwc2/Hwc2TestClientTarget.h              |   69 -
 .../surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp    |  249 -
 services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h |  103 -
 .../surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp   |  281 --
 .../surfaceflinger/tests/hwc2/Hwc2TestLayers.h     |   86 -
 .../tests/hwc2/Hwc2TestPixelComparator.cpp         |  113 -
 .../tests/hwc2/Hwc2TestPixelComparator.h           |   59 -
 .../tests/hwc2/Hwc2TestProperties.cpp              |  782 ----
 .../surfaceflinger/tests/hwc2/Hwc2TestProperties.h |  386 --
 .../tests/hwc2/Hwc2TestVirtualDisplay.cpp          |   98 -
 .../tests/hwc2/Hwc2TestVirtualDisplay.h            |   55 -
 services/surfaceflinger/tests/unittests/Android.bp |   43 -
 .../surfaceflinger/tests/unittests/AndroidTest.xml |   26 -
 .../tests/unittests/AsyncCallRecorder.h            |  165 -
 .../tests/unittests/DisplayTransactionTest.cpp     | 2798 ------------
 .../tests/unittests/EventControlThreadTest.cpp     |  119 -
 .../tests/unittests/EventThreadTest.cpp            |  422 --
 .../tests/unittests/TestableSurfaceFlinger.h       |  336 --
 .../mock/DisplayHardware/MockComposer.cpp          |   29 -
 .../unittests/mock/DisplayHardware/MockComposer.h  |  118 -
 .../mock/DisplayHardware/MockDisplaySurface.cpp    |   27 -
 .../mock/DisplayHardware/MockDisplaySurface.h      |   43 -
 .../unittests/mock/MockEventControlThread.cpp      |   27 -
 .../tests/unittests/mock/MockEventControlThread.h  |   35 -
 .../tests/unittests/mock/MockEventThread.cpp       |   27 -
 .../tests/unittests/mock/MockEventThread.h         |   40 -
 .../tests/unittests/mock/MockMessageQueue.cpp      |   27 -
 .../tests/unittests/mock/MockMessageQueue.h        |   40 -
 .../unittests/mock/MockNativeWindowSurface.cpp     |   27 -
 .../tests/unittests/mock/MockNativeWindowSurface.h |   38 -
 .../unittests/mock/MockSurfaceInterceptor.cpp      |   27 -
 .../tests/unittests/mock/MockSurfaceInterceptor.h  |   50 -
 .../mock/RenderEngine/MockRenderEngine.cpp         |   35 -
 .../unittests/mock/RenderEngine/MockRenderEngine.h |  108 -
 .../mock/gui/MockGraphicBufferConsumer.cpp         |   27 -
 .../unittests/mock/gui/MockGraphicBufferConsumer.h |   56 -
 .../mock/gui/MockGraphicBufferProducer.cpp         |   27 -
 .../unittests/mock/gui/MockGraphicBufferProducer.h |   62 -
 .../mock/system/window/MockNativeWindow.cpp        |   93 -
 .../mock/system/window/MockNativeWindow.h          |   46 -
 services/surfaceflinger/tests/vsync/Android.bp     |   30 -
 services/surfaceflinger/tests/vsync/vsync.cpp      |   84 -
 .../surfaceflinger/tests/waitforvsync/Android.bp   |   26 -
 .../tests/waitforvsync/waitforvsync.cpp            |   46 -
 65 files changed, 19668 deletions(-)
 delete mode 100644 services/surfaceflinger/tests/Android.bp
 delete mode 100644 services/surfaceflinger/tests/AndroidTest.xml
 delete mode 100644 services/surfaceflinger/tests/Stress_test.cpp
 delete mode 100644 services/surfaceflinger/tests/SurfaceFlinger_test.filter
 delete mode 100644 services/surfaceflinger/tests/SurfaceInterceptor_test.cpp
 delete mode 100644 services/surfaceflinger/tests/Transaction_test.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/Android.bp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerClient.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerService.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/RenderState.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Android.bp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2Test.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h
 delete mode 100644 services/surfaceflinger/tests/unittests/Android.bp
 delete mode 100644 services/surfaceflinger/tests/unittests/AndroidTest.xml
 delete mode 100644 services/surfaceflinger/tests/unittests/AsyncCallRecorder.h
 delete mode 100644 services/surfaceflinger/tests/unittests/DisplayTransactionTest.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/EventControlThreadTest.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/EventThreadTest.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockEventControlThread.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockEventControlThread.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockEventThread.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockEventThread.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockMessageQueue.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockMessageQueue.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.h
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.cpp
 delete mode 100644 services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.h
 delete mode 100644 services/surfaceflinger/tests/vsync/Android.bp
 delete mode 100644 services/surfaceflinger/tests/vsync/vsync.cpp
 delete mode 100644 services/surfaceflinger/tests/waitforvsync/Android.bp
 delete mode 100644 services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp

diff --git a/services/surfaceflinger/Android.bp b/services/surfaceflinger/Android.bp
index c2bb6ad6b..8c17db2c8 100644
--- a/services/surfaceflinger/Android.bp
+++ b/services/surfaceflinger/Android.bp
@@ -218,5 +218,4 @@ cc_library_shared {
 subdirs = [
     "layerproto",
     "TimeStats/timestatsproto",
-    "tests",
 ]
diff --git a/services/surfaceflinger/tests/Android.bp b/services/surfaceflinger/tests/Android.bp
deleted file mode 100644
index 322e8a0fe..000000000
--- a/services/surfaceflinger/tests/Android.bp
+++ /dev/null
@@ -1,52 +0,0 @@
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_test {
-    name: "SurfaceFlinger_test",
-    defaults: ["surfaceflinger_defaults"],
-    tags: ["test"],
-    test_suites: ["device-tests"],
-    srcs: [
-        "Stress_test.cpp",
-        "SurfaceInterceptor_test.cpp",
-        "Transaction_test.cpp",
-    ],
-    data: ["SurfaceFlinger_test.filter"],
-    static_libs: [
-        "libtrace_proto",
-    ],
-    shared_libs: [
-        "libandroid",
-        "libbinder",
-        "libcutils",
-        "libEGL",
-        "libGLESv2",
-        "libgui",
-        "liblayers_proto",
-        "liblog",
-        "libprotobuf-cpp-full",
-        "libtimestats_proto",
-        "libui",
-        "libutils",
-    ]
-
-}
-
-subdirs = [
-    "fakehwc",
-    "hwc2",
-    "unittests",
-    "vsync",
-    "waitforvsync",
-]
diff --git a/services/surfaceflinger/tests/AndroidTest.xml b/services/surfaceflinger/tests/AndroidTest.xml
deleted file mode 100644
index 8315037b9..000000000
--- a/services/surfaceflinger/tests/AndroidTest.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2017 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Config for SurfaceFlinger_test">
-    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
-        <option name="cleanup" value="true" />
-        <option name="push" value="SurfaceFlinger_test->/data/local/tmp/SurfaceFlinger_test" />
-    </target_preparer>
-    <option name="test-suite-tag" value="apct" />
-    <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp" />
-        <option name="module-name" value="SurfaceFlinger_test" />
-    </test>
-</configuration>
diff --git a/services/surfaceflinger/tests/Stress_test.cpp b/services/surfaceflinger/tests/Stress_test.cpp
deleted file mode 100644
index 4577153df..000000000
--- a/services/surfaceflinger/tests/Stress_test.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gtest/gtest.h>
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <utils/String8.h>
-
-#include <thread>
-#include <functional>
-#include <layerproto/LayerProtoParser.h>
-
-namespace android {
-
-TEST(SurfaceFlingerStress, create_and_destroy) {
-    auto do_stress = []() {
-        sp<SurfaceComposerClient> client = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, client->initCheck());
-        for (int j = 0; j < 1000; j++) {
-            auto surf = client->createSurface(String8("t"), 100, 100,
-                    PIXEL_FORMAT_RGBA_8888, 0);
-            ASSERT_TRUE(surf != nullptr);
-            client->destroySurface(surf->getHandle());
-        }
-    };
-
-    std::vector<std::thread> threads;
-    for (int i = 0; i < 10; i++) {
-        threads.push_back(std::thread(do_stress));
-    }
-    for (auto& thread : threads) {
-        thread.join();
-    }
-}
-
-surfaceflinger::LayersProto generateLayerProto() {
-    surfaceflinger::LayersProto layersProto;
-    std::array<surfaceflinger::LayerProto*, 10> layers = {};
-    for (size_t i = 0; i < layers.size(); ++i) {
-        layers[i] = layersProto.add_layers();
-        layers[i]->set_id(i);
-    }
-
-    layers[0]->add_children(1);
-    layers[1]->set_parent(0);
-    layers[0]->add_children(2);
-    layers[2]->set_parent(0);
-    layers[0]->add_children(3);
-    layers[3]->set_parent(0);
-    layers[2]->add_children(4);
-    layers[4]->set_parent(2);
-    layers[3]->add_children(5);
-    layers[5]->set_parent(3);
-    layers[5]->add_children(6);
-    layers[6]->set_parent(5);
-    layers[5]->add_children(7);
-    layers[7]->set_parent(5);
-    layers[6]->add_children(8);
-    layers[8]->set_parent(6);
-
-    layers[4]->set_z_order_relative_of(3);
-    layers[3]->add_relatives(4);
-    layers[8]->set_z_order_relative_of(9);
-    layers[9]->add_relatives(8);
-    layers[3]->set_z_order_relative_of(1);
-    layers[1]->add_relatives(3);
-
-/* ----------------------------
- *       - 0 -      - 9 -
- *      /  |  \
- *     1   2   3(1)
- *         |    |
- *         4(3) 5
- *             / \
- *            6   7
- *            |
- *            8(9)
- * -------------------------- */
-
-    return layersProto;
-}
-
-TEST(LayerProtoStress, mem_info) {
-    std::string cmd = "dumpsys meminfo ";
-    cmd += std::to_string(getpid());
-    system(cmd.c_str());
-    for (int i = 0; i < 100000; i++) {
-        surfaceflinger::LayersProto layersProto = generateLayerProto();
-        auto layerTree = surfaceflinger::LayerProtoParser::generateLayerTree(layersProto);
-        // Allow some layerTrees to just fall out of scope (instead of std::move)
-        if (i % 2) {
-            surfaceflinger::LayerProtoParser::layersToString(std::move(layerTree));
-        }
-    }
-    system(cmd.c_str());
-}
-
-}
diff --git a/services/surfaceflinger/tests/SurfaceFlinger_test.filter b/services/surfaceflinger/tests/SurfaceFlinger_test.filter
deleted file mode 100644
index 36424b9c5..000000000
--- a/services/surfaceflinger/tests/SurfaceFlinger_test.filter
+++ /dev/null
@@ -1,5 +0,0 @@
-{
-        "presubmit": {
-            "filter": "LayerTransactionTest.*:LayerUpdateTest.*:ChildLayerTest.*:SurfaceFlingerStress.*:CropLatchingTest.*:GeometryLatchingTest.*:ScreenCaptureTest.*:DereferenceSurfaceControlTest.*"
-        }
-}
diff --git a/services/surfaceflinger/tests/SurfaceInterceptor_test.cpp b/services/surfaceflinger/tests/SurfaceInterceptor_test.cpp
deleted file mode 100644
index de78c3f35..000000000
--- a/services/surfaceflinger/tests/SurfaceInterceptor_test.cpp
+++ /dev/null
@@ -1,872 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <frameworks/native/cmds/surfacereplayer/proto/src/trace.pb.h>
-#include <google/protobuf/io/zero_copy_stream_impl.h>
-
-#include <gtest/gtest.h>
-
-#include <android/native_window.h>
-
-#include <gui/ISurfaceComposer.h>
-#include <gui/LayerState.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-
-#include <private/gui/ComposerService.h>
-#include <ui/DisplayInfo.h>
-
-#include <fstream>
-#include <random>
-#include <thread>
-
-namespace android {
-
-using Transaction = SurfaceComposerClient::Transaction;
-
-constexpr int32_t SCALING_UPDATE = 1;
-constexpr uint32_t BUFFER_UPDATES = 18;
-constexpr uint32_t LAYER_UPDATE = INT_MAX - 2;
-constexpr uint32_t SIZE_UPDATE = 134;
-constexpr uint32_t STACK_UPDATE = 1;
-constexpr uint64_t DEFERRED_UPDATE = 13;
-constexpr float ALPHA_UPDATE = 0.29f;
-constexpr float POSITION_UPDATE = 121;
-const Rect CROP_UPDATE(16, 16, 32, 32);
-
-const String8 DISPLAY_NAME("SurfaceInterceptor Display Test");
-constexpr auto LAYER_NAME = "Layer Create and Delete Test";
-
-constexpr auto DEFAULT_FILENAME = "/data/SurfaceTrace.dat";
-
-// Fill an RGBA_8888 formatted surface with a single color.
-static void fillSurfaceRGBA8(const sp<SurfaceControl>& sc, uint8_t r, uint8_t g, uint8_t b) {
-    ANativeWindow_Buffer outBuffer;
-    sp<Surface> s = sc->getSurface();
-    ASSERT_TRUE(s != nullptr);
-    ASSERT_EQ(NO_ERROR, s->lock(&outBuffer, nullptr));
-    uint8_t* img = reinterpret_cast<uint8_t*>(outBuffer.bits);
-    for (int y = 0; y < outBuffer.height; y++) {
-        for (int x = 0; x < outBuffer.width; x++) {
-            uint8_t* pixel = img + (4 * (y*outBuffer.stride + x));
-            pixel[0] = r;
-            pixel[1] = g;
-            pixel[2] = b;
-            pixel[3] = 255;
-        }
-    }
-    ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-}
-
-static status_t readProtoFile(Trace* trace) {
-    status_t err = NO_ERROR;
-
-    int fd = open(DEFAULT_FILENAME, O_RDONLY);
-    {
-        google::protobuf::io::FileInputStream f(fd);
-        if (fd && !trace->ParseFromZeroCopyStream(&f)) {
-            err = PERMISSION_DENIED;
-        }
-    }
-    close(fd);
-
-    return err;
-}
-
-static void enableInterceptor() {
-    system("service call SurfaceFlinger 1020 i32 1 > /dev/null");
-}
-
-static void disableInterceptor() {
-    system("service call SurfaceFlinger 1020 i32 0 > /dev/null");
-}
-
-int32_t getSurfaceId(const std::string& surfaceName) {
-    enableInterceptor();
-    disableInterceptor();
-    Trace capturedTrace;
-    readProtoFile(&capturedTrace);
-    int32_t layerId = 0;
-    for (const auto& increment : *capturedTrace.mutable_increment()) {
-        if (increment.increment_case() == increment.kSurfaceCreation) {
-            if (increment.surface_creation().name() == surfaceName) {
-                layerId = increment.surface_creation().id();
-                break;
-            }
-        }
-    }
-    return layerId;
-}
-
-int32_t getDisplayId(const std::string& displayName) {
-    enableInterceptor();
-    disableInterceptor();
-    Trace capturedTrace;
-    readProtoFile(&capturedTrace);
-    int32_t displayId = 0;
-    for (const auto& increment : *capturedTrace.mutable_increment()) {
-        if (increment.increment_case() == increment.kDisplayCreation) {
-            if (increment.display_creation().name() == displayName) {
-                displayId = increment.display_creation().id();
-                break;
-            }
-        }
-    }
-    return displayId;
-}
-
-class SurfaceInterceptorTest : public ::testing::Test {
-protected:
-    virtual void SetUp() {
-        // Allow SurfaceInterceptor write to /data
-        system("setenforce 0");
-
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        sp<IBinder> display(SurfaceComposerClient::getBuiltInDisplay(
-                ISurfaceComposer::eDisplayIdMain));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-        ssize_t displayWidth = info.w;
-        ssize_t displayHeight = info.h;
-
-        // Background surface
-        mBGSurfaceControl = mComposerClient->createSurface(
-                String8("BG Interceptor Test Surface"), displayWidth, displayHeight,
-                PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mBGSurfaceControl != nullptr);
-        ASSERT_TRUE(mBGSurfaceControl->isValid());
-        mBGLayerId = getSurfaceId("BG Interceptor Test Surface");
-
-        Transaction t;
-        t.setDisplayLayerStack(display, 0);
-        ASSERT_EQ(NO_ERROR, t.setLayer(mBGSurfaceControl, INT_MAX-3)
-                .show(mBGSurfaceControl)
-                .apply());
-    }
-
-    virtual void TearDown() {
-        mComposerClient->dispose();
-        mBGSurfaceControl.clear();
-        mComposerClient.clear();
-    }
-
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mBGSurfaceControl;
-    int32_t mBGLayerId;
-    // Used to verify creation and destruction of surfaces and displays
-    int32_t mTargetId;
-
-public:
-    void captureTest(void (SurfaceInterceptorTest::* action)(Transaction&),
-            bool (SurfaceInterceptorTest::* verification)(Trace *));
-    void captureTest(void (SurfaceInterceptorTest::* action)(Transaction&),
-            SurfaceChange::SurfaceChangeCase changeCase);
-    void captureTest(void (SurfaceInterceptorTest::* action)(Transaction&),
-            Increment::IncrementCase incrementCase);
-    void runInTransaction(void (SurfaceInterceptorTest::* action)(Transaction&),
-            bool intercepted = false);
-
-    // Verification of changes to a surface
-    bool positionUpdateFound(const SurfaceChange& change, bool foundPosition);
-    bool sizeUpdateFound(const SurfaceChange& change, bool foundSize);
-    bool alphaUpdateFound(const SurfaceChange& change, bool foundAlpha);
-    bool layerUpdateFound(const SurfaceChange& change, bool foundLayer);
-    bool cropUpdateFound(const SurfaceChange& change, bool foundCrop);
-    bool finalCropUpdateFound(const SurfaceChange& change, bool foundFinalCrop);
-    bool matrixUpdateFound(const SurfaceChange& change, bool foundMatrix);
-    bool scalingModeUpdateFound(const SurfaceChange& change, bool foundScalingMode);
-    bool transparentRegionHintUpdateFound(const SurfaceChange& change, bool foundTransparentRegion);
-    bool layerStackUpdateFound(const SurfaceChange& change, bool foundLayerStack);
-    bool hiddenFlagUpdateFound(const SurfaceChange& change, bool foundHiddenFlag);
-    bool opaqueFlagUpdateFound(const SurfaceChange& change, bool foundOpaqueFlag);
-    bool secureFlagUpdateFound(const SurfaceChange& change, bool foundSecureFlag);
-    bool deferredTransactionUpdateFound(const SurfaceChange& change, bool foundDeferred);
-    bool surfaceUpdateFound(Trace* trace, SurfaceChange::SurfaceChangeCase changeCase);
-    void assertAllUpdatesFound(Trace* trace);
-
-    // Verification of creation and deletion of a surface
-    bool surfaceCreationFound(const Increment& increment, bool foundSurface);
-    bool surfaceDeletionFound(const Increment& increment, bool foundSurface);
-    bool displayCreationFound(const Increment& increment, bool foundDisplay);
-    bool displayDeletionFound(const Increment& increment, bool foundDisplay);
-    bool singleIncrementFound(Trace* trace, Increment::IncrementCase incrementCase);
-
-    // Verification of buffer updates
-    bool bufferUpdatesFound(Trace* trace);
-
-    // Perform each of the possible changes to a surface
-    void positionUpdate(Transaction&);
-    void sizeUpdate(Transaction&);
-    void alphaUpdate(Transaction&);
-    void layerUpdate(Transaction&);
-    void cropUpdate(Transaction&);
-    void finalCropUpdate(Transaction&);
-    void matrixUpdate(Transaction&);
-    void overrideScalingModeUpdate(Transaction&);
-    void transparentRegionHintUpdate(Transaction&);
-    void layerStackUpdate(Transaction&);
-    void hiddenFlagUpdate(Transaction&);
-    void opaqueFlagUpdate(Transaction&);
-    void secureFlagUpdate(Transaction&);
-    void deferredTransactionUpdate(Transaction&);
-    void surfaceCreation(Transaction&);
-    void displayCreation(Transaction&);
-    void displayDeletion(Transaction&);
-
-    void nBufferUpdates();
-    void runAllUpdates();
-};
-
-void SurfaceInterceptorTest::captureTest(void (SurfaceInterceptorTest::* action)(Transaction&),
-        bool (SurfaceInterceptorTest::* verification)(Trace *))
-{
-    runInTransaction(action, true);
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE((this->*verification)(&capturedTrace));
-}
-
-void SurfaceInterceptorTest::captureTest(void (SurfaceInterceptorTest::* action)(Transaction&),
-        Increment::IncrementCase incrementCase)
-{
-    runInTransaction(action, true);
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE(singleIncrementFound(&capturedTrace, incrementCase));
-}
-
-void SurfaceInterceptorTest::captureTest(void (SurfaceInterceptorTest::* action)(Transaction&),
-        SurfaceChange::SurfaceChangeCase changeCase)
-{
-    runInTransaction(action, true);
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE(surfaceUpdateFound(&capturedTrace, changeCase));
-}
-
-void SurfaceInterceptorTest::runInTransaction(void (SurfaceInterceptorTest::* action)(Transaction&),
-        bool intercepted)
-{
-    if (intercepted) {
-        enableInterceptor();
-    }
-    Transaction t;
-    (this->*action)(t);
-    t.apply(true);
-
-    if (intercepted) {
-        disableInterceptor();
-    }
-}
-
-void SurfaceInterceptorTest::positionUpdate(Transaction& t) {
-    t.setPosition(mBGSurfaceControl, POSITION_UPDATE, POSITION_UPDATE);
-}
-
-void SurfaceInterceptorTest::sizeUpdate(Transaction& t) {
-    t.setSize(mBGSurfaceControl, SIZE_UPDATE, SIZE_UPDATE);
-}
-
-void SurfaceInterceptorTest::alphaUpdate(Transaction& t) {
-    t.setAlpha(mBGSurfaceControl, ALPHA_UPDATE);
-}
-
-void SurfaceInterceptorTest::layerUpdate(Transaction& t) {
-    t.setLayer(mBGSurfaceControl, LAYER_UPDATE);
-}
-
-void SurfaceInterceptorTest::cropUpdate(Transaction& t) {
-    t.setCrop(mBGSurfaceControl, CROP_UPDATE);
-}
-
-void SurfaceInterceptorTest::finalCropUpdate(Transaction& t) {
-    t.setFinalCrop(mBGSurfaceControl, CROP_UPDATE);
-}
-
-void SurfaceInterceptorTest::matrixUpdate(Transaction& t) {
-    t.setMatrix(mBGSurfaceControl, M_SQRT1_2, M_SQRT1_2, -M_SQRT1_2, M_SQRT1_2);
-}
-
-void SurfaceInterceptorTest::overrideScalingModeUpdate(Transaction& t) {
-    t.setOverrideScalingMode(mBGSurfaceControl, SCALING_UPDATE);
-}
-
-void SurfaceInterceptorTest::transparentRegionHintUpdate(Transaction& t) {
-    Region region(CROP_UPDATE);
-    t.setTransparentRegionHint(mBGSurfaceControl, region);
-}
-
-void SurfaceInterceptorTest::layerStackUpdate(Transaction& t) {
-    t.setLayerStack(mBGSurfaceControl, STACK_UPDATE);
-}
-
-void SurfaceInterceptorTest::hiddenFlagUpdate(Transaction& t) {
-    t.setFlags(mBGSurfaceControl, layer_state_t::eLayerHidden, layer_state_t::eLayerHidden);
-}
-
-void SurfaceInterceptorTest::opaqueFlagUpdate(Transaction& t) {
-    t.setFlags(mBGSurfaceControl, layer_state_t::eLayerOpaque, layer_state_t::eLayerOpaque);
-}
-
-void SurfaceInterceptorTest::secureFlagUpdate(Transaction& t) {
-    t.setFlags(mBGSurfaceControl, layer_state_t::eLayerSecure, layer_state_t::eLayerSecure);
-}
-
-void SurfaceInterceptorTest::deferredTransactionUpdate(Transaction& t) {
-    t.deferTransactionUntil(mBGSurfaceControl, mBGSurfaceControl->getHandle(), DEFERRED_UPDATE);
-}
-
-void SurfaceInterceptorTest::displayCreation(Transaction&) {
-    sp<IBinder> testDisplay = SurfaceComposerClient::createDisplay(DISPLAY_NAME, true);
-    SurfaceComposerClient::destroyDisplay(testDisplay);
-}
-
-void SurfaceInterceptorTest::displayDeletion(Transaction&) {
-    sp<IBinder> testDisplay = SurfaceComposerClient::createDisplay(DISPLAY_NAME, false);
-    mTargetId = getDisplayId(DISPLAY_NAME.string());
-    SurfaceComposerClient::destroyDisplay(testDisplay);
-}
-
-void SurfaceInterceptorTest::runAllUpdates() {
-    runInTransaction(&SurfaceInterceptorTest::positionUpdate);
-    runInTransaction(&SurfaceInterceptorTest::sizeUpdate);
-    runInTransaction(&SurfaceInterceptorTest::alphaUpdate);
-    runInTransaction(&SurfaceInterceptorTest::layerUpdate);
-    runInTransaction(&SurfaceInterceptorTest::cropUpdate);
-    runInTransaction(&SurfaceInterceptorTest::finalCropUpdate);
-    runInTransaction(&SurfaceInterceptorTest::matrixUpdate);
-    runInTransaction(&SurfaceInterceptorTest::overrideScalingModeUpdate);
-    runInTransaction(&SurfaceInterceptorTest::transparentRegionHintUpdate);
-    runInTransaction(&SurfaceInterceptorTest::layerStackUpdate);
-    runInTransaction(&SurfaceInterceptorTest::hiddenFlagUpdate);
-    runInTransaction(&SurfaceInterceptorTest::opaqueFlagUpdate);
-    runInTransaction(&SurfaceInterceptorTest::secureFlagUpdate);
-    runInTransaction(&SurfaceInterceptorTest::deferredTransactionUpdate);
-}
-
-void SurfaceInterceptorTest::surfaceCreation(Transaction&) {
-    mComposerClient->createSurface(String8(LAYER_NAME), SIZE_UPDATE, SIZE_UPDATE,
-            PIXEL_FORMAT_RGBA_8888, 0);
-}
-
-void SurfaceInterceptorTest::nBufferUpdates() {
-    std::random_device rd;
-    std::mt19937_64 gen(rd());
-    // This makes testing fun
-    std::uniform_int_distribution<uint8_t> dis;
-    for (uint32_t i = 0; i < BUFFER_UPDATES; ++i) {
-        fillSurfaceRGBA8(mBGSurfaceControl, dis(gen), dis(gen), dis(gen));
-    }
-}
-
-bool SurfaceInterceptorTest::positionUpdateFound(const SurfaceChange& change, bool foundPosition) {
-    // There should only be one position transaction with x and y = POSITION_UPDATE
-    bool hasX(change.position().x() == POSITION_UPDATE);
-    bool hasY(change.position().y() == POSITION_UPDATE);
-    if (hasX && hasY && !foundPosition) {
-        foundPosition = true;
-    }
-    // Failed because the position update was found a second time
-    else if (hasX && hasY && foundPosition) {
-        [] () { FAIL(); }();
-    }
-    return foundPosition;
-}
-
-bool SurfaceInterceptorTest::sizeUpdateFound(const SurfaceChange& change, bool foundSize) {
-    bool hasWidth(change.size().h() == SIZE_UPDATE);
-    bool hasHeight(change.size().w() == SIZE_UPDATE);
-    if (hasWidth && hasHeight && !foundSize) {
-        foundSize = true;
-    }
-    else if (hasWidth && hasHeight && foundSize) {
-        [] () { FAIL(); }();
-    }
-    return foundSize;
-}
-
-bool SurfaceInterceptorTest::alphaUpdateFound(const SurfaceChange& change, bool foundAlpha) {
-    bool hasAlpha(change.alpha().alpha() == ALPHA_UPDATE);
-    if (hasAlpha && !foundAlpha) {
-        foundAlpha = true;
-    }
-    else if (hasAlpha && foundAlpha) {
-        [] () { FAIL(); }();
-    }
-    return foundAlpha;
-}
-
-bool SurfaceInterceptorTest::layerUpdateFound(const SurfaceChange& change, bool foundLayer) {
-    bool hasLayer(change.layer().layer() == LAYER_UPDATE);
-    if (hasLayer && !foundLayer) {
-        foundLayer = true;
-    }
-    else if (hasLayer && foundLayer) {
-        [] () { FAIL(); }();
-    }
-    return foundLayer;
-}
-
-bool SurfaceInterceptorTest::cropUpdateFound(const SurfaceChange& change, bool foundCrop) {
-    bool hasLeft(change.crop().rectangle().left() == CROP_UPDATE.left);
-    bool hasTop(change.crop().rectangle().top() == CROP_UPDATE.top);
-    bool hasRight(change.crop().rectangle().right() == CROP_UPDATE.right);
-    bool hasBottom(change.crop().rectangle().bottom() == CROP_UPDATE.bottom);
-    if (hasLeft && hasRight && hasTop && hasBottom && !foundCrop) {
-        foundCrop = true;
-    }
-    else if (hasLeft && hasRight && hasTop && hasBottom && foundCrop) {
-        [] () { FAIL(); }();
-    }
-    return foundCrop;
-}
-
-bool SurfaceInterceptorTest::finalCropUpdateFound(const SurfaceChange& change,
-        bool foundFinalCrop)
-{
-    bool hasLeft(change.final_crop().rectangle().left() == CROP_UPDATE.left);
-    bool hasTop(change.final_crop().rectangle().top() == CROP_UPDATE.top);
-    bool hasRight(change.final_crop().rectangle().right() == CROP_UPDATE.right);
-    bool hasBottom(change.final_crop().rectangle().bottom() == CROP_UPDATE.bottom);
-    if (hasLeft && hasRight && hasTop && hasBottom && !foundFinalCrop) {
-        foundFinalCrop = true;
-    }
-    else if (hasLeft && hasRight && hasTop && hasBottom && foundFinalCrop) {
-        [] () { FAIL(); }();
-    }
-    return foundFinalCrop;
-}
-
-bool SurfaceInterceptorTest::matrixUpdateFound(const SurfaceChange& change, bool foundMatrix) {
-    bool hasSx((float)change.matrix().dsdx() == (float)M_SQRT1_2);
-    bool hasTx((float)change.matrix().dtdx() == (float)M_SQRT1_2);
-    bool hasSy((float)change.matrix().dsdy() == (float)-M_SQRT1_2);
-    bool hasTy((float)change.matrix().dtdy() == (float)M_SQRT1_2);
-    if (hasSx && hasTx && hasSy && hasTy && !foundMatrix) {
-        foundMatrix = true;
-    }
-    else if (hasSx && hasTx && hasSy && hasTy && foundMatrix) {
-        [] () { FAIL(); }();
-    }
-    return foundMatrix;
-}
-
-bool SurfaceInterceptorTest::scalingModeUpdateFound(const SurfaceChange& change,
-        bool foundScalingMode)
-{
-    bool hasScalingUpdate(change.override_scaling_mode().override_scaling_mode() == SCALING_UPDATE);
-    if (hasScalingUpdate && !foundScalingMode) {
-        foundScalingMode = true;
-    }
-    else if (hasScalingUpdate && foundScalingMode) {
-        [] () { FAIL(); }();
-    }
-    return foundScalingMode;
-}
-
-bool SurfaceInterceptorTest::transparentRegionHintUpdateFound(const SurfaceChange& change,
-        bool foundTransparentRegion)
-{
-    auto traceRegion = change.transparent_region_hint().region(0);
-    bool hasLeft(traceRegion.left() == CROP_UPDATE.left);
-    bool hasTop(traceRegion.top() == CROP_UPDATE.top);
-    bool hasRight(traceRegion.right() == CROP_UPDATE.right);
-    bool hasBottom(traceRegion.bottom() == CROP_UPDATE.bottom);
-    if (hasLeft && hasRight && hasTop && hasBottom && !foundTransparentRegion) {
-        foundTransparentRegion = true;
-    }
-    else if (hasLeft && hasRight && hasTop && hasBottom && foundTransparentRegion) {
-        [] () { FAIL(); }();
-    }
-    return foundTransparentRegion;
-}
-
-bool SurfaceInterceptorTest::layerStackUpdateFound(const SurfaceChange& change,
-        bool foundLayerStack)
-{
-    bool hasLayerStackUpdate(change.layer_stack().layer_stack() == STACK_UPDATE);
-    if (hasLayerStackUpdate && !foundLayerStack) {
-        foundLayerStack = true;
-    }
-    else if (hasLayerStackUpdate && foundLayerStack) {
-        [] () { FAIL(); }();
-    }
-    return foundLayerStack;
-}
-
-bool SurfaceInterceptorTest::hiddenFlagUpdateFound(const SurfaceChange& change,
-        bool foundHiddenFlag)
-{
-    bool hasHiddenFlag(change.hidden_flag().hidden_flag());
-    if (hasHiddenFlag && !foundHiddenFlag) {
-        foundHiddenFlag = true;
-    }
-    else if (hasHiddenFlag && foundHiddenFlag) {
-        [] () { FAIL(); }();
-    }
-    return foundHiddenFlag;
-}
-
-bool SurfaceInterceptorTest::opaqueFlagUpdateFound(const SurfaceChange& change,
-        bool foundOpaqueFlag)
-{
-    bool hasOpaqueFlag(change.opaque_flag().opaque_flag());
-    if (hasOpaqueFlag && !foundOpaqueFlag) {
-        foundOpaqueFlag = true;
-    }
-    else if (hasOpaqueFlag && foundOpaqueFlag) {
-        [] () { FAIL(); }();
-    }
-    return foundOpaqueFlag;
-}
-
-bool SurfaceInterceptorTest::secureFlagUpdateFound(const SurfaceChange& change,
-        bool foundSecureFlag)
-{
-    bool hasSecureFlag(change.secure_flag().secure_flag());
-    if (hasSecureFlag && !foundSecureFlag) {
-        foundSecureFlag = true;
-    }
-    else if (hasSecureFlag && foundSecureFlag) {
-        [] () { FAIL(); }();
-    }
-    return foundSecureFlag;
-}
-
-bool SurfaceInterceptorTest::deferredTransactionUpdateFound(const SurfaceChange& change,
-        bool foundDeferred)
-{
-    bool hasId(change.deferred_transaction().layer_id() == mBGLayerId);
-    bool hasFrameNumber(change.deferred_transaction().frame_number() == DEFERRED_UPDATE);
-    if (hasId && hasFrameNumber && !foundDeferred) {
-        foundDeferred = true;
-    }
-    else if (hasId && hasFrameNumber && foundDeferred) {
-        [] () { FAIL(); }();
-    }
-    return foundDeferred;
-}
-
-bool SurfaceInterceptorTest::surfaceUpdateFound(Trace* trace,
-        SurfaceChange::SurfaceChangeCase changeCase)
-{
-    bool foundUpdate = false;
-    for (const auto& increment : *trace->mutable_increment()) {
-        if (increment.increment_case() == increment.kTransaction) {
-            for (const auto& change : increment.transaction().surface_change()) {
-                if (change.id() == mBGLayerId && change.SurfaceChange_case() == changeCase) {
-                    switch (changeCase) {
-                        case SurfaceChange::SurfaceChangeCase::kPosition:
-                            // foundUpdate is sent for the tests to fail on duplicated increments
-                            foundUpdate = positionUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kSize:
-                            foundUpdate = sizeUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kAlpha:
-                            foundUpdate = alphaUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kLayer:
-                            foundUpdate = layerUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kCrop:
-                            foundUpdate = cropUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kFinalCrop:
-                            foundUpdate = finalCropUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kMatrix:
-                            foundUpdate = matrixUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kOverrideScalingMode:
-                            foundUpdate = scalingModeUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kTransparentRegionHint:
-                            foundUpdate = transparentRegionHintUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kLayerStack:
-                            foundUpdate = layerStackUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kHiddenFlag:
-                            foundUpdate = hiddenFlagUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kOpaqueFlag:
-                            foundUpdate = opaqueFlagUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kSecureFlag:
-                            foundUpdate = secureFlagUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kDeferredTransaction:
-                            foundUpdate = deferredTransactionUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::SURFACECHANGE_NOT_SET:
-                            break;
-                    }
-                }
-            }
-        }
-    }
-    return foundUpdate;
-}
-
-void SurfaceInterceptorTest::assertAllUpdatesFound(Trace* trace) {
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kPosition));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kSize));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kAlpha));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kLayer));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kCrop));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kFinalCrop));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kMatrix));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kOverrideScalingMode));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kTransparentRegionHint));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kLayerStack));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kHiddenFlag));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kOpaqueFlag));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kSecureFlag));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kDeferredTransaction));
-}
-
-bool SurfaceInterceptorTest::surfaceCreationFound(const Increment& increment, bool foundSurface) {
-    bool isMatch(increment.surface_creation().name() == LAYER_NAME &&
-            increment.surface_creation().w() == SIZE_UPDATE &&
-            increment.surface_creation().h() == SIZE_UPDATE);
-    if (isMatch && !foundSurface) {
-        foundSurface = true;
-    }
-    else if (isMatch && foundSurface) {
-        [] () { FAIL(); }();
-    }
-    return foundSurface;
-}
-
-bool SurfaceInterceptorTest::surfaceDeletionFound(const Increment& increment, bool foundSurface) {
-    bool isMatch(increment.surface_deletion().id() == mTargetId);
-    if (isMatch && !foundSurface) {
-        foundSurface = true;
-    }
-    else if (isMatch && foundSurface) {
-        [] () { FAIL(); }();
-    }
-    return foundSurface;
-}
-
-bool SurfaceInterceptorTest::displayCreationFound(const Increment& increment, bool foundDisplay) {
-    bool isMatch(increment.display_creation().name() == DISPLAY_NAME.string() &&
-            increment.display_creation().is_secure());
-    if (isMatch && !foundDisplay) {
-        foundDisplay = true;
-    }
-    else if (isMatch && foundDisplay) {
-        [] () { FAIL(); }();
-    }
-    return foundDisplay;
-}
-
-bool SurfaceInterceptorTest::displayDeletionFound(const Increment& increment, bool foundDisplay) {
-    bool isMatch(increment.display_deletion().id() == mTargetId);
-    if (isMatch && !foundDisplay) {
-        foundDisplay = true;
-    }
-    else if (isMatch && foundDisplay) {
-        [] () { FAIL(); }();
-    }
-    return foundDisplay;
-}
-
-bool SurfaceInterceptorTest::singleIncrementFound(Trace* trace,
-        Increment::IncrementCase incrementCase)
-{
-    bool foundIncrement = false;
-    for (const auto& increment : *trace->mutable_increment()) {
-        if (increment.increment_case() == incrementCase) {
-            switch (incrementCase) {
-                case Increment::IncrementCase::kSurfaceCreation:
-                    foundIncrement = surfaceCreationFound(increment, foundIncrement);
-                    break;
-                case Increment::IncrementCase::kSurfaceDeletion:
-                    foundIncrement = surfaceDeletionFound(increment, foundIncrement);
-                    break;
-                case Increment::IncrementCase::kDisplayCreation:
-                    foundIncrement = displayCreationFound(increment, foundIncrement);
-                    break;
-                case Increment::IncrementCase::kDisplayDeletion:
-                    foundIncrement = displayDeletionFound(increment, foundIncrement);
-                    break;
-                default:
-                    /* code */
-                    break;
-            }
-        }
-    }
-    return foundIncrement;
-}
-
-bool SurfaceInterceptorTest::bufferUpdatesFound(Trace* trace) {
-    uint32_t updates = 0;
-    for (const auto& inc : *trace->mutable_increment()) {
-        if (inc.increment_case() == inc.kBufferUpdate && inc.buffer_update().id() == mBGLayerId) {
-            updates++;
-        }
-    }
-    return updates == BUFFER_UPDATES;
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptPositionUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::positionUpdate,
-            SurfaceChange::SurfaceChangeCase::kPosition);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSizeUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::sizeUpdate, SurfaceChange::SurfaceChangeCase::kSize);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptAlphaUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::alphaUpdate, SurfaceChange::SurfaceChangeCase::kAlpha);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptLayerUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::layerUpdate, SurfaceChange::SurfaceChangeCase::kLayer);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptCropUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::cropUpdate, SurfaceChange::SurfaceChangeCase::kCrop);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptFinalCropUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::finalCropUpdate,
-            SurfaceChange::SurfaceChangeCase::kFinalCrop);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptMatrixUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::matrixUpdate, SurfaceChange::SurfaceChangeCase::kMatrix);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptOverrideScalingModeUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::overrideScalingModeUpdate,
-            SurfaceChange::SurfaceChangeCase::kOverrideScalingMode);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptTransparentRegionHintUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::transparentRegionHintUpdate,
-            SurfaceChange::SurfaceChangeCase::kTransparentRegionHint);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptLayerStackUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::layerStackUpdate,
-            SurfaceChange::SurfaceChangeCase::kLayerStack);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptHiddenFlagUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::hiddenFlagUpdate,
-            SurfaceChange::SurfaceChangeCase::kHiddenFlag);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptOpaqueFlagUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::opaqueFlagUpdate,
-            SurfaceChange::SurfaceChangeCase::kOpaqueFlag);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSecureFlagUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::secureFlagUpdate,
-            SurfaceChange::SurfaceChangeCase::kSecureFlag);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptDeferredTransactionUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::deferredTransactionUpdate,
-            SurfaceChange::SurfaceChangeCase::kDeferredTransaction);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptAllUpdatesWorks) {
-    enableInterceptor();
-    runAllUpdates();
-    disableInterceptor();
-
-    // Find all of the updates in the single trace
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    assertAllUpdatesFound(&capturedTrace);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSurfaceCreationWorks) {
-    captureTest(&SurfaceInterceptorTest::surfaceCreation,
-            Increment::IncrementCase::kSurfaceCreation);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSurfaceDeletionWorks) {
-    sp<SurfaceControl> layerToDelete = mComposerClient->createSurface(String8(LAYER_NAME),
-            SIZE_UPDATE, SIZE_UPDATE, PIXEL_FORMAT_RGBA_8888, 0);
-    this->mTargetId = getSurfaceId(LAYER_NAME);
-    enableInterceptor();
-    mComposerClient->destroySurface(layerToDelete->getHandle());
-    disableInterceptor();
-
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE(singleIncrementFound(&capturedTrace, Increment::IncrementCase::kSurfaceDeletion));
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptDisplayCreationWorks) {
-    captureTest(&SurfaceInterceptorTest::displayCreation,
-            Increment::IncrementCase::kDisplayCreation);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptDisplayDeletionWorks) {
-    captureTest(&SurfaceInterceptorTest::displayDeletion,
-            Increment::IncrementCase::kDisplayDeletion);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptBufferUpdateWorks) {
-    nBufferUpdates();
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE(bufferUpdatesFound(&capturedTrace));
-}
-
-// If the interceptor is enabled while buffer updates are being pushed, the interceptor should
-// first create a snapshot of the existing displays and surfaces and then start capturing
-// the buffer updates
-TEST_F(SurfaceInterceptorTest, InterceptWhileBufferUpdatesWorks) {
-    std::thread bufferUpdates(&SurfaceInterceptorTest::nBufferUpdates, this);
-    enableInterceptor();
-    disableInterceptor();
-    bufferUpdates.join();
-
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    const auto& firstIncrement = capturedTrace.mutable_increment(0);
-    ASSERT_EQ(firstIncrement->increment_case(), Increment::IncrementCase::kDisplayCreation);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSimultaneousUpdatesWorks) {
-    enableInterceptor();
-    std::thread bufferUpdates(&SurfaceInterceptorTest::nBufferUpdates, this);
-    std::thread surfaceUpdates(&SurfaceInterceptorTest::runAllUpdates, this);
-    runInTransaction(&SurfaceInterceptorTest::surfaceCreation);
-    bufferUpdates.join();
-    surfaceUpdates.join();
-    disableInterceptor();
-
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-
-    assertAllUpdatesFound(&capturedTrace);
-    ASSERT_TRUE(bufferUpdatesFound(&capturedTrace));
-    ASSERT_TRUE(singleIncrementFound(&capturedTrace, Increment::IncrementCase::kSurfaceCreation));
-}
-
-}
diff --git a/services/surfaceflinger/tests/Transaction_test.cpp b/services/surfaceflinger/tests/Transaction_test.cpp
deleted file mode 100644
index 510827904..000000000
--- a/services/surfaceflinger/tests/Transaction_test.cpp
+++ /dev/null
@@ -1,2693 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <algorithm>
-#include <functional>
-#include <limits>
-#include <ostream>
-
-#include <gtest/gtest.h>
-
-#include <android/native_window.h>
-
-#include <gui/ISurfaceComposer.h>
-#include <gui/LayerState.h>
-
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-#include <private/gui/ComposerService.h>
-
-#include <ui/DisplayInfo.h>
-#include <ui/Rect.h>
-#include <utils/String8.h>
-
-#include <math.h>
-#include <math/vec3.h>
-
-namespace android {
-
-namespace {
-
-struct Color {
-    uint8_t r;
-    uint8_t g;
-    uint8_t b;
-    uint8_t a;
-
-    static const Color RED;
-    static const Color GREEN;
-    static const Color BLUE;
-    static const Color WHITE;
-    static const Color BLACK;
-    static const Color TRANSPARENT;
-};
-
-const Color Color::RED{255, 0, 0, 255};
-const Color Color::GREEN{0, 255, 0, 255};
-const Color Color::BLUE{0, 0, 255, 255};
-const Color Color::WHITE{255, 255, 255, 255};
-const Color Color::BLACK{0, 0, 0, 255};
-const Color Color::TRANSPARENT{0, 0, 0, 0};
-
-std::ostream& operator<<(std::ostream& os, const Color& color) {
-    os << int(color.r) << ", " << int(color.g) << ", " << int(color.b) << ", " << int(color.a);
-    return os;
-}
-
-// Fill a region with the specified color.
-void fillBufferColor(const ANativeWindow_Buffer& buffer, const Rect& rect, const Color& color) {
-    int32_t x = rect.left;
-    int32_t y = rect.top;
-    int32_t width = rect.right - rect.left;
-    int32_t height = rect.bottom - rect.top;
-
-    if (x < 0) {
-        width += x;
-        x = 0;
-    }
-    if (y < 0) {
-        height += y;
-        y = 0;
-    }
-    if (x + width > buffer.width) {
-        x = std::min(x, buffer.width);
-        width = buffer.width - x;
-    }
-    if (y + height > buffer.height) {
-        y = std::min(y, buffer.height);
-        height = buffer.height - y;
-    }
-
-    for (int32_t j = 0; j < height; j++) {
-        uint8_t* dst = static_cast<uint8_t*>(buffer.bits) + (buffer.stride * (y + j) + x) * 4;
-        for (int32_t i = 0; i < width; i++) {
-            dst[0] = color.r;
-            dst[1] = color.g;
-            dst[2] = color.b;
-            dst[3] = color.a;
-            dst += 4;
-        }
-    }
-}
-
-// Check if a region has the specified color.
-void expectBufferColor(const sp<GraphicBuffer>& outBuffer, uint8_t* pixels, const Rect& rect,
-                       const Color& color, uint8_t tolerance) {
-    int32_t x = rect.left;
-    int32_t y = rect.top;
-    int32_t width = rect.right - rect.left;
-    int32_t height = rect.bottom - rect.top;
-
-    int32_t bufferWidth = int32_t(outBuffer->getWidth());
-    int32_t bufferHeight = int32_t(outBuffer->getHeight());
-    if (x + width > bufferWidth) {
-        x = std::min(x, bufferWidth);
-        width = bufferWidth - x;
-    }
-    if (y + height > bufferHeight) {
-        y = std::min(y, bufferHeight);
-        height = bufferHeight - y;
-    }
-
-    auto colorCompare = [tolerance](uint8_t a, uint8_t b) {
-        uint8_t tmp = a >= b ? a - b : b - a;
-        return tmp <= tolerance;
-    };
-    for (int32_t j = 0; j < height; j++) {
-        const uint8_t* src = pixels + (outBuffer->getStride() * (y + j) + x) * 4;
-        for (int32_t i = 0; i < width; i++) {
-            const uint8_t expected[4] = {color.r, color.g, color.b, color.a};
-            EXPECT_TRUE(std::equal(src, src + 4, expected, colorCompare))
-                    << "pixel @ (" << x + i << ", " << y + j << "): "
-                    << "expected (" << color << "), "
-                    << "got (" << Color{src[0], src[1], src[2], src[3]} << ")";
-            src += 4;
-        }
-    }
-}
-
-} // anonymous namespace
-
-using Transaction = SurfaceComposerClient::Transaction;
-
-// Fill an RGBA_8888 formatted surface with a single color.
-static void fillSurfaceRGBA8(const sp<SurfaceControl>& sc, uint8_t r, uint8_t g, uint8_t b,
-                             bool unlock = true) {
-    ANativeWindow_Buffer outBuffer;
-    sp<Surface> s = sc->getSurface();
-    ASSERT_TRUE(s != nullptr);
-    ASSERT_EQ(NO_ERROR, s->lock(&outBuffer, nullptr));
-    uint8_t* img = reinterpret_cast<uint8_t*>(outBuffer.bits);
-    for (int y = 0; y < outBuffer.height; y++) {
-        for (int x = 0; x < outBuffer.width; x++) {
-            uint8_t* pixel = img + (4 * (y * outBuffer.stride + x));
-            pixel[0] = r;
-            pixel[1] = g;
-            pixel[2] = b;
-            pixel[3] = 255;
-        }
-    }
-    if (unlock) {
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-    }
-}
-
-// A ScreenCapture is a screenshot from SurfaceFlinger that can be used to check
-// individual pixel values for testing purposes.
-class ScreenCapture : public RefBase {
-public:
-    static void captureScreen(sp<ScreenCapture>* sc, int32_t minLayerZ = 0,
-                              int32_t maxLayerZ = std::numeric_limits<int32_t>::max()) {
-        sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-        sp<IBinder> display(sf->getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
-        SurfaceComposerClient::Transaction().apply(true);
-
-        sp<GraphicBuffer> outBuffer;
-        ASSERT_EQ(NO_ERROR,
-                  sf->captureScreen(display, &outBuffer, Rect(), 0, 0, minLayerZ, maxLayerZ,
-                                    false));
-        *sc = new ScreenCapture(outBuffer);
-    }
-
-    static void captureLayers(std::unique_ptr<ScreenCapture>* sc, sp<IBinder>& parentHandle,
-                              Rect crop = Rect::EMPTY_RECT, float frameScale = 1.0) {
-        sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-        SurfaceComposerClient::Transaction().apply(true);
-
-        sp<GraphicBuffer> outBuffer;
-        ASSERT_EQ(NO_ERROR, sf->captureLayers(parentHandle, &outBuffer, crop, frameScale));
-        *sc = std::make_unique<ScreenCapture>(outBuffer);
-    }
-
-    static void captureChildLayers(std::unique_ptr<ScreenCapture>* sc, sp<IBinder>& parentHandle,
-                                   Rect crop = Rect::EMPTY_RECT, float frameScale = 1.0) {
-        sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-        SurfaceComposerClient::Transaction().apply(true);
-
-        sp<GraphicBuffer> outBuffer;
-        ASSERT_EQ(NO_ERROR, sf->captureLayers(parentHandle, &outBuffer, crop, frameScale, true));
-        *sc = std::make_unique<ScreenCapture>(outBuffer);
-    }
-
-    void expectColor(const Rect& rect, const Color& color, uint8_t tolerance = 0) {
-        ASSERT_EQ(HAL_PIXEL_FORMAT_RGBA_8888, mOutBuffer->getPixelFormat());
-        expectBufferColor(mOutBuffer, mPixels, rect, color, tolerance);
-    }
-
-    void expectBorder(const Rect& rect, const Color& color, uint8_t tolerance = 0) {
-        ASSERT_EQ(HAL_PIXEL_FORMAT_RGBA_8888, mOutBuffer->getPixelFormat());
-        const bool leftBorder = rect.left > 0;
-        const bool topBorder = rect.top > 0;
-        const bool rightBorder = rect.right < int32_t(mOutBuffer->getWidth());
-        const bool bottomBorder = rect.bottom < int32_t(mOutBuffer->getHeight());
-
-        if (topBorder) {
-            Rect top(rect.left, rect.top - 1, rect.right, rect.top);
-            if (leftBorder) {
-                top.left -= 1;
-            }
-            if (rightBorder) {
-                top.right += 1;
-            }
-            expectColor(top, color, tolerance);
-        }
-        if (leftBorder) {
-            Rect left(rect.left - 1, rect.top, rect.left, rect.bottom);
-            expectColor(left, color, tolerance);
-        }
-        if (rightBorder) {
-            Rect right(rect.right, rect.top, rect.right + 1, rect.bottom);
-            expectColor(right, color, tolerance);
-        }
-        if (bottomBorder) {
-            Rect bottom(rect.left, rect.bottom, rect.right, rect.bottom + 1);
-            if (leftBorder) {
-                bottom.left -= 1;
-            }
-            if (rightBorder) {
-                bottom.right += 1;
-            }
-            expectColor(bottom, color, tolerance);
-        }
-    }
-
-    void expectQuadrant(const Rect& rect, const Color& topLeft, const Color& topRight,
-                        const Color& bottomLeft, const Color& bottomRight, bool filtered = false,
-                        uint8_t tolerance = 0) {
-        ASSERT_TRUE((rect.right - rect.left) % 2 == 0 && (rect.bottom - rect.top) % 2 == 0);
-
-        const int32_t centerX = rect.left + (rect.right - rect.left) / 2;
-        const int32_t centerY = rect.top + (rect.bottom - rect.top) / 2;
-        // avoid checking borders due to unspecified filtering behavior
-        const int32_t offsetX = filtered ? 2 : 0;
-        const int32_t offsetY = filtered ? 2 : 0;
-        expectColor(Rect(rect.left, rect.top, centerX - offsetX, centerY - offsetY), topLeft,
-                    tolerance);
-        expectColor(Rect(centerX + offsetX, rect.top, rect.right, centerY - offsetY), topRight,
-                    tolerance);
-        expectColor(Rect(rect.left, centerY + offsetY, centerX - offsetX, rect.bottom), bottomLeft,
-                    tolerance);
-        expectColor(Rect(centerX + offsetX, centerY + offsetY, rect.right, rect.bottom),
-                    bottomRight, tolerance);
-    }
-
-    void checkPixel(uint32_t x, uint32_t y, uint8_t r, uint8_t g, uint8_t b) {
-        ASSERT_EQ(HAL_PIXEL_FORMAT_RGBA_8888, mOutBuffer->getPixelFormat());
-        const uint8_t* pixel = mPixels + (4 * (y * mOutBuffer->getStride() + x));
-        if (r != pixel[0] || g != pixel[1] || b != pixel[2]) {
-            String8 err(String8::format("pixel @ (%3d, %3d): "
-                                        "expected [%3d, %3d, %3d], got [%3d, %3d, %3d]",
-                                        x, y, r, g, b, pixel[0], pixel[1], pixel[2]));
-            EXPECT_EQ(String8(), err) << err.string();
-        }
-    }
-
-    void expectFGColor(uint32_t x, uint32_t y) { checkPixel(x, y, 195, 63, 63); }
-
-    void expectBGColor(uint32_t x, uint32_t y) { checkPixel(x, y, 63, 63, 195); }
-
-    void expectChildColor(uint32_t x, uint32_t y) { checkPixel(x, y, 200, 200, 200); }
-
-    ScreenCapture(const sp<GraphicBuffer>& outBuffer) : mOutBuffer(outBuffer) {
-        mOutBuffer->lock(GRALLOC_USAGE_SW_READ_OFTEN, reinterpret_cast<void**>(&mPixels));
-    }
-
-    ~ScreenCapture() { mOutBuffer->unlock(); }
-
-private:
-    sp<GraphicBuffer> mOutBuffer;
-    uint8_t* mPixels = nullptr;
-};
-
-class LayerTransactionTest : public ::testing::Test {
-protected:
-    void SetUp() override {
-        mClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mClient->initCheck()) << "failed to create SurfaceComposerClient";
-
-        ASSERT_NO_FATAL_FAILURE(SetUpDisplay());
-    }
-
-    sp<SurfaceControl> createLayer(const char* name, uint32_t width, uint32_t height,
-                                   uint32_t flags = 0) {
-        auto layer =
-                mClient->createSurface(String8(name), width, height, PIXEL_FORMAT_RGBA_8888, flags);
-        EXPECT_NE(nullptr, layer.get()) << "failed to create SurfaceControl";
-
-        status_t error = Transaction()
-                                 .setLayerStack(layer, mDisplayLayerStack)
-                                 .setLayer(layer, mLayerZBase)
-                                 .apply();
-        if (error != NO_ERROR) {
-            ADD_FAILURE() << "failed to initialize SurfaceControl";
-            layer.clear();
-        }
-
-        return layer;
-    }
-
-    ANativeWindow_Buffer getLayerBuffer(const sp<SurfaceControl>& layer) {
-        // wait for previous transactions (such as setSize) to complete
-        Transaction().apply(true);
-
-        ANativeWindow_Buffer buffer = {};
-        EXPECT_EQ(NO_ERROR, layer->getSurface()->lock(&buffer, nullptr));
-
-        return buffer;
-    }
-
-    void postLayerBuffer(const sp<SurfaceControl>& layer) {
-        ASSERT_EQ(NO_ERROR, layer->getSurface()->unlockAndPost());
-
-        // wait for the newly posted buffer to be latched
-        waitForLayerBuffers();
-    }
-
-    void fillLayerColor(const sp<SurfaceControl>& layer, const Color& color) {
-        ANativeWindow_Buffer buffer;
-        ASSERT_NO_FATAL_FAILURE(buffer = getLayerBuffer(layer));
-        fillBufferColor(buffer, Rect(0, 0, buffer.width, buffer.height), color);
-        postLayerBuffer(layer);
-    }
-
-    void fillLayerQuadrant(const sp<SurfaceControl>& layer, const Color& topLeft,
-                           const Color& topRight, const Color& bottomLeft,
-                           const Color& bottomRight) {
-        ANativeWindow_Buffer buffer;
-        ASSERT_NO_FATAL_FAILURE(buffer = getLayerBuffer(layer));
-        ASSERT_TRUE(buffer.width % 2 == 0 && buffer.height % 2 == 0);
-
-        const int32_t halfW = buffer.width / 2;
-        const int32_t halfH = buffer.height / 2;
-        fillBufferColor(buffer, Rect(0, 0, halfW, halfH), topLeft);
-        fillBufferColor(buffer, Rect(halfW, 0, buffer.width, halfH), topRight);
-        fillBufferColor(buffer, Rect(0, halfH, halfW, buffer.height), bottomLeft);
-        fillBufferColor(buffer, Rect(halfW, halfH, buffer.width, buffer.height), bottomRight);
-
-        postLayerBuffer(layer);
-    }
-
-    sp<ScreenCapture> screenshot() {
-        sp<ScreenCapture> screenshot;
-        ScreenCapture::captureScreen(&screenshot, mLayerZBase);
-        return screenshot;
-    }
-
-    sp<SurfaceComposerClient> mClient;
-
-    sp<IBinder> mDisplay;
-    uint32_t mDisplayWidth;
-    uint32_t mDisplayHeight;
-    uint32_t mDisplayLayerStack;
-
-    // leave room for ~256 layers
-    const int32_t mLayerZBase = std::numeric_limits<int32_t>::max() - 256;
-
-private:
-    void SetUpDisplay() {
-        mDisplay = mClient->getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain);
-        ASSERT_NE(nullptr, mDisplay.get()) << "failed to get built-in display";
-
-        // get display width/height
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(mDisplay, &info);
-        mDisplayWidth = info.w;
-        mDisplayHeight = info.h;
-
-        // After a new buffer is queued, SurfaceFlinger is notified and will
-        // latch the new buffer on next vsync.  Let's heuristically wait for 3
-        // vsyncs.
-        mBufferPostDelay = int32_t(1e6 / info.fps) * 3;
-
-        mDisplayLayerStack = 0;
-        // set layer stack (b/68888219)
-        Transaction t;
-        t.setDisplayLayerStack(mDisplay, mDisplayLayerStack);
-        t.apply();
-    }
-
-    void waitForLayerBuffers() { usleep(mBufferPostDelay); }
-
-    int32_t mBufferPostDelay;
-};
-
-TEST_F(LayerTransactionTest, SetPositionBasic) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    {
-        SCOPED_TRACE("default position");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-        shot->expectBorder(Rect(0, 0, 32, 32), Color::BLACK);
-    }
-
-    Transaction().setPosition(layer, 5, 10).apply();
-    {
-        SCOPED_TRACE("new position");
-        auto shot = screenshot();
-        shot->expectColor(Rect(5, 10, 37, 42), Color::RED);
-        shot->expectBorder(Rect(5, 10, 37, 42), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetPositionRounding) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // GLES requires only 4 bits of subpixel precision during rasterization
-    // XXX GLES composition does not match HWC composition due to precision
-    // loss (b/69315223)
-    const float epsilon = 1.0f / 16.0f;
-    Transaction().setPosition(layer, 0.5f - epsilon, 0.5f - epsilon).apply();
-    {
-        SCOPED_TRACE("rounding down");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setPosition(layer, 0.5f + epsilon, 0.5f + epsilon).apply();
-    {
-        SCOPED_TRACE("rounding up");
-        screenshot()->expectColor(Rect(1, 1, 33, 33), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetPositionOutOfBounds) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    Transaction().setPosition(layer, -32, -32).apply();
-    {
-        SCOPED_TRACE("negative coordinates");
-        screenshot()->expectColor(Rect(0, 0, mDisplayWidth, mDisplayHeight), Color::BLACK);
-    }
-
-    Transaction().setPosition(layer, mDisplayWidth, mDisplayHeight).apply();
-    {
-        SCOPED_TRACE("positive coordinates");
-        screenshot()->expectColor(Rect(0, 0, mDisplayWidth, mDisplayHeight), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetPositionPartiallyOutOfBounds) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // partially out of bounds
-    Transaction().setPosition(layer, -30, -30).apply();
-    {
-        SCOPED_TRACE("negative coordinates");
-        screenshot()->expectColor(Rect(0, 0, 2, 2), Color::RED);
-    }
-
-    Transaction().setPosition(layer, mDisplayWidth - 2, mDisplayHeight - 2).apply();
-    {
-        SCOPED_TRACE("positive coordinates");
-        screenshot()->expectColor(Rect(mDisplayWidth - 2, mDisplayHeight - 2, mDisplayWidth,
-                                       mDisplayHeight),
-                                  Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetPositionWithResize) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // setPosition is applied immediately by default, with or without resize
-    // pending
-    Transaction().setPosition(layer, 5, 10).setSize(layer, 64, 64).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        auto shot = screenshot();
-        shot->expectColor(Rect(5, 10, 37, 42), Color::RED);
-        shot->expectBorder(Rect(5, 10, 37, 42), Color::BLACK);
-    }
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("resize applied");
-        screenshot()->expectColor(Rect(5, 10, 69, 74), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetPositionWithNextResize) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // request setPosition to be applied with the next resize
-    Transaction().setPosition(layer, 5, 10).setGeometryAppliesWithResize(layer).apply();
-    {
-        SCOPED_TRACE("new position pending");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setPosition(layer, 15, 20).apply();
-    {
-        SCOPED_TRACE("pending new position modified");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setSize(layer, 64, 64).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    // finally resize and latch the buffer
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("new position applied");
-        screenshot()->expectColor(Rect(15, 20, 79, 84), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetPositionWithNextResizeScaleToWindow) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // setPosition is not immediate even with SCALE_TO_WINDOW override
-    Transaction()
-            .setPosition(layer, 5, 10)
-            .setSize(layer, 64, 64)
-            .setOverrideScalingMode(layer, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW)
-            .setGeometryAppliesWithResize(layer)
-            .apply();
-    {
-        SCOPED_TRACE("new position pending");
-        screenshot()->expectColor(Rect(0, 0, 64, 64), Color::RED);
-    }
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("new position applied");
-        screenshot()->expectColor(Rect(5, 10, 69, 74), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetSizeBasic) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    Transaction().setSize(layer, 64, 64).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-        shot->expectBorder(Rect(0, 0, 32, 32), Color::BLACK);
-    }
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("resize applied");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 64, 64), Color::RED);
-        shot->expectBorder(Rect(0, 0, 64, 64), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetSizeInvalid) {
-    // cannot test robustness against invalid sizes (zero or really huge)
-}
-
-TEST_F(LayerTransactionTest, SetSizeWithScaleToWindow) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // setSize is immediate with SCALE_TO_WINDOW, unlike setPosition
-    Transaction()
-            .setSize(layer, 64, 64)
-            .setOverrideScalingMode(layer, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW)
-            .apply();
-    screenshot()->expectColor(Rect(0, 0, 64, 64), Color::RED);
-}
-
-TEST_F(LayerTransactionTest, SetZBasic) {
-    sp<SurfaceControl> layerR;
-    sp<SurfaceControl> layerG;
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(layerG = createLayer("test G", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerG, Color::GREEN));
-
-    Transaction().setLayer(layerR, mLayerZBase + 1).apply();
-    {
-        SCOPED_TRACE("layerR");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setLayer(layerG, mLayerZBase + 2).apply();
-    {
-        SCOPED_TRACE("layerG");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::GREEN);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetZNegative) {
-    sp<SurfaceControl> layerR;
-    sp<SurfaceControl> layerG;
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(layerG = createLayer("test G", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerG, Color::GREEN));
-
-    Transaction().setLayer(layerR, -1).setLayer(layerG, -2).apply();
-    {
-        SCOPED_TRACE("layerR");
-        sp<ScreenCapture> screenshot;
-        ScreenCapture::captureScreen(&screenshot, -2, -1);
-        screenshot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setLayer(layerR, -3).apply();
-    {
-        SCOPED_TRACE("layerG");
-        sp<ScreenCapture> screenshot;
-        ScreenCapture::captureScreen(&screenshot, -3, -1);
-        screenshot->expectColor(Rect(0, 0, 32, 32), Color::GREEN);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetRelativeZBasic) {
-    sp<SurfaceControl> layerR;
-    sp<SurfaceControl> layerG;
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(layerG = createLayer("test G", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerG, Color::GREEN));
-
-    Transaction()
-            .setPosition(layerG, 16, 16)
-            .setRelativeLayer(layerG, layerR->getHandle(), 1)
-            .apply();
-    {
-        SCOPED_TRACE("layerG above");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 16, 16), Color::RED);
-        shot->expectColor(Rect(16, 16, 48, 48), Color::GREEN);
-    }
-
-    Transaction().setRelativeLayer(layerG, layerR->getHandle(), -1).apply();
-    {
-        SCOPED_TRACE("layerG below");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-        shot->expectColor(Rect(32, 32, 48, 48), Color::GREEN);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetRelativeZNegative) {
-    sp<SurfaceControl> layerR;
-    sp<SurfaceControl> layerG;
-    sp<SurfaceControl> layerB;
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(layerG = createLayer("test G", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerG, Color::GREEN));
-    ASSERT_NO_FATAL_FAILURE(layerB = createLayer("test B", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerB, Color::BLUE));
-
-    // layerR = mLayerZBase, layerG = layerR - 1, layerB = -2
-    Transaction().setRelativeLayer(layerG, layerR->getHandle(), -1).setLayer(layerB, -2).apply();
-
-    sp<ScreenCapture> screenshot;
-    // only layerB is in this range
-    ScreenCapture::captureScreen(&screenshot, -2, -1);
-    screenshot->expectColor(Rect(0, 0, 32, 32), Color::BLUE);
-}
-
-TEST_F(LayerTransactionTest, SetRelativeZGroup) {
-    sp<SurfaceControl> layerR;
-    sp<SurfaceControl> layerG;
-    sp<SurfaceControl> layerB;
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(layerG = createLayer("test G", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerG, Color::GREEN));
-    ASSERT_NO_FATAL_FAILURE(layerB = createLayer("test B", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerB, Color::BLUE));
-
-    // layerR = 0, layerG = layerR + 3, layerB = 2
-    Transaction()
-            .setPosition(layerG, 8, 8)
-            .setRelativeLayer(layerG, layerR->getHandle(), 3)
-            .setPosition(layerB, 16, 16)
-            .setLayer(layerB, mLayerZBase + 2)
-            .apply();
-    {
-        SCOPED_TRACE("(layerR < layerG) < layerB");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 8, 8), Color::RED);
-        shot->expectColor(Rect(8, 8, 16, 16), Color::GREEN);
-        shot->expectColor(Rect(16, 16, 48, 48), Color::BLUE);
-    }
-
-    // layerR = 4, layerG = layerR + 3, layerB = 2
-    Transaction().setLayer(layerR, mLayerZBase + 4).apply();
-    {
-        SCOPED_TRACE("layerB < (layerR < layerG)");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 8, 8), Color::RED);
-        shot->expectColor(Rect(8, 8, 40, 40), Color::GREEN);
-        shot->expectColor(Rect(40, 40, 48, 48), Color::BLUE);
-    }
-
-    // layerR = 4, layerG = layerR - 3, layerB = 2
-    Transaction().setRelativeLayer(layerG, layerR->getHandle(), -3).apply();
-    {
-        SCOPED_TRACE("layerB < (layerG < layerR)");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-        shot->expectColor(Rect(32, 32, 40, 40), Color::GREEN);
-        shot->expectColor(Rect(40, 40, 48, 48), Color::BLUE);
-    }
-
-    // restore to absolute z
-    // layerR = 4, layerG = 0, layerB = 2
-    Transaction().setLayer(layerG, mLayerZBase).apply();
-    {
-        SCOPED_TRACE("layerG < layerB < layerR");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-        shot->expectColor(Rect(32, 32, 48, 48), Color::BLUE);
-    }
-
-    // layerR should not affect layerG anymore
-    // layerR = 1, layerG = 0, layerB = 2
-    Transaction().setLayer(layerR, mLayerZBase + 1).apply();
-    {
-        SCOPED_TRACE("layerG < layerR < layerB");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 16, 16), Color::RED);
-        shot->expectColor(Rect(16, 16, 48, 48), Color::BLUE);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetRelativeZBug64572777) {
-    sp<SurfaceControl> layerR;
-    sp<SurfaceControl> layerG;
-
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(layerG = createLayer("test G", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerG, Color::GREEN));
-
-    Transaction()
-            .setPosition(layerG, 16, 16)
-            .setRelativeLayer(layerG, layerR->getHandle(), 1)
-            .apply();
-
-    mClient->destroySurface(layerG->getHandle());
-    // layerG should have been removed
-    screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-}
-
-TEST_F(LayerTransactionTest, SetFlagsHidden) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    Transaction().setFlags(layer, layer_state_t::eLayerHidden, layer_state_t::eLayerHidden).apply();
-    {
-        SCOPED_TRACE("layer hidden");
-        screenshot()->expectColor(Rect(0, 0, mDisplayWidth, mDisplayHeight), Color::BLACK);
-    }
-
-    Transaction().setFlags(layer, 0, layer_state_t::eLayerHidden).apply();
-    {
-        SCOPED_TRACE("layer shown");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetFlagsOpaque) {
-    const Color translucentRed = {100, 0, 0, 100};
-    sp<SurfaceControl> layerR;
-    sp<SurfaceControl> layerG;
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, translucentRed));
-    ASSERT_NO_FATAL_FAILURE(layerG = createLayer("test G", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerG, Color::GREEN));
-
-    Transaction()
-            .setLayer(layerR, mLayerZBase + 1)
-            .setFlags(layerR, layer_state_t::eLayerOpaque, layer_state_t::eLayerOpaque)
-            .apply();
-    {
-        SCOPED_TRACE("layerR opaque");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), {100, 0, 0, 255});
-    }
-
-    Transaction().setFlags(layerR, 0, layer_state_t::eLayerOpaque).apply();
-    {
-        SCOPED_TRACE("layerR translucent");
-        const uint8_t g = uint8_t(255 - translucentRed.a);
-        screenshot()->expectColor(Rect(0, 0, 32, 32), {100, g, 0, 255});
-    }
-}
-
-TEST_F(LayerTransactionTest, SetFlagsSecure) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    sp<ISurfaceComposer> composer = ComposerService::getComposerService();
-    sp<GraphicBuffer> outBuffer;
-    Transaction()
-            .setFlags(layer, layer_state_t::eLayerSecure, layer_state_t::eLayerSecure)
-            .apply(true);
-    ASSERT_EQ(PERMISSION_DENIED,
-              composer->captureScreen(mDisplay, &outBuffer, Rect(), 0, 0, mLayerZBase, mLayerZBase,
-                                      false));
-
-    Transaction().setFlags(layer, 0, layer_state_t::eLayerSecure).apply(true);
-    ASSERT_EQ(NO_ERROR,
-              composer->captureScreen(mDisplay, &outBuffer, Rect(), 0, 0, mLayerZBase, mLayerZBase,
-                                      false));
-}
-
-TEST_F(LayerTransactionTest, SetTransparentRegionHintBasic) {
-    const Rect top(0, 0, 32, 16);
-    const Rect bottom(0, 16, 32, 32);
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-
-    ANativeWindow_Buffer buffer;
-    ASSERT_NO_FATAL_FAILURE(buffer = getLayerBuffer(layer));
-    ASSERT_NO_FATAL_FAILURE(fillBufferColor(buffer, top, Color::TRANSPARENT));
-    ASSERT_NO_FATAL_FAILURE(fillBufferColor(buffer, bottom, Color::RED));
-    // setTransparentRegionHint always applies to the following buffer
-    Transaction().setTransparentRegionHint(layer, Region(top)).apply();
-    ASSERT_NO_FATAL_FAILURE(postLayerBuffer(layer));
-    {
-        SCOPED_TRACE("top transparent");
-        auto shot = screenshot();
-        shot->expectColor(top, Color::BLACK);
-        shot->expectColor(bottom, Color::RED);
-    }
-
-    Transaction().setTransparentRegionHint(layer, Region(bottom)).apply();
-    {
-        SCOPED_TRACE("transparent region hint pending");
-        auto shot = screenshot();
-        shot->expectColor(top, Color::BLACK);
-        shot->expectColor(bottom, Color::RED);
-    }
-
-    ASSERT_NO_FATAL_FAILURE(buffer = getLayerBuffer(layer));
-    ASSERT_NO_FATAL_FAILURE(fillBufferColor(buffer, top, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(fillBufferColor(buffer, bottom, Color::TRANSPARENT));
-    ASSERT_NO_FATAL_FAILURE(postLayerBuffer(layer));
-    {
-        SCOPED_TRACE("bottom transparent");
-        auto shot = screenshot();
-        shot->expectColor(top, Color::RED);
-        shot->expectColor(bottom, Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetTransparentRegionHintOutOfBounds) {
-    sp<SurfaceControl> layerTransparent;
-    sp<SurfaceControl> layerR;
-    ASSERT_NO_FATAL_FAILURE(layerTransparent = createLayer("test transparent", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(layerR = createLayer("test R", 32, 32));
-
-    // check that transparent region hint is bound by the layer size
-    Transaction()
-            .setTransparentRegionHint(layerTransparent,
-                                      Region(Rect(0, 0, mDisplayWidth, mDisplayHeight)))
-            .setPosition(layerR, 16, 16)
-            .setLayer(layerR, mLayerZBase + 1)
-            .apply();
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerTransparent, Color::TRANSPARENT));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layerR, Color::RED));
-    screenshot()->expectColor(Rect(16, 16, 48, 48), Color::RED);
-}
-
-TEST_F(LayerTransactionTest, SetAlphaBasic) {
-    sp<SurfaceControl> layer1;
-    sp<SurfaceControl> layer2;
-    ASSERT_NO_FATAL_FAILURE(layer1 = createLayer("test 1", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(layer2 = createLayer("test 2", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer1, {64, 0, 0, 255}));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer2, {0, 64, 0, 255}));
-
-    Transaction()
-            .setAlpha(layer1, 0.25f)
-            .setAlpha(layer2, 0.75f)
-            .setPosition(layer2, 16, 0)
-            .setLayer(layer2, mLayerZBase + 1)
-            .apply();
-    {
-        auto shot = screenshot();
-        uint8_t r = 16; // 64 * 0.25f
-        uint8_t g = 48; // 64 * 0.75f
-        shot->expectColor(Rect(0, 0, 16, 32), {r, 0, 0, 255});
-        shot->expectColor(Rect(32, 0, 48, 32), {0, g, 0, 255});
-
-        r /= 4; // r * (1.0f - 0.75f)
-        shot->expectColor(Rect(16, 0, 32, 32), {r, g, 0, 255});
-    }
-}
-
-TEST_F(LayerTransactionTest, SetAlphaClamped) {
-    const Color color = {64, 0, 0, 255};
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, color));
-
-    Transaction().setAlpha(layer, 2.0f).apply();
-    {
-        SCOPED_TRACE("clamped to 1.0f");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), color);
-    }
-
-    Transaction().setAlpha(layer, -1.0f).apply();
-    {
-        SCOPED_TRACE("clamped to 0.0f");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetColorBasic) {
-    sp<SurfaceControl> bufferLayer;
-    sp<SurfaceControl> colorLayer;
-    ASSERT_NO_FATAL_FAILURE(bufferLayer = createLayer("test bg", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(bufferLayer, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(
-            colorLayer = createLayer("test", 32, 32, ISurfaceComposerClient::eFXSurfaceColor));
-
-    Transaction().setLayer(colorLayer, mLayerZBase + 1).apply();
-    {
-        SCOPED_TRACE("default color");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::BLACK);
-    }
-
-    const half3 color(15.0f / 255.0f, 51.0f / 255.0f, 85.0f / 255.0f);
-    const Color expected = {15, 51, 85, 255};
-    // this is handwavy, but the precison loss scaled by 255 (8-bit per
-    // channel) should be less than one
-    const uint8_t tolerance = 1;
-    Transaction().setColor(colorLayer, color).apply();
-    {
-        SCOPED_TRACE("new color");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), expected, tolerance);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetColorClamped) {
-    sp<SurfaceControl> colorLayer;
-    ASSERT_NO_FATAL_FAILURE(
-            colorLayer = createLayer("test", 32, 32, ISurfaceComposerClient::eFXSurfaceColor));
-
-    Transaction().setColor(colorLayer, half3(2.0f, -1.0f, 0.0f)).apply();
-    screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-}
-
-TEST_F(LayerTransactionTest, SetColorWithAlpha) {
-    sp<SurfaceControl> bufferLayer;
-    sp<SurfaceControl> colorLayer;
-    ASSERT_NO_FATAL_FAILURE(bufferLayer = createLayer("test bg", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(bufferLayer, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(
-            colorLayer = createLayer("test", 32, 32, ISurfaceComposerClient::eFXSurfaceColor));
-
-    const half3 color(15.0f / 255.0f, 51.0f / 255.0f, 85.0f / 255.0f);
-    const float alpha = 0.25f;
-    const ubyte3 expected((vec3(color) * alpha + vec3(1.0f, 0.0f, 0.0f) * (1.0f - alpha)) * 255.0f);
-    // this is handwavy, but the precison loss scaled by 255 (8-bit per
-    // channel) should be less than one
-    const uint8_t tolerance = 1;
-    Transaction()
-            .setColor(colorLayer, color)
-            .setAlpha(colorLayer, alpha)
-            .setLayer(colorLayer, mLayerZBase + 1)
-            .apply();
-    screenshot()->expectColor(Rect(0, 0, 32, 32), {expected.r, expected.g, expected.b, 255},
-                              tolerance);
-}
-
-TEST_F(LayerTransactionTest, SetColorWithParentAlpha_Bug74220420) {
-    sp<SurfaceControl> bufferLayer;
-    sp<SurfaceControl> parentLayer;
-    sp<SurfaceControl> colorLayer;
-    ASSERT_NO_FATAL_FAILURE(bufferLayer = createLayer("test bg", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(parentLayer = createLayer("parentWithAlpha", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(bufferLayer, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(colorLayer = createLayer(
-            "childWithColor", 32, 32, ISurfaceComposerClient::eFXSurfaceColor));
-
-    const half3 color(15.0f / 255.0f, 51.0f / 255.0f, 85.0f / 255.0f);
-    const float alpha = 0.25f;
-    const ubyte3 expected((vec3(color) * alpha + vec3(1.0f, 0.0f, 0.0f) * (1.0f - alpha)) * 255.0f);
-    // this is handwavy, but the precision loss scaled by 255 (8-bit per
-    // channel) should be less than one
-    const uint8_t tolerance = 1;
-    Transaction()
-            .reparent(colorLayer, parentLayer->getHandle())
-            .setColor(colorLayer, color)
-            .setAlpha(parentLayer, alpha)
-            .setLayer(parentLayer, mLayerZBase + 1)
-            .apply();
-    screenshot()->expectColor(Rect(0, 0, 32, 32), {expected.r, expected.g, expected.b, 255},
-                              tolerance);
-}
-
-TEST_F(LayerTransactionTest, SetColorWithBuffer) {
-    sp<SurfaceControl> bufferLayer;
-    ASSERT_NO_FATAL_FAILURE(bufferLayer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(bufferLayer, Color::RED));
-
-    // color is ignored
-    Transaction().setColor(bufferLayer, half3(0.0f, 1.0f, 0.0f)).apply();
-    screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-}
-
-TEST_F(LayerTransactionTest, SetLayerStackBasic) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    Transaction().setLayerStack(layer, mDisplayLayerStack + 1).apply();
-    {
-        SCOPED_TRACE("non-existing layer stack");
-        screenshot()->expectColor(Rect(0, 0, mDisplayWidth, mDisplayHeight), Color::BLACK);
-    }
-
-    Transaction().setLayerStack(layer, mDisplayLayerStack).apply();
-    {
-        SCOPED_TRACE("original layer stack");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetMatrixBasic) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(
-            fillLayerQuadrant(layer, Color::RED, Color::GREEN, Color::BLUE, Color::WHITE));
-
-    Transaction().setMatrix(layer, 1.0f, 0.0f, 0.0f, 1.0f).setPosition(layer, 0, 0).apply();
-    {
-        SCOPED_TRACE("IDENTITY");
-        screenshot()->expectQuadrant(Rect(0, 0, 32, 32), Color::RED, Color::GREEN, Color::BLUE,
-                                     Color::WHITE);
-    }
-
-    Transaction().setMatrix(layer, -1.0f, 0.0f, 0.0f, 1.0f).setPosition(layer, 32, 0).apply();
-    {
-        SCOPED_TRACE("FLIP_H");
-        screenshot()->expectQuadrant(Rect(0, 0, 32, 32), Color::GREEN, Color::RED, Color::WHITE,
-                                     Color::BLUE);
-    }
-
-    Transaction().setMatrix(layer, 1.0f, 0.0f, 0.0f, -1.0f).setPosition(layer, 0, 32).apply();
-    {
-        SCOPED_TRACE("FLIP_V");
-        screenshot()->expectQuadrant(Rect(0, 0, 32, 32), Color::BLUE, Color::WHITE, Color::RED,
-                                     Color::GREEN);
-    }
-
-    Transaction().setMatrix(layer, 0.0f, 1.0f, -1.0f, 0.0f).setPosition(layer, 32, 0).apply();
-    {
-        SCOPED_TRACE("ROT_90");
-        screenshot()->expectQuadrant(Rect(0, 0, 32, 32), Color::BLUE, Color::RED, Color::WHITE,
-                                     Color::GREEN);
-    }
-
-    Transaction().setMatrix(layer, 2.0f, 0.0f, 0.0f, 2.0f).setPosition(layer, 0, 0).apply();
-    {
-        SCOPED_TRACE("SCALE");
-        screenshot()->expectQuadrant(Rect(0, 0, 64, 64), Color::RED, Color::GREEN, Color::BLUE,
-                                     Color::WHITE, true /* filtered */);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetMatrixRot45) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(
-            fillLayerQuadrant(layer, Color::RED, Color::GREEN, Color::BLUE, Color::WHITE));
-
-    const float rot = M_SQRT1_2; // 45 degrees
-    const float trans = M_SQRT2 * 16.0f;
-    Transaction().setMatrix(layer, rot, rot, -rot, rot).setPosition(layer, trans, 0).apply();
-
-    auto shot = screenshot();
-    // check a 8x8 region inside each color
-    auto get8x8Rect = [](int32_t centerX, int32_t centerY) {
-        const int32_t halfL = 4;
-        return Rect(centerX - halfL, centerY - halfL, centerX + halfL, centerY + halfL);
-    };
-    const int32_t unit = int32_t(trans / 2);
-    shot->expectColor(get8x8Rect(2 * unit, 1 * unit), Color::RED);
-    shot->expectColor(get8x8Rect(3 * unit, 2 * unit), Color::GREEN);
-    shot->expectColor(get8x8Rect(1 * unit, 2 * unit), Color::BLUE);
-    shot->expectColor(get8x8Rect(2 * unit, 3 * unit), Color::WHITE);
-}
-
-TEST_F(LayerTransactionTest, SetMatrixWithResize) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // setMatrix is applied after any pending resize, unlike setPosition
-    Transaction().setMatrix(layer, 2.0f, 0.0f, 0.0f, 2.0f).setSize(layer, 64, 64).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-        shot->expectBorder(Rect(0, 0, 32, 32), Color::BLACK);
-    }
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("resize applied");
-        screenshot()->expectColor(Rect(0, 0, 128, 128), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetMatrixWithScaleToWindow) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // setMatrix is immediate with SCALE_TO_WINDOW, unlike setPosition
-    Transaction()
-            .setMatrix(layer, 2.0f, 0.0f, 0.0f, 2.0f)
-            .setSize(layer, 64, 64)
-            .setOverrideScalingMode(layer, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW)
-            .apply();
-    screenshot()->expectColor(Rect(0, 0, 128, 128), Color::RED);
-}
-
-TEST_F(LayerTransactionTest, SetOverrideScalingModeBasic) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(
-            fillLayerQuadrant(layer, Color::RED, Color::GREEN, Color::BLUE, Color::WHITE));
-
-    // XXX SCALE_CROP is not respected; calling setSize and
-    // setOverrideScalingMode in separate transactions does not work
-    // (b/69315456)
-    Transaction()
-            .setSize(layer, 64, 16)
-            .setOverrideScalingMode(layer, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW)
-            .apply();
-    {
-        SCOPED_TRACE("SCALE_TO_WINDOW");
-        screenshot()->expectQuadrant(Rect(0, 0, 64, 16), Color::RED, Color::GREEN, Color::BLUE,
-                                     Color::WHITE, true /* filtered */);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetCropBasic) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    const Rect crop(8, 8, 24, 24);
-
-    Transaction().setCrop(layer, crop).apply();
-    auto shot = screenshot();
-    shot->expectColor(crop, Color::RED);
-    shot->expectBorder(crop, Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetCropEmpty) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    {
-        SCOPED_TRACE("empty rect");
-        Transaction().setCrop(layer, Rect(8, 8, 8, 8)).apply();
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    {
-        SCOPED_TRACE("negative rect");
-        Transaction().setCrop(layer, Rect(8, 8, 0, 0)).apply();
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetCropOutOfBounds) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    Transaction().setCrop(layer, Rect(-128, -64, 128, 64)).apply();
-    auto shot = screenshot();
-    shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    shot->expectBorder(Rect(0, 0, 32, 32), Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetCropWithTranslation) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    const Point position(32, 32);
-    const Rect crop(8, 8, 24, 24);
-    Transaction().setPosition(layer, position.x, position.y).setCrop(layer, crop).apply();
-    auto shot = screenshot();
-    shot->expectColor(crop + position, Color::RED);
-    shot->expectBorder(crop + position, Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetCropWithScale) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // crop is affected by matrix
-    Transaction()
-            .setMatrix(layer, 2.0f, 0.0f, 0.0f, 2.0f)
-            .setCrop(layer, Rect(8, 8, 24, 24))
-            .apply();
-    auto shot = screenshot();
-    shot->expectColor(Rect(16, 16, 48, 48), Color::RED);
-    shot->expectBorder(Rect(16, 16, 48, 48), Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetCropWithResize) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // setCrop is applied immediately by default, with or without resize pending
-    Transaction().setCrop(layer, Rect(8, 8, 24, 24)).setSize(layer, 16, 16).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        auto shot = screenshot();
-        shot->expectColor(Rect(8, 8, 24, 24), Color::RED);
-        shot->expectBorder(Rect(8, 8, 24, 24), Color::BLACK);
-    }
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("resize applied");
-        auto shot = screenshot();
-        shot->expectColor(Rect(8, 8, 16, 16), Color::RED);
-        shot->expectBorder(Rect(8, 8, 16, 16), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetCropWithNextResize) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // request setCrop to be applied with the next resize
-    Transaction().setCrop(layer, Rect(8, 8, 24, 24)).setGeometryAppliesWithResize(layer).apply();
-    {
-        SCOPED_TRACE("waiting for next resize");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setCrop(layer, Rect(4, 4, 12, 12)).apply();
-    {
-        SCOPED_TRACE("pending crop modified");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setSize(layer, 16, 16).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    // finally resize
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("new crop applied");
-        auto shot = screenshot();
-        shot->expectColor(Rect(4, 4, 12, 12), Color::RED);
-        shot->expectBorder(Rect(4, 4, 12, 12), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetCropWithNextResizeScaleToWindow) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // setCrop is not immediate even with SCALE_TO_WINDOW override
-    Transaction()
-            .setCrop(layer, Rect(4, 4, 12, 12))
-            .setSize(layer, 16, 16)
-            .setOverrideScalingMode(layer, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW)
-            .setGeometryAppliesWithResize(layer)
-            .apply();
-    {
-        SCOPED_TRACE("new crop pending");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 16, 16), Color::RED);
-        shot->expectBorder(Rect(0, 0, 16, 16), Color::BLACK);
-    }
-
-    // XXX crop is never latched without other geometry change (b/69315677)
-    Transaction().setPosition(layer, 1, 0).setGeometryAppliesWithResize(layer).apply();
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    Transaction().setPosition(layer, 0, 0).apply();
-    {
-        SCOPED_TRACE("new crop applied");
-        auto shot = screenshot();
-        shot->expectColor(Rect(4, 4, 12, 12), Color::RED);
-        shot->expectBorder(Rect(4, 4, 12, 12), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropBasic) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    const Rect crop(8, 8, 24, 24);
-
-    // same as in SetCropBasic
-    Transaction().setFinalCrop(layer, crop).apply();
-    auto shot = screenshot();
-    shot->expectColor(crop, Color::RED);
-    shot->expectBorder(crop, Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropEmpty) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // same as in SetCropEmpty
-    {
-        SCOPED_TRACE("empty rect");
-        Transaction().setFinalCrop(layer, Rect(8, 8, 8, 8)).apply();
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    {
-        SCOPED_TRACE("negative rect");
-        Transaction().setFinalCrop(layer, Rect(8, 8, 0, 0)).apply();
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropOutOfBounds) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // same as in SetCropOutOfBounds
-    Transaction().setFinalCrop(layer, Rect(-128, -64, 128, 64)).apply();
-    auto shot = screenshot();
-    shot->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    shot->expectBorder(Rect(0, 0, 32, 32), Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropWithTranslation) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // final crop is applied post-translation
-    Transaction().setPosition(layer, 16, 16).setFinalCrop(layer, Rect(8, 8, 24, 24)).apply();
-    auto shot = screenshot();
-    shot->expectColor(Rect(16, 16, 24, 24), Color::RED);
-    shot->expectBorder(Rect(16, 16, 24, 24), Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropWithScale) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // final crop is not affected by matrix
-    Transaction()
-            .setMatrix(layer, 2.0f, 0.0f, 0.0f, 2.0f)
-            .setFinalCrop(layer, Rect(8, 8, 24, 24))
-            .apply();
-    auto shot = screenshot();
-    shot->expectColor(Rect(8, 8, 24, 24), Color::RED);
-    shot->expectBorder(Rect(8, 8, 24, 24), Color::BLACK);
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropWithResize) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // same as in SetCropWithResize
-    Transaction().setFinalCrop(layer, Rect(8, 8, 24, 24)).setSize(layer, 16, 16).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        auto shot = screenshot();
-        shot->expectColor(Rect(8, 8, 24, 24), Color::RED);
-        shot->expectBorder(Rect(8, 8, 24, 24), Color::BLACK);
-    }
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("resize applied");
-        auto shot = screenshot();
-        shot->expectColor(Rect(8, 8, 16, 16), Color::RED);
-        shot->expectBorder(Rect(8, 8, 16, 16), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropWithNextResize) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // same as in SetCropWithNextResize
-    Transaction()
-            .setFinalCrop(layer, Rect(8, 8, 24, 24))
-            .setGeometryAppliesWithResize(layer)
-            .apply();
-    {
-        SCOPED_TRACE("waiting for next resize");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setFinalCrop(layer, Rect(4, 4, 12, 12)).apply();
-    {
-        SCOPED_TRACE("pending final crop modified");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    Transaction().setSize(layer, 16, 16).apply();
-    {
-        SCOPED_TRACE("resize pending");
-        screenshot()->expectColor(Rect(0, 0, 32, 32), Color::RED);
-    }
-
-    // finally resize
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    {
-        SCOPED_TRACE("new final crop applied");
-        auto shot = screenshot();
-        shot->expectColor(Rect(4, 4, 12, 12), Color::RED);
-        shot->expectBorder(Rect(4, 4, 12, 12), Color::BLACK);
-    }
-}
-
-TEST_F(LayerTransactionTest, SetFinalCropWithNextResizeScaleToWindow) {
-    sp<SurfaceControl> layer;
-    ASSERT_NO_FATAL_FAILURE(layer = createLayer("test", 32, 32));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-
-    // same as in SetCropWithNextResizeScaleToWindow
-    Transaction()
-            .setFinalCrop(layer, Rect(4, 4, 12, 12))
-            .setSize(layer, 16, 16)
-            .setOverrideScalingMode(layer, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW)
-            .setGeometryAppliesWithResize(layer)
-            .apply();
-    {
-        SCOPED_TRACE("new final crop pending");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 16, 16), Color::RED);
-        shot->expectBorder(Rect(0, 0, 16, 16), Color::BLACK);
-    }
-
-    // XXX final crop is never latched without other geometry change (b/69315677)
-    Transaction().setPosition(layer, 1, 0).setGeometryAppliesWithResize(layer).apply();
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(layer, Color::RED));
-    Transaction().setPosition(layer, 0, 0).apply();
-    {
-        SCOPED_TRACE("new final crop applied");
-        auto shot = screenshot();
-        shot->expectColor(Rect(4, 4, 12, 12), Color::RED);
-        shot->expectBorder(Rect(4, 4, 12, 12), Color::BLACK);
-    }
-}
-
-class LayerUpdateTest : public LayerTransactionTest {
-protected:
-    virtual void SetUp() {
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        sp<IBinder> display(
-                SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-
-        ssize_t displayWidth = info.w;
-        ssize_t displayHeight = info.h;
-
-        // Background surface
-        mBGSurfaceControl =
-                mComposerClient->createSurface(String8("BG Test Surface"), displayWidth,
-                                               displayHeight, PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mBGSurfaceControl != nullptr);
-        ASSERT_TRUE(mBGSurfaceControl->isValid());
-        fillSurfaceRGBA8(mBGSurfaceControl, 63, 63, 195);
-
-        // Foreground surface
-        mFGSurfaceControl = mComposerClient->createSurface(String8("FG Test Surface"), 64, 64,
-                                                           PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mFGSurfaceControl != nullptr);
-        ASSERT_TRUE(mFGSurfaceControl->isValid());
-
-        fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63);
-
-        // Synchronization surface
-        mSyncSurfaceControl = mComposerClient->createSurface(String8("Sync Test Surface"), 1, 1,
-                                                             PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mSyncSurfaceControl != nullptr);
-        ASSERT_TRUE(mSyncSurfaceControl->isValid());
-
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-
-        asTransaction([&](Transaction& t) {
-            t.setDisplayLayerStack(display, 0);
-
-            t.setLayer(mBGSurfaceControl, INT32_MAX - 2).show(mBGSurfaceControl);
-
-            t.setLayer(mFGSurfaceControl, INT32_MAX - 1)
-                    .setPosition(mFGSurfaceControl, 64, 64)
-                    .show(mFGSurfaceControl);
-
-            t.setLayer(mSyncSurfaceControl, INT32_MAX - 1)
-                    .setPosition(mSyncSurfaceControl, displayWidth - 2, displayHeight - 2)
-                    .show(mSyncSurfaceControl);
-        });
-    }
-
-    virtual void TearDown() {
-        mComposerClient->dispose();
-        mBGSurfaceControl = 0;
-        mFGSurfaceControl = 0;
-        mSyncSurfaceControl = 0;
-        mComposerClient = 0;
-    }
-
-    void waitForPostedBuffers() {
-        // Since the sync surface is in synchronous mode (i.e. double buffered)
-        // posting three buffers to it should ensure that at least two
-        // SurfaceFlinger::handlePageFlip calls have been made, which should
-        // guaranteed that a buffer posted to another Surface has been retired.
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-    }
-
-    void asTransaction(const std::function<void(Transaction&)>& exec) {
-        Transaction t;
-        exec(t);
-        t.apply(true);
-    }
-
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mBGSurfaceControl;
-    sp<SurfaceControl> mFGSurfaceControl;
-
-    // This surface is used to ensure that the buffers posted to
-    // mFGSurfaceControl have been picked up by SurfaceFlinger.
-    sp<SurfaceControl> mSyncSurfaceControl;
-};
-
-TEST_F(LayerUpdateTest, RelativesAreNotDetached) {
-    sp<ScreenCapture> sc;
-
-    sp<SurfaceControl> relative = mComposerClient->createSurface(String8("relativeTestSurface"), 10,
-                                                                 10, PIXEL_FORMAT_RGBA_8888, 0);
-    fillSurfaceRGBA8(relative, 10, 10, 10);
-    waitForPostedBuffers();
-
-    Transaction{}
-            .setRelativeLayer(relative, mFGSurfaceControl->getHandle(), 1)
-            .setPosition(relative, 64, 64)
-            .apply();
-
-    {
-        // The relative should be on top of the FG control.
-        ScreenCapture::captureScreen(&sc);
-        sc->checkPixel(64, 64, 10, 10, 10);
-    }
-    Transaction{}.detachChildren(mFGSurfaceControl).apply();
-
-    {
-        // Nothing should change at this point.
-        ScreenCapture::captureScreen(&sc);
-        sc->checkPixel(64, 64, 10, 10, 10);
-    }
-
-    Transaction{}.hide(relative).apply();
-
-    {
-        // Ensure that the relative was actually hidden, rather than
-        // being left in the detached but visible state.
-        ScreenCapture::captureScreen(&sc);
-        sc->expectFGColor(64, 64);
-    }
-}
-
-class GeometryLatchingTest : public LayerUpdateTest {
-protected:
-    void EXPECT_INITIAL_STATE(const char* trace) {
-        SCOPED_TRACE(trace);
-        ScreenCapture::captureScreen(&sc);
-        // We find the leading edge of the FG surface.
-        sc->expectFGColor(127, 127);
-        sc->expectBGColor(128, 128);
-    }
-
-    void lockAndFillFGBuffer() { fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63, false); }
-
-    void unlockFGBuffer() {
-        sp<Surface> s = mFGSurfaceControl->getSurface();
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-        waitForPostedBuffers();
-    }
-
-    void completeFGResize() {
-        fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63);
-        waitForPostedBuffers();
-    }
-    void restoreInitialState() {
-        asTransaction([&](Transaction& t) {
-            t.setSize(mFGSurfaceControl, 64, 64);
-            t.setPosition(mFGSurfaceControl, 64, 64);
-            t.setCrop(mFGSurfaceControl, Rect(0, 0, 64, 64));
-            t.setFinalCrop(mFGSurfaceControl, Rect(0, 0, -1, -1));
-        });
-
-        EXPECT_INITIAL_STATE("After restoring initial state");
-    }
-    sp<ScreenCapture> sc;
-};
-
-class CropLatchingTest : public GeometryLatchingTest {
-protected:
-    void EXPECT_CROPPED_STATE(const char* trace) {
-        SCOPED_TRACE(trace);
-        ScreenCapture::captureScreen(&sc);
-        // The edge should be moved back one pixel by our crop.
-        sc->expectFGColor(126, 126);
-        sc->expectBGColor(127, 127);
-        sc->expectBGColor(128, 128);
-    }
-
-    void EXPECT_RESIZE_STATE(const char* trace) {
-        SCOPED_TRACE(trace);
-        ScreenCapture::captureScreen(&sc);
-        // The FG is now resized too 128,128 at 64,64
-        sc->expectFGColor(64, 64);
-        sc->expectFGColor(191, 191);
-        sc->expectBGColor(192, 192);
-    }
-};
-
-// In this test we ensure that setGeometryAppliesWithResize actually demands
-// a buffer of the new size, and not just any size.
-TEST_F(CropLatchingTest, FinalCropLatchingBufferOldSize) {
-    EXPECT_INITIAL_STATE("before anything");
-    // Normally the crop applies immediately even while a resize is pending.
-    asTransaction([&](Transaction& t) {
-        t.setSize(mFGSurfaceControl, 128, 128);
-        t.setFinalCrop(mFGSurfaceControl, Rect(64, 64, 127, 127));
-    });
-
-    EXPECT_CROPPED_STATE("after setting crop (without geometryAppliesWithResize)");
-
-    restoreInitialState();
-
-    // In order to prepare to submit a buffer at the wrong size, we acquire it prior to
-    // initiating the resize.
-    lockAndFillFGBuffer();
-
-    asTransaction([&](Transaction& t) {
-        t.setSize(mFGSurfaceControl, 128, 128);
-        t.setGeometryAppliesWithResize(mFGSurfaceControl);
-        t.setFinalCrop(mFGSurfaceControl, Rect(64, 64, 127, 127));
-    });
-
-    EXPECT_INITIAL_STATE("after setting crop (with geometryAppliesWithResize)");
-
-    // We now submit our old buffer, at the old size, and ensure it doesn't
-    // trigger geometry latching.
-    unlockFGBuffer();
-
-    EXPECT_INITIAL_STATE("after unlocking FG buffer (with geometryAppliesWithResize)");
-
-    completeFGResize();
-
-    EXPECT_CROPPED_STATE("after the resize finishes");
-}
-
-TEST_F(LayerUpdateTest, DeferredTransactionTest) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before anything");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->expectFGColor(96, 96);
-        sc->expectBGColor(160, 160);
-    }
-
-    // set up two deferred transactions on different frames
-    asTransaction([&](Transaction& t) {
-        t.setAlpha(mFGSurfaceControl, 0.75);
-        t.deferTransactionUntil(mFGSurfaceControl, mSyncSurfaceControl->getHandle(),
-                                mSyncSurfaceControl->getSurface()->getNextFrameNumber());
-    });
-
-    asTransaction([&](Transaction& t) {
-        t.setPosition(mFGSurfaceControl, 128, 128);
-        t.deferTransactionUntil(mFGSurfaceControl, mSyncSurfaceControl->getHandle(),
-                                mSyncSurfaceControl->getSurface()->getNextFrameNumber() + 1);
-    });
-
-    {
-        SCOPED_TRACE("before any trigger");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->expectFGColor(96, 96);
-        sc->expectBGColor(160, 160);
-    }
-
-    // should trigger the first deferred transaction, but not the second one
-    fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-    {
-        SCOPED_TRACE("after first trigger");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->checkPixel(96, 96, 162, 63, 96);
-        sc->expectBGColor(160, 160);
-    }
-
-    // should show up immediately since it's not deferred
-    asTransaction([&](Transaction& t) { t.setAlpha(mFGSurfaceControl, 1.0); });
-
-    // trigger the second deferred transaction
-    fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-    {
-        SCOPED_TRACE("after second trigger");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->expectBGColor(96, 96);
-        sc->expectFGColor(160, 160);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerWithNoBuffersResizesImmediately) {
-    sp<ScreenCapture> sc;
-
-    sp<SurfaceControl> childNoBuffer =
-            mComposerClient->createSurface(String8("Bufferless child"), 10, 10,
-                                           PIXEL_FORMAT_RGBA_8888, 0, mFGSurfaceControl.get());
-    sp<SurfaceControl> childBuffer =
-            mComposerClient->createSurface(String8("Buffered child"), 20, 20,
-                                           PIXEL_FORMAT_RGBA_8888, 0, childNoBuffer.get());
-    fillSurfaceRGBA8(childBuffer, 200, 200, 200);
-
-    SurfaceComposerClient::Transaction{}.show(childNoBuffer).show(childBuffer).apply(true);
-
-    {
-        ScreenCapture::captureScreen(&sc);
-        sc->expectChildColor(73, 73);
-        sc->expectFGColor(74, 74);
-    }
-
-    SurfaceComposerClient::Transaction{}.setSize(childNoBuffer, 20, 20).apply(true);
-
-    {
-        ScreenCapture::captureScreen(&sc);
-        sc->expectChildColor(73, 73);
-        sc->expectChildColor(74, 74);
-    }
-}
-
-TEST_F(LayerUpdateTest, MergingTransactions) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before move");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(0, 12);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    Transaction t1, t2;
-    t1.setPosition(mFGSurfaceControl, 128, 128);
-    t2.setPosition(mFGSurfaceControl, 0, 0);
-    // We expect that the position update from t2 now
-    // overwrites the position update from t1.
-    t1.merge(std::move(t2));
-    t1.apply();
-
-    {
-        ScreenCapture::captureScreen(&sc);
-        sc->expectFGColor(1, 1);
-    }
-}
-
-class ChildLayerTest : public LayerUpdateTest {
-protected:
-    void SetUp() override {
-        LayerUpdateTest::SetUp();
-        mChild = mComposerClient->createSurface(String8("Child surface"), 10, 10,
-                                                PIXEL_FORMAT_RGBA_8888, 0, mFGSurfaceControl.get());
-        fillSurfaceRGBA8(mChild, 200, 200, 200);
-
-        {
-            SCOPED_TRACE("before anything");
-            ScreenCapture::captureScreen(&mCapture);
-            mCapture->expectChildColor(64, 64);
-        }
-    }
-    void TearDown() override {
-        LayerUpdateTest::TearDown();
-        mChild = 0;
-    }
-
-    sp<SurfaceControl> mChild;
-    sp<ScreenCapture> mCapture;
-};
-
-TEST_F(ChildLayerTest, ChildLayerPositioning) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 10, 10);
-        t.setPosition(mFGSurfaceControl, 64, 64);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-
-    asTransaction([&](Transaction& t) { t.setPosition(mFGSurfaceControl, 0, 0); });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground should now be at 0, 0
-        mCapture->expectFGColor(0, 0);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(10, 10);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(20, 20);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerCropping) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 0, 0);
-        t.setPosition(mFGSurfaceControl, 0, 0);
-        t.setCrop(mFGSurfaceControl, Rect(0, 0, 5, 5));
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectChildColor(4, 4);
-        mCapture->expectBGColor(5, 5);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerFinalCropping) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 0, 0);
-        t.setPosition(mFGSurfaceControl, 0, 0);
-        t.setFinalCrop(mFGSurfaceControl, Rect(0, 0, 5, 5));
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectChildColor(4, 4);
-        mCapture->expectBGColor(5, 5);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerConstraints) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mFGSurfaceControl, 0, 0);
-        t.setPosition(mChild, 63, 63);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(0, 0);
-        // Last pixel in foreground should now be the child.
-        mCapture->expectChildColor(63, 63);
-        // But the child should be constrained and the next pixel
-        // must be the background
-        mCapture->expectBGColor(64, 64);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerScaling) {
-    asTransaction([&](Transaction& t) { t.setPosition(mFGSurfaceControl, 0, 0); });
-
-    // Find the boundary between the parent and child
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(9, 9);
-        mCapture->expectFGColor(10, 10);
-    }
-
-    asTransaction([&](Transaction& t) { t.setMatrix(mFGSurfaceControl, 2.0, 0, 0, 2.0); });
-
-    // The boundary should be twice as far from the origin now.
-    // The pixels from the last test should all be child now
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(9, 9);
-        mCapture->expectChildColor(10, 10);
-        mCapture->expectChildColor(19, 19);
-        mCapture->expectFGColor(20, 20);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerAlpha) {
-    fillSurfaceRGBA8(mBGSurfaceControl, 0, 0, 254);
-    fillSurfaceRGBA8(mFGSurfaceControl, 254, 0, 0);
-    fillSurfaceRGBA8(mChild, 0, 254, 0);
-    waitForPostedBuffers();
-
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 0, 0);
-        t.setPosition(mFGSurfaceControl, 0, 0);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Unblended child color
-        mCapture->checkPixel(0, 0, 0, 254, 0);
-    }
-
-    asTransaction([&](Transaction& t) { t.setAlpha(mChild, 0.5); });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Child and BG blended.
-        mCapture->checkPixel(0, 0, 127, 127, 0);
-    }
-
-    asTransaction([&](Transaction& t) { t.setAlpha(mFGSurfaceControl, 0.5); });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Child and BG blended.
-        mCapture->checkPixel(0, 0, 95, 64, 95);
-    }
-}
-
-TEST_F(ChildLayerTest, ReparentChildren) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 10, 10);
-        t.setPosition(mFGSurfaceControl, 64, 64);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-
-    asTransaction([&](Transaction& t) {
-        t.reparentChildren(mFGSurfaceControl, mBGSurfaceControl->getHandle());
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(64, 64);
-        // In reparenting we should have exposed the entire foreground surface.
-        mCapture->expectFGColor(74, 74);
-        // And the child layer should now begin at 10, 10 (since the BG
-        // layer is at (0, 0)).
-        mCapture->expectBGColor(9, 9);
-        mCapture->expectChildColor(10, 10);
-    }
-}
-
-TEST_F(ChildLayerTest, DetachChildrenSameClient) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 10, 10);
-        t.setPosition(mFGSurfaceControl, 64, 64);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-
-    asTransaction([&](Transaction& t) { t.detachChildren(mFGSurfaceControl); });
-
-    asTransaction([&](Transaction& t) { t.hide(mChild); });
-
-    // Since the child has the same client as the parent, it will not get
-    // detached and will be hidden.
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(64, 64);
-        mCapture->expectFGColor(74, 74);
-        mCapture->expectFGColor(84, 84);
-    }
-}
-
-TEST_F(ChildLayerTest, DetachChildrenDifferentClient) {
-    sp<SurfaceComposerClient> mNewComposerClient = new SurfaceComposerClient;
-    sp<SurfaceControl> mChildNewClient =
-            mNewComposerClient->createSurface(String8("New Child Test Surface"), 10, 10,
-                                              PIXEL_FORMAT_RGBA_8888, 0, mFGSurfaceControl.get());
-
-    ASSERT_TRUE(mChildNewClient != nullptr);
-    ASSERT_TRUE(mChildNewClient->isValid());
-
-    fillSurfaceRGBA8(mChildNewClient, 200, 200, 200);
-
-    asTransaction([&](Transaction& t) {
-        t.hide(mChild);
-        t.show(mChildNewClient);
-        t.setPosition(mChildNewClient, 10, 10);
-        t.setPosition(mFGSurfaceControl, 64, 64);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-
-    asTransaction([&](Transaction& t) { t.detachChildren(mFGSurfaceControl); });
-
-    asTransaction([&](Transaction& t) { t.hide(mChildNewClient); });
-
-    // Nothing should have changed.
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(64, 64);
-        mCapture->expectChildColor(74, 74);
-        mCapture->expectFGColor(84, 84);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildrenInheritNonTransformScalingFromParent) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 0, 0);
-        t.setPosition(mFGSurfaceControl, 0, 0);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // We've positioned the child in the top left.
-        mCapture->expectChildColor(0, 0);
-        // But it's only 10x10.
-        mCapture->expectFGColor(10, 10);
-    }
-
-    asTransaction([&](Transaction& t) {
-        t.setOverrideScalingMode(mFGSurfaceControl, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
-        // We cause scaling by 2.
-        t.setSize(mFGSurfaceControl, 128, 128);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // We've positioned the child in the top left.
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectChildColor(10, 10);
-        mCapture->expectChildColor(19, 19);
-        // And now it should be scaled all the way to 20x20
-        mCapture->expectFGColor(20, 20);
-    }
-}
-
-// Regression test for b/37673612
-TEST_F(ChildLayerTest, ChildrenWithParentBufferTransform) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 0, 0);
-        t.setPosition(mFGSurfaceControl, 0, 0);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // We've positioned the child in the top left.
-        mCapture->expectChildColor(0, 0);
-        // But it's only 10x10.
-        mCapture->expectFGColor(10, 10);
-    }
-    // We set things up as in b/37673612 so that there is a mismatch between the buffer size and
-    // the WM specified state size.
-    asTransaction([&](Transaction& t) { t.setSize(mFGSurfaceControl, 128, 64); });
-    sp<Surface> s = mFGSurfaceControl->getSurface();
-    auto anw = static_cast<ANativeWindow*>(s.get());
-    native_window_set_buffers_transform(anw, NATIVE_WINDOW_TRANSFORM_ROT_90);
-    native_window_set_buffers_dimensions(anw, 64, 128);
-    fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63);
-    waitForPostedBuffers();
-
-    {
-        // The child should still be in the same place and not have any strange scaling as in
-        // b/37673612.
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectFGColor(10, 10);
-    }
-}
-
-TEST_F(ChildLayerTest, Bug36858924) {
-    // Destroy the child layer
-    mChild.clear();
-
-    // Now recreate it as hidden
-    mChild = mComposerClient->createSurface(String8("Child surface"), 10, 10,
-                                            PIXEL_FORMAT_RGBA_8888, ISurfaceComposerClient::eHidden,
-                                            mFGSurfaceControl.get());
-
-    // Show the child layer in a deferred transaction
-    asTransaction([&](Transaction& t) {
-        t.deferTransactionUntil(mChild, mFGSurfaceControl->getHandle(),
-                                mFGSurfaceControl->getSurface()->getNextFrameNumber());
-        t.show(mChild);
-    });
-
-    // Render the foreground surface a few times
-    //
-    // Prior to the bugfix for b/36858924, this would usually hang while trying to fill the third
-    // frame because SurfaceFlinger would never process the deferred transaction and would therefore
-    // never acquire/release the first buffer
-    ALOGI("Filling 1");
-    fillSurfaceRGBA8(mFGSurfaceControl, 0, 255, 0);
-    ALOGI("Filling 2");
-    fillSurfaceRGBA8(mFGSurfaceControl, 0, 0, 255);
-    ALOGI("Filling 3");
-    fillSurfaceRGBA8(mFGSurfaceControl, 255, 0, 0);
-    ALOGI("Filling 4");
-    fillSurfaceRGBA8(mFGSurfaceControl, 0, 255, 0);
-}
-
-TEST_F(ChildLayerTest, Reparent) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 10, 10);
-        t.setPosition(mFGSurfaceControl, 64, 64);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-
-    asTransaction([&](Transaction& t) { t.reparent(mChild, mBGSurfaceControl->getHandle()); });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(64, 64);
-        // In reparenting we should have exposed the entire foreground surface.
-        mCapture->expectFGColor(74, 74);
-        // And the child layer should now begin at 10, 10 (since the BG
-        // layer is at (0, 0)).
-        mCapture->expectBGColor(9, 9);
-        mCapture->expectChildColor(10, 10);
-    }
-}
-
-TEST_F(ChildLayerTest, ReparentToNoParent) {
-    asTransaction([&](Transaction& t) {
-        t.show(mChild);
-        t.setPosition(mChild, 10, 10);
-        t.setPosition(mFGSurfaceControl, 64, 64);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-    asTransaction([&](Transaction& t) { t.reparent(mChild, nullptr); });
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Nothing should have changed.
-        mCapture->expectFGColor(64, 64);
-        mCapture->expectChildColor(74, 74);
-        mCapture->expectFGColor(84, 84);
-    }
-}
-
-TEST_F(ChildLayerTest, ReparentFromNoParent) {
-    sp<SurfaceControl> newSurface = mComposerClient->createSurface(String8("New Surface"), 10, 10,
-                                                                   PIXEL_FORMAT_RGBA_8888, 0);
-    ASSERT_TRUE(newSurface != nullptr);
-    ASSERT_TRUE(newSurface->isValid());
-
-    fillSurfaceRGBA8(newSurface, 63, 195, 63);
-    asTransaction([&](Transaction& t) {
-        t.hide(mChild);
-        t.show(newSurface);
-        t.setPosition(newSurface, 10, 10);
-        t.setLayer(newSurface, INT32_MAX - 2);
-        t.setPosition(mFGSurfaceControl, 64, 64);
-    });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // At 10, 10 we should see the new surface
-        mCapture->checkPixel(10, 10, 63, 195, 63);
-    }
-
-    asTransaction([&](Transaction& t) { t.reparent(newSurface, mFGSurfaceControl->getHandle()); });
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // newSurface will now be a child of mFGSurface so it will be 10, 10 offset from
-        // mFGSurface, putting it at 74, 74.
-        mCapture->expectFGColor(64, 64);
-        mCapture->checkPixel(74, 74, 63, 195, 63);
-        mCapture->expectFGColor(84, 84);
-    }
-}
-
-TEST_F(ChildLayerTest, NestedChildren) {
-    sp<SurfaceControl> grandchild =
-            mComposerClient->createSurface(String8("Grandchild surface"), 10, 10,
-                                           PIXEL_FORMAT_RGBA_8888, 0, mChild.get());
-    fillSurfaceRGBA8(grandchild, 50, 50, 50);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Expect the grandchild to begin at 64, 64 because it's a child of mChild layer
-        // which begins at 64, 64
-        mCapture->checkPixel(64, 64, 50, 50, 50);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerRelativeLayer) {
-    sp<SurfaceControl> relative = mComposerClient->createSurface(String8("Relative surface"), 128,
-                                                                 128, PIXEL_FORMAT_RGBA_8888, 0);
-    fillSurfaceRGBA8(relative, 255, 255, 255);
-
-    Transaction t;
-    t.setLayer(relative, INT32_MAX)
-            .setRelativeLayer(mChild, relative->getHandle(), 1)
-            .setPosition(mFGSurfaceControl, 0, 0)
-            .apply(true);
-
-    // We expect that the child should have been elevated above our
-    // INT_MAX layer even though it's not a child of it.
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectChildColor(9, 9);
-        mCapture->checkPixel(10, 10, 255, 255, 255);
-    }
-}
-
-class ScreenCaptureTest : public LayerUpdateTest {
-protected:
-    std::unique_ptr<ScreenCapture> mCapture;
-};
-
-TEST_F(ScreenCaptureTest, CaptureSingleLayer) {
-    auto bgHandle = mBGSurfaceControl->getHandle();
-    ScreenCapture::captureLayers(&mCapture, bgHandle);
-    mCapture->expectBGColor(0, 0);
-    // Doesn't capture FG layer which is at 64, 64
-    mCapture->expectBGColor(64, 64);
-}
-
-TEST_F(ScreenCaptureTest, CaptureLayerWithChild) {
-    auto fgHandle = mFGSurfaceControl->getHandle();
-
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-    fillSurfaceRGBA8(child, 200, 200, 200);
-
-    SurfaceComposerClient::Transaction().show(child).apply(true);
-
-    // Captures mFGSurfaceControl layer and its child.
-    ScreenCapture::captureLayers(&mCapture, fgHandle);
-    mCapture->expectFGColor(10, 10);
-    mCapture->expectChildColor(0, 0);
-}
-
-TEST_F(ScreenCaptureTest, CaptureLayerChildOnly) {
-    auto fgHandle = mFGSurfaceControl->getHandle();
-
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-    fillSurfaceRGBA8(child, 200, 200, 200);
-
-    SurfaceComposerClient::Transaction().show(child).apply(true);
-
-    // Captures mFGSurfaceControl's child
-    ScreenCapture::captureChildLayers(&mCapture, fgHandle);
-    mCapture->checkPixel(10, 10, 0, 0, 0);
-    mCapture->expectChildColor(0, 0);
-}
-
-TEST_F(ScreenCaptureTest, CaptureTransparent) {
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-
-    fillSurfaceRGBA8(child, 200, 200, 200);
-
-    SurfaceComposerClient::Transaction().show(child).apply(true);
-
-    auto childHandle = child->getHandle();
-
-    // Captures child
-    ScreenCapture::captureLayers(&mCapture, childHandle, {0, 0, 10, 20});
-    mCapture->expectColor(Rect(0, 0, 9, 9), {200, 200, 200, 255});
-    // Area outside of child's bounds is transparent.
-    mCapture->expectColor(Rect(0, 10, 9, 19), {0, 0, 0, 0});
-}
-
-TEST_F(ScreenCaptureTest, DontCaptureRelativeOutsideTree) {
-    auto fgHandle = mFGSurfaceControl->getHandle();
-
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-    sp<SurfaceControl> relative = mComposerClient->createSurface(String8("Relative surface"), 10,
-                                                                 10, PIXEL_FORMAT_RGBA_8888, 0);
-    fillSurfaceRGBA8(child, 200, 200, 200);
-    fillSurfaceRGBA8(relative, 100, 100, 100);
-
-    SurfaceComposerClient::Transaction()
-            .show(child)
-            // Set relative layer above fg layer so should be shown above when computing all layers.
-            .setRelativeLayer(relative, fgHandle, 1)
-            .show(relative)
-            .apply(true);
-
-    // Captures mFGSurfaceControl layer and its child. Relative layer shouldn't be captured.
-    ScreenCapture::captureLayers(&mCapture, fgHandle);
-    mCapture->expectFGColor(10, 10);
-    mCapture->expectChildColor(0, 0);
-}
-
-TEST_F(ScreenCaptureTest, CaptureRelativeInTree) {
-    auto fgHandle = mFGSurfaceControl->getHandle();
-
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-    sp<SurfaceControl> relative =
-            mComposerClient->createSurface(String8("Relative surface"), 10, 10,
-                                           PIXEL_FORMAT_RGBA_8888, 0, mFGSurfaceControl.get());
-    fillSurfaceRGBA8(child, 200, 200, 200);
-    fillSurfaceRGBA8(relative, 100, 100, 100);
-
-    SurfaceComposerClient::Transaction()
-            .show(child)
-            // Set relative layer below fg layer but relative to child layer so it should be shown
-            // above child layer.
-            .setLayer(relative, -1)
-            .setRelativeLayer(relative, child->getHandle(), 1)
-            .show(relative)
-            .apply(true);
-
-    // Captures mFGSurfaceControl layer and its children. Relative layer is a child of fg so its
-    // relative value should be taken into account, placing it above child layer.
-    ScreenCapture::captureLayers(&mCapture, fgHandle);
-    mCapture->expectFGColor(10, 10);
-    // Relative layer is showing on top of child layer
-    mCapture->expectColor(Rect(0, 0, 9, 9), {100, 100, 100, 255});
-}
-
-// In the following tests we verify successful skipping of a parent layer,
-// so we use the same verification logic and only change how we mutate
-// the parent layer to verify that various properties are ignored.
-class ScreenCaptureChildOnlyTest : public LayerUpdateTest {
-public:
-    void SetUp() override {
-        LayerUpdateTest::SetUp();
-
-        mChild =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                    0, mFGSurfaceControl.get());
-        fillSurfaceRGBA8(mChild, 200, 200, 200);
-
-        SurfaceComposerClient::Transaction().show(mChild).apply(true);
-    }
-
-    void verify() {
-        auto fgHandle = mFGSurfaceControl->getHandle();
-        ScreenCapture::captureChildLayers(&mCapture, fgHandle);
-        mCapture->checkPixel(10, 10, 0, 0, 0);
-        mCapture->expectChildColor(0, 0);
-    }
-
-    std::unique_ptr<ScreenCapture> mCapture;
-    sp<SurfaceControl> mChild;
-};
-
-TEST_F(ScreenCaptureChildOnlyTest, CaptureLayerIgnoresParentVisibility) {
-
-    SurfaceComposerClient::Transaction().hide(mFGSurfaceControl).apply(true);
-
-    // Even though the parent is hidden we should still capture the child.
-    verify();
-}
-
-TEST_F(ScreenCaptureChildOnlyTest, CaptureLayerIgnoresParentCrop) {
-
-    SurfaceComposerClient::Transaction().setCrop(mFGSurfaceControl, Rect(0, 0, 1, 1)).apply(true);
-
-    // Even though the parent is cropped out we should still capture the child.
-    verify();
-}
-
-TEST_F(ScreenCaptureChildOnlyTest, CaptureLayerIgnoresTransform) {
-
-    SurfaceComposerClient::Transaction().setMatrix(mFGSurfaceControl, 2, 0, 0, 2);
-
-    // We should not inherit the parent scaling.
-    verify();
-}
-
-TEST_F(ScreenCaptureChildOnlyTest, RegressionTest76099859) {
-    SurfaceComposerClient::Transaction().hide(mFGSurfaceControl).apply(true);
-
-    // Even though the parent is hidden we should still capture the child.
-    verify();
-
-    // Verify everything was properly hidden when rendering the full-screen.
-    screenshot()->expectBGColor(0,0);
-}
-
-
-TEST_F(ScreenCaptureTest, CaptureLayerWithGrandchild) {
-    auto fgHandle = mFGSurfaceControl->getHandle();
-
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-    fillSurfaceRGBA8(child, 200, 200, 200);
-
-    sp<SurfaceControl> grandchild =
-            mComposerClient->createSurface(String8("Grandchild surface"), 5, 5,
-                                           PIXEL_FORMAT_RGBA_8888, 0, child.get());
-
-    fillSurfaceRGBA8(grandchild, 50, 50, 50);
-    SurfaceComposerClient::Transaction()
-            .show(child)
-            .setPosition(grandchild, 5, 5)
-            .show(grandchild)
-            .apply(true);
-
-    // Captures mFGSurfaceControl, its child, and the grandchild.
-    ScreenCapture::captureLayers(&mCapture, fgHandle);
-    mCapture->expectFGColor(10, 10);
-    mCapture->expectChildColor(0, 0);
-    mCapture->checkPixel(5, 5, 50, 50, 50);
-}
-
-TEST_F(ScreenCaptureTest, CaptureChildOnly) {
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-    fillSurfaceRGBA8(child, 200, 200, 200);
-    auto childHandle = child->getHandle();
-
-    SurfaceComposerClient::Transaction().setPosition(child, 5, 5).show(child).apply(true);
-
-    // Captures only the child layer, and not the parent.
-    ScreenCapture::captureLayers(&mCapture, childHandle);
-    mCapture->expectChildColor(0, 0);
-    mCapture->expectChildColor(9, 9);
-}
-
-TEST_F(ScreenCaptureTest, CaptureGrandchildOnly) {
-    sp<SurfaceControl> child =
-            mComposerClient->createSurface(String8("Child surface"), 10, 10, PIXEL_FORMAT_RGBA_8888,
-                                           0, mFGSurfaceControl.get());
-    fillSurfaceRGBA8(child, 200, 200, 200);
-    auto childHandle = child->getHandle();
-
-    sp<SurfaceControl> grandchild =
-            mComposerClient->createSurface(String8("Grandchild surface"), 5, 5,
-                                           PIXEL_FORMAT_RGBA_8888, 0, child.get());
-    fillSurfaceRGBA8(grandchild, 50, 50, 50);
-
-    SurfaceComposerClient::Transaction()
-            .show(child)
-            .setPosition(grandchild, 5, 5)
-            .show(grandchild)
-            .apply(true);
-
-    auto grandchildHandle = grandchild->getHandle();
-
-    // Captures only the grandchild.
-    ScreenCapture::captureLayers(&mCapture, grandchildHandle);
-    mCapture->checkPixel(0, 0, 50, 50, 50);
-    mCapture->checkPixel(4, 4, 50, 50, 50);
-}
-
-TEST_F(ScreenCaptureTest, CaptureCrop) {
-    sp<SurfaceControl> redLayer = mComposerClient->createSurface(String8("Red surface"), 60, 60,
-                                                                 PIXEL_FORMAT_RGBA_8888, 0);
-    sp<SurfaceControl> blueLayer =
-            mComposerClient->createSurface(String8("Blue surface"), 30, 30, PIXEL_FORMAT_RGBA_8888,
-                                           0, redLayer.get());
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(redLayer, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(blueLayer, Color::BLUE));
-
-    SurfaceComposerClient::Transaction()
-            .setLayer(redLayer, INT32_MAX - 1)
-            .show(redLayer)
-            .show(blueLayer)
-            .apply(true);
-
-    auto redLayerHandle = redLayer->getHandle();
-
-    // Capturing full screen should have both red and blue are visible.
-    ScreenCapture::captureLayers(&mCapture, redLayerHandle);
-    mCapture->expectColor(Rect(0, 0, 29, 29), Color::BLUE);
-    // red area below the blue area
-    mCapture->expectColor(Rect(0, 30, 59, 59), Color::RED);
-    // red area to the right of the blue area
-    mCapture->expectColor(Rect(30, 0, 59, 59), Color::RED);
-
-    Rect crop = Rect(0, 0, 30, 30);
-    ScreenCapture::captureLayers(&mCapture, redLayerHandle, crop);
-    // Capturing the cropped screen, cropping out the shown red area, should leave only the blue
-    // area visible.
-    mCapture->expectColor(Rect(0, 0, 29, 29), Color::BLUE);
-    mCapture->checkPixel(30, 30, 0, 0, 0);
-}
-
-TEST_F(ScreenCaptureTest, CaptureSize) {
-    sp<SurfaceControl> redLayer = mComposerClient->createSurface(String8("Red surface"), 60, 60,
-                                                                 PIXEL_FORMAT_RGBA_8888, 0);
-    sp<SurfaceControl> blueLayer =
-            mComposerClient->createSurface(String8("Blue surface"), 30, 30, PIXEL_FORMAT_RGBA_8888,
-                                           0, redLayer.get());
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(redLayer, Color::RED));
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(blueLayer, Color::BLUE));
-
-    SurfaceComposerClient::Transaction()
-            .setLayer(redLayer, INT32_MAX - 1)
-            .show(redLayer)
-            .show(blueLayer)
-            .apply(true);
-
-    auto redLayerHandle = redLayer->getHandle();
-
-    // Capturing full screen should have both red and blue are visible.
-    ScreenCapture::captureLayers(&mCapture, redLayerHandle);
-    mCapture->expectColor(Rect(0, 0, 29, 29), Color::BLUE);
-    // red area below the blue area
-    mCapture->expectColor(Rect(0, 30, 59, 59), Color::RED);
-    // red area to the right of the blue area
-    mCapture->expectColor(Rect(30, 0, 59, 59), Color::RED);
-
-    ScreenCapture::captureLayers(&mCapture, redLayerHandle, Rect::EMPTY_RECT, 0.5);
-    // Capturing the downsized area (30x30) should leave both red and blue but in a smaller area.
-    mCapture->expectColor(Rect(0, 0, 14, 14), Color::BLUE);
-    // red area below the blue area
-    mCapture->expectColor(Rect(0, 15, 29, 29), Color::RED);
-    // red area to the right of the blue area
-    mCapture->expectColor(Rect(15, 0, 29, 29), Color::RED);
-    mCapture->checkPixel(30, 30, 0, 0, 0);
-}
-
-TEST_F(ScreenCaptureTest, CaptureInvalidLayer) {
-    sp<SurfaceControl> redLayer = mComposerClient->createSurface(String8("Red surface"), 60, 60,
-                                                                 PIXEL_FORMAT_RGBA_8888, 0);
-
-    ASSERT_NO_FATAL_FAILURE(fillLayerColor(redLayer, Color::RED));
-
-    auto redLayerHandle = redLayer->getHandle();
-    mComposerClient->destroySurface(redLayerHandle);
-    SurfaceComposerClient::Transaction().apply(true);
-
-    sp<GraphicBuffer> outBuffer;
-
-    // Layer was deleted so captureLayers should fail with NAME_NOT_FOUND
-    sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-    ASSERT_EQ(NAME_NOT_FOUND, sf->captureLayers(redLayerHandle, &outBuffer, Rect::EMPTY_RECT, 1.0));
-}
-
-
-class DereferenceSurfaceControlTest : public LayerTransactionTest {
-protected:
-    void SetUp() override {
-        LayerTransactionTest::SetUp();
-        bgLayer = createLayer("BG layer", 20, 20);
-        fillLayerColor(bgLayer, Color::RED);
-        fgLayer = createLayer("FG layer", 20, 20);
-        fillLayerColor(fgLayer, Color::BLUE);
-        Transaction().setLayer(fgLayer, mLayerZBase + 1).apply();
-        {
-            SCOPED_TRACE("before anything");
-            auto shot = screenshot();
-            shot->expectColor(Rect(0, 0, 20, 20), Color::BLUE);
-        }
-    }
-    void TearDown() override {
-        LayerTransactionTest::TearDown();
-        bgLayer = 0;
-        fgLayer = 0;
-    }
-
-    sp<SurfaceControl> bgLayer;
-    sp<SurfaceControl> fgLayer;
-};
-
-TEST_F(DereferenceSurfaceControlTest, LayerNotInTransaction) {
-    fgLayer = nullptr;
-    {
-        SCOPED_TRACE("after setting null");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 20, 20), Color::RED);
-    }
-}
-
-TEST_F(DereferenceSurfaceControlTest, LayerInTransaction) {
-    auto transaction = Transaction().show(fgLayer);
-    fgLayer = nullptr;
-    {
-        SCOPED_TRACE("after setting null");
-        auto shot = screenshot();
-        shot->expectColor(Rect(0, 0, 20, 20), Color::BLUE);
-    }
-}
-
-} // namespace android
diff --git a/services/surfaceflinger/tests/fakehwc/Android.bp b/services/surfaceflinger/tests/fakehwc/Android.bp
deleted file mode 100644
index 520df2d63..000000000
--- a/services/surfaceflinger/tests/fakehwc/Android.bp
+++ /dev/null
@@ -1,41 +0,0 @@
-cc_test {
-    name: "sffakehwc_test",
-    defaults: ["surfaceflinger_defaults"],
-    tags: ["test"],
-    test_suites: ["device-tests"],
-    srcs: [
-         "FakeComposerClient.cpp",
-         "FakeComposerService.cpp",
-         "FakeComposerUtils.cpp",
-         "SFFakeHwc_test.cpp"
-    ],
-    shared_libs: [
-        "android.hardware.graphics.composer@2.1",
-        "android.hardware.graphics.mapper@2.0",
-        "libbase",
-        "libbinder",
-        "libcutils",
-        "libfmq",
-        "libgui",
-        "libhardware",
-        "libhidlbase",
-        "libhidltransport",
-        "libhwbinder",
-        "liblayers_proto",
-        "liblog",
-        "libnativewindow",
-        "libsync",
-        "libtimestats_proto",
-        "libui",
-        "libutils",
-    ],
-    static_libs: [
-        "libtrace_proto",
-        "libgmock"
-    ],
-    header_libs: [
-        "android.hardware.graphics.composer@2.1-command-buffer",
-        "android.hardware.graphics.composer@2.1-hal",
-        "libsurfaceflinger_headers",
-    ],
-}
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp b/services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp
deleted file mode 100644
index 973156a7c..000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp
+++ /dev/null
@@ -1,619 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//#define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeComposer"
-
-#include "FakeComposerClient.h"
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <log/log.h>
-
-#include <gtest/gtest.h>
-
-#include <inttypes.h>
-#include <time.h>
-#include <algorithm>
-#include <condition_variable>
-#include <iostream>
-#include <mutex>
-#include <set>
-#include <thread>
-
-constexpr Config NULL_DISPLAY_CONFIG = static_cast<Config>(0);
-
-using namespace sftest;
-
-using android::Condition;
-using android::Mutex;
-
-using Clock = std::chrono::steady_clock;
-using TimePoint = std::chrono::time_point<Clock>;
-
-namespace {
-
-// Internal state of a layer in the HWC API.
-class LayerImpl {
-public:
-    LayerImpl() = default;
-
-    bool mValid = true;
-    RenderState mRenderState;
-    uint32_t mZ = 0;
-};
-
-// Struct for storing per frame rectangle state. Contains the render
-// state shared to the test case. Basically a snapshot and a subset of
-// LayerImpl sufficient to re-create the pixels of a layer for the
-// frame.
-struct FrameRect {
-public:
-    FrameRect(Layer layer_, const RenderState& state, uint32_t z_)
-          : layer(layer_), renderState(state), z(z_) {}
-
-    const Layer layer;
-    const RenderState renderState;
-    const uint32_t z;
-};
-
-// Collection of FrameRects forming one rendered frame. Could store
-// related fences and other data in the future.
-class Frame {
-public:
-    Frame() = default;
-    std::vector<std::unique_ptr<FrameRect>> rectangles;
-};
-
-class DelayedEventGenerator {
-public:
-    DelayedEventGenerator(std::function<void()> onTimerExpired)
-          : mOnTimerExpired(onTimerExpired), mThread([this]() { loop(); }) {}
-
-    ~DelayedEventGenerator() {
-        ALOGI("DelayedEventGenerator exiting.");
-        {
-            std::unique_lock<std::mutex> lock(mMutex);
-            mRunning = false;
-            mWakeups.clear();
-            mCondition.notify_one();
-        }
-        mThread.join();
-        ALOGI("DelayedEventGenerator exited.");
-    }
-
-    void wakeAfter(std::chrono::nanoseconds waitTime) {
-        std::unique_lock<std::mutex> lock(mMutex);
-        mWakeups.insert(Clock::now() + waitTime);
-        mCondition.notify_one();
-    }
-
-private:
-    void loop() {
-        while (true) {
-            // Lock scope
-            {
-                std::unique_lock<std::mutex> lock(mMutex);
-                mCondition.wait(lock, [this]() { return !mRunning || !mWakeups.empty(); });
-                if (!mRunning && mWakeups.empty()) {
-                    // This thread should only exit once the destructor has been called and all
-                    // wakeups have been processed
-                    return;
-                }
-
-                // At this point, mWakeups will not be empty
-
-                TimePoint target = *(mWakeups.begin());
-                auto status = mCondition.wait_until(lock, target);
-                while (status == std::cv_status::no_timeout) {
-                    // This was either a spurious wakeup or another wakeup was added, so grab the
-                    // oldest point and wait again
-                    target = *(mWakeups.begin());
-                    status = mCondition.wait_until(lock, target);
-                }
-
-                // status must have been timeout, so we can finally clear this point
-                mWakeups.erase(target);
-            }
-            // Callback *without* locks!
-            mOnTimerExpired();
-        }
-    }
-
-    std::function<void()> mOnTimerExpired;
-    std::thread mThread;
-    std::mutex mMutex;
-    std::condition_variable mCondition;
-    bool mRunning = true;
-    std::set<TimePoint> mWakeups;
-};
-
-} // namespace
-
-FakeComposerClient::FakeComposerClient()
-      : mEventCallback(nullptr),
-        mCurrentConfig(NULL_DISPLAY_CONFIG),
-        mVsyncEnabled(false),
-        mLayers(),
-        mDelayedEventGenerator(
-                std::make_unique<DelayedEventGenerator>([this]() { this->requestVSync(); })),
-        mSurfaceComposer(nullptr) {}
-
-FakeComposerClient::~FakeComposerClient() {}
-
-bool FakeComposerClient::hasCapability(hwc2_capability_t /*capability*/) {
-    return false;
-}
-
-std::string FakeComposerClient::dumpDebugInfo() {
-    return {};
-}
-
-void FakeComposerClient::registerEventCallback(EventCallback* callback) {
-    ALOGV("registerEventCallback");
-    mEventCallback = callback;
-    if (mEventCallback) {
-        mEventCallback->onHotplug(PRIMARY_DISPLAY, IComposerCallback::Connection::CONNECTED);
-    }
-}
-
-void FakeComposerClient::unregisterEventCallback() {
-    ALOGV("unregisterEventCallback");
-    mEventCallback = nullptr;
-}
-
-void FakeComposerClient::hotplugDisplay(Display display, IComposerCallback::Connection state) {
-    if (mEventCallback) {
-        mEventCallback->onHotplug(display, state);
-    }
-}
-
-void FakeComposerClient::refreshDisplay(Display display) {
-    if (mEventCallback) {
-        mEventCallback->onRefresh(display);
-    }
-}
-
-uint32_t FakeComposerClient::getMaxVirtualDisplayCount() {
-    ALOGV("getMaxVirtualDisplayCount");
-    return 1;
-}
-
-Error FakeComposerClient::createVirtualDisplay(uint32_t /*width*/, uint32_t /*height*/,
-                                               PixelFormat* /*format*/, Display* /*outDisplay*/) {
-    ALOGV("createVirtualDisplay");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::destroyVirtualDisplay(Display /*display*/) {
-    ALOGV("destroyVirtualDisplay");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::createLayer(Display /*display*/, Layer* outLayer) {
-    ALOGV("createLayer");
-    *outLayer = mLayers.size();
-    auto newLayer = std::make_unique<LayerImpl>();
-    mLayers.push_back(std::move(newLayer));
-    return Error::NONE;
-}
-
-Error FakeComposerClient::destroyLayer(Display /*display*/, Layer layer) {
-    ALOGV("destroyLayer");
-    mLayers[layer]->mValid = false;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getActiveConfig(Display /*display*/, Config* outConfig) {
-    ALOGV("getActiveConfig");
-
-    // TODO Assert outConfig != nullptr
-
-    // TODO This is my reading of the
-    // IComposerClient::getActiveConfig, but returning BAD_CONFIG
-    // seems to not fit SurfaceFlinger plans. See version 2 below.
-    // if (mCurrentConfig == NULL_DISPLAY_CONFIG) {
-    //     return Error::BAD_CONFIG;
-    // }
-    //*outConfig = mCurrentConfig;
-    *outConfig = 1; // Very special config for you my friend
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getClientTargetSupport(Display /*display*/, uint32_t /*width*/,
-                                                 uint32_t /*height*/, PixelFormat /*format*/,
-                                                 Dataspace /*dataspace*/) {
-    ALOGV("getClientTargetSupport");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getColorModes(Display /*display*/, hidl_vec<ColorMode>* /*outModes*/) {
-    ALOGV("getColorModes");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayAttribute(Display display, Config config,
-                                              IComposerClient::Attribute attribute,
-                                              int32_t* outValue) {
-    ALOGV("getDisplayAttribute (%d, %d, %d, %p)", static_cast<int>(display),
-          static_cast<int>(config), static_cast<int>(attribute), outValue);
-
-    // TODO: SOOO much fun to be had with these alone
-    switch (attribute) {
-        case IComposerClient::Attribute::WIDTH:
-            *outValue = 1920;
-            break;
-        case IComposerClient::Attribute::HEIGHT:
-            *outValue = 1080;
-            break;
-        case IComposerClient::Attribute::VSYNC_PERIOD:
-            *outValue = 1666666666;
-            break; // TOOD: Tests break down if lowered to 16ms?
-        case IComposerClient::Attribute::DPI_X:
-            *outValue = 240;
-            break;
-        case IComposerClient::Attribute::DPI_Y:
-            *outValue = 240;
-            break;
-        default:
-            LOG_ALWAYS_FATAL("Say what!?! New attribute");
-    }
-
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayConfigs(Display /*display*/, hidl_vec<Config>* outConfigs) {
-    ALOGV("getDisplayConfigs");
-    // TODO assert display == 1, outConfigs != nullptr
-
-    outConfigs->resize(1);
-    (*outConfigs)[0] = 1;
-
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayName(Display /*display*/, hidl_string* /*outName*/) {
-    ALOGV("getDisplayName");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayType(Display /*display*/,
-                                         IComposerClient::DisplayType* outType) {
-    ALOGV("getDisplayType");
-    // TODO: This setting nothing on the output had no effect on initial trials. Is first display
-    // assumed to be physical?
-    *outType = static_cast<IComposerClient::DisplayType>(HWC2_DISPLAY_TYPE_PHYSICAL);
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDozeSupport(Display /*display*/, bool* /*outSupport*/) {
-    ALOGV("getDozeSupport");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getHdrCapabilities(Display /*display*/, hidl_vec<Hdr>* /*outTypes*/,
-                                             float* /*outMaxLuminance*/,
-                                             float* /*outMaxAverageLuminance*/,
-                                             float* /*outMinLuminance*/) {
-    ALOGV("getHdrCapabilities");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setActiveConfig(Display /*display*/, Config config) {
-    ALOGV("setActiveConfig");
-    mCurrentConfig = config;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setColorMode(Display /*display*/, ColorMode /*mode*/) {
-    ALOGV("setColorMode");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setPowerMode(Display /*display*/, IComposerClient::PowerMode /*mode*/) {
-    ALOGV("setPowerMode");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setVsyncEnabled(Display /*display*/, IComposerClient::Vsync enabled) {
-    mVsyncEnabled = (enabled == IComposerClient::Vsync::ENABLE);
-    ALOGV("setVsyncEnabled(%s)", mVsyncEnabled ? "ENABLE" : "DISABLE");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setColorTransform(Display /*display*/, const float* /*matrix*/,
-                                            int32_t /*hint*/) {
-    ALOGV("setColorTransform");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setClientTarget(Display /*display*/, buffer_handle_t /*target*/,
-                                          int32_t /*acquireFence*/, int32_t /*dataspace*/,
-                                          const std::vector<hwc_rect_t>& /*damage*/) {
-    ALOGV("setClientTarget");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setOutputBuffer(Display /*display*/, buffer_handle_t /*buffer*/,
-                                          int32_t /*releaseFence*/) {
-    ALOGV("setOutputBuffer");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::validateDisplay(
-        Display /*display*/, std::vector<Layer>* /*outChangedLayers*/,
-        std::vector<IComposerClient::Composition>* /*outCompositionTypes*/,
-        uint32_t* /*outDisplayRequestMask*/, std::vector<Layer>* /*outRequestedLayers*/,
-        std::vector<uint32_t>* /*outRequestMasks*/) {
-    ALOGV("validateDisplay");
-    // TODO: Assume touching nothing means All Korrekt!
-    return Error::NONE;
-}
-
-Error FakeComposerClient::acceptDisplayChanges(Display /*display*/) {
-    ALOGV("acceptDisplayChanges");
-    // Didn't ask for changes because software is omnipotent.
-    return Error::NONE;
-}
-
-bool layerZOrdering(const std::unique_ptr<FrameRect>& a, const std::unique_ptr<FrameRect>& b) {
-    return a->z <= b->z;
-}
-
-Error FakeComposerClient::presentDisplay(Display /*display*/, int32_t* /*outPresentFence*/,
-                                         std::vector<Layer>* /*outLayers*/,
-                                         std::vector<int32_t>* /*outReleaseFences*/) {
-    ALOGV("presentDisplay");
-    // TODO Leaving layers and their fences out for now. Doing so
-    // means that we've already processed everything. Important to
-    // test that the fences are respected, though. (How?)
-
-    std::unique_ptr<Frame> newFrame(new Frame);
-    for (uint64_t layer = 0; layer < mLayers.size(); layer++) {
-        const LayerImpl& layerImpl = *mLayers[layer];
-
-        if (!layerImpl.mValid) continue;
-
-        auto rect = std::make_unique<FrameRect>(layer, layerImpl.mRenderState, layerImpl.mZ);
-        newFrame->rectangles.push_back(std::move(rect));
-    }
-    std::sort(newFrame->rectangles.begin(), newFrame->rectangles.end(), layerZOrdering);
-    {
-        Mutex::Autolock _l(mStateMutex);
-        mFrames.push_back(std::move(newFrame));
-        mFramesAvailable.broadcast();
-    }
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerCursorPosition(Display /*display*/, Layer /*layer*/,
-                                                 int32_t /*x*/, int32_t /*y*/) {
-    ALOGV("setLayerCursorPosition");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerBuffer(Display /*display*/, Layer layer, buffer_handle_t buffer,
-                                         int32_t acquireFence) {
-    ALOGV("setLayerBuffer");
-    LayerImpl& l = getLayerImpl(layer);
-    if (buffer != l.mRenderState.mBuffer) {
-        l.mRenderState.mSwapCount++; // TODO: Is setting to same value a swap or not?
-    }
-    l.mRenderState.mBuffer = buffer;
-    l.mRenderState.mAcquireFence = acquireFence;
-
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerSurfaceDamage(Display /*display*/, Layer /*layer*/,
-                                                const std::vector<hwc_rect_t>& /*damage*/) {
-    ALOGV("setLayerSurfaceDamage");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerBlendMode(Display /*display*/, Layer layer, int32_t mode) {
-    ALOGV("setLayerBlendMode");
-    getLayerImpl(layer).mRenderState.mBlendMode = static_cast<hwc2_blend_mode_t>(mode);
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerColor(Display /*display*/, Layer layer,
-                                        IComposerClient::Color color) {
-    ALOGV("setLayerColor");
-    getLayerImpl(layer).mRenderState.mLayerColor.r = color.r;
-    getLayerImpl(layer).mRenderState.mLayerColor.g = color.g;
-    getLayerImpl(layer).mRenderState.mLayerColor.b = color.b;
-    getLayerImpl(layer).mRenderState.mLayerColor.a = color.a;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerCompositionType(Display /*display*/, Layer /*layer*/,
-                                                  int32_t /*type*/) {
-    ALOGV("setLayerCompositionType");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerDataspace(Display /*display*/, Layer /*layer*/,
-                                            int32_t /*dataspace*/) {
-    ALOGV("setLayerDataspace");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerDisplayFrame(Display /*display*/, Layer layer,
-                                               const hwc_rect_t& frame) {
-    ALOGV("setLayerDisplayFrame (%d, %d, %d, %d)", frame.left, frame.top, frame.right,
-          frame.bottom);
-    getLayerImpl(layer).mRenderState.mDisplayFrame = frame;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerPlaneAlpha(Display /*display*/, Layer layer, float alpha) {
-    ALOGV("setLayerPlaneAlpha");
-    getLayerImpl(layer).mRenderState.mPlaneAlpha = alpha;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerSidebandStream(Display /*display*/, Layer /*layer*/,
-                                                 buffer_handle_t /*stream*/) {
-    ALOGV("setLayerSidebandStream");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerSourceCrop(Display /*display*/, Layer layer,
-                                             const hwc_frect_t& crop) {
-    ALOGV("setLayerSourceCrop");
-    getLayerImpl(layer).mRenderState.mSourceCrop = crop;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerTransform(Display /*display*/, Layer layer, int32_t transform) {
-    ALOGV("setLayerTransform");
-    getLayerImpl(layer).mRenderState.mTransform = static_cast<hwc_transform_t>(transform);
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerVisibleRegion(Display /*display*/, Layer layer,
-                                                const std::vector<hwc_rect_t>& visible) {
-    ALOGV("setLayerVisibleRegion");
-    getLayerImpl(layer).mRenderState.mVisibleRegion = visible;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerZOrder(Display /*display*/, Layer layer, uint32_t z) {
-    ALOGV("setLayerZOrder");
-    getLayerImpl(layer).mZ = z;
-    return Error::NONE;
-}
-
-//////////////////////////////////////////////////////////////////
-
-void FakeComposerClient::requestVSync(uint64_t vsyncTime) {
-    if (mEventCallback) {
-        uint64_t timestamp = vsyncTime;
-        ALOGV("Vsync");
-        if (timestamp == 0) {
-            struct timespec ts;
-            clock_gettime(CLOCK_MONOTONIC, &ts);
-            timestamp = ts.tv_sec * 1000 * 1000 * 1000 + ts.tv_nsec;
-        }
-        if (mSurfaceComposer != nullptr) {
-            mSurfaceComposer->injectVSync(timestamp);
-        } else {
-            mEventCallback->onVsync(PRIMARY_DISPLAY, timestamp);
-        }
-    }
-}
-
-void FakeComposerClient::runVSyncAfter(std::chrono::nanoseconds wait) {
-    mDelayedEventGenerator->wakeAfter(wait);
-}
-
-LayerImpl& FakeComposerClient::getLayerImpl(Layer handle) {
-    // TODO Change these to an internal state check that can be
-    // invoked from the gtest? GTest macros do not seem all that safe
-    // when used outside the test class
-    EXPECT_GE(handle, static_cast<Layer>(0));
-    EXPECT_LT(handle, mLayers.size());
-    return *(mLayers[handle]);
-}
-
-int FakeComposerClient::getFrameCount() const {
-    return mFrames.size();
-}
-
-static std::vector<RenderState> extractRenderState(
-        const std::vector<std::unique_ptr<FrameRect>>& internalRects) {
-    std::vector<RenderState> result;
-    result.reserve(internalRects.size());
-    for (const std::unique_ptr<FrameRect>& rect : internalRects) {
-        result.push_back(rect->renderState);
-    }
-    return result;
-}
-
-std::vector<RenderState> FakeComposerClient::getFrameRects(int frame) const {
-    Mutex::Autolock _l(mStateMutex);
-    return extractRenderState(mFrames[frame]->rectangles);
-}
-
-std::vector<RenderState> FakeComposerClient::getLatestFrame() const {
-    Mutex::Autolock _l(mStateMutex);
-    return extractRenderState(mFrames[mFrames.size() - 1]->rectangles);
-}
-
-void FakeComposerClient::runVSyncAndWait(std::chrono::nanoseconds maxWait) {
-    int currentFrame = 0;
-    {
-        Mutex::Autolock _l(mStateMutex); // I hope this is ok...
-        currentFrame = static_cast<int>(mFrames.size());
-        requestVSync();
-    }
-    waitUntilFrame(currentFrame + 1, maxWait);
-}
-
-void FakeComposerClient::waitUntilFrame(int targetFrame, std::chrono::nanoseconds maxWait) const {
-    Mutex::Autolock _l(mStateMutex);
-    while (mFrames.size() < static_cast<size_t>(targetFrame)) {
-        android::status_t result = mFramesAvailable.waitRelative(mStateMutex, maxWait.count());
-        if (result == android::TIMED_OUT) {
-            ALOGE("Waiting for frame %d (at frame %zu now) timed out after %lld ns", targetFrame,
-                  mFrames.size(), maxWait.count());
-            return;
-        }
-    }
-}
-
-void FakeComposerClient::clearFrames() {
-    Mutex::Autolock _l(mStateMutex);
-    mFrames.clear();
-    for (const std::unique_ptr<LayerImpl>& layer : mLayers) {
-        if (layer->mValid) {
-            layer->mRenderState.mSwapCount = 0;
-        }
-    }
-}
-
-void FakeComposerClient::onSurfaceFlingerStart() {
-    mSurfaceComposer = nullptr;
-    do {
-        mSurfaceComposer = new android::SurfaceComposerClient;
-        android::status_t initResult = mSurfaceComposer->initCheck();
-        if (initResult != android::NO_ERROR) {
-            ALOGD("Init result: %d", initResult);
-            mSurfaceComposer = nullptr;
-            std::this_thread::sleep_for(10ms);
-        }
-    } while (mSurfaceComposer == nullptr);
-    ALOGD("SurfaceComposerClient created");
-    mSurfaceComposer->enableVSyncInjections(true);
-}
-
-void FakeComposerClient::onSurfaceFlingerStop() {
-    mSurfaceComposer->dispose();
-    mSurfaceComposer.clear();
-}
-
-// Includes destroyed layers, stored in order of creation.
-int FakeComposerClient::getLayerCount() const {
-    return mLayers.size();
-}
-
-Layer FakeComposerClient::getLayer(size_t index) const {
-    // NOTE: If/when passing calls through to actual implementation,
-    // this might get more involving.
-    return static_cast<Layer>(index);
-}
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.h b/services/surfaceflinger/tests/fakehwc/FakeComposerClient.h
deleted file mode 100644
index d115d79fd..000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#define HWC2_USE_CPP11
-#define HWC2_INCLUDE_STRINGIFICATION
-#include <composer-hal/2.1/ComposerClient.h>
-#undef HWC2_USE_CPP11
-#undef HWC2_INCLUDE_STRINGIFICATION
-#include "RenderState.h"
-
-// Needed for display type/ID enums
-#include <hardware/hwcomposer_defs.h>
-
-#include <utils/Condition.h>
-
-#include <chrono>
-
-using namespace android::hardware::graphics::composer::V2_1;
-using namespace android::hardware::graphics::composer::V2_1::hal;
-using namespace android::hardware;
-using namespace std::chrono_literals;
-
-namespace {
-class LayerImpl;
-class Frame;
-class DelayedEventGenerator;
-} // namespace
-
-namespace android {
-class SurfaceComposerClient;
-} // namespace android
-
-namespace sftest {
-
-// NOTE: The ID's need to be exactly these. VR composer and parts of
-// the SurfaceFlinger assume the display IDs to have these values
-// despite the enum being documented as a display type.
-// TODO: Reference to actual documentation
-constexpr Display PRIMARY_DISPLAY = static_cast<Display>(HWC_DISPLAY_PRIMARY);
-constexpr Display EXTERNAL_DISPLAY = static_cast<Display>(HWC_DISPLAY_EXTERNAL);
-
-class FakeComposerClient : public ComposerHal {
-public:
-    FakeComposerClient();
-    virtual ~FakeComposerClient();
-
-    bool hasCapability(hwc2_capability_t capability) override;
-
-    std::string dumpDebugInfo() override;
-    void registerEventCallback(EventCallback* callback) override;
-    void unregisterEventCallback() override;
-
-    uint32_t getMaxVirtualDisplayCount() override;
-    Error createVirtualDisplay(uint32_t width, uint32_t height, PixelFormat* format,
-                               Display* outDisplay) override;
-    Error destroyVirtualDisplay(Display display) override;
-    Error createLayer(Display display, Layer* outLayer) override;
-    Error destroyLayer(Display display, Layer layer) override;
-
-    Error getActiveConfig(Display display, Config* outConfig) override;
-    Error getClientTargetSupport(Display display, uint32_t width, uint32_t height,
-                                 PixelFormat format, Dataspace dataspace) override;
-    Error getColorModes(Display display, hidl_vec<ColorMode>* outModes) override;
-    Error getDisplayAttribute(Display display, Config config, IComposerClient::Attribute attribute,
-                              int32_t* outValue) override;
-    Error getDisplayConfigs(Display display, hidl_vec<Config>* outConfigs) override;
-    Error getDisplayName(Display display, hidl_string* outName) override;
-    Error getDisplayType(Display display, IComposerClient::DisplayType* outType) override;
-    Error getDozeSupport(Display display, bool* outSupport) override;
-    Error getHdrCapabilities(Display display, hidl_vec<Hdr>* outTypes, float* outMaxLuminance,
-                             float* outMaxAverageLuminance, float* outMinLuminance) override;
-
-    Error setActiveConfig(Display display, Config config) override;
-    Error setColorMode(Display display, ColorMode mode) override;
-    Error setPowerMode(Display display, IComposerClient::PowerMode mode) override;
-    Error setVsyncEnabled(Display display, IComposerClient::Vsync enabled) override;
-
-    Error setColorTransform(Display display, const float* matrix, int32_t hint) override;
-    Error setClientTarget(Display display, buffer_handle_t target, int32_t acquireFence,
-                          int32_t dataspace, const std::vector<hwc_rect_t>& damage) override;
-    Error setOutputBuffer(Display display, buffer_handle_t buffer, int32_t releaseFence) override;
-    Error validateDisplay(Display display, std::vector<Layer>* outChangedLayers,
-                          std::vector<IComposerClient::Composition>* outCompositionTypes,
-                          uint32_t* outDisplayRequestMask, std::vector<Layer>* outRequestedLayers,
-                          std::vector<uint32_t>* outRequestMasks) override;
-    Error acceptDisplayChanges(Display display) override;
-    Error presentDisplay(Display display, int32_t* outPresentFence, std::vector<Layer>* outLayers,
-                         std::vector<int32_t>* outReleaseFences) override;
-
-    Error setLayerCursorPosition(Display display, Layer layer, int32_t x, int32_t y) override;
-    Error setLayerBuffer(Display display, Layer layer, buffer_handle_t buffer,
-                         int32_t acquireFence) override;
-    Error setLayerSurfaceDamage(Display display, Layer layer,
-                                const std::vector<hwc_rect_t>& damage) override;
-    Error setLayerBlendMode(Display display, Layer layer, int32_t mode) override;
-    Error setLayerColor(Display display, Layer layer, IComposerClient::Color color) override;
-    Error setLayerCompositionType(Display display, Layer layer, int32_t type) override;
-    Error setLayerDataspace(Display display, Layer layer, int32_t dataspace) override;
-    Error setLayerDisplayFrame(Display display, Layer layer, const hwc_rect_t& frame) override;
-    Error setLayerPlaneAlpha(Display display, Layer layer, float alpha) override;
-    Error setLayerSidebandStream(Display display, Layer layer, buffer_handle_t stream) override;
-    Error setLayerSourceCrop(Display display, Layer layer, const hwc_frect_t& crop) override;
-    Error setLayerTransform(Display display, Layer layer, int32_t transform) override;
-    Error setLayerVisibleRegion(Display display, Layer layer,
-                                const std::vector<hwc_rect_t>& visible) override;
-    Error setLayerZOrder(Display display, Layer layer, uint32_t z) override;
-
-    void setClient(ComposerClient* client);
-
-    void requestVSync(uint64_t vsyncTime = 0);
-    // We don't want tests hanging, so always use a timeout. Remember
-    // to always check the number of frames with test ASSERT_!
-    // Wait until next frame is rendered after requesting vsync.
-    void runVSyncAndWait(std::chrono::nanoseconds maxWait = 100ms);
-    void runVSyncAfter(std::chrono::nanoseconds wait);
-
-    int getFrameCount() const;
-    // We don't want tests hanging, so always use a timeout. Remember
-    // to always check the number of frames with test ASSERT_!
-    void waitUntilFrame(int targetFrame, std::chrono::nanoseconds maxWait = 100ms) const;
-    std::vector<RenderState> getFrameRects(int frame) const;
-    std::vector<RenderState> getLatestFrame() const;
-    void clearFrames();
-
-    void onSurfaceFlingerStart();
-    void onSurfaceFlingerStop();
-
-    int getLayerCount() const;
-    Layer getLayer(size_t index) const;
-
-    void hotplugDisplay(Display display, IComposerCallback::Connection state);
-    void refreshDisplay(Display display);
-
-private:
-    LayerImpl& getLayerImpl(Layer handle);
-
-    EventCallback* mEventCallback;
-    Config mCurrentConfig;
-    bool mVsyncEnabled;
-    std::vector<std::unique_ptr<LayerImpl>> mLayers;
-    std::vector<std::unique_ptr<Frame>> mFrames;
-    // Using a pointer to hide the implementation into the CPP file.
-    std::unique_ptr<DelayedEventGenerator> mDelayedEventGenerator;
-    android::sp<android::SurfaceComposerClient> mSurfaceComposer; // For VSync injections
-    mutable android::Mutex mStateMutex;
-    mutable android::Condition mFramesAvailable;
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp b/services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp
deleted file mode 100644
index f70cbdbc6..000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeHwcService"
-#include <log/log.h>
-
-#include "FakeComposerService.h"
-
-using namespace android::hardware;
-
-namespace sftest {
-
-FakeComposerService::FakeComposerService(android::sp<ComposerClient>& client) : mClient(client) {}
-
-FakeComposerService::~FakeComposerService() {
-    ALOGI("Maybe killing client %p", mClient.get());
-    // Rely on sp to kill the client.
-}
-
-Return<void> FakeComposerService::getCapabilities(getCapabilities_cb hidl_cb) {
-    ALOGI("FakeComposerService::getCapabilities");
-    hidl_cb(hidl_vec<Capability>());
-    return Void();
-}
-
-Return<void> FakeComposerService::dumpDebugInfo(dumpDebugInfo_cb hidl_cb) {
-    ALOGI("FakeComposerService::dumpDebugInfo");
-    hidl_cb(hidl_string());
-    return Void();
-}
-
-Return<void> FakeComposerService::createClient(createClient_cb hidl_cb) {
-    ALOGI("FakeComposerService::createClient %p", mClient.get());
-    if (!mClient->init()) {
-        LOG_ALWAYS_FATAL("failed to initialize ComposerClient");
-    }
-    hidl_cb(Error::NONE, mClient);
-    return Void();
-}
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerService.h b/services/surfaceflinger/tests/fakehwc/FakeComposerService.h
deleted file mode 100644
index c439b7e3b..000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerService.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <composer-hal/2.1/ComposerClient.h>
-
-using namespace android::hardware::graphics::composer::V2_1;
-using namespace android::hardware::graphics::composer::V2_1::hal;
-using android::hardware::Return;
-
-namespace sftest {
-
-class FakeComposerService : public IComposer {
-public:
-    FakeComposerService(android::sp<ComposerClient>& client);
-    virtual ~FakeComposerService();
-
-    Return<void> getCapabilities(getCapabilities_cb hidl_cb) override;
-    Return<void> dumpDebugInfo(dumpDebugInfo_cb hidl_cb) override;
-    Return<void> createClient(createClient_cb hidl_cb) override;
-
-private:
-    android::sp<ComposerClient> mClient;
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp b/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp
deleted file mode 100644
index 51956ec97..000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeHwcUtil"
-#include <log/log.h>
-
-#include "FakeComposerUtils.h"
-#include "RenderState.h"
-
-#include "SurfaceFlinger.h" // Get the name of the service...
-
-#include <binder/IServiceManager.h>
-
-#include <cutils/properties.h>
-
-#include <iomanip>
-#include <thread>
-
-using android::String16;
-using android::sp;
-using namespace std::chrono_literals;
-using namespace sftest;
-using std::setw;
-
-namespace sftest {
-
-// clang-format off
-inline void printSourceRectAligned(::std::ostream& os, const hwc_frect_t& sourceRect, int align) {
-    os << std::fixed << std::setprecision(1) << "("
-       << setw(align) << sourceRect.left << setw(0) << ","
-       << setw(align) << sourceRect.top << setw(0) << ","
-       << setw(align) << sourceRect.right << setw(0) << ","
-       << setw(align) << sourceRect.bottom << setw(0) << ")";
-}
-
-inline void printDisplayRectAligned(::std::ostream& os, const hwc_rect_t& displayRect, int align) {
-    os << "("
-       << setw(align) << displayRect.left << setw(0) << ","
-       << setw(align) << displayRect.top << setw(0) << ","
-       << setw(align) << displayRect.right << setw(0) << ","
-       << setw(align) << displayRect.bottom << setw(0) << ")";
-}
-// clang-format on
-
-inline ::std::ostream& operator<<(::std::ostream& os, const sftest::RenderState& state) {
-    printSourceRectAligned(os, state.mSourceCrop, 7);
-    os << "->";
-    printDisplayRectAligned(os, state.mDisplayFrame, 5);
-    return os << " Swaps:" << state.mSwapCount << " Alpha:" << std::setprecision(3)
-              << state.mPlaneAlpha << " Xform:" << state.mTransform;
-}
-
-// Helper for verifying the parts of the RenderState
-template <typename T>
-bool valuesMatch(::testing::AssertionResult& message, const T& ref, const T& val,
-                 const char* name) {
-    if (ref != val) {
-        message = message << "Expected " << name << ":" << ref << ", got:" << val << ".";
-        return false;
-    }
-    return true;
-}
-
-::testing::AssertionResult rectsAreSame(const RenderState& ref, const RenderState& val) {
-    // TODO: Message could start as success and be assigned as failure.
-    // Only problem is that utility assumes it to be failure and just adds stuff. Would
-    // need still special case the initial failure in the utility?
-    // TODO: ... or would it be possible to break this back to gtest primitives?
-    ::testing::AssertionResult message = ::testing::AssertionFailure();
-    bool passes = true;
-
-    // The work here is mostly about providing good log strings for differences
-    passes &= valuesMatch(message, ref.mDisplayFrame, val.mDisplayFrame, "display frame");
-    passes &= valuesMatch(message, ref.mPlaneAlpha, val.mPlaneAlpha, "alpha");
-    passes &= valuesMatch(message, ref.mSwapCount, val.mSwapCount, "swap count");
-    passes &= valuesMatch(message, ref.mSourceCrop, val.mSourceCrop, "source crop");
-    // ... add more
-    if (passes) {
-        return ::testing::AssertionSuccess();
-    }
-    return message;
-}
-
-::testing::AssertionResult framesAreSame(const std::vector<RenderState>& ref,
-                                         const std::vector<RenderState>& val) {
-    ::testing::AssertionResult message = ::testing::AssertionFailure();
-    bool passed = true;
-    if (ref.size() != val.size()) {
-        message << "Expected " << ref.size() << " rects, got " << val.size() << ".";
-        passed = false;
-    }
-    for (size_t rectIndex = 0; rectIndex < std::min(ref.size(), val.size()); rectIndex++) {
-        ::testing::AssertionResult rectResult = rectsAreSame(ref[rectIndex], val[rectIndex]);
-        if (rectResult == false) {
-            message << "First different rect at " << rectIndex << ": " << rectResult.message();
-            passed = false;
-            break;
-        }
-    }
-
-    if (passed) {
-        return ::testing::AssertionSuccess();
-    } else {
-        message << "\nReference:";
-        for (auto state = ref.begin(); state != ref.end(); ++state) {
-            message << "\n" << *state;
-        }
-        message << "\nActual:";
-        for (auto state = val.begin(); state != val.end(); ++state) {
-            message << "\n" << *state;
-        }
-    }
-    return message;
-}
-
-void startSurfaceFlinger() {
-    ALOGI("Start SurfaceFlinger");
-    system("start surfaceflinger");
-
-    sp<android::IServiceManager> sm(android::defaultServiceManager());
-    sp<android::IBinder> sf;
-    while (sf == nullptr) {
-        std::this_thread::sleep_for(10ms);
-        sf = sm->checkService(String16(android::SurfaceFlinger::getServiceName()));
-    }
-    ALOGV("SurfaceFlinger running");
-}
-
-void stopSurfaceFlinger() {
-    ALOGI("Stop SurfaceFlinger");
-    system("stop surfaceflinger");
-    sp<android::IServiceManager> sm(android::defaultServiceManager());
-    sp<android::IBinder> sf;
-    while (sf != nullptr) {
-        std::this_thread::sleep_for(10ms);
-        sf = sm->checkService(String16(android::SurfaceFlinger::getServiceName()));
-    }
-    ALOGV("SurfaceFlinger stopped");
-}
-
-////////////////////////////////////////////////
-
-void FakeHwcEnvironment::SetUp() {
-    ALOGI("Test env setup");
-    system("setenforce 0");
-    system("stop");
-    property_set("debug.sf.nobootanimation", "1");
-    {
-        char value[PROPERTY_VALUE_MAX];
-        property_get("debug.sf.nobootanimation", value, "0");
-        LOG_FATAL_IF(atoi(value) != 1, "boot skip not set");
-    }
-    // TODO: Try registering the mock as the default service instead.
-    property_set("debug.sf.hwc_service_name", "mock");
-    // This allows the SurfaceFlinger to load a HIDL service not listed in manifest files.
-    property_set("debug.sf.treble_testing_override", "true");
-}
-
-void FakeHwcEnvironment::TearDown() {
-    ALOGI("Test env tear down");
-    system("stop");
-    // Wait for mock call signaling teardown?
-    property_set("debug.sf.nobootanimation", "0");
-    property_set("debug.sf.hwc_service_name", "default");
-    ALOGI("Test env tear down - done");
-}
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h b/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h
deleted file mode 100644
index 1258a970c..000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include "FakeComposerClient.h"
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <hardware/hwcomposer_defs.h>
-
-#include <log/log.h>
-
-#include <gtest/gtest.h>
-
-// clang-format off
-// Note: This needs to reside in the global namespace for the GTest to use it
-inline ::std::ostream& operator<<(::std::ostream& os, const hwc_rect_t& rect) {
-    return os << "(" << rect.left << ","
-              << rect.top << ","
-              << rect.right << ","
-              << rect.bottom << ")";
-}
-
-inline ::std::ostream& operator<<(::std::ostream& os, const hwc_frect_t& rect) {
-    return os << "(" << rect.left << ","
-              << rect.top << ","
-              << rect.right << ","
-              << rect.bottom << ")";
-}
-// clang-format on
-
-namespace sftest {
-
-class RenderState;
-
-// clang-format off
-inline bool operator==(const hwc_rect_t& a, const hwc_rect_t& b) {
-    return a.top == b.top &&
-            a.left == b.left &&
-            a.bottom == b.bottom &&
-            a.right == b.right;
-}
-
-inline bool operator==(const hwc_frect_t& a, const hwc_frect_t& b) {
-    return a.top == b.top &&
-            a.left == b.left &&
-            a.bottom == b.bottom &&
-            a.right == b.right;
-}
-// clang-format on
-
-inline bool operator!=(const hwc_rect_t& a, const hwc_rect_t& b) {
-    return !(a == b);
-}
-
-inline bool operator!=(const hwc_frect_t& a, const hwc_frect_t& b) {
-    return !(a == b);
-}
-
-::testing::AssertionResult rectsAreSame(const RenderState& ref, const RenderState& val);
-::testing::AssertionResult framesAreSame(const std::vector<RenderState>& ref,
-                                         const std::vector<RenderState>& val);
-
-void startSurfaceFlinger();
-void stopSurfaceFlinger();
-
-class FakeHwcEnvironment : public ::testing::Environment {
-public:
-    virtual ~FakeHwcEnvironment() {}
-    void SetUp() override;
-    void TearDown() override;
-};
-
-/*
- * All surface state changes are supposed to happen inside a global
- * transaction. TransactionScope object at the beginning of
- * scope automates the process. The resulting scope gives a visual cue
- * on the span of the transaction as well.
- *
- * Closing the transaction is synchronous, i.e., it waits for
- * SurfaceFlinger to composite one frame. Now, the FakeComposerClient
- * is built to explicitly request vsyncs one at the time. A delayed
- * request must be made before closing the transaction or the test
- * thread stalls until SurfaceFlinger does an emergency vsync by
- * itself. TransactionScope encapsulates this vsync magic.
- */
-class TransactionScope : public android::SurfaceComposerClient::Transaction {
-public:
-    TransactionScope(FakeComposerClient& composer) :
-            Transaction(),
-            mComposer(composer) {
-    }
-
-    ~TransactionScope() {
-        int frameCount = mComposer.getFrameCount();
-        mComposer.runVSyncAfter(1ms);
-        LOG_ALWAYS_FATAL_IF(android::NO_ERROR != apply());
-        // Make sure that exactly one frame has been rendered.
-        mComposer.waitUntilFrame(frameCount + 1);
-        LOG_ALWAYS_FATAL_IF(frameCount + 1 != mComposer.getFrameCount(),
-                            "Unexpected frame advance. Delta: %d",
-                            mComposer.getFrameCount() - frameCount);
-    }
-
-    FakeComposerClient& mComposer;
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/RenderState.h b/services/surfaceflinger/tests/fakehwc/RenderState.h
deleted file mode 100644
index 0059289d4..000000000
--- a/services/surfaceflinger/tests/fakehwc/RenderState.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <hardware/hwcomposer2.h>
-
-#include <vector>
-
-namespace sftest {
-// Description of a rendered rectangle.  Should only contain
-// instructions necessary to rasterize the rectangle. The full scene
-// is given as a sorted list of rectangles, bottom layer at index 0.
-class RenderState {
-public:
-    RenderState() = default;
-    // Default copy-ctor
-
-    hwc_rect_t mDisplayFrame = {0, 0, 0, 0};
-    hwc_frect_t mSourceCrop = {0.f, 0.f, 0.f, 0.f};
-    std::vector<hwc_rect_t> mVisibleRegion;
-    hwc2_blend_mode_t mBlendMode = HWC2_BLEND_MODE_NONE;
-    buffer_handle_t mBuffer = 0;
-    uint32_t mSwapCount = 0;   // How many set buffer calls to the layer.
-    int32_t mAcquireFence = 0; // Probably should not be here.
-    float mPlaneAlpha = 0.f;
-    hwc_color_t mLayerColor = {0, 0, 0, 0};
-    hwc_transform_t mTransform = static_cast<hwc_transform_t>(0);
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp b/services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp
deleted file mode 100644
index 9b319854e..000000000
--- a/services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp
+++ /dev/null
@@ -1,1424 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// #define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeHwcTest"
-
-#include "FakeComposerClient.h"
-#include "FakeComposerService.h"
-#include "FakeComposerUtils.h"
-
-#include <gui/DisplayEventReceiver.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/LayerDebugInfo.h>
-#include <gui/LayerState.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-
-#include <android/hidl/manager/1.0/IServiceManager.h>
-#include <android/looper.h>
-#include <android/native_window.h>
-#include <binder/ProcessState.h>
-#include <hwbinder/ProcessState.h>
-#include <log/log.h>
-#include <private/gui/ComposerService.h>
-#include <ui/DisplayInfo.h>
-#include <utils/Looper.h>
-
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
-#include <limits>
-
-using namespace std::chrono_literals;
-
-using namespace android;
-using namespace android::hardware;
-
-using namespace sftest;
-
-namespace {
-
-// Mock test helpers
-using ::testing::Invoke;
-using ::testing::Return;
-using ::testing::SetArgPointee;
-using ::testing::_;
-
-using Transaction = SurfaceComposerClient::Transaction;
-
-///////////////////////////////////////////////
-
-struct TestColor {
-public:
-    uint8_t r;
-    uint8_t g;
-    uint8_t b;
-    uint8_t a;
-};
-
-constexpr static TestColor RED = {195, 63, 63, 255};
-constexpr static TestColor LIGHT_RED = {255, 177, 177, 255};
-constexpr static TestColor GREEN = {63, 195, 63, 255};
-constexpr static TestColor BLUE = {63, 63, 195, 255};
-constexpr static TestColor DARK_GRAY = {63, 63, 63, 255};
-constexpr static TestColor LIGHT_GRAY = {200, 200, 200, 255};
-
-// Fill an RGBA_8888 formatted surface with a single color.
-static void fillSurfaceRGBA8(const sp<SurfaceControl>& sc, const TestColor& color,
-                             bool unlock = true) {
-    ANativeWindow_Buffer outBuffer;
-    sp<Surface> s = sc->getSurface();
-    ASSERT_TRUE(s != nullptr);
-    ASSERT_EQ(NO_ERROR, s->lock(&outBuffer, nullptr));
-    uint8_t* img = reinterpret_cast<uint8_t*>(outBuffer.bits);
-    for (int y = 0; y < outBuffer.height; y++) {
-        for (int x = 0; x < outBuffer.width; x++) {
-            uint8_t* pixel = img + (4 * (y * outBuffer.stride + x));
-            pixel[0] = color.r;
-            pixel[1] = color.g;
-            pixel[2] = color.b;
-            pixel[3] = color.a;
-        }
-    }
-    if (unlock) {
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-    }
-}
-
-inline RenderState makeSimpleRect(int left, int top, int right, int bottom) {
-    RenderState res;
-    res.mDisplayFrame = hwc_rect_t{left, top, right, bottom};
-    res.mPlaneAlpha = 1.0f;
-    res.mSwapCount = 0;
-    res.mSourceCrop = hwc_frect_t{0.f, 0.f, static_cast<float>(right - left),
-                                  static_cast<float>(bottom - top)};
-    return res;
-}
-
-inline RenderState makeSimpleRect(unsigned int left, unsigned int top, unsigned int right,
-                                  unsigned int bottom) {
-    EXPECT_LE(left, static_cast<unsigned int>(INT_MAX));
-    EXPECT_LE(top, static_cast<unsigned int>(INT_MAX));
-    EXPECT_LE(right, static_cast<unsigned int>(INT_MAX));
-    EXPECT_LE(bottom, static_cast<unsigned int>(INT_MAX));
-    return makeSimpleRect(static_cast<int>(left), static_cast<int>(top), static_cast<int>(right),
-                          static_cast<int>(bottom));
-}
-
-////////////////////////////////////////////////
-
-class DisplayTest : public ::testing::Test {
-public:
-    class MockComposerClient : public FakeComposerClient {
-    public:
-        MOCK_METHOD2(getDisplayType, Error(Display display, ComposerClient::DisplayType* outType));
-        MOCK_METHOD4(getDisplayAttribute,
-                     Error(Display display, Config config, IComposerClient::Attribute attribute,
-                           int32_t* outValue));
-
-        // Re-routing to basic fake implementation
-        Error getDisplayAttributeFake(Display display, Config config,
-                                      IComposerClient::Attribute attribute, int32_t* outValue) {
-            return FakeComposerClient::getDisplayAttribute(display, config, attribute, outValue);
-        }
-    };
-
-protected:
-    static int processDisplayEvents(int fd, int events, void* data);
-
-    void SetUp() override;
-    void TearDown() override;
-
-    void waitForDisplayTransaction();
-    bool waitForHotplugEvent(uint32_t id, bool connected);
-
-    sp<IComposer> mFakeService;
-    sp<SurfaceComposerClient> mComposerClient;
-
-    MockComposerClient* mMockComposer;
-
-    std::unique_ptr<DisplayEventReceiver> mReceiver;
-    sp<Looper> mLooper;;
-    std::deque<DisplayEventReceiver::Event> mReceivedDisplayEvents;
-};
-
-void DisplayTest::SetUp() {
-    // TODO: The mMockComposer should be a unique_ptr, but it needs to
-    // outlive the test class.  Currently ComposerClient only dies
-    // when the service is replaced. The Mock deletes itself when
-    // removeClient is called on it, which is ugly.  This can be
-    // changed if HIDL ServiceManager allows removing services or
-    // ComposerClient starts taking the ownership of the contained
-    // implementation class. Moving the fake class to the HWC2
-    // interface instead of the current Composer interface might also
-    // change the situation.
-    mMockComposer = new MockComposerClient;
-    sp<ComposerClient> client = new ComposerClient(mMockComposer);
-    mFakeService = new FakeComposerService(client);
-    (void)mFakeService->registerAsService("mock");
-
-    android::hardware::ProcessState::self()->startThreadPool();
-    android::ProcessState::self()->startThreadPool();
-
-    EXPECT_CALL(*mMockComposer, getDisplayType(PRIMARY_DISPLAY, _))
-            .WillOnce(DoAll(SetArgPointee<1>(IComposerClient::DisplayType::PHYSICAL),
-                            Return(Error::NONE)));
-    // Primary display will be queried twice for all 5 attributes. One
-    // set of queries comes from the SurfaceFlinger proper an the
-    // other set from the VR composer.
-    // TODO: Is VR composer always present? Change to atLeast(5)?
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(PRIMARY_DISPLAY, 1, _, _))
-            .Times(2 * 5)
-            .WillRepeatedly(Invoke(mMockComposer, &MockComposerClient::getDisplayAttributeFake));
-
-    startSurfaceFlinger();
-
-    // Fake composer wants to enable VSync injection
-    mMockComposer->onSurfaceFlingerStart();
-
-    mComposerClient = new SurfaceComposerClient;
-    ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-    mReceiver.reset(new DisplayEventReceiver());
-    mLooper = new Looper(false);
-    mLooper->addFd(mReceiver->getFd(), 0, ALOOPER_EVENT_INPUT, processDisplayEvents, this);
-}
-
-void DisplayTest::TearDown() {
-    mLooper = nullptr;
-    mReceiver = nullptr;
-
-    mComposerClient->dispose();
-    mComposerClient = nullptr;
-
-    // Fake composer needs to release SurfaceComposerClient before the stop.
-    mMockComposer->onSurfaceFlingerStop();
-    stopSurfaceFlinger();
-
-    mFakeService = nullptr;
-    // TODO: Currently deleted in FakeComposerClient::removeClient(). Devise better lifetime
-    // management.
-    mMockComposer = nullptr;
-}
-
-
-int DisplayTest::processDisplayEvents(int /*fd*/, int /*events*/, void* data) {
-    auto self = static_cast<DisplayTest*>(data);
-
-    ssize_t n;
-    DisplayEventReceiver::Event buffer[1];
-
-    while ((n = self->mReceiver->getEvents(buffer, 1)) > 0) {
-        for (int i=0 ; i<n ; i++) {
-            self->mReceivedDisplayEvents.push_back(buffer[i]);
-        }
-    }
-    ALOGD_IF(n < 0, "Error reading events (%s)\n", strerror(-n));
-    return 1;
-}
-
-void DisplayTest::waitForDisplayTransaction() {
-    // Both a refresh and a vsync event are needed to apply pending display
-    // transactions.
-    mMockComposer->refreshDisplay(EXTERNAL_DISPLAY);
-    mMockComposer->runVSyncAndWait();
-
-    // Extra vsync and wait to avoid a 10% flake due to a race.
-    mMockComposer->runVSyncAndWait();
-}
-
-bool DisplayTest::waitForHotplugEvent(uint32_t id, bool connected) {
-    int waitCount = 20;
-    while (waitCount--) {
-        while (!mReceivedDisplayEvents.empty()) {
-            auto event = mReceivedDisplayEvents.front();
-            mReceivedDisplayEvents.pop_front();
-
-            ALOGV_IF(event.header.type == DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG,
-                    "event hotplug: id %d, connected %d\t", event.header.id,
-                    event.hotplug.connected);
-
-            if (event.header.type == DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG &&
-                event.header.id == id && event.hotplug.connected == connected) {
-                return true;
-            }
-        }
-
-        mLooper->pollOnce(1);
-    }
-
-    return false;
-}
-
-TEST_F(DisplayTest, Hotplug) {
-    ALOGD("DisplayTest::Hotplug");
-
-    EXPECT_CALL(*mMockComposer, getDisplayType(EXTERNAL_DISPLAY, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<1>(IComposerClient::DisplayType::PHYSICAL),
-                                  Return(Error::NONE)));
-    // The attribute queries will get done twice. This is for defaults
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(EXTERNAL_DISPLAY, 1, _, _))
-            .Times(2 * 3)
-            .WillRepeatedly(Invoke(mMockComposer, &MockComposerClient::getDisplayAttributeFake));
-    // ... and then special handling for dimensions. Specifying these
-    // rules later means that gmock will try them first, i.e.,
-    // ordering of width/height vs. the default implementation for
-    // other queries is significant.
-    EXPECT_CALL(*mMockComposer,
-                getDisplayAttribute(EXTERNAL_DISPLAY, 1, IComposerClient::Attribute::WIDTH, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<3>(400), Return(Error::NONE)));
-
-    EXPECT_CALL(*mMockComposer,
-                getDisplayAttribute(EXTERNAL_DISPLAY, 1, IComposerClient::Attribute::HEIGHT, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<3>(200), Return(Error::NONE)));
-
-    mMockComposer->hotplugDisplay(EXTERNAL_DISPLAY, IComposerCallback::Connection::CONNECTED);
-
-    waitForDisplayTransaction();
-
-    EXPECT_TRUE(waitForHotplugEvent(ISurfaceComposer::eDisplayIdHdmi, true));
-
-    {
-        sp<android::IBinder> display(
-                SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdHdmi));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-        ASSERT_EQ(400u, info.w);
-        ASSERT_EQ(200u, info.h);
-
-        auto surfaceControl =
-                mComposerClient->createSurface(String8("Display Test Surface Foo"), info.w, info.h,
-                                               PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(surfaceControl != nullptr);
-        ASSERT_TRUE(surfaceControl->isValid());
-        fillSurfaceRGBA8(surfaceControl, BLUE);
-
-        {
-            TransactionScope ts(*mMockComposer);
-            ts.setDisplayLayerStack(display, 0);
-
-            ts.setLayer(surfaceControl, INT32_MAX - 2)
-                .show(surfaceControl);
-        }
-    }
-
-    mMockComposer->hotplugDisplay(EXTERNAL_DISPLAY, IComposerCallback::Connection::DISCONNECTED);
-
-    mMockComposer->clearFrames();
-
-    mMockComposer->hotplugDisplay(EXTERNAL_DISPLAY, IComposerCallback::Connection::CONNECTED);
-
-    waitForDisplayTransaction();
-
-    EXPECT_TRUE(waitForHotplugEvent(ISurfaceComposer::eDisplayIdHdmi, false));
-    EXPECT_TRUE(waitForHotplugEvent(ISurfaceComposer::eDisplayIdHdmi, true));
-
-    {
-        sp<android::IBinder> display(
-                SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdHdmi));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-        ASSERT_EQ(400u, info.w);
-        ASSERT_EQ(200u, info.h);
-
-        auto surfaceControl =
-                mComposerClient->createSurface(String8("Display Test Surface Bar"), info.w, info.h,
-                                               PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(surfaceControl != nullptr);
-        ASSERT_TRUE(surfaceControl->isValid());
-        fillSurfaceRGBA8(surfaceControl, BLUE);
-
-        {
-            TransactionScope ts(*mMockComposer);
-            ts.setDisplayLayerStack(display, 0);
-
-            ts.setLayer(surfaceControl, INT32_MAX - 2)
-                .show(surfaceControl);
-        }
-    }
-    mMockComposer->hotplugDisplay(EXTERNAL_DISPLAY, IComposerCallback::Connection::DISCONNECTED);
-}
-
-TEST_F(DisplayTest, HotplugPrimaryDisplay) {
-    ALOGD("DisplayTest::HotplugPrimaryDisplay");
-
-    mMockComposer->hotplugDisplay(PRIMARY_DISPLAY, IComposerCallback::Connection::DISCONNECTED);
-
-    waitForDisplayTransaction();
-
-    EXPECT_TRUE(waitForHotplugEvent(ISurfaceComposer::eDisplayIdMain, false));
-
-    {
-        sp<android::IBinder> display(
-                SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
-        DisplayInfo info;
-        auto result = SurfaceComposerClient::getDisplayInfo(display, &info);
-        EXPECT_NE(NO_ERROR, result);
-    }
-
-    mMockComposer->clearFrames();
-
-    EXPECT_CALL(*mMockComposer, getDisplayType(PRIMARY_DISPLAY, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<1>(IComposerClient::DisplayType::PHYSICAL),
-                                  Return(Error::NONE)));
-    // The attribute queries will get done twice. This is for defaults
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(PRIMARY_DISPLAY, 1, _, _))
-            .Times(2 * 3)
-            .WillRepeatedly(Invoke(mMockComposer, &MockComposerClient::getDisplayAttributeFake));
-    // ... and then special handling for dimensions. Specifying these
-    // rules later means that gmock will try them first, i.e.,
-    // ordering of width/height vs. the default implementation for
-    // other queries is significant.
-    EXPECT_CALL(*mMockComposer,
-                getDisplayAttribute(PRIMARY_DISPLAY, 1, IComposerClient::Attribute::WIDTH, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<3>(400), Return(Error::NONE)));
-
-    EXPECT_CALL(*mMockComposer,
-                getDisplayAttribute(PRIMARY_DISPLAY, 1, IComposerClient::Attribute::HEIGHT, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<3>(200), Return(Error::NONE)));
-
-    mMockComposer->hotplugDisplay(PRIMARY_DISPLAY, IComposerCallback::Connection::CONNECTED);
-
-    waitForDisplayTransaction();
-
-    EXPECT_TRUE(waitForHotplugEvent(ISurfaceComposer::eDisplayIdMain, true));
-
-    {
-        sp<android::IBinder> display(
-                SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
-        DisplayInfo info;
-        auto result = SurfaceComposerClient::getDisplayInfo(display, &info);
-        EXPECT_EQ(NO_ERROR, result);
-        ASSERT_EQ(400u, info.w);
-        ASSERT_EQ(200u, info.h);
-    }
-}
-
-////////////////////////////////////////////////
-
-class TransactionTest : public ::testing::Test {
-protected:
-    // Layer array indexing constants.
-    constexpr static int BG_LAYER = 0;
-    constexpr static int FG_LAYER = 1;
-
-    static void SetUpTestCase();
-    static void TearDownTestCase();
-
-    void SetUp() override;
-    void TearDown() override;
-
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mBGSurfaceControl;
-    sp<SurfaceControl> mFGSurfaceControl;
-    std::vector<RenderState> mBaseFrame;
-    uint32_t mDisplayWidth;
-    uint32_t mDisplayHeight;
-
-    static FakeComposerClient* sFakeComposer;
-};
-
-FakeComposerClient* TransactionTest::sFakeComposer;
-
-void TransactionTest::SetUpTestCase() {
-    // TODO: See TODO comment at DisplayTest::SetUp for background on
-    // the lifetime of the FakeComposerClient.
-    sFakeComposer = new FakeComposerClient;
-    sp<ComposerClient> client = new ComposerClient(sFakeComposer);
-    sp<IComposer> fakeService = new FakeComposerService(client);
-    (void)fakeService->registerAsService("mock");
-
-    android::hardware::ProcessState::self()->startThreadPool();
-    android::ProcessState::self()->startThreadPool();
-
-    startSurfaceFlinger();
-
-    // Fake composer wants to enable VSync injection
-    sFakeComposer->onSurfaceFlingerStart();
-}
-
-void TransactionTest::TearDownTestCase() {
-    // Fake composer needs to release SurfaceComposerClient before the stop.
-    sFakeComposer->onSurfaceFlingerStop();
-    stopSurfaceFlinger();
-    // TODO: This is deleted when the ComposerClient calls
-    // removeClient. Devise better lifetime control.
-    sFakeComposer = nullptr;
-}
-
-void TransactionTest::SetUp() {
-    ALOGI("TransactionTest::SetUp");
-    mComposerClient = new SurfaceComposerClient;
-    ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-    ALOGI("TransactionTest::SetUp - display");
-    sp<android::IBinder> display(
-            SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
-    DisplayInfo info;
-    SurfaceComposerClient::getDisplayInfo(display, &info);
-
-    mDisplayWidth = info.w;
-    mDisplayHeight = info.h;
-
-    // Background surface
-    mBGSurfaceControl = mComposerClient->createSurface(String8("BG Test Surface"), mDisplayWidth,
-                                                       mDisplayHeight, PIXEL_FORMAT_RGBA_8888, 0);
-    ASSERT_TRUE(mBGSurfaceControl != nullptr);
-    ASSERT_TRUE(mBGSurfaceControl->isValid());
-    fillSurfaceRGBA8(mBGSurfaceControl, BLUE);
-
-    // Foreground surface
-    mFGSurfaceControl = mComposerClient->createSurface(String8("FG Test Surface"), 64, 64,
-                                                       PIXEL_FORMAT_RGBA_8888, 0);
-    ASSERT_TRUE(mFGSurfaceControl != nullptr);
-    ASSERT_TRUE(mFGSurfaceControl->isValid());
-
-    fillSurfaceRGBA8(mFGSurfaceControl, RED);
-
-    Transaction t;
-    t.setDisplayLayerStack(display, 0);
-
-    t.setLayer(mBGSurfaceControl, INT32_MAX - 2);
-    t.show(mBGSurfaceControl);
-
-    t.setLayer(mFGSurfaceControl, INT32_MAX - 1);
-    t.setPosition(mFGSurfaceControl, 64, 64);
-    t.show(mFGSurfaceControl);
-
-    // Synchronous transaction will stop this thread, so we set up a
-    // delayed, off-thread vsync request before closing the
-    // transaction. In the test code this is usually done with
-    // TransactionScope. Leaving here in the 'vanilla' form for
-    // reference.
-    ASSERT_EQ(0, sFakeComposer->getFrameCount());
-    sFakeComposer->runVSyncAfter(1ms);
-    t.apply();
-    sFakeComposer->waitUntilFrame(1);
-
-    // Reference data. This is what the HWC should see.
-    static_assert(BG_LAYER == 0 && FG_LAYER == 1, "Unexpected enum values for array indexing");
-    mBaseFrame.push_back(makeSimpleRect(0u, 0u, mDisplayWidth, mDisplayHeight));
-    mBaseFrame[BG_LAYER].mSwapCount = 1;
-    mBaseFrame.push_back(makeSimpleRect(64, 64, 64 + 64, 64 + 64));
-    mBaseFrame[FG_LAYER].mSwapCount = 1;
-
-    auto frame = sFakeComposer->getFrameRects(0);
-    ASSERT_TRUE(framesAreSame(mBaseFrame, frame));
-}
-
-void TransactionTest::TearDown() {
-    ALOGD("TransactionTest::TearDown");
-
-    mComposerClient->dispose();
-    mBGSurfaceControl = 0;
-    mFGSurfaceControl = 0;
-    mComposerClient = 0;
-
-    sFakeComposer->runVSyncAndWait();
-    mBaseFrame.clear();
-    sFakeComposer->clearFrames();
-    ASSERT_EQ(0, sFakeComposer->getFrameCount());
-
-    sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-    std::vector<LayerDebugInfo> layers;
-    status_t result = sf->getLayerDebugInfo(&layers);
-    if (result != NO_ERROR) {
-        ALOGE("Failed to get layers %s %d", strerror(-result), result);
-    } else {
-        // If this fails, the test being torn down leaked layers.
-        EXPECT_EQ(0u, layers.size());
-        if (layers.size() > 0) {
-            for (auto layer = layers.begin(); layer != layers.end(); ++layer) {
-                std::cout << to_string(*layer).c_str();
-            }
-            // To ensure the next test has clean slate, will run the class
-            // tear down and setup here.
-            TearDownTestCase();
-            SetUpTestCase();
-        }
-    }
-    ALOGD("TransactionTest::TearDown - complete");
-}
-
-TEST_F(TransactionTest, LayerMove) {
-    ALOGD("TransactionTest::LayerMove");
-
-    // The scope opens and closes a global transaction and, at the
-    // same time, makes sure the SurfaceFlinger progresses one frame
-    // after the transaction closes. The results of the transaction
-    // should be available in the latest frame stored by the fake
-    // composer.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setPosition(mFGSurfaceControl, 128, 128);
-        // NOTE: No changes yet, so vsync will do nothing, HWC does not get any calls.
-        // (How to verify that? Throw in vsync and wait a 2x frame time? Separate test?)
-        //
-        // sFakeComposer->runVSyncAndWait();
-    }
-
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-
-    ASSERT_EQ(3, sFakeComposer->getFrameCount()); // Make sure the waits didn't time out and there's
-                                                  // no extra frames.
-
-    // NOTE: Frame 0 is produced in the SetUp.
-    auto frame1Ref = mBaseFrame;
-    frame1Ref[FG_LAYER].mDisplayFrame =
-            hwc_rect_t{128, 128, 128 + 64, 128 + 64}; // Top-most layer moves.
-    EXPECT_TRUE(framesAreSame(frame1Ref, sFakeComposer->getFrameRects(1)));
-
-    auto frame2Ref = frame1Ref;
-    frame2Ref[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(frame2Ref, sFakeComposer->getFrameRects(2)));
-}
-
-TEST_F(TransactionTest, LayerResize) {
-    ALOGD("TransactionTest::LayerResize");
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-    }
-
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-
-    ASSERT_EQ(3, sFakeComposer->getFrameCount()); // Make sure the waits didn't time out and there's
-                                                  // no extra frames.
-
-    auto frame1Ref = mBaseFrame;
-    // NOTE: The resize should not be visible for frame 1 as there's no buffer with new size posted.
-    EXPECT_TRUE(framesAreSame(frame1Ref, sFakeComposer->getFrameRects(1)));
-
-    auto frame2Ref = frame1Ref;
-    frame2Ref[FG_LAYER].mSwapCount++;
-    frame2Ref[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 128, 64 + 128};
-    frame2Ref[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 128.f, 128.f};
-    EXPECT_TRUE(framesAreSame(frame2Ref, sFakeComposer->getFrameRects(2)));
-}
-
-TEST_F(TransactionTest, LayerCrop) {
-    // TODO: Add scaling to confirm that crop happens in buffer space?
-    {
-        TransactionScope ts(*sFakeComposer);
-        Rect cropRect(16, 16, 32, 32);
-        ts.setCrop(mFGSurfaceControl, cropRect);
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{16.f, 16.f, 32.f, 32.f};
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64 + 16, 64 + 16, 64 + 32, 64 + 32};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerFinalCrop) {
-    // TODO: Add scaling to confirm that crop happens in display space?
-    {
-        TransactionScope ts(*sFakeComposer);
-        Rect cropRect(32, 32, 32 + 64, 32 + 64);
-        ts.setFinalCrop(mFGSurfaceControl, cropRect);
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // In display space we are cropping with [32, 32, 96, 96] against display rect
-    // [64, 64, 128, 128]. Should yield display rect [64, 64, 96, 96]
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 32.f, 32.f};
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 32, 64 + 32};
-
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerFinalCropEmpty) {
-    // TODO: Add scaling to confirm that crop happens in display space?
-    {
-        TransactionScope ts(*sFakeComposer);
-        Rect cropRect(16, 16, 32, 32);
-        ts.setFinalCrop(mFGSurfaceControl, cropRect);
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // In display space we are cropping with [16, 16, 32, 32] against display rect
-    // [64, 64, 128, 128]. The intersection is empty and only the background layer is composited.
-    std::vector<RenderState> referenceFrame(1);
-    referenceFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetLayer) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setLayer(mFGSurfaceControl, INT_MAX - 3);
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // The layers will switch order, but both are rendered because the background layer is
-    // transparent (RGBA8888).
-    std::vector<RenderState> referenceFrame(2);
-    referenceFrame[0] = mBaseFrame[FG_LAYER];
-    referenceFrame[1] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetLayerOpaque) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setLayer(mFGSurfaceControl, INT_MAX - 3);
-        ts.setFlags(mBGSurfaceControl, layer_state_t::eLayerOpaque,
-                layer_state_t::eLayerOpaque);
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // The former foreground layer is now covered with opaque layer - it should have disappeared
-    std::vector<RenderState> referenceFrame(1);
-    referenceFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, SetLayerStack) {
-    ALOGD("TransactionTest::SetLayerStack");
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setLayerStack(mFGSurfaceControl, 1);
-    }
-
-    // Foreground layer should have disappeared.
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    std::vector<RenderState> refFrame(1);
-    refFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(refFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerShowHide) {
-    ALOGD("TransactionTest::LayerShowHide");
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.hide(mFGSurfaceControl);
-    }
-
-    // Foreground layer should have disappeared.
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    std::vector<RenderState> refFrame(1);
-    refFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(refFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mFGSurfaceControl);
-    }
-
-    // Foreground layer should be back
-    ASSERT_EQ(3, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetAlpha) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setAlpha(mFGSurfaceControl, 0.75f);
-    }
-
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mPlaneAlpha = 0.75f;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetFlags) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setFlags(mFGSurfaceControl, layer_state_t::eLayerHidden,
-                layer_state_t::eLayerHidden);
-    }
-
-    // Foreground layer should have disappeared.
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    std::vector<RenderState> refFrame(1);
-    refFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(refFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetMatrix) {
-    struct matrixTestData {
-        float matrix[4];
-        hwc_transform_t expectedTransform;
-        hwc_rect_t expectedDisplayFrame;
-    };
-
-    // The matrix operates on the display frame and is applied before
-    // the position is added. So, the foreground layer rect is (0, 0,
-    // 64, 64) is first transformed, potentially yielding negative
-    // coordinates and then the position (64, 64) is added yielding
-    // the final on-screen rectangles given.
-
-    const matrixTestData MATRIX_TESTS[7] = // clang-format off
-            {{{-1.f, 0.f, 0.f, 1.f},    HWC_TRANSFORM_FLIP_H,           {0, 64, 64, 128}},
-             {{1.f, 0.f, 0.f, -1.f},    HWC_TRANSFORM_FLIP_V,           {64, 0, 128, 64}},
-             {{0.f, 1.f, -1.f, 0.f},    HWC_TRANSFORM_ROT_90,           {0, 64, 64, 128}},
-             {{-1.f, 0.f, 0.f, -1.f},   HWC_TRANSFORM_ROT_180,          {0, 0, 64, 64}},
-             {{0.f, -1.f, 1.f, 0.f},    HWC_TRANSFORM_ROT_270,          {64, 0, 128, 64}},
-             {{0.f, 1.f, 1.f, 0.f},     HWC_TRANSFORM_FLIP_H_ROT_90,    {64, 64, 128, 128}},
-             {{0.f, 1.f, 1.f, 0.f},     HWC_TRANSFORM_FLIP_V_ROT_90,    {64, 64, 128, 128}}};
-    // clang-format on
-    constexpr int TEST_COUNT = sizeof(MATRIX_TESTS) / sizeof(matrixTestData);
-
-    for (int i = 0; i < TEST_COUNT; i++) {
-        // TODO: How to leverage the HWC2 stringifiers?
-        const matrixTestData& xform = MATRIX_TESTS[i];
-        SCOPED_TRACE(i);
-        {
-            TransactionScope ts(*sFakeComposer);
-            ts.setMatrix(mFGSurfaceControl, xform.matrix[0], xform.matrix[1],
-                    xform.matrix[2], xform.matrix[3]);
-        }
-
-        auto referenceFrame = mBaseFrame;
-        referenceFrame[FG_LAYER].mTransform = xform.expectedTransform;
-        referenceFrame[FG_LAYER].mDisplayFrame = xform.expectedDisplayFrame;
-
-        EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-    }
-}
-
-#if 0
-TEST_F(TransactionTest, LayerSetMatrix2) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        // TODO: PLEASE SPEC THE FUNCTION!
-        ts.setMatrix(mFGSurfaceControl, 0.11f, 0.123f,
-                -2.33f, 0.22f);
-    }
-    auto referenceFrame = mBaseFrame;
-    // TODO: Is this correct for sure?
-    //referenceFrame[FG_LAYER].mTransform = HWC_TRANSFORM_FLIP_V & HWC_TRANSFORM_ROT_90;
-
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-#endif
-
-TEST_F(TransactionTest, DeferredTransaction) {
-    // Synchronization surface
-    constexpr static int SYNC_LAYER = 2;
-    auto syncSurfaceControl = mComposerClient->createSurface(String8("Sync Test Surface"), 1, 1,
-                                                             PIXEL_FORMAT_RGBA_8888, 0);
-    ASSERT_TRUE(syncSurfaceControl != nullptr);
-    ASSERT_TRUE(syncSurfaceControl->isValid());
-
-    fillSurfaceRGBA8(syncSurfaceControl, DARK_GRAY);
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setLayer(syncSurfaceControl, INT32_MAX - 1);
-        ts.setPosition(syncSurfaceControl, mDisplayWidth - 2, mDisplayHeight - 2);
-        ts.show(syncSurfaceControl);
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame.push_back(makeSimpleRect(mDisplayWidth - 2, mDisplayHeight - 2,
-                                            mDisplayWidth - 1, mDisplayHeight - 1));
-    referenceFrame[SYNC_LAYER].mSwapCount = 1;
-    EXPECT_EQ(2, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // set up two deferred transactions on different frames - these should not yield composited
-    // frames
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setAlpha(mFGSurfaceControl, 0.75);
-        ts.deferTransactionUntil(mFGSurfaceControl, 
-                syncSurfaceControl->getHandle(),
-                syncSurfaceControl->getSurface()->getNextFrameNumber());
-    }
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setPosition(mFGSurfaceControl, 128, 128);
-        ts.deferTransactionUntil(mFGSurfaceControl,
-                syncSurfaceControl->getHandle(),
-                syncSurfaceControl->getSurface()->getNextFrameNumber() + 1);
-    }
-    EXPECT_EQ(4, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // should trigger the first deferred transaction, but not the second one
-    fillSurfaceRGBA8(syncSurfaceControl, DARK_GRAY);
-    sFakeComposer->runVSyncAndWait();
-    EXPECT_EQ(5, sFakeComposer->getFrameCount());
-
-    referenceFrame[FG_LAYER].mPlaneAlpha = 0.75f;
-    referenceFrame[SYNC_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // should show up immediately since it's not deferred
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setAlpha(mFGSurfaceControl, 1.0);
-    }
-    referenceFrame[FG_LAYER].mPlaneAlpha = 1.f;
-    EXPECT_EQ(6, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // trigger the second deferred transaction
-    fillSurfaceRGBA8(syncSurfaceControl, DARK_GRAY);
-    sFakeComposer->runVSyncAndWait();
-    // TODO: Compute from layer size?
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{128, 128, 128 + 64, 128 + 64};
-    referenceFrame[SYNC_LAYER].mSwapCount++;
-    EXPECT_EQ(7, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, SetRelativeLayer) {
-    constexpr int RELATIVE_LAYER = 2;
-    auto relativeSurfaceControl = mComposerClient->createSurface(String8("Test Surface"), 64, 64,
-                                                                 PIXEL_FORMAT_RGBA_8888, 0);
-    fillSurfaceRGBA8(relativeSurfaceControl, LIGHT_RED);
-
-    // Now we stack the surface above the foreground surface and make sure it is visible.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setPosition(relativeSurfaceControl, 64, 64);
-        ts.show(relativeSurfaceControl);
-        ts.setRelativeLayer(relativeSurfaceControl, mFGSurfaceControl->getHandle(), 1);
-    }
-    auto referenceFrame = mBaseFrame;
-    // NOTE: All three layers will be visible as the surfaces are
-    // transparent because of the RGBA format.
-    referenceFrame.push_back(makeSimpleRect(64, 64, 64 + 64, 64 + 64));
-    referenceFrame[RELATIVE_LAYER].mSwapCount = 1;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // A call to setLayer will override a call to setRelativeLayer
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setLayer(relativeSurfaceControl, 0);
-    }
-
-    // Previous top layer will now appear at the bottom.
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2.insert(referenceFrame2.begin(), referenceFrame[RELATIVE_LAYER]);
-    EXPECT_EQ(3, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-class ChildLayerTest : public TransactionTest {
-protected:
-    constexpr static int CHILD_LAYER = 2;
-
-    void SetUp() override {
-        TransactionTest::SetUp();
-        mChild = mComposerClient->createSurface(String8("Child surface"), 10, 10,
-                                                PIXEL_FORMAT_RGBA_8888, 0, mFGSurfaceControl.get());
-        fillSurfaceRGBA8(mChild, LIGHT_GRAY);
-
-        sFakeComposer->runVSyncAndWait();
-        mBaseFrame.push_back(makeSimpleRect(64, 64, 64 + 10, 64 + 10));
-        mBaseFrame[CHILD_LAYER].mSwapCount = 1;
-        ASSERT_EQ(2, sFakeComposer->getFrameCount());
-        ASSERT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-    }
-    void TearDown() override {
-        mChild = 0;
-        TransactionTest::TearDown();
-    }
-
-    sp<SurfaceControl> mChild;
-};
-
-TEST_F(ChildLayerTest, Positioning) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 10, 10);
-        // Move to the same position as in the original setup.
-        ts.setPosition(mFGSurfaceControl, 64, 64);
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{64 + 10, 64 + 10, 64 + 10 + 10, 64 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-    }
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 64, 0 + 64};
-    referenceFrame2[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{0 + 10, 0 + 10, 0 + 10 + 10, 0 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Cropping) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 0, 0);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-        ts.setCrop(mFGSurfaceControl, Rect(0, 0, 5, 5));
-    }
-    // NOTE: The foreground surface would be occluded by the child
-    // now, but is included in the stack because the child is
-    // transparent.
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, FinalCropping) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 0, 0);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-        ts.setFinalCrop(mFGSurfaceControl, Rect(0, 0, 5, 5));
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Constraints) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-        ts.setPosition(mChild, 63, 63);
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 64, 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{63, 63, 64, 64};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 1.f, 1.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Scaling) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 64, 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 10, 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setMatrix(mFGSurfaceControl, 2.0, 0, 0, 2.0);
-    }
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 128, 128};
-    referenceFrame2[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 20, 20};
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, LayerAlpha) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 0, 0);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-        ts.setAlpha(mChild, 0.5);
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 64, 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 10, 10};
-    referenceFrame[CHILD_LAYER].mPlaneAlpha = 0.5f;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setAlpha(mFGSurfaceControl, 0.5);
-    }
-
-    auto referenceFrame2 = referenceFrame;
-    referenceFrame2[FG_LAYER].mPlaneAlpha = 0.5f;
-    referenceFrame2[CHILD_LAYER].mPlaneAlpha = 0.25f;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, ReparentChildren) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 10, 10);
-        ts.setPosition(mFGSurfaceControl, 64, 64);
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{64 + 10, 64 + 10, 64 + 10 + 10, 64 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.reparentChildren(mFGSurfaceControl, mBGSurfaceControl->getHandle());
-    }
-
-    auto referenceFrame2 = referenceFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame2[CHILD_LAYER].mDisplayFrame = hwc_rect_t{10, 10, 10 + 10, 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, DetachChildren) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 10, 10);
-        ts.setPosition(mFGSurfaceControl, 64, 64);
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{64 + 10, 64 + 10, 64 + 10 + 10, 64 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.detachChildren(mFGSurfaceControl);
-    }
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.hide(mChild);
-    }
-
-    // Nothing should have changed. The child control becomes a no-op
-    // zombie on detach. See comments for detachChildren in the
-    // SurfaceControl.h file.
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, InheritNonTransformScalingFromParent) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 0, 0);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-    }
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setOverrideScalingMode(mFGSurfaceControl, NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
-        // We cause scaling by 2.
-        ts.setSize(mFGSurfaceControl, 128, 128);
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 128, 128};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 64.f, 64.f};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 20, 20};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 10.f, 10.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-// Regression test for b/37673612
-TEST_F(ChildLayerTest, ChildrenWithParentBufferTransform) {
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.show(mChild);
-        ts.setPosition(mChild, 0, 0);
-        ts.setPosition(mFGSurfaceControl, 0, 0);
-    }
-
-    // We set things up as in b/37673612 so that there is a mismatch between the buffer size and
-    // the WM specified state size.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 64);
-    }
-
-    sp<Surface> s = mFGSurfaceControl->getSurface();
-    auto anw = static_cast<ANativeWindow*>(s.get());
-    native_window_set_buffers_transform(anw, NATIVE_WINDOW_TRANSFORM_ROT_90);
-    native_window_set_buffers_dimensions(anw, 64, 128);
-    fillSurfaceRGBA8(mFGSurfaceControl, RED);
-    sFakeComposer->runVSyncAndWait();
-
-    // The child should still be in the same place and not have any strange scaling as in
-    // b/37673612.
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 128, 64};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 64.f, 128.f};
-    referenceFrame[FG_LAYER].mSwapCount++;
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 10, 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Bug36858924) {
-    // Destroy the child layer
-    mChild.clear();
-
-    // Now recreate it as hidden
-    mChild = mComposerClient->createSurface(String8("Child surface"), 10, 10,
-                                            PIXEL_FORMAT_RGBA_8888, ISurfaceComposerClient::eHidden,
-                                            mFGSurfaceControl.get());
-
-    // Show the child layer in a deferred transaction
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.deferTransactionUntil(mChild, mFGSurfaceControl->getHandle(), 
-                                      mFGSurfaceControl->getSurface()->getNextFrameNumber());
-        ts.show(mChild);
-    }
-
-    // Render the foreground surface a few times
-    //
-    // Prior to the bugfix for b/36858924, this would usually hang while trying to fill the third
-    // frame because SurfaceFlinger would never process the deferred transaction and would therefore
-    // never acquire/release the first buffer
-    ALOGI("Filling 1");
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-    ALOGI("Filling 2");
-    fillSurfaceRGBA8(mFGSurfaceControl, BLUE);
-    sFakeComposer->runVSyncAndWait();
-    ALOGI("Filling 3");
-    fillSurfaceRGBA8(mFGSurfaceControl, RED);
-    sFakeComposer->runVSyncAndWait();
-    ALOGI("Filling 4");
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-}
-
-class LatchingTest : public TransactionTest {
-protected:
-    void lockAndFillFGBuffer() { fillSurfaceRGBA8(mFGSurfaceControl, RED, false); }
-
-    void unlockFGBuffer() {
-        sp<Surface> s = mFGSurfaceControl->getSurface();
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-        sFakeComposer->runVSyncAndWait();
-    }
-
-    void completeFGResize() {
-        fillSurfaceRGBA8(mFGSurfaceControl, RED);
-        sFakeComposer->runVSyncAndWait();
-    }
-    void restoreInitialState() {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 64, 64);
-        ts.setPosition(mFGSurfaceControl, 64, 64);
-        ts.setCrop(mFGSurfaceControl, Rect(0, 0, 64, 64));
-        ts.setFinalCrop(mFGSurfaceControl, Rect(0, 0, -1, -1));
-    }
-};
-
-TEST_F(LatchingTest, SurfacePositionLatching) {
-    // By default position can be updated even while
-    // a resize is pending.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 32, 32);
-        ts.setPosition(mFGSurfaceControl, 100, 100);
-    }
-
-    // The size should not have updated as we have not provided a new buffer.
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{100, 100, 100 + 64, 100 + 64};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    // Now we repeat with setGeometryAppliesWithResize
-    // and verify the position DOESN'T latch.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setGeometryAppliesWithResize(mFGSurfaceControl);
-        ts.setSize(mFGSurfaceControl, 32, 32);
-        ts.setPosition(mFGSurfaceControl, 100, 100);
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{100, 100, 100 + 32, 100 + 32};
-    referenceFrame2[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 32.f, 32.f};
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(LatchingTest, CropLatching) {
-    // Normally the crop applies immediately even while a resize is pending.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-        ts.setCrop(mFGSurfaceControl, Rect(0, 0, 63, 63));
-    }
-
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 63, 64 + 63};
-    referenceFrame1[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 63.f, 63.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-        ts.setGeometryAppliesWithResize(mFGSurfaceControl);
-        ts.setCrop(mFGSurfaceControl, Rect(0, 0, 63, 63));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 63, 64 + 63};
-    referenceFrame2[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 63.f, 63.f};
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(LatchingTest, FinalCropLatching) {
-    // Normally the crop applies immediately even while a resize is pending.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-        ts.setFinalCrop(mFGSurfaceControl, Rect(64, 64, 127, 127));
-    }
-
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame1[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-        ts.setGeometryAppliesWithResize(mFGSurfaceControl);
-        ts.setFinalCrop(mFGSurfaceControl, Rect(64, 64, 127, 127));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame2[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-// In this test we ensure that setGeometryAppliesWithResize actually demands
-// a buffer of the new size, and not just any size.
-TEST_F(LatchingTest, FinalCropLatchingBufferOldSize) {
-    // Normally the crop applies immediately even while a resize is pending.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-        ts.setFinalCrop(mFGSurfaceControl, Rect(64, 64, 127, 127));
-    }
-
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame1[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    // In order to prepare to submit a buffer at the wrong size, we acquire it prior to
-    // initiating the resize.
-    lockAndFillFGBuffer();
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-        ts.setGeometryAppliesWithResize(mFGSurfaceControl);
-        ts.setFinalCrop(mFGSurfaceControl, Rect(64, 64, 127, 127));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    // We now submit our old buffer, at the old size, and ensure it doesn't
-    // trigger geometry latching.
-    unlockFGBuffer();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-    auto referenceFrame3 = referenceFrame2;
-    referenceFrame3[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame3[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    referenceFrame3[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame3, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(LatchingTest, FinalCropLatchingRegressionForb37531386) {
-    // In this scenario, we attempt to set the final crop a second time while the resize
-    // is still pending, and ensure we are successful. Success meaning the second crop
-    // is the one which eventually latches and not the first.
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setSize(mFGSurfaceControl, 128, 128);
-        ts.setGeometryAppliesWithResize(mFGSurfaceControl);
-        ts.setFinalCrop(mFGSurfaceControl, Rect(64, 64, 127, 127));
-    }
-
-    {
-        TransactionScope ts(*sFakeComposer);
-        ts.setFinalCrop(mFGSurfaceControl, Rect(0, 0, -1, -1));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-} // namespace
-
-int main(int argc, char** argv) {
-    ::testing::InitGoogleTest(&argc, argv);
-
-    sftest::FakeHwcEnvironment* fakeEnvironment = new sftest::FakeHwcEnvironment;
-    ::testing::AddGlobalTestEnvironment(fakeEnvironment);
-    ::testing::InitGoogleMock(&argc, argv);
-    return RUN_ALL_TESTS();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Android.bp b/services/surfaceflinger/tests/hwc2/Android.bp
deleted file mode 100644
index 0957d6a90..000000000
--- a/services/surfaceflinger/tests/hwc2/Android.bp
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_test {
-    name: "test-hwc2",
-    defaults: ["surfaceflinger_defaults"],
-    tags: ["test"],
-    cflags: [
-        "-DEGL_EGLEXT_PROTOTYPES",
-        "-DGL_GLEXT_PROTOTYPES",
-        "-fno-builtin",
-        "-fstack-protector-all",
-        "-g",
-        "-Wextra",
-    ],
-    srcs: [
-        "Hwc2Test.cpp",
-        "Hwc2TestProperties.cpp",
-        "Hwc2TestLayer.cpp",
-        "Hwc2TestLayers.cpp",
-        "Hwc2TestBuffer.cpp",
-        "Hwc2TestClientTarget.cpp",
-        "Hwc2TestVirtualDisplay.cpp",
-        "Hwc2TestPixelComparator.cpp",
-    ],
-    static_libs: [
-        "libadf",
-        "libadfhwc",
-        "libbase",
-        "libmath",
-    ],
-    shared_libs: [
-        "android.hardware.graphics.common@1.1",
-        "libcutils",
-        "libEGL",
-        "libGLESv2",
-        "libgui",
-        "libhardware",
-        "libhwui",
-        "liblog",
-        "libsync",
-        "libui",
-        "libutils",
-    ],
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2Test.cpp b/services/surfaceflinger/tests/hwc2/Hwc2Test.cpp
deleted file mode 100644
index 13774b4ed..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2Test.cpp
+++ /dev/null
@@ -1,4772 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <array>
-#include <unordered_set>
-#include <unordered_map>
-#include <gtest/gtest.h>
-#include <dlfcn.h>
-#include <android-base/unique_fd.h>
-#include <hardware/hardware.h>
-#include <sync/sync.h>
-#include <ui/GraphicTypes.h>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestLayer.h"
-#include "Hwc2TestLayers.h"
-#include "Hwc2TestClientTarget.h"
-#include "Hwc2TestVirtualDisplay.h"
-
-using android::ui::ColorMode;
-using android::ui::Dataspace;
-
-void hwc2TestHotplugCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int32_t connected);
-void hwc2TestVsyncCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int64_t timestamp);
-
-class Hwc2Test : public testing::Test {
-public:
-
-    virtual void SetUp()
-    {
-        hw_module_t const* hwc2Module;
-
-        int err = hw_get_module(HWC_HARDWARE_MODULE_ID, &hwc2Module);
-        ASSERT_GE(err, 0) << "failed to get hwc hardware module: "
-                << strerror(-err);
-
-        /* The following method will fail if you have not run
-         * "adb shell stop" */
-        err = hwc2_open(hwc2Module, &mHwc2Device);
-        ASSERT_GE(err, 0) << "failed to open hwc hardware module: "
-                << strerror(-err);
-
-        populateDisplays();
-    }
-
-    virtual void TearDown()
-    {
-
-        for (auto itr = mLayers.begin(); itr != mLayers.end();) {
-            hwc2_display_t display = itr->first;
-            hwc2_layer_t layer = itr->second;
-            itr++;
-            /* Destroys and removes the layer from mLayers */
-            destroyLayer(display, layer);
-        }
-
-        for (auto itr = mActiveDisplays.begin(); itr != mActiveDisplays.end();) {
-            hwc2_display_t display = *itr;
-            itr++;
-            /* Sets power mode to off and removes the display from
-             * mActiveDisplays */
-            setPowerMode(display, HWC2_POWER_MODE_OFF);
-        }
-
-        for (auto itr = mVirtualDisplays.begin(); itr != mVirtualDisplays.end();) {
-            hwc2_display_t display = *itr;
-            itr++;
-            /* Destroys virtual displays */
-            destroyVirtualDisplay(display);
-        }
-
-        if (mHwc2Device)
-            hwc2_close(mHwc2Device);
-    }
-
-    void registerCallback(hwc2_callback_descriptor_t descriptor,
-            hwc2_callback_data_t callbackData, hwc2_function_pointer_t pointer,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_REGISTER_CALLBACK>(
-                getFunction(HWC2_FUNCTION_REGISTER_CALLBACK));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, descriptor,
-                callbackData, pointer));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to register callback";
-        }
-    }
-
-    void getDisplayType(hwc2_display_t display, hwc2_display_type_t* outType,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_TYPE>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_TYPE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    reinterpret_cast<int32_t*>(outType)));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display type";
-        }
-    }
-
-    /* If the populateDisplays function is still receiving displays and the
-     * display is connected, the display handle is stored in mDisplays. */
-    void hotplugCallback(hwc2_display_t display, int32_t connected)
-    {
-        std::lock_guard<std::mutex> lock(mHotplugMutex);
-
-        if (mHotplugStatus != Hwc2TestHotplugStatus::Receiving)
-            return;
-
-        if (connected == HWC2_CONNECTION_CONNECTED)
-            mDisplays.insert(display);
-
-        mHotplugCv.notify_all();
-    }
-
-    void createLayer(hwc2_display_t display, hwc2_layer_t* outLayer,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_CREATE_LAYER>(
-                getFunction(HWC2_FUNCTION_CREATE_LAYER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outLayer));
-
-        if (err == HWC2_ERROR_NONE)
-            mLayers.insert(std::make_pair(display, *outLayer));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to create layer";
-        }
-    }
-
-    void destroyLayer(hwc2_display_t display, hwc2_layer_t layer,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_DESTROY_LAYER>(
-                getFunction(HWC2_FUNCTION_DESTROY_LAYER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer));
-
-        if (err == HWC2_ERROR_NONE)
-            mLayers.erase(std::make_pair(display, layer));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to destroy layer "
-                    << layer;
-        }
-    }
-
-    void getDisplayAttribute(hwc2_display_t display, hwc2_config_t config,
-            hwc2_attribute_t attribute, int32_t* outValue,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_ATTRIBUTE>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_ATTRIBUTE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, config,
-                attribute, outValue));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display attribute "
-                    << getAttributeName(attribute) << " for config " << config;
-        }
-    }
-
-    void getDisplayConfigs(hwc2_display_t display,
-            std::vector<hwc2_config_t>* outConfigs,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_CONFIGS>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_CONFIGS));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numConfigs = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numConfigs, nullptr));
-
-        if (err == HWC2_ERROR_NONE) {
-            outConfigs->resize(numConfigs);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numConfigs, outConfigs->data()));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get configs for"
-                    " display " << display;
-        }
-    }
-
-    void getActiveConfig(hwc2_display_t display, hwc2_config_t* outConfig,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_ACTIVE_CONFIG>(
-                getFunction(HWC2_FUNCTION_GET_ACTIVE_CONFIG));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outConfig));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get active config on"
-                    " display " << display;
-        }
-    }
-
-    void setActiveConfig(hwc2_display_t display, hwc2_config_t config,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_ACTIVE_CONFIG>(
-                getFunction(HWC2_FUNCTION_SET_ACTIVE_CONFIG));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, config));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set active config "
-                    << config;
-        }
-    }
-
-    void getDozeSupport(hwc2_display_t display, int32_t* outSupport,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DOZE_SUPPORT>(
-                getFunction(HWC2_FUNCTION_GET_DOZE_SUPPORT));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outSupport));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get doze support on"
-                    " display " << display;
-        }
-    }
-
-    void setPowerMode(hwc2_display_t display, hwc2_power_mode_t mode,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_POWER_MODE>(
-                getFunction(HWC2_FUNCTION_SET_POWER_MODE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                mode));
-        if (outErr) {
-            *outErr = err;
-            if (err != HWC2_ERROR_NONE)
-                return;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set power mode "
-                    << getPowerModeName(mode) << " on display " << display;
-        }
-
-        if (mode == HWC2_POWER_MODE_OFF) {
-            mActiveDisplays.erase(display);
-        } else {
-            mActiveDisplays.insert(display);
-        }
-    }
-
-    void setVsyncEnabled(hwc2_display_t display, hwc2_vsync_t enabled,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_VSYNC_ENABLED>(
-                getFunction(HWC2_FUNCTION_SET_VSYNC_ENABLED));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                enabled));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set vsync enabled "
-                    << getVsyncName(enabled);
-        }
-    }
-
-    void vsyncCallback(hwc2_display_t display, int64_t timestamp)
-    {
-        std::lock_guard<std::mutex> lock(mVsyncMutex);
-        mVsyncDisplay = display;
-        mVsyncTimestamp = timestamp;
-        mVsyncCv.notify_all();
-    }
-
-    void getDisplayName(hwc2_display_t display, std::string* outName,
-                hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_NAME>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_NAME));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t size = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, &size,
-                nullptr));
-
-        if (err == HWC2_ERROR_NONE) {
-            std::vector<char> name(size);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, &size,
-                    name.data()));
-
-            outName->assign(name.data());
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display name for "
-                    << display;
-        }
-    }
-
-    void setLayerCompositionType(hwc2_display_t display, hwc2_layer_t layer,
-            hwc2_composition_t composition, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_COMPOSITION_TYPE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_COMPOSITION_TYPE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                composition));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer composition"
-                    " type " << getCompositionName(composition);
-        }
-    }
-
-    void setCursorPosition(hwc2_display_t display, hwc2_layer_t layer,
-            int32_t x, int32_t y, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_CURSOR_POSITION>(
-                getFunction(HWC2_FUNCTION_SET_CURSOR_POSITION));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer, x,
-                y));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_TRUE((err == HWC2_ERROR_NONE) ||
-                (err == HWC2_ERROR_BAD_LAYER)) <<
-                "failed to set cursor position";
-        }
-    }
-
-    void setLayerBlendMode(hwc2_display_t display, hwc2_layer_t layer,
-            hwc2_blend_mode_t mode, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_BLEND_MODE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_BLEND_MODE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                mode));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer blend mode "
-                    << getBlendModeName(mode);
-        }
-    }
-
-    void setLayerBuffer(hwc2_display_t display, hwc2_layer_t layer,
-            buffer_handle_t buffer, int32_t acquireFence,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_BUFFER>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_BUFFER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                buffer, acquireFence));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer buffer";
-        }
-    }
-
-    void setLayerColor(hwc2_display_t display, hwc2_layer_t layer,
-            hwc_color_t color, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_COLOR>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_COLOR));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                color));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer color";
-        }
-    }
-
-    void setLayerDataspace(hwc2_display_t display, hwc2_layer_t layer,
-            Dataspace dataspace, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_DATASPACE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_DATASPACE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                layer, static_cast<int>(dataspace)));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer dataspace";
-        }
-    }
-
-    void setLayerDisplayFrame(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_rect_t& displayFrame, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_DISPLAY_FRAME>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_DISPLAY_FRAME));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                displayFrame));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer display"
-                    " frame";
-        }
-    }
-
-    void setLayerPlaneAlpha(hwc2_display_t display, hwc2_layer_t layer,
-            float alpha, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_PLANE_ALPHA>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_PLANE_ALPHA));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                alpha));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer plane alpha "
-                    << alpha;
-        }
-    }
-
-    void setLayerSourceCrop(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_frect_t& sourceCrop, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_SOURCE_CROP>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_SOURCE_CROP));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                sourceCrop));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer source crop";
-        }
-    }
-
-    void setLayerSurfaceDamage(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_region_t& surfaceDamage, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_SURFACE_DAMAGE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_SURFACE_DAMAGE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                surfaceDamage));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer surface"
-                    " damage";
-        }
-    }
-
-    void setLayerTransform(hwc2_display_t display, hwc2_layer_t layer,
-            hwc_transform_t transform, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_TRANSFORM>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_TRANSFORM));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                transform));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer transform "
-                    << getTransformName(transform);
-        }
-    }
-
-    void setLayerVisibleRegion(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_region_t& visibleRegion, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_VISIBLE_REGION>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_VISIBLE_REGION));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                visibleRegion));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer visible"
-                    " region";
-        }
-    }
-
-    void setLayerZOrder(hwc2_display_t display, hwc2_layer_t layer,
-            uint32_t zOrder, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_Z_ORDER>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_Z_ORDER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                zOrder));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer z order "
-                    << zOrder;
-        }
-    }
-
-    void validateDisplay(hwc2_display_t display, uint32_t* outNumTypes,
-            uint32_t* outNumRequests, hwc2_error_t* outErr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_VALIDATE_DISPLAY>(
-                getFunction(HWC2_FUNCTION_VALIDATE_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        *outErr = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outNumTypes, outNumRequests));
-    }
-
-    void validateDisplay(hwc2_display_t display, uint32_t* outNumTypes,
-            uint32_t* outNumRequests, bool* outHasChanges)
-    {
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        EXPECT_NO_FATAL_FAILURE(validateDisplay(display, outNumTypes,
-                outNumRequests, &err));
-
-        if (err != HWC2_ERROR_HAS_CHANGES) {
-            *outHasChanges = false;
-            EXPECT_EQ(err, HWC2_ERROR_NONE) << "failed to validate display";
-        } else {
-            *outHasChanges = true;
-        }
-    }
-
-    void getDisplayRequests(hwc2_display_t display,
-            hwc2_display_request_t* outDisplayRequests,
-            std::vector<hwc2_layer_t>* outLayers,
-            std::vector<hwc2_layer_request_t>* outLayerRequests,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_REQUESTS>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_REQUESTS));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numElements = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                reinterpret_cast<int32_t*>(outDisplayRequests), &numElements,
-                nullptr, nullptr));
-
-        if (err == HWC2_ERROR_NONE && numElements > 0) {
-            outLayers->resize(numElements);
-            outLayerRequests->resize(numElements);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    reinterpret_cast<int32_t*>(outDisplayRequests), &numElements,
-                    reinterpret_cast<uint64_t*>(outLayers->data()),
-                    reinterpret_cast<int32_t*>(outLayerRequests->data())));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display requests";
-        }
-    }
-
-    void handleRequests(hwc2_display_t display,
-            const std::vector<hwc2_layer_t>& layers, uint32_t numRequests,
-            std::set<hwc2_layer_t>* outClearLayers = nullptr,
-            bool* outFlipClientTarget = nullptr)
-    {
-        hwc2_display_request_t displayRequest =
-                static_cast<hwc2_display_request_t>(0);
-        std::vector<hwc2_layer_t> requestedLayers;
-        std::vector<hwc2_layer_request_t> requests;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayRequests(display, &displayRequest,
-                &requestedLayers, &requests));
-
-        EXPECT_EQ(numRequests, requests.size()) << "validate returned "
-                << numRequests << " requests and get display requests returned "
-                << requests.size() << " requests";
-
-        for (size_t i = 0; i < requests.size(); i++) {
-            hwc2_layer_t requestedLayer = requestedLayers.at(i);
-            hwc2_layer_request_t request = requests.at(i);
-
-            EXPECT_EQ(std::count(layers.begin(), layers.end(), requestedLayer),
-                    1) << "get display requests returned an unknown layer";
-            EXPECT_NE(request, 0) << "returned empty request for layer "
-                    << requestedLayer;
-
-            if (outClearLayers && request
-                    == HWC2_LAYER_REQUEST_CLEAR_CLIENT_TARGET)
-                outClearLayers->insert(requestedLayer);
-        }
-
-        if (outFlipClientTarget)
-            *outFlipClientTarget = displayRequest
-                    & HWC2_DISPLAY_REQUEST_FLIP_CLIENT_TARGET;
-    }
-
-    void getChangedCompositionTypes(hwc2_display_t display,
-            std::vector<hwc2_layer_t>* outLayers,
-            std::vector<hwc2_composition_t>* outTypes,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_CHANGED_COMPOSITION_TYPES>(
-                getFunction(HWC2_FUNCTION_GET_CHANGED_COMPOSITION_TYPES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numElements = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numElements, nullptr, nullptr));
-
-        if (err == HWC2_ERROR_NONE && numElements > 0) {
-            outLayers->resize(numElements);
-            outTypes->resize(numElements);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numElements, reinterpret_cast<uint64_t*>(outLayers->data()),
-                    reinterpret_cast<int32_t*>(outTypes->data())));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get changed"
-                    " composition types";
-        }
-    }
-
-    void handleCompositionChanges(hwc2_display_t display,
-            const Hwc2TestLayers& testLayers,
-            const std::vector<hwc2_layer_t>& layers, uint32_t numTypes,
-            std::set<hwc2_layer_t>* outClientLayers = nullptr)
-    {
-        std::vector<hwc2_layer_t> changedLayers;
-        std::vector<hwc2_composition_t> types;
-
-        ASSERT_NO_FATAL_FAILURE(getChangedCompositionTypes(display,
-                &changedLayers, &types));
-
-        EXPECT_EQ(numTypes, types.size()) << "validate returned "
-                << numTypes << " types and get changed composition types"
-                " returned " << types.size() << " types";
-
-        for (size_t i = 0; i < types.size(); i++) {
-
-            auto layer = std::find(layers.begin(), layers.end(),
-                    changedLayers.at(i));
-
-            EXPECT_TRUE(layer != layers.end() || !testLayers.contains(*layer))
-                    << "get changed composition types returned an unknown layer";
-
-            hwc2_composition_t requestedType = testLayers.getComposition(*layer);
-            hwc2_composition_t returnedType = types.at(i);
-
-            EXPECT_NE(returnedType, HWC2_COMPOSITION_INVALID) << "get changed"
-                    " composition types returned invalid composition";
-
-            switch (requestedType) {
-            case HWC2_COMPOSITION_CLIENT:
-                EXPECT_TRUE(false) << getCompositionName(returnedType)
-                        << " cannot be changed";
-                break;
-            case HWC2_COMPOSITION_DEVICE:
-            case HWC2_COMPOSITION_SOLID_COLOR:
-                EXPECT_EQ(returnedType, HWC2_COMPOSITION_CLIENT)
-                        << "composition of type "
-                        << getCompositionName(requestedType)
-                        << " can only be changed to "
-                        << getCompositionName(HWC2_COMPOSITION_CLIENT);
-                break;
-            case HWC2_COMPOSITION_CURSOR:
-            case HWC2_COMPOSITION_SIDEBAND:
-                EXPECT_TRUE(returnedType == HWC2_COMPOSITION_CLIENT
-                        || returnedType == HWC2_COMPOSITION_DEVICE)
-                        << "composition of type "
-                        << getCompositionName(requestedType)
-                        << " can only be changed to "
-                        << getCompositionName(HWC2_COMPOSITION_CLIENT) << " or "
-                        << getCompositionName(HWC2_COMPOSITION_DEVICE);
-                break;
-            default:
-                EXPECT_TRUE(false) << "unknown type "
-                        << getCompositionName(requestedType);
-                break;
-            }
-
-            if (outClientLayers)
-                if (returnedType == HWC2_COMPOSITION_CLIENT)
-                    outClientLayers->insert(*layer);
-        }
-
-        if (outClientLayers) {
-            for (auto layer : layers) {
-                if (testLayers.getComposition(layer) == HWC2_COMPOSITION_CLIENT)
-                    outClientLayers->insert(layer);
-            }
-        }
-    }
-
-    void acceptDisplayChanges(hwc2_display_t display,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_ACCEPT_DISPLAY_CHANGES>(
-                getFunction(HWC2_FUNCTION_ACCEPT_DISPLAY_CHANGES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to accept display changes";
-        }
-    }
-
-    void getClientTargetSupport(hwc2_display_t display, int32_t width,
-            int32_t height, android_pixel_format_t format,
-            Dataspace dataspace, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_CLIENT_TARGET_SUPPORT>(
-                getFunction(HWC2_FUNCTION_GET_CLIENT_TARGET_SUPPORT));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, width,
-                height, format, static_cast<int>(dataspace)));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get client target"
-                    " support";
-        }
-    }
-
-    void setClientTarget(hwc2_display_t display, buffer_handle_t handle,
-            int32_t acquireFence, Dataspace dataspace,
-            hwc_region_t damage, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_CLIENT_TARGET>(
-                getFunction(HWC2_FUNCTION_SET_CLIENT_TARGET));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, handle,
-                acquireFence, static_cast<int>(dataspace), damage));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set client target";
-        }
-    }
-
-    void presentDisplay(hwc2_display_t display, int32_t* outPresentFence,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_PRESENT_DISPLAY>(
-                getFunction(HWC2_FUNCTION_PRESENT_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outPresentFence));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to present display";
-        }
-    }
-
-    void getReleaseFences(hwc2_display_t display,
-            std::vector<hwc2_layer_t>* outLayers,
-            std::vector<int32_t>* outFences, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_RELEASE_FENCES>(
-                getFunction(HWC2_FUNCTION_GET_RELEASE_FENCES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numElements = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numElements, nullptr, nullptr));
-
-        if (err == HWC2_ERROR_NONE) {
-            outLayers->resize(numElements);
-            outFences->resize(numElements);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numElements, outLayers->data(), outFences->data()));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get release fences";
-        }
-    }
-
-    void getColorModes(hwc2_display_t display,
-            std::vector<ColorMode>* outColorModes,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_COLOR_MODES>(
-                getFunction(HWC2_FUNCTION_GET_COLOR_MODES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numColorModes = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numColorModes, nullptr));
-        if (err == HWC2_ERROR_NONE) {
-            outColorModes->resize(numColorModes);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numColorModes,
-                    reinterpret_cast<int32_t*>(outColorModes->data())));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get color modes for"
-                    " display " << display;
-        }
-    }
-
-    void setColorMode(hwc2_display_t display, ColorMode colorMode,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_COLOR_MODE>(
-                getFunction(HWC2_FUNCTION_SET_COLOR_MODE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                static_cast<int32_t>(colorMode)));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set color mode "
-                    << static_cast<int>(colorMode);
-        }
-    }
-
-    void getHdrCapabilities(hwc2_display_t display,
-            std::vector<android_hdr_t>* outTypes, float* outMaxLuminance,
-            float* outMaxAverageLuminance, float* outMinLuminance,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_HDR_CAPABILITIES>(
-                getFunction(HWC2_FUNCTION_GET_HDR_CAPABILITIES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numTypes = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numTypes, nullptr, outMaxLuminance, outMaxAverageLuminance,
-                outMinLuminance));
-
-        if (err == HWC2_ERROR_NONE) {
-            outTypes->resize(numTypes);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, &numTypes,
-                    reinterpret_cast<int32_t*>(outTypes->data()), outMaxLuminance,
-                    outMaxAverageLuminance, outMinLuminance));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get hdr capabilities"
-                    " for display " << display;
-        }
-    }
-
-    void setColorTransform(hwc2_display_t display,
-            const std::array<float, 16>& matrix, android_color_transform_t hint,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_COLOR_TRANSFORM>(
-                getFunction(HWC2_FUNCTION_SET_COLOR_TRANSFORM));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                matrix.data(), hint));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set color transform "
-                    << hint;
-        }
-    }
-
-    void createVirtualDisplay(uint32_t width, uint32_t height,
-            android_pixel_format_t* outFormat, hwc2_display_t* outDisplay,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_CREATE_VIRTUAL_DISPLAY>(
-                getFunction(HWC2_FUNCTION_CREATE_VIRTUAL_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, width, height,
-                reinterpret_cast<int32_t*>(outFormat), outDisplay));
-
-        if (err == HWC2_ERROR_NONE)
-            mVirtualDisplays.insert(*outDisplay);
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to create virtual display";
-        }
-    }
-
-    void destroyVirtualDisplay(hwc2_display_t display,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_DESTROY_VIRTUAL_DISPLAY>(
-                getFunction(HWC2_FUNCTION_DESTROY_VIRTUAL_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display));
-
-        if (err == HWC2_ERROR_NONE)
-            mVirtualDisplays.erase(display);
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to destroy virtual display";
-        }
-    }
-
-    void getMaxVirtualDisplayCount(uint32_t* outMaxCnt)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_MAX_VIRTUAL_DISPLAY_COUNT>(
-                getFunction(HWC2_FUNCTION_GET_MAX_VIRTUAL_DISPLAY_COUNT));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        *outMaxCnt = pfn(mHwc2Device);
-    }
-
-    void setOutputBuffer(hwc2_display_t display, buffer_handle_t buffer,
-            int32_t releaseFence, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_OUTPUT_BUFFER>(
-                getFunction(HWC2_FUNCTION_SET_OUTPUT_BUFFER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, buffer,
-                releaseFence));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set output buffer";
-        }
-    }
-
-    void dump(std::string* outBuffer)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_DUMP>(
-                getFunction(HWC2_FUNCTION_DUMP));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t size = 0;
-
-        pfn(mHwc2Device, &size, nullptr);
-
-        std::vector<char> buffer(size);
-
-        pfn(mHwc2Device, &size, buffer.data());
-
-        outBuffer->assign(buffer.data());
-    }
-
-    void getBadDisplay(hwc2_display_t* outDisplay)
-    {
-        for (hwc2_display_t display = 0; display < UINT64_MAX; display++) {
-            if (mDisplays.count(display) == 0) {
-                *outDisplay = display;
-                return;
-            }
-        }
-        ASSERT_TRUE(false) << "Unable to find bad display. UINT64_MAX displays"
-                " are registered. This should never happen.";
-    }
-
-    void waitForVsync(hwc2_display_t* outDisplay = nullptr,
-            int64_t* outTimestamp = nullptr)
-    {
-        std::unique_lock<std::mutex> lock(mVsyncMutex);
-        ASSERT_EQ(mVsyncCv.wait_for(lock, std::chrono::seconds(3)),
-                std::cv_status::no_timeout) << "timed out attempting to get"
-                " vsync callback";
-        if (outDisplay)
-            *outDisplay = mVsyncDisplay;
-        if (outTimestamp)
-            *outTimestamp = mVsyncTimestamp;
-    }
-
-    void enableVsync(hwc2_display_t display)
-    {
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, this,
-                reinterpret_cast<hwc2_function_pointer_t>(
-                hwc2TestVsyncCallback)));
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-    }
-
-    void disableVsync(hwc2_display_t display)
-    {
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-    }
-
-protected:
-    hwc2_function_pointer_t getFunction(hwc2_function_descriptor_t descriptor)
-    {
-        return mHwc2Device->getFunction(mHwc2Device, descriptor);
-    }
-
-    void getCapabilities(std::vector<hwc2_capability_t>* outCapabilities)
-    {
-        uint32_t num = 0;
-
-        mHwc2Device->getCapabilities(mHwc2Device, &num, nullptr);
-
-        outCapabilities->resize(num);
-
-        mHwc2Device->getCapabilities(mHwc2Device, &num,
-                reinterpret_cast<int32_t*>(outCapabilities->data()));
-    }
-
-    /* Registers a hotplug callback and waits for hotplug callbacks. This
-     * function will have no effect if called more than once. */
-    void populateDisplays()
-    {
-        /* Sets the hotplug status to receiving */
-        {
-            std::lock_guard<std::mutex> lock(mHotplugMutex);
-
-            if (mHotplugStatus != Hwc2TestHotplugStatus::Init)
-                return;
-            mHotplugStatus = Hwc2TestHotplugStatus::Receiving;
-        }
-
-        /* Registers the callback. This function call cannot be locked because
-         * a callback could happen on the same thread */
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_HOTPLUG, this,
-                reinterpret_cast<hwc2_function_pointer_t>(
-                hwc2TestHotplugCallback)));
-
-        /* Waits for hotplug events. If a hotplug event has not come within 1
-         * second, stop waiting. */
-        std::unique_lock<std::mutex> lock(mHotplugMutex);
-
-        while (mHotplugCv.wait_for(lock, std::chrono::seconds(1)) !=
-                std::cv_status::timeout) { }
-
-        /* Sets the hotplug status to done. Future calls will have no effect */
-        mHotplugStatus = Hwc2TestHotplugStatus::Done;
-    }
-
-    /* NOTE: will create min(newlayerCnt, max supported layers) layers */
-    void createLayers(hwc2_display_t display,
-            std::vector<hwc2_layer_t>* outLayers, size_t newLayerCnt)
-    {
-        std::vector<hwc2_layer_t> newLayers;
-        hwc2_layer_t layer;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        for (size_t i = 0; i < newLayerCnt; i++) {
-
-            EXPECT_NO_FATAL_FAILURE(createLayer(display, &layer, &err));
-            if (err == HWC2_ERROR_NO_RESOURCES)
-                break;
-            if (err != HWC2_ERROR_NONE) {
-                newLayers.clear();
-                ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to create layer";
-            }
-            newLayers.push_back(layer);
-        }
-
-        *outLayers = std::move(newLayers);
-    }
-
-    void destroyLayers(hwc2_display_t display,
-            std::vector<hwc2_layer_t>&& layers)
-    {
-        for (hwc2_layer_t layer : layers) {
-            EXPECT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-        }
-    }
-
-    void getInvalidConfig(hwc2_display_t display, hwc2_config_t* outConfig)
-    {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        hwc2_config_t CONFIG_MAX = UINT32_MAX;
-
-        ASSERT_LE(configs.size() - 1, CONFIG_MAX) << "every config value"
-                " (2^32 values) has been taken which shouldn't happen";
-
-        hwc2_config_t config;
-        for (config = 0; config < CONFIG_MAX; config++) {
-            if (std::count(configs.begin(), configs.end(), config) == 0)
-                break;
-        }
-
-        *outConfig = config;
-    }
-
-    /* Calls a set property function from Hwc2Test to set a property value from
-     * Hwc2TestLayer to hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertyFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayer* testLayer, hwc2_error_t* outErr);
-
-    /* Calls a set property function from Hwc2Test to set property values from
-     * Hwc2TestLayers to hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertiesFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayers* testLayers);
-
-    /* Calls a set property function from Hwc2Test to set a bad property value
-     * on hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertyBadLayerFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayer* testLayer, hwc2_error_t* outErr);
-
-    /* Calls a set property function from Hwc2Test to set a bad property value
-     * on hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertyBadParameterFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer, hwc2_error_t* outErr);
-
-    /* Is called after a display is powered on and all layer properties have
-     * been set. It should be used to test functions such as validate, accepting
-     * changes, present, etc. */
-    using TestDisplayLayersFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestLayers* testLayers);
-
-    /* It is called on an non validated display */
-    using TestDisplayNonValidatedLayersFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, std::vector<hwc2_layer_t>* layers);
-
-    /* Tests client target support on a particular display and config */
-    using TestClientTargetSupportFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display,
-            const Hwc2TestClientTargetSupport& testClientTargetSupport);
-
-    /* Tests a particular active display config */
-    using TestActiveDisplayConfigFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display);
-
-    /* Tests a newly created virtual display */
-    using TestCreateVirtualDisplayFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, Hwc2TestVirtualDisplay* testVirtualDisplay);
-
-    /* Advances a property of Hwc2TestLayer */
-    using AdvanceProperty = bool (*)(Hwc2TestLayer* testLayer);
-
-    /* Advances properties of Hwc2TestLayers */
-    using AdvanceProperties = bool (*)(Hwc2TestLayers* testLayer);
-
-    /* Advances properties of Hwc2TestClientTargetSupport */
-    using AdvanceClientTargetSupport = bool (*)(
-            Hwc2TestClientTargetSupport* testClientTargetSupport);
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates a layer, sets the property and then
-     * destroys the layer */
-    void setLayerProperty(Hwc2TestCoverage coverage,
-            TestLayerPropertyFunction function, AdvanceProperty advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer;
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestLayer testLayer(coverage, displayArea);
-
-                do {
-                    ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                    ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                            &testLayer, nullptr));
-
-                    ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-                } while (advance(&testLayer));
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates a layer, cycles through each property
-     * value and updates the layer property value and then destroys the layer */
-    void setLayerPropertyUpdate(Hwc2TestCoverage coverage,
-            TestLayerPropertyFunction function, AdvanceProperty advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer;
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestLayer testLayer(coverage, displayArea);
-
-                ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                do {
-                    ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                            &testLayer, nullptr));
-                } while (advance(&testLayer));
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates multiple layers, calls the
-     * TestLayerPropertiesFunction to set property values and then
-     * destroys the layers */
-    void setLayerProperties(Hwc2TestCoverage coverage, size_t layerCnt,
-            TestLayerPropertiesFunction function, AdvanceProperties advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                std::vector<hwc2_layer_t> layers;
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-
-                ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-                Hwc2TestLayers testLayers(layers, coverage, displayArea);
-
-                do {
-                    for (auto layer : layers) {
-                        EXPECT_NO_FATAL_FAILURE(function(this, display, layer,
-                                &testLayers));
-                    }
-                } while (advance(&testLayers));
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config.
-     * 1) It attempts to set a valid property value to bad layer handle.
-     * 2) It creates a layer x and attempts to set a valid property value to
-     *    layer x + 1
-     * 3) It destroys the layer x and attempts to set a valid property value to
-     *    the destroyed layer x.
-     */
-    void setLayerPropertyBadLayer(Hwc2TestCoverage coverage,
-            TestLayerPropertyBadLayerFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer = 0;
-                Area displayArea;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestLayer testLayer(coverage, displayArea);
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                        &testLayer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-                ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer + 1,
-                        &testLayer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                        &testLayer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates a layer, sets a bad property value and
-     * then destroys the layer */
-    void setLayerPropertyBadParameter(TestLayerPropertyBadParameterFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-
-                ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong"
-                        " error code";
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-            }
-        }
-    }
-
-    /* For each active display it powers on the display, cycles through each
-     * config and creates a set of layers with a certain amount of coverage.
-     * For each active display, for each config and for each set of layers,
-     * it calls the TestDisplayLayersFunction */
-    void displayLayers(Hwc2TestCoverage coverage, size_t layerCnt,
-            TestDisplayLayersFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                Area displayArea;
-                std::vector<hwc2_layer_t> layers;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display, &displayArea));
-
-                ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-                Hwc2TestLayers testLayers(layers, coverage, displayArea);
-
-                do {
-                    bool skip;
-
-                    ASSERT_NO_FATAL_FAILURE(setLayerProperties(display, layers,
-                            &testLayers, &skip));
-                    if (!skip)
-                        EXPECT_NO_FATAL_FAILURE(function(this, display, layers,
-                                &testLayers));
-
-                } while (testLayers.advance());
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayers(display,
-                        std::move(layers)));
-            }
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        }
-    }
-
-    /* For each active display, it calls the
-     * TestDisplayNonValidatedLayersFunction on a variety on non-validated
-     * layer combinations */
-    void displayNonValidatedLayers(size_t layerCnt,
-            TestDisplayNonValidatedLayersFunction function)
-    {
-        for (auto display : mDisplays) {
-            uint32_t numTypes, numRequests;
-            std::vector<hwc2_layer_t> layers;
-            bool hasChanges;
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            for (auto layer : layers) {
-                ASSERT_NO_FATAL_FAILURE(setLayerCompositionType(display, layer,
-                        HWC2_COMPOSITION_CLIENT));
-            }
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes,
-                    &numRequests, &hasChanges));
-
-            for (auto layer : layers) {
-                ASSERT_NO_FATAL_FAILURE(setLayerCompositionType(display, layer,
-                        HWC2_COMPOSITION_DEVICE));
-            }
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        }
-    }
-
-    /* Test client target support on each config on each active display */
-    void setClientTargetSupport(Hwc2TestCoverage coverage,
-            TestClientTargetSupportFunction function,
-            AdvanceClientTargetSupport advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestClientTargetSupport testClientTargetSupport(coverage,
-                        displayArea);
-
-                do {
-                    EXPECT_NO_FATAL_FAILURE(function(this, display,
-                            testClientTargetSupport));
-
-                } while (advance(&testClientTargetSupport));
-            }
-        }
-    }
-
-    /* Cycles through each config on each active display and calls
-     * a TestActiveDisplayConfigFunction */
-    void setActiveDisplayConfig(TestActiveDisplayConfigFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-
-                EXPECT_NO_FATAL_FAILURE(function(this, display));
-            }
-        }
-    }
-
-    /* Creates a virtual display for testing */
-    void createVirtualDisplay(Hwc2TestCoverage coverage,
-            TestCreateVirtualDisplayFunction function)
-    {
-        Hwc2TestVirtualDisplay testVirtualDisplay(coverage);
-
-        do {
-            hwc2_display_t display;
-            hwc2_error_t err = HWC2_ERROR_NONE;
-
-            const UnsignedArea& dimension =
-                    testVirtualDisplay.getDisplayDimension();
-            android_pixel_format_t desiredFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-
-            ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(dimension.width,
-                    dimension.height, &desiredFormat, &display, &err));
-
-            EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_NO_RESOURCES
-                    || err == HWC2_ERROR_UNSUPPORTED)
-                    << "returned wrong error code";
-            EXPECT_GE(desiredFormat, 0) << "invalid format";
-
-            if (err != HWC2_ERROR_NONE)
-                continue;
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display,
-                    &testVirtualDisplay));
-
-            ASSERT_NO_FATAL_FAILURE(destroyVirtualDisplay(display));
-
-        } while (testVirtualDisplay.advance());
-    }
-
-
-    void getActiveConfigAttribute(hwc2_display_t display,
-            hwc2_attribute_t attribute, int32_t* outValue)
-    {
-        hwc2_config_t config;
-        ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &config));
-        ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                attribute, outValue));
-        ASSERT_GE(*outValue, 0) << "failed to get valid "
-                << getAttributeName(attribute);
-    }
-
-    void getActiveDisplayArea(hwc2_display_t display, Area* displayArea)
-    {
-        ASSERT_NO_FATAL_FAILURE(getActiveConfigAttribute(display,
-                HWC2_ATTRIBUTE_WIDTH, &displayArea->width));
-        ASSERT_NO_FATAL_FAILURE(getActiveConfigAttribute(display,
-                HWC2_ATTRIBUTE_HEIGHT, &displayArea->height));
-    }
-
-    void closeFences(hwc2_display_t display, int32_t presentFence)
-    {
-        std::vector<hwc2_layer_t> layers;
-        std::vector<int32_t> fences;
-        const int msWait = 3000;
-
-        if (presentFence >= 0) {
-            ASSERT_GE(sync_wait(presentFence, msWait), 0);
-            close(presentFence);
-        }
-
-        ASSERT_NO_FATAL_FAILURE(getReleaseFences(display, &layers, &fences));
-        EXPECT_EQ(layers.size(), fences.size());
-
-        for (int32_t fence : fences) {
-            if (fence >= 0) {
-                EXPECT_GE(sync_wait(fence, msWait), 0);
-                close(fence);
-            }
-        }
-    }
-
-    void setLayerProperties(hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayers* testLayers, bool* outSkip)
-    {
-        hwc2_composition_t composition;
-        buffer_handle_t handle = nullptr;
-        int32_t acquireFence;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-        *outSkip = true;
-
-        if (!testLayers->contains(layer))
-            return;
-
-        composition = testLayers->getComposition(layer);
-
-        /* If the device cannot support a buffer format, then do not continue */
-        if ((composition == HWC2_COMPOSITION_DEVICE
-                || composition == HWC2_COMPOSITION_CURSOR)
-                && testLayers->getBuffer(layer, &handle, &acquireFence) < 0)
-            return;
-
-        EXPECT_NO_FATAL_FAILURE(setLayerCompositionType(display, layer,
-                composition, &err));
-        if (err == HWC2_ERROR_UNSUPPORTED)
-            EXPECT_TRUE(composition != HWC2_COMPOSITION_CLIENT
-                    && composition != HWC2_COMPOSITION_DEVICE);
-
-        const hwc_rect_t cursor = testLayers->getCursorPosition(layer);
-
-        EXPECT_NO_FATAL_FAILURE(setLayerBuffer(display, layer, handle,
-                acquireFence));
-        EXPECT_NO_FATAL_FAILURE(setLayerBlendMode(display, layer,
-                testLayers->getBlendMode(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerColor(display, layer,
-                testLayers->getColor(layer)));
-        if (composition == HWC2_COMPOSITION_CURSOR)
-            EXPECT_NO_FATAL_FAILURE(setCursorPosition(display, layer,
-            cursor.left, cursor.top));
-        EXPECT_NO_FATAL_FAILURE(setLayerDataspace(display, layer,
-                testLayers->getDataspace(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerDisplayFrame(display, layer,
-                testLayers->getDisplayFrame(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerPlaneAlpha(display, layer,
-                testLayers->getPlaneAlpha(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerSourceCrop(display, layer,
-                testLayers->getSourceCrop(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerSurfaceDamage(display, layer,
-                testLayers->getSurfaceDamage(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerTransform(display, layer,
-                testLayers->getTransform(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerVisibleRegion(display, layer,
-                testLayers->getVisibleRegion(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerZOrder(display, layer,
-                testLayers->getZOrder(layer)));
-
-        *outSkip = false;
-    }
-
-    void setLayerProperties(hwc2_display_t display,
-            const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestLayers* testLayers, bool* outSkip)
-    {
-        for (auto layer : layers) {
-            EXPECT_NO_FATAL_FAILURE(setLayerProperties(display, layer,
-                    testLayers, outSkip));
-            if (*outSkip)
-                return;
-        }
-    }
-
-    void setClientTarget(hwc2_display_t display,
-            Hwc2TestClientTarget* testClientTarget,
-            const Hwc2TestLayers& testLayers,
-            const std::set<hwc2_layer_t>& clientLayers,
-            const std::set<hwc2_layer_t>& clearLayers, bool flipClientTarget,
-            const Area& displayArea)
-    {
-        Dataspace dataspace = Dataspace::UNKNOWN;
-        hwc_region_t damage = { };
-        buffer_handle_t handle;
-        int32_t acquireFence;
-
-        ASSERT_EQ(testClientTarget->getBuffer(testLayers, clientLayers,
-                clearLayers, flipClientTarget, displayArea, &handle,
-                &acquireFence), 0);
-        EXPECT_NO_FATAL_FAILURE(setClientTarget(display, handle, acquireFence,
-                dataspace, damage));
-    }
-
-    void presentDisplays(size_t layerCnt, Hwc2TestCoverage coverage,
-            const std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>&
-            coverageExceptions, bool optimize)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-            ASSERT_NO_FATAL_FAILURE(enableVsync(display));
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                Area displayArea;
-                std::vector<hwc2_layer_t> layers;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-
-                ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-                Hwc2TestLayers testLayers(layers, coverage, displayArea,
-                        coverageExceptions);
-
-                if (optimize && !testLayers.optimizeLayouts())
-                    continue;
-
-                std::set<hwc2_layer_t> clientLayers;
-                std::set<hwc2_layer_t> clearLayers;
-                Hwc2TestClientTarget testClientTarget;
-
-                do {
-                    uint32_t numTypes, numRequests;
-                    bool hasChanges, skip;
-                    bool flipClientTarget;
-                    int32_t presentFence;
-
-                    ASSERT_NO_FATAL_FAILURE(setLayerProperties(display, layers,
-                            &testLayers, &skip));
-                    if (skip)
-                        continue;
-
-                    ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes,
-                            &numRequests, &hasChanges));
-                    if (hasChanges)
-                        EXPECT_LE(numTypes, static_cast<uint32_t>(layers.size()))
-                                << "wrong number of requests";
-
-                    ASSERT_NO_FATAL_FAILURE(handleCompositionChanges(display,
-                            testLayers, layers, numTypes, &clientLayers));
-                    ASSERT_NO_FATAL_FAILURE(handleRequests(display, layers,
-                            numRequests, &clearLayers, &flipClientTarget));
-                    ASSERT_NO_FATAL_FAILURE(setClientTarget(display,
-                            &testClientTarget, testLayers, clientLayers,
-                            clearLayers, flipClientTarget, displayArea));
-                    ASSERT_NO_FATAL_FAILURE(acceptDisplayChanges(display));
-
-                    ASSERT_NO_FATAL_FAILURE(waitForVsync());
-
-                    EXPECT_NO_FATAL_FAILURE(presentDisplay(display,
-                            &presentFence));
-
-                    ASSERT_NO_FATAL_FAILURE(closeFences(display, presentFence));
-
-                } while (testLayers.advance());
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayers(display,
-                        std::move(layers)));
-            }
-
-            ASSERT_NO_FATAL_FAILURE(disableVsync(display));
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        }
-    }
-
-    void createAndPresentVirtualDisplay(size_t layerCnt,
-            Hwc2TestCoverage coverage,
-            const std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>&
-            coverageExceptions)
-    {
-        Hwc2TestVirtualDisplay testVirtualDisplay(coverage);
-        hwc2_display_t display;
-        android_pixel_format_t desiredFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-
-        do {
-            // Items dependent on the display dimensions
-            hwc2_error_t err = HWC2_ERROR_NONE;
-            const UnsignedArea& dimension =
-                    testVirtualDisplay.getDisplayDimension();
-            ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(dimension.width,
-                    dimension.height, &desiredFormat, &display, &err));
-            ASSERT_TRUE(err == HWC2_ERROR_NONE)
-                    << "Cannot allocate virtual display";
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-            ASSERT_NO_FATAL_FAILURE(enableVsync(display));
-
-            std::vector<hwc2_config_t> configs;
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-
-                Area displayArea;
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-
-                std::vector<hwc2_layer_t> layers;
-                ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers,
-                        layerCnt));
-                Hwc2TestLayers testLayers(layers, coverage, displayArea,
-                        coverageExceptions);
-
-                /*
-                 * Layouts that do not cover an entire virtual display will
-                 * cause undefined behavior.
-                 * Enable optimizeLayouts to avoid this.
-                 */
-                testLayers.optimizeLayouts();
-                do {
-                    // Items dependent on the testLayers properties
-                    std::set<hwc2_layer_t> clientLayers;
-                    std::set<hwc2_layer_t> clearLayers;
-                    uint32_t numTypes, numRequests;
-                    bool hasChanges, skip;
-                    bool flipClientTarget;
-                    int32_t presentFence;
-                    Hwc2TestClientTarget testClientTarget;
-                    buffer_handle_t outputBufferHandle;
-                    android::base::unique_fd outputBufferReleaseFence;
-
-                    ASSERT_NO_FATAL_FAILURE(setLayerProperties(display, layers,
-                            &testLayers, &skip));
-
-                    if (skip)
-                        continue;
-
-                    ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes,
-                            &numRequests, &hasChanges));
-
-                    if (hasChanges)
-                        EXPECT_LE(numTypes, static_cast<uint32_t>(layers.size()))
-                                << "wrong number of requests";
-
-                    ASSERT_NO_FATAL_FAILURE(handleCompositionChanges(display,
-                            testLayers, layers, numTypes, &clientLayers));
-
-                    ASSERT_NO_FATAL_FAILURE(handleRequests(display, layers,
-                            numRequests, &clearLayers, &flipClientTarget));
-                    ASSERT_NO_FATAL_FAILURE(setClientTarget(display,
-                            &testClientTarget, testLayers, clientLayers,
-                            clearLayers, flipClientTarget, displayArea));
-                    ASSERT_NO_FATAL_FAILURE(acceptDisplayChanges(display));
-
-                    ASSERT_EQ(testVirtualDisplay.getOutputBuffer(
-                            &outputBufferHandle, &outputBufferReleaseFence), 0);
-                    ASSERT_NO_FATAL_FAILURE(setOutputBuffer(display,
-                            outputBufferHandle, outputBufferReleaseFence));
-
-                    EXPECT_NO_FATAL_FAILURE(presentDisplay(display,
-                            &presentFence));
-                    ASSERT_NO_FATAL_FAILURE(closeFences(display, presentFence));
-
-                    ASSERT_EQ(testVirtualDisplay.verifyOutputBuffer(&testLayers,
-                            &layers, &clearLayers), 0);
-
-                    /*
-                     * Upscaling the image causes minor pixel differences.
-                     * Work around this by using some threshold.
-                     *
-                     * Fail test if we are off by more than 1% of our
-                     * pixels.
-                     */
-                    ComparatorResult& comparatorResult = ComparatorResult::get();
-                    int threshold = (dimension.width * dimension.height) / 100;
-                    double diffPercent = (comparatorResult.getDifferentPixelCount() * 100.0) /
-                            (dimension.width * dimension.height);
-
-                    if (comparatorResult.getDifferentPixelCount() != 0)
-                        EXPECT_TRUE(false)
-                                << comparatorResult.getDifferentPixelCount() << " pixels ("
-                                << diffPercent << "%) are different.";
-
-                    if (comparatorResult.getDifferentPixelCount() > threshold) {
-                        EXPECT_TRUE(false)
-                                << "Mismatched pixel count exceeds threshold. "
-                                << "Writing buffers to file.";
-
-                        const ::testing::TestInfo* const test_info =
-                                ::testing::UnitTest::GetInstance()
-                                ->current_test_info();
-
-                        EXPECT_EQ(testVirtualDisplay.writeBuffersToFile(
-                                test_info->name()), 0)
-                                << "Failed to write buffers.";
-                    }
-
-                    ASSERT_LE(comparatorResult.getDifferentPixelCount(), threshold)
-                            << comparatorResult.getDifferentPixelCount() << " pixels ("
-                            << diffPercent << "%) are different. "
-                            << "Exceeds 1% threshold, terminating test. "
-                            << "Test case: " << testLayers.dump();
-
-                } while (testLayers.advance());
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayers(display,
-                        std::move(layers)));
-            }
-            ASSERT_NO_FATAL_FAILURE(disableVsync(display));
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-            ASSERT_NO_FATAL_FAILURE(destroyVirtualDisplay(display));
-        } while (testVirtualDisplay.advance());
-    }
-
-    hwc2_device_t* mHwc2Device = nullptr;
-
-    enum class Hwc2TestHotplugStatus {
-        Init = 1,
-        Receiving,
-        Done,
-    };
-
-    std::mutex mHotplugMutex;
-    std::condition_variable mHotplugCv;
-    Hwc2TestHotplugStatus mHotplugStatus = Hwc2TestHotplugStatus::Init;
-    std::unordered_set<hwc2_display_t> mDisplays;
-
-    /* Store all created layers that have not been destroyed. If an ASSERT_*
-     * fails, then destroy the layers on exit */
-    std::set<std::pair<hwc2_display_t, hwc2_layer_t>> mLayers;
-
-    /* Store the power mode state. If it is not HWC2_POWER_MODE_OFF when
-     * tearing down the test cases, change it to HWC2_POWER_MODE_OFF */
-    std::set<hwc2_display_t> mActiveDisplays;
-
-    /* Store all created virtual displays that have not been destroyed. If an
-     * ASSERT_* fails, then destroy the virtual displays on exit */
-    std::set<hwc2_display_t> mVirtualDisplays;
-
-    std::mutex mVsyncMutex;
-    std::condition_variable mVsyncCv;
-    hwc2_display_t mVsyncDisplay;
-    int64_t mVsyncTimestamp = -1;
-};
-
-void hwc2TestHotplugCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int32_t connection)
-{
-    if (callbackData)
-        static_cast<Hwc2Test*>(callbackData)->hotplugCallback(display,
-                connection);
-}
-
-void hwc2TestVsyncCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int64_t timestamp)
-{
-    if (callbackData)
-        static_cast<Hwc2Test*>(callbackData)->vsyncCallback(display,
-                timestamp);
-}
-
-void setBlendMode(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerBlendMode(display, layer,
-            testLayer->getBlendMode(), outErr));
-}
-
-void setBuffer(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    buffer_handle_t handle;
-    android::base::unique_fd acquireFence;
-    hwc2_composition_t composition = testLayer->getComposition();
-
-    if (composition == HWC2_COMPOSITION_CLIENT
-            || composition == HWC2_COMPOSITION_SOLID_COLOR
-            || composition == HWC2_COMPOSITION_SIDEBAND)
-        return;
-
-    if (testLayer->getBuffer(&handle, &acquireFence) < 0)
-        return;
-
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display, layer,
-            composition));
-    EXPECT_NO_FATAL_FAILURE(test->setLayerBuffer(display, layer,
-            handle, acquireFence, outErr));
-}
-
-void setColor(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display,
-            layer, HWC2_COMPOSITION_SOLID_COLOR));
-    ASSERT_NO_FATAL_FAILURE(test->setLayerPlaneAlpha(display,
-            layer, testLayer->getPlaneAlpha()));
-    ASSERT_NO_FATAL_FAILURE(test->setLayerBlendMode(display,
-            layer, testLayer->getBlendMode()));
-    EXPECT_NO_FATAL_FAILURE(test->setLayerColor(display, layer,
-            testLayer->getColor(), outErr));
-}
-
-void setComposition(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    hwc2_composition_t composition = testLayer->getComposition();
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display, layer,
-            composition, &err));
-    if (outErr) {
-        *outErr = err;
-        return;
-    }
-
-    if (composition != HWC2_COMPOSITION_SIDEBAND) {
-        EXPECT_EQ(err, HWC2_ERROR_NONE) << "returned wrong error code";
-    } else {
-        EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_UNSUPPORTED)
-                 << "returned wrong error code";
-    }
-}
-
-void setCursorPosition(Hwc2Test* test, hwc2_display_t display,
-        hwc2_layer_t layer, Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display,
-            layer, HWC2_COMPOSITION_CURSOR));
-
-    const hwc_rect_t cursorPosition = testLayer->getCursorPosition();
-    EXPECT_NO_FATAL_FAILURE(test->setCursorPosition(display, layer,
-            cursorPosition.left, cursorPosition.top, outErr));
-}
-
-void setDataspace(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerDataspace(display, layer,
-            testLayer->getDataspace(), outErr));
-}
-
-void setDisplayFrame(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerDisplayFrame(display, layer,
-            testLayer->getDisplayFrame(), outErr));
-}
-
-void setPlaneAlpha(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t *outErr)
-{
-    ASSERT_NO_FATAL_FAILURE(test->setLayerBlendMode(display, layer,
-            testLayer->getBlendMode()));
-    EXPECT_NO_FATAL_FAILURE(test->setLayerPlaneAlpha(display, layer,
-            testLayer->getPlaneAlpha(), outErr));
-}
-
-void setSourceCrop(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerSourceCrop(display, layer,
-            testLayer->getSourceCrop(), outErr));
-}
-
-void setSurfaceDamage(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerSurfaceDamage(display, layer,
-            testLayer->getSurfaceDamage(), outErr));
-}
-
-void setTransform(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerTransform(display, layer,
-            testLayer->getTransform(), outErr));
-}
-
-void setVisibleRegion(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerVisibleRegion(display, layer,
-            testLayer->getVisibleRegion(), outErr));
-}
-
-void setZOrder(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerZOrder(display, layer,
-            testLayer->getZOrder(), outErr));
-}
-
-bool advanceBlendMode(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceBlendMode();
-}
-
-bool advanceBuffer(Hwc2TestLayer* testLayer)
-{
-    if (testLayer->advanceComposition())
-        return true;
-    return testLayer->advanceBufferArea();
-}
-
-bool advanceColor(Hwc2TestLayer* testLayer)
-{
-    /* Color depends on blend mode so advance blend mode last so color is not
-     * force to update as often */
-    if (testLayer->advancePlaneAlpha())
-        return true;
-    if (testLayer->advanceColor())
-        return true;
-    return testLayer->advanceBlendMode();
-}
-
-bool advanceComposition(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceComposition();
-}
-
-bool advanceCursorPosition(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceCursorPosition();
-}
-
-bool advanceDataspace(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceDataspace();
-}
-
-bool advanceDisplayFrame(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceDisplayFrame();
-}
-
-bool advancePlaneAlpha(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advancePlaneAlpha();
-}
-
-bool advanceSourceCrop(Hwc2TestLayer* testLayer)
-{
-    if (testLayer->advanceSourceCrop())
-        return true;
-    return testLayer->advanceBufferArea();
-}
-
-bool advanceSurfaceDamage(Hwc2TestLayer* testLayer)
-{
-    if (testLayer->advanceSurfaceDamage())
-        return true;
-    return testLayer->advanceBufferArea();
-}
-
-bool advanceTransform(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceTransform();
-}
-
-bool advanceVisibleRegions(Hwc2TestLayers* testLayers)
-{
-    return testLayers->advanceVisibleRegions();
-}
-
-bool advanceClientTargetSupport(
-        Hwc2TestClientTargetSupport* testClientTargetSupport)
-{
-    return testClientTargetSupport->advance();
-}
-
-static const std::array<hwc2_function_descriptor_t, 42> requiredFunctions = {{
-    HWC2_FUNCTION_ACCEPT_DISPLAY_CHANGES,
-    HWC2_FUNCTION_CREATE_LAYER,
-    HWC2_FUNCTION_CREATE_VIRTUAL_DISPLAY,
-    HWC2_FUNCTION_DESTROY_LAYER,
-    HWC2_FUNCTION_DESTROY_VIRTUAL_DISPLAY,
-    HWC2_FUNCTION_DUMP,
-    HWC2_FUNCTION_GET_ACTIVE_CONFIG,
-    HWC2_FUNCTION_GET_CHANGED_COMPOSITION_TYPES,
-    HWC2_FUNCTION_GET_CLIENT_TARGET_SUPPORT,
-    HWC2_FUNCTION_GET_COLOR_MODES,
-    HWC2_FUNCTION_GET_DISPLAY_ATTRIBUTE,
-    HWC2_FUNCTION_GET_DISPLAY_CONFIGS,
-    HWC2_FUNCTION_GET_DISPLAY_NAME,
-    HWC2_FUNCTION_GET_DISPLAY_REQUESTS,
-    HWC2_FUNCTION_GET_DISPLAY_TYPE,
-    HWC2_FUNCTION_GET_DOZE_SUPPORT,
-    HWC2_FUNCTION_GET_HDR_CAPABILITIES,
-    HWC2_FUNCTION_GET_MAX_VIRTUAL_DISPLAY_COUNT,
-    HWC2_FUNCTION_GET_RELEASE_FENCES,
-    HWC2_FUNCTION_PRESENT_DISPLAY,
-    HWC2_FUNCTION_REGISTER_CALLBACK,
-    HWC2_FUNCTION_SET_ACTIVE_CONFIG,
-    HWC2_FUNCTION_SET_CLIENT_TARGET,
-    HWC2_FUNCTION_SET_COLOR_MODE,
-    HWC2_FUNCTION_SET_COLOR_TRANSFORM,
-    HWC2_FUNCTION_SET_CURSOR_POSITION,
-    HWC2_FUNCTION_SET_LAYER_BLEND_MODE,
-    HWC2_FUNCTION_SET_LAYER_BUFFER,
-    HWC2_FUNCTION_SET_LAYER_COLOR,
-    HWC2_FUNCTION_SET_LAYER_COMPOSITION_TYPE,
-    HWC2_FUNCTION_SET_LAYER_DATASPACE,
-    HWC2_FUNCTION_SET_LAYER_DISPLAY_FRAME,
-    HWC2_FUNCTION_SET_LAYER_PLANE_ALPHA,
-    HWC2_FUNCTION_SET_LAYER_SOURCE_CROP,
-    HWC2_FUNCTION_SET_LAYER_SURFACE_DAMAGE,
-    HWC2_FUNCTION_SET_LAYER_TRANSFORM,
-    HWC2_FUNCTION_SET_LAYER_VISIBLE_REGION,
-    HWC2_FUNCTION_SET_LAYER_Z_ORDER,
-    HWC2_FUNCTION_SET_OUTPUT_BUFFER,
-    HWC2_FUNCTION_SET_POWER_MODE,
-    HWC2_FUNCTION_SET_VSYNC_ENABLED,
-    HWC2_FUNCTION_VALIDATE_DISPLAY,
-}};
-
-/* TESTCASE: Tests that the HWC2 supports all required functions. */
-TEST_F(Hwc2Test, GET_FUNCTION)
-{
-    for (hwc2_function_descriptor_t descriptor : requiredFunctions) {
-        hwc2_function_pointer_t pfn = getFunction(descriptor);
-        EXPECT_TRUE(pfn) << "failed to get function "
-                << getFunctionDescriptorName(descriptor);
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 fails to retrieve and invalid function. */
-TEST_F(Hwc2Test, GET_FUNCTION_invalid_function)
-{
-    hwc2_function_pointer_t pfn = getFunction(HWC2_FUNCTION_INVALID);
-    EXPECT_FALSE(pfn) << "failed to get invalid function";
-}
-
-/* TESTCASE: Tests that the HWC2 does not return an invalid capability. */
-TEST_F(Hwc2Test, GET_CAPABILITIES)
-{
-    std::vector<hwc2_capability_t> capabilities;
-
-    getCapabilities(&capabilities);
-
-    EXPECT_EQ(std::count(capabilities.begin(), capabilities.end(),
-            HWC2_CAPABILITY_INVALID), 0);
-}
-
-static const std::array<hwc2_callback_descriptor_t, 3> callbackDescriptors = {{
-    HWC2_CALLBACK_HOTPLUG,
-    HWC2_CALLBACK_REFRESH,
-    HWC2_CALLBACK_VSYNC,
-}};
-
-/* TESTCASE: Tests that the HWC2 can successfully register all required
- * callback functions. */
-TEST_F(Hwc2Test, REGISTER_CALLBACK)
-{
-    hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-            const_cast<char*>("data"));
-
-    for (auto descriptor : callbackDescriptors) {
-        ASSERT_NO_FATAL_FAILURE(registerCallback(descriptor, data,
-                []() { return; }));
-    }
-}
-
-/* TESTCASE: Test that the HWC2 fails to register invalid callbacks. */
-TEST_F(Hwc2Test, REGISTER_CALLBACK_bad_parameter)
-{
-    hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-            const_cast<char*>("data"));
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_INVALID, data,
-            []() { return; }, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can register a callback with null data. */
-TEST_F(Hwc2Test, REGISTER_CALLBACK_null_data)
-{
-    hwc2_callback_data_t data = nullptr;
-
-    for (auto descriptor : callbackDescriptors) {
-        ASSERT_NO_FATAL_FAILURE(registerCallback(descriptor, data,
-                []() { return; }));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns the correct display type for each
- * physical display. */
-TEST_F(Hwc2Test, GET_DISPLAY_TYPE)
-{
-    for (auto display : mDisplays) {
-        hwc2_display_type_t type;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayType(display, &type));
-        EXPECT_EQ(type, HWC2_DISPLAY_TYPE_PHYSICAL) << "failed to return"
-                " correct display type";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns an error when the display type of a bad
- * display is requested. */
-TEST_F(Hwc2Test, GET_DISPLAY_TYPE_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_display_type_t type;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDisplayType(display, &type, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can create and destroy layers. */
-TEST_F(Hwc2Test, CREATE_DESTROY_LAYER)
-{
-    for (auto display : mDisplays) {
-        hwc2_layer_t layer;
-
-        ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot create a layer for a bad display */
-TEST_F(Hwc2Test, CREATE_LAYER_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_layer_t layer;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 will either support a large number of resources
- * or will return no resources. */
-TEST_F(Hwc2Test, CREATE_LAYER_no_resources)
-{
-    const size_t layerCnt = 1000;
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_layer_t> layers;
-
-        ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destroy a layer for a bad display */
-TEST_F(Hwc2Test, DESTROY_LAYER_bad_display)
-{
-    hwc2_display_t badDisplay;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&badDisplay));
-
-    for (auto display : mDisplays) {
-        hwc2_layer_t layer = 0;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(badDisplay, layer, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(badDisplay, layer, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destory a bad layer */
-TEST_F(Hwc2Test, DESTROY_LAYER_bad_layer)
-{
-    for (auto display : mDisplays) {
-        hwc2_layer_t layer;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, UINT64_MAX / 2, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, 0, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, UINT64_MAX - 1, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, 1, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, UINT64_MAX, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer + 1, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-    }
-}
-
-static const std::array<hwc2_attribute_t, 2> requiredAttributes = {{
-    HWC2_ATTRIBUTE_WIDTH,
-    HWC2_ATTRIBUTE_HEIGHT,
-}};
-
-static const std::array<hwc2_attribute_t, 3> optionalAttributes = {{
-    HWC2_ATTRIBUTE_VSYNC_PERIOD,
-    HWC2_ATTRIBUTE_DPI_X,
-    HWC2_ATTRIBUTE_DPI_Y,
-}};
-
-/* TESTCASE: Tests that the HWC2 can return display attributes for a valid
- * config. */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            int32_t value;
-
-            for (auto attribute : requiredAttributes) {
-                ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                        attribute, &value));
-                EXPECT_GE(value, 0) << "missing required attribute "
-                        << getAttributeName(attribute) << " for config "
-                        << config;
-            }
-            for (auto attribute : optionalAttributes) {
-                ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                        attribute, &value));
-            }
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will return a value of -1 for an invalid
- * attribute */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE_invalid_attribute)
-{
-    const hwc2_attribute_t attribute = HWC2_ATTRIBUTE_INVALID;
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            int32_t value;
-            hwc2_error_t err = HWC2_ERROR_NONE;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                    attribute, &value, &err));
-            EXPECT_EQ(value, -1) << "failed to return -1 for an invalid"
-                    " attribute for config " << config;
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will fail to get attributes for a bad display */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE_bad_display)
-{
-    hwc2_display_t display;
-    const hwc2_config_t config = 0;
-    int32_t value;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    for (auto attribute : requiredAttributes) {
-        ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config, attribute,
-                &value, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-    }
-
-    for (auto attribute : optionalAttributes) {
-        ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config, attribute,
-                &value, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will fail to get attributes for a bad config */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE_bad_config)
-{
-    for (auto display : mDisplays) {
-        hwc2_config_t config;
-        int32_t value;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getInvalidConfig(display, &config));
-
-        for (auto attribute : requiredAttributes) {
-            ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                    attribute, &value, &err));
-            EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-        }
-
-        for (auto attribute : optionalAttributes) {
-            ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                    attribute, &value, &err));
-            EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will get display configs for active displays */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will not get display configs for bad displays */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_config_t> configs;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs, &err));
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-    EXPECT_TRUE(configs.empty()) << "returned configs for bad display";
-}
-
-/* TESTCASE: Tests that the HWC2 will return the same config list multiple
- * times in a row. */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS_same)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs1, configs2;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs1));
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs2));
-
-        EXPECT_TRUE(std::is_permutation(configs1.begin(), configs1.end(),
-                configs2.begin())) << "returned two different config sets";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 does not return duplicate display configs */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS_duplicate)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        std::unordered_set<hwc2_config_t> configsSet(configs.begin(),
-                configs.end());
-        EXPECT_EQ(configs.size(), configsSet.size()) << "returned duplicate"
-                " configs";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns the active config for a display */
-TEST_F(Hwc2Test, GET_ACTIVE_CONFIG)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            hwc2_config_t activeConfig;
-
-            ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-            ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &activeConfig));
-
-            EXPECT_EQ(activeConfig, config) << "failed to get active config";
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 does not return an active config for a bad
- * display. */
-TEST_F(Hwc2Test, GET_ACTIVE_CONFIG_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_config_t activeConfig;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &activeConfig, &err));
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 either begins with a valid active config
- * or returns an error when getActiveConfig is called. */
-TEST_F(Hwc2Test, GET_ACTIVE_CONFIG_bad_config)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-        hwc2_config_t activeConfig;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        if (configs.empty())
-            return;
-
-        ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &activeConfig, &err));
-        if (err == HWC2_ERROR_NONE) {
-            EXPECT_NE(std::count(configs.begin(), configs.end(),
-                    activeConfig), 0) << "active config is not found in "
-                    " configs for display";
-        } else {
-            EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set every display config as an active
- * config */
-TEST_F(Hwc2Test, SET_ACTIVE_CONFIG)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            EXPECT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an active config for a bad display */
-TEST_F(Hwc2Test, SET_ACTIVE_CONFIG_bad_display)
-{
-    hwc2_display_t display;
-    const hwc2_config_t config = 0;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid active config */
-TEST_F(Hwc2Test, SET_ACTIVE_CONFIG_bad_config)
-{
-    for (auto display : mDisplays) {
-        hwc2_config_t config;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getInvalidConfig(display, &config));
-
-        ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns a valid value for getDozeSupport. */
-TEST_F(Hwc2Test, GET_DOZE_SUPPORT)
-{
-    for (auto display : mDisplays) {
-        int32_t support = -1;
-
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support));
-
-        EXPECT_TRUE(support == 0 || support == 1) << "invalid doze support value";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get doze support for a bad display. */
-TEST_F(Hwc2Test, GET_DOZE_SUPPORT_bad_display)
-{
-    hwc2_display_t display;
-    int32_t support = -1;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support, &err));
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can set all supported power modes */
-TEST_F(Hwc2Test, SET_POWER_MODE)
-{
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-
-        int32_t support = -1;
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support));
-        if (support != 1)
-            return;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a power mode for a bad display. */
-TEST_F(Hwc2Test, SET_POWER_MODE_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    int32_t support = -1;
-    ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support, &err));
-    if (support != 1)
-        return;
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE_SUSPEND,
-            &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid power mode value. */
-TEST_F(Hwc2Test, SET_POWER_MODE_bad_parameter)
-{
-    for (auto display : mDisplays) {
-        hwc2_power_mode_t mode = static_cast<hwc2_power_mode_t>(
-                HWC2_POWER_MODE_DOZE_SUSPEND + 1);
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, mode, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code "
-                << mode;
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will return unsupported if it does not support
- * an optional power mode. */
-TEST_F(Hwc2Test, SET_POWER_MODE_unsupported)
-{
-    for (auto display : mDisplays) {
-        int32_t support = -1;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support, &err));
-        if (support == 1)
-            return;
-
-        ASSERT_EQ(support, 0) << "invalid doze support value";
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE,
-                &err));
-        EXPECT_EQ(err, HWC2_ERROR_UNSUPPORTED) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND, &err));
-        EXPECT_EQ(err, HWC2_ERROR_UNSUPPORTED) <<  "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set the same power mode multiple times. */
-TEST_F(Hwc2Test, SET_POWER_MODE_stress)
-{
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-
-        int32_t support = -1;
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support));
-        if (support != 1)
-            return;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can enable and disable vsync on active
- * displays */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED)
-{
-    for (auto display : mDisplays) {
-        hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-                const_cast<char*>("data"));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-                []() { return; }));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 issues a valid vsync callback. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_callback)
-{
-    for (auto display : mDisplays) {
-        hwc2_display_t receivedDisplay;
-        int64_t receivedTimestamp;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(enableVsync(display));
-
-        ASSERT_NO_FATAL_FAILURE(waitForVsync(&receivedDisplay,
-                &receivedTimestamp));
-
-        EXPECT_EQ(receivedDisplay, display) << "failed to get correct display";
-        EXPECT_GE(receivedTimestamp, 0) << "failed to get valid timestamp";
-
-        ASSERT_NO_FATAL_FAILURE(disableVsync(display));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot enable a vsync for a bad display */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-            const_cast<char*>("data"));
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-            []() { return; }));
-
-    ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot enable an invalid vsync value */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_bad_parameter)
-{
-    for (auto display : mDisplays) {
-        hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-                const_cast<char*>("data"));
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-                []() { return; }));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_INVALID,
-                &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can enable and disable a vsync value multiple
- * times. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_stress)
-{
-    for (auto display : mDisplays) {
-        hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-                const_cast<char*>("data"));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-                []() { return; }));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set a vsync enable value when the display
- * is off and no callback is registered. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_no_callback_no_power)
-{
-    const uint secs = 1;
-
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        sleep(secs);
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set a vsync enable value when no callback
- * is registered. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_no_callback)
-{
-    const uint secs = 1;
-
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        sleep(secs);
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns a display name for each display */
-TEST_F(Hwc2Test, GET_DISPLAY_NAME)
-{
-    for (auto display : mDisplays) {
-        std::string name;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayName(display, &name));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 does not return a display name for a bad
- * display */
-TEST_F(Hwc2Test, GET_DISPLAY_NAME_bad_display)
-{
-    hwc2_display_t display;
-    std::string name;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDisplayName(display, &name, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can set basic composition types. */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setComposition, advanceComposition));
-}
-
-/* TESTCASE: Tests that the HWC2 can update a basic composition type on a
- * layer. */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setComposition, advanceComposition));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a composition type for a bad layer */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setComposition));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a bad composition type */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadParameter(
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    hwc2_error_t* outErr) {
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display,
-                        layer, HWC2_COMPOSITION_INVALID, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the cursor position of a layer. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            ::setCursorPosition, advanceCursorPosition));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the cursor position of a layer. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            ::setCursorPosition, advanceCursorPosition));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the cursor position of a layer when the
- * composition type has not been set to HWC2_COMPOSITION_CURSOR. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_composition_type_unset)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-                const hwc_rect_t cursorPosition = testLayer->getCursorPosition();
-                EXPECT_NO_FATAL_FAILURE(test->setCursorPosition(display, layer,
-                        cursorPosition.left, cursorPosition.top, outErr));
-            },
-
-            advanceCursorPosition));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the cursor position of a bad
- * display. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_layer_t layer = 0;
-    int32_t x = 0, y = 0;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setCursorPosition(display, layer, x, y, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the cursor position of a bad layer. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                const hwc_rect_t cursorPosition = testLayer->getCursorPosition();
-                EXPECT_NO_FATAL_FAILURE(test->setCursorPosition(display,
-                        badLayer, cursorPosition.left, cursorPosition.top,
-                        outErr));
-            }
-   ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set a blend mode value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setBlendMode, advanceBlendMode));
-}
-
-/* TESTCASE: Tests that the HWC2 can update a blend mode value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setBlendMode, advanceBlendMode));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a blend mode for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setBlendMode));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid blend mode. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadParameter(
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    hwc2_error_t* outErr) {
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerBlendMode(display,
-                        layer, HWC2_BLEND_MODE_INVALID, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the buffer of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setBuffer, advanceBuffer));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the buffer of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setBuffer, advanceBuffer));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the buffer of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                buffer_handle_t handle = nullptr;
-                android::base::unique_fd acquireFence;
-
-                /* If there is not available buffer for the given buffer
-                 * properties, it should not fail this test case */
-                if (testLayer->getBuffer(&handle, &acquireFence) == 0) {
-                    *outErr = HWC2_ERROR_BAD_LAYER;
-                    return;
-                }
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerBuffer(display, badLayer,
-                        handle, acquireFence, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set an invalid buffer for a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadParameter(
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    hwc2_error_t* outErr) {
-
-                buffer_handle_t handle = nullptr;
-                int32_t acquireFence = -1;
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerBuffer(display, layer,
-                        handle, acquireFence, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the color of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setColor, advanceColor));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the color of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setColor, advanceColor));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the color of a layer when the
- * composition type has not been set to HWC2_COMPOSITION_SOLID_COLOR. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR_composition_type_unset)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Basic,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerColor(display, layer,
-                        testLayer->getColor(), outErr));
-            },
-
-            advanceColor));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the color of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerColor(display, badLayer,
-                        testLayer->getColor(), outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the dataspace of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DATASPACE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setDataspace, advanceDataspace));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the dataspace of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DATASPACE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setDataspace, advanceDataspace));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a dataspace for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_DATASPACE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setDataspace));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the display frame of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DISPLAY_FRAME)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setDisplayFrame, advanceDisplayFrame));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the display frame of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DISPLAY_FRAME_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setDisplayFrame, advanceDisplayFrame));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the display frame of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_DISPLAY_FRAME_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setDisplayFrame));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the plane alpha of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_PLANE_ALPHA)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setPlaneAlpha, advancePlaneAlpha));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the plane alpha of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_PLANE_ALPHA_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setPlaneAlpha, advancePlaneAlpha));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a plane alpha for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_PLANE_ALPHA_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t *outErr) {
-
-                    EXPECT_NO_FATAL_FAILURE(test->setLayerPlaneAlpha(display,
-                            badLayer, testLayer->getPlaneAlpha(), outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the source crop of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SOURCE_CROP)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setSourceCrop, advanceSourceCrop));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the source crop of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SOURCE_CROP_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setSourceCrop, advanceSourceCrop));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the source crop of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_SOURCE_CROP_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setSourceCrop));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the surface damage of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SURFACE_DAMAGE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setSurfaceDamage, advanceSurfaceDamage));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the surface damage of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SURFACE_DAMAGE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setSurfaceDamage, advanceSurfaceDamage));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the surface damage of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_SURFACE_DAMAGE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setSurfaceDamage));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the transform value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_TRANSFORM)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setTransform, advanceTransform));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the transform value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_TRANSFORM_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setTransform, advanceTransform));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the transform for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_TRANSFORM_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setTransform));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the visible region of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_VISIBLE_REGION)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperties(Hwc2TestCoverage::Basic, 5,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayers* testLayers) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerVisibleRegion(display,
-                        layer, testLayers->getVisibleRegion(layer)));
-            },
-
-            advanceVisibleRegions));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the visible region of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_VISIBLE_REGION_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setVisibleRegion));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the z order of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_Z_ORDER)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperties(Hwc2TestCoverage::Complete, 10,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayers* testLayers) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerZOrder(display, layer,
-                        testLayers->getZOrder(layer)));
-            },
-
-            /* TestLayer z orders are set during the construction of TestLayers
-             * and cannot be updated. There is no need (or ability) to cycle
-             * through additional z order configurations. */
-            [] (Hwc2TestLayers* /*testLayers*/) {
-                return false;
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the z order of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_Z_ORDER_update)
-{
-    const std::vector<uint32_t> zOrders = { static_cast<uint32_t>(0),
-            static_cast<uint32_t>(1), static_cast<uint32_t>(UINT32_MAX / 4),
-            static_cast<uint32_t>(UINT32_MAX / 2),
-            static_cast<uint32_t>(UINT32_MAX) };
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            hwc2_layer_t layer;
-
-            ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-
-            ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-            for (uint32_t zOrder : zOrders) {
-                EXPECT_NO_FATAL_FAILURE(setLayerZOrder(display, layer, zOrder));
-            }
-
-            ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the z order of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_Z_ORDER_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setZOrder));
-}
-
-/* TESTCASE: Tests that the HWC2 can display a layer with basic property
- * coverage */
-TEST_F(Hwc2Test, VALIDATE_DISPLAY_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                EXPECT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, static_cast<uint32_t>(layers.size()))
-                            << "wrong number of requests";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can display 5 layers with default coverage. */
-TEST_F(Hwc2Test, VALIDATE_DISPLAY_default_5)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Default, 5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                EXPECT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, static_cast<uint32_t>(layers.size()))
-                            << "wrong number of requests";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot validate a bad display */
-TEST_F(Hwc2Test, VALIDATE_DISPLAY_bad_display)
-{
-    hwc2_display_t display;
-    uint32_t numTypes, numRequests;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes, &numRequests,
-            &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can get display requests after validating a
- * basic layer. */
-TEST_F(Hwc2Test, GET_DISPLAY_REQUESTS_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                ASSERT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                EXPECT_NO_FATAL_FAILURE(test->handleRequests(display, layers,
-                        numRequests));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get display requests from a bad display */
-TEST_F(Hwc2Test, GET_DISPLAY_REQUESTS_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_display_request_t displayRequests;
-    std::vector<hwc2_layer_t> layers;
-    std::vector<hwc2_layer_request_t> layerRequests;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    EXPECT_NO_FATAL_FAILURE(getDisplayRequests(display, &displayRequests,
-            &layers, &layerRequests, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get display requests from an non
- * validated display. */
-TEST_F(Hwc2Test, GET_DISPLAY_REQUESTS_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayNonValidatedLayers(5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    std::vector<hwc2_layer_t>* layers) {
-
-                hwc2_display_request_t displayRequests;
-                std::vector<hwc2_layer_request_t> layerRequests;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getDisplayRequests(display,
-                        &displayRequests, layers, &layerRequests, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can get changed composition types after
- * validating a basic layer. */
-TEST_F(Hwc2Test, GET_CHANGED_COMPOSITION_TYPES_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* testLayers) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                ASSERT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                EXPECT_NO_FATAL_FAILURE(test->handleCompositionChanges(display,
-                        *testLayers, layers, numTypes));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get changed composition types from a bad
- * display */
-TEST_F(Hwc2Test, GET_CHANGED_COMPOSITION_TYPES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_layer_t> layers;
-    std::vector<hwc2_composition_t> types;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    EXPECT_NO_FATAL_FAILURE(getChangedCompositionTypes(display, &layers,
-            &types, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get changed composition types from an non
- * validated display. */
-TEST_F(Hwc2Test, GET_CHANGED_COMPOSITION_TYPES_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayNonValidatedLayers(5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    std::vector<hwc2_layer_t>* layers) {
-
-                std::vector<hwc2_composition_t> types;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getChangedCompositionTypes(
-                        display, layers, &types, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can accept display changes after validating a
- * basic layer. */
-TEST_F(Hwc2Test, ACCEPT_DISPLAY_CHANGES_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* testLayers) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                ASSERT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                ASSERT_NO_FATAL_FAILURE(test->handleCompositionChanges(display,
-                        *testLayers, layers, numTypes));
-
-                EXPECT_NO_FATAL_FAILURE(test->acceptDisplayChanges(display));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot accept display changes from a bad
- * display */
-TEST_F(Hwc2Test, ACCEPT_DISPLAY_CHANGES_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    EXPECT_NO_FATAL_FAILURE(acceptDisplayChanges(display, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot accept display changes from an non
- * validated display. */
-TEST_F(Hwc2Test, ACCEPT_DISPLAY_CHANGES_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayNonValidatedLayers(5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    std::vector<hwc2_layer_t>* /*layers*/) {
-
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->acceptDisplayChanges(display, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 supports client target with required values */
-TEST_F(Hwc2Test, GET_CLIENT_TARGET_SUPPORT)
-{
-    ASSERT_NO_FATAL_FAILURE(setClientTargetSupport(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const Hwc2TestClientTargetSupport& testClientTargetSupport) {
-
-                const Area bufferArea = testClientTargetSupport.getBufferArea();
-                const android_pixel_format_t format = HAL_PIXEL_FORMAT_RGBA_8888;
-
-                ASSERT_NO_FATAL_FAILURE(test->getClientTargetSupport(display,
-                        bufferArea.width, bufferArea.height, format,
-                        testClientTargetSupport.getDataspace()));
-            },
-
-            advanceClientTargetSupport));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get client target support for a bad
- * display. */
-TEST_F(Hwc2Test, GET_CLIENT_TARGET_SUPPORT_bad_display)
-{
-    ASSERT_NO_FATAL_FAILURE(setClientTargetSupport(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t /*display*/,
-                    const Hwc2TestClientTargetSupport& testClientTargetSupport) {
-
-                const Area bufferArea = testClientTargetSupport.getBufferArea();
-                const android_pixel_format_t format = HAL_PIXEL_FORMAT_RGBA_8888;
-                hwc2_display_t badDisplay;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getBadDisplay(&badDisplay));
-
-                ASSERT_NO_FATAL_FAILURE(test->getClientTargetSupport(badDisplay,
-                        bufferArea.width, bufferArea.height, format,
-                        testClientTargetSupport.getDataspace(), &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-            },
-
-            advanceClientTargetSupport));
-}
-
-/* TESTCASE: Tests that the HWC2 either supports or returns error unsupported
- * for a variety of client target values. */
-TEST_F(Hwc2Test, GET_CLIENT_TARGET_SUPPORT_unsupported)
-{
-    ASSERT_NO_FATAL_FAILURE(setClientTargetSupport(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const Hwc2TestClientTargetSupport& testClientTargetSupport) {
-
-                const Area bufferArea = testClientTargetSupport.getBufferArea();
-                const android_pixel_format_t format = HAL_PIXEL_FORMAT_RGBA_8888;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getClientTargetSupport(display,
-                        bufferArea.width, bufferArea.height, format,
-                        testClientTargetSupport.getDataspace(), &err));
-                EXPECT_TRUE(err == HWC2_ERROR_NONE
-                        || err == HWC2_ERROR_UNSUPPORTED)
-                        << "returned wrong error code";
-            },
-
-            advanceClientTargetSupport));
-}
-
-/* TESTCASE: Tests that the HWC2 can set a client target buffer for a basic
- * layer. */
-TEST_F(Hwc2Test, SET_CLIENT_TARGET_basic)
-{
-    const Dataspace dataspace = Dataspace::UNKNOWN;
-    const hwc_region_t damage = { };
-    const size_t layerCnt = 1;
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            Area displayArea;
-            std::vector<hwc2_layer_t> layers;
-
-            ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-            ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display, &displayArea));
-
-            ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-            Hwc2TestLayers testLayers(layers, Hwc2TestCoverage::Basic,
-                    displayArea);
-
-            if (!testLayers.optimizeLayouts())
-                continue;
-
-            Hwc2TestClientTarget testClientTarget;
-
-            do {
-                std::set<hwc2_layer_t> clientLayers;
-                std::set<hwc2_layer_t> clearLayers;
-                uint32_t numTypes, numRequests;
-                bool hasChanges, skip;
-                bool flipClientTarget;
-                buffer_handle_t handle;
-                int32_t acquireFence;
-
-                ASSERT_NO_FATAL_FAILURE(setLayerProperties(display, layers,
-                        &testLayers, &skip));
-                if (skip)
-                    continue;
-
-                ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                ASSERT_NO_FATAL_FAILURE(handleCompositionChanges(display,
-                        testLayers, layers, numTypes, &clientLayers));
-                ASSERT_NO_FATAL_FAILURE(handleRequests(display, layers,
-                        numRequests, &clearLayers, &flipClientTarget));
-                ASSERT_EQ(testClientTarget.getBuffer(testLayers, clientLayers,
-                        clearLayers, flipClientTarget, displayArea, &handle,
-                        &acquireFence), 0);
-                EXPECT_NO_FATAL_FAILURE(setClientTarget(display, handle,
-                        acquireFence, dataspace, damage));
-
-                if (acquireFence >= 0)
-                    close(acquireFence);
-
-            } while (testLayers.advance());
-
-            ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-        }
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a client target for a bad display. */
-TEST_F(Hwc2Test, SET_CLIENT_TARGET_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_layer_t> layers;
-    const Area displayArea = {0, 0};
-    Hwc2TestLayers testLayers(layers, Hwc2TestCoverage::Default, displayArea);
-    std::set<hwc2_layer_t> clientLayers;
-    std::set<hwc2_layer_t> flipClientTargetLayers;
-    bool flipClientTarget = true;
-    const Dataspace dataspace = Dataspace::UNKNOWN;
-    const hwc_region_t damage = { };
-    buffer_handle_t handle;
-    int32_t acquireFence;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    Hwc2TestClientTarget testClientTarget;
-
-    ASSERT_EQ(testClientTarget.getBuffer(testLayers, clientLayers,
-            flipClientTargetLayers, flipClientTarget, displayArea, &handle,
-            &acquireFence), 0);
-
-    EXPECT_NO_FATAL_FAILURE(setClientTarget(display, handle, acquireFence,
-            dataspace, damage, &err));
-
-    if (acquireFence >= 0)
-        close(acquireFence);
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 default layer. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 3 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_3)
-{
-    const size_t layerCnt = 3;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 4 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_4)
-{
-    const size_t layerCnt = 4;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 5 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_5)
-{
-    const size_t layerCnt = 5;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 6 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_6)
-{
-    const size_t layerCnt = 6;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * blend mode. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_blend_mode_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::Transform, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Basic}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * blend mode. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_blend_mode_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Basic}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * buffer. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_buffer_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BufferArea, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * color. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_color_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::Color, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * color. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_color_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::Color, Hwc2TestCoverage::Basic}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * composition. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_composition_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * cursor. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_cursor_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::CursorPosition, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * cursor. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_cursor_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::CursorPosition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Basic}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * dataspace. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_dataspace_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Dataspace, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 3 layers with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_3)
-{
-    const size_t layerCnt = 3;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 4 layers with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_4)
-{
-    const size_t layerCnt = 4;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * plane alpha. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_plane_alpha_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Complete}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * plane alpha. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_plane_alpha_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Complete}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * source crop. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_source_crop_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::SourceCrop, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * source crop. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_source_crop_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::SourceCrop, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * surface damage. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_surface_damage_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::SurfaceDamage, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * transform. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_transform_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Transform, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * transform. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_transform_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Transform, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Basic}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * basic. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_basic_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Basic;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot present a bad display.  */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_bad_display)
-{
-    hwc2_display_t display;
-    int32_t presentFence;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplay(display, &presentFence, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot present an unvalidated display. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Default, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& /*layers*/,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                int32_t presentFence;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setPowerMode(display,
-                        HWC2_POWER_MODE_ON));
-                ASSERT_NO_FATAL_FAILURE(test->enableVsync(display));
-
-                ASSERT_NO_FATAL_FAILURE(test->waitForVsync());
-
-                ASSERT_NO_FATAL_FAILURE(test->presentDisplay(display,
-                        &presentFence, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-
-                ASSERT_NO_FATAL_FAILURE(test->disableVsync(display));
-                ASSERT_NO_FATAL_FAILURE(test->setPowerMode(display,
-                        HWC2_POWER_MODE_OFF));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get release fences from a bad display. */
-TEST_F(Hwc2Test, GET_RELEASE_FENCES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_layer_t> layers;
-    std::vector<int32_t> fences;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getReleaseFences(display, &layers, &fences, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-static const std::array<ColorMode, 9> androidColorModes = {{
-    ColorMode::NATIVE,
-    ColorMode::STANDARD_BT601_625,
-    ColorMode::STANDARD_BT601_625_UNADJUSTED,
-    ColorMode::STANDARD_BT601_525,
-    ColorMode::STANDARD_BT601_525_UNADJUSTED,
-    ColorMode::STANDARD_BT709,
-    ColorMode::DCI_P3,
-    ColorMode::SRGB,
-    ColorMode::ADOBE_RGB,
-}};
-
-/* TESTCASE: Tests that the HWC2 can get the color modes for a display. The
- * display must support ColorMode::NATIVE */
-TEST_F(Hwc2Test, GET_COLOR_MODES)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                std::vector<ColorMode> colorModes;
-
-                ASSERT_NO_FATAL_FAILURE(test->getColorModes(display,
-                        &colorModes));
-
-                EXPECT_NE(std::count(colorModes.begin(), colorModes.end(),
-                        ColorMode::NATIVE), 0) << "all displays"
-                        " must support ColorMode::NATIVE";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get color modes from a bad display. */
-TEST_F(Hwc2Test, GET_COLOR_MODES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<ColorMode> colorModes;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getColorModes(display, &colorModes, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can set the required color mode on a display. */
-TEST_F(Hwc2Test, SET_COLOR_MODES)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const ColorMode colorMode = ColorMode::NATIVE;
-
-                EXPECT_NO_FATAL_FAILURE(test->setColorMode(display, colorMode));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a color mode on a bad display. */
-TEST_F(Hwc2Test, SET_COLOR_MODES_bad_display)
-{
-    hwc2_display_t display;
-    const ColorMode colorMode = ColorMode::NATIVE;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setColorMode(display, colorMode, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid color mode. */
-TEST_F(Hwc2Test, SET_COLOR_MODES_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const ColorMode colorMode = static_cast<ColorMode>(-1);
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setColorMode(display, colorMode,
-                        &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 either supports or returns error unsupported
- * for all valid color modes. */
-TEST_F(Hwc2Test, SET_COLOR_MODES_unsupported)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                for (auto colorMode : androidColorModes) {
-                    hwc2_error_t err = HWC2_ERROR_NONE;
-
-                    ASSERT_NO_FATAL_FAILURE(test->setColorMode(display,
-                            colorMode, &err));
-
-                    EXPECT_TRUE(err == HWC2_ERROR_NONE
-                            || err == HWC2_ERROR_UNSUPPORTED)
-                            << "returned wrong error code";
-                }
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 gets the HDR capabilities for a display and
- * test if they are valid. */
-TEST_F(Hwc2Test, GET_HDR_CAPABILITIES)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                std::vector<android_hdr_t> hdrCapabilities;
-                float maxLuminance, maxAverageLuminance, minLuminance;
-
-                EXPECT_NO_FATAL_FAILURE(test->getHdrCapabilities(display,
-                        &hdrCapabilities, &maxLuminance, &maxAverageLuminance,
-                        &minLuminance));
-
-                if (hdrCapabilities.empty())
-                    return;
-
-                EXPECT_GE(maxLuminance, maxAverageLuminance);
-                EXPECT_GE(maxAverageLuminance, minLuminance);
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get hdr capabilities from a bad display */
-TEST_F(Hwc2Test, GET_HDR_CAPABILITIES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<android_hdr_t> hdrCapabilities;
-    float maxLuminance, maxAverageLuminance, minLuminance;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getHdrCapabilities(display, &hdrCapabilities,
-            &maxLuminance, &maxAverageLuminance, &minLuminance, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-static const std::array<float, 16> identityMatrix = {{
-    1.0,  0.0,  0.0,  0.0,
-    0.0,  1.0,  0.0,  0.0,
-    0.0,  0.0,  1.0,  0.0,
-    0.0,  0.0,  0.0,  1.0,
-}};
-
-/* Values for the color transform matrices were precomputed using the source code
- * in surfaceflinger/Effects/Daltonizer.cpp. */
-
-static const std::array<const std::array<float, 16>, 5> exampleMatrices = {{
-    identityMatrix,
-    /* Converts RGB color to the XYZ space */
-    {{ 0.4124, 0.2126, 0.0193, 0,
-       0.3576, 0.7152, 0.1192, 0,
-       0.1805, 0.0722, 0.9505, 0,
-       0     , 0     , 0     , 1 }},
-    /* Protanomaly */
-    {{ 0.068493,  0.931506,  0,  0,
-       0.068493,  0.931507,  0,  0,
-       0.013626, -0.013626,  1,  0,
-       0,         0,         0,  1 }},
-    /* Deuteranomaly */
-    {{ 0.288299, 0.711701,  0,  0,
-       0.052709, 0.947291,  0,  0,
-      -0.257912, 0.257912,  1,  0,
-       0,        0,         0,  1 }},
-    /* Tritanomaly */
-    {{ 1, -0.805712, 0.805712,  0,
-       0,  0.378838, 0.621162,  0,
-       0,  0.104823, 0.895177,  0,
-       0,  0,        0,         1 }},
-}};
-
-/* TESTCASE: Tests that the HWC2 can set the identity color transform */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setColorTransform(display,
-                        identityMatrix, HAL_COLOR_TRANSFORM_IDENTITY));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the color transform for a bad
- * display. */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setColorTransform(display, identityMatrix,
-            HAL_COLOR_TRANSFORM_IDENTITY, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid color transform. */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const android_color_transform_t hint =
-                        static_cast<android_color_transform_t>(-1);
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setColorTransform(display,
-                        identityMatrix, hint, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set an arbitrary color matrix. */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM_arbitrary_matrix)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const android_color_transform_t hint =
-                        HAL_COLOR_TRANSFORM_ARBITRARY_MATRIX;
-
-                for (const std::array<float, 16>& matrix : exampleMatrices) {
-                    EXPECT_NO_FATAL_FAILURE(test->setColorTransform(display,
-                            matrix, hint));
-                }
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 create an destory virtual displays. */
-TEST_F(Hwc2Test, CREATE_DESTROY_VIRTUAL_DISPLAY)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* /*test*/, hwc2_display_t /*display*/,
-                    Hwc2TestVirtualDisplay* /*testVirtualDisplay*/) { }));
-}
-
-/* TESTCASE: Tests that the HWC2 can create and destroy multiple virtual
- * displays. */
-TEST_F(Hwc2Test, CREATE_DESTROY_VIRTUAL_DISPLAY_multiple)
-{
-    Hwc2TestVirtualDisplay testVirtualDisplay(Hwc2TestCoverage::Complete);
-    std::vector<hwc2_display_t> displays;
-
-    do {
-        const UnsignedArea& dimension =
-                testVirtualDisplay.getDisplayDimension();
-        android_pixel_format_t desiredFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-        hwc2_display_t display;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(dimension.width,
-                dimension.height, &desiredFormat, &display, &err));
-
-        EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_NO_RESOURCES
-                || err == HWC2_ERROR_UNSUPPORTED) << "returned wrong error code";
-        EXPECT_GE(desiredFormat, 0) << "invalid format";
-
-        if (err == HWC2_ERROR_NONE)
-            displays.push_back(display);
-
-    } while (testVirtualDisplay.advance());
-
-    for (hwc2_display_t display : displays) {
-        EXPECT_NO_FATAL_FAILURE(destroyVirtualDisplay(display));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destroy a bad virtual displays.  */
-TEST_F(Hwc2Test, DESTROY_VIRTUAL_DISPLAY_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(destroyVirtualDisplay(display, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destroy a physical display. */
-TEST_F(Hwc2Test, DESTROY_VIRTUAL_DISPLAY_bad_parameter)
-{
-    hwc2_error_t err = HWC2_ERROR_NONE;
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(destroyVirtualDisplay(display, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can get the max virtual display count. */
-TEST_F(Hwc2Test, GET_MAX_VIRTUAL_DISPLAY_COUNT)
-{
-    uint32_t maxCnt;
-
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt));
-}
-
-/* TESTCASE: Tests that the HWC2 returns the same max virtual display count for
- * each call. */
-TEST_F(Hwc2Test, GET_MAX_VIRTUAL_DISPLAY_COUNT_duplicate)
-{
-    uint32_t maxCnt1, maxCnt2;
-
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt1));
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt2));
-
-    EXPECT_EQ(maxCnt1, maxCnt2) << "returned two different max virtual display"
-            " counts";
-}
-
-/* TESTCASE: Tests that the HWC2 can create the max number of virtual displays
- * that it reports. */
-TEST_F(Hwc2Test, GET_MAX_VIRTUAL_DISPLAY_COUNT_create_max)
-{
-    std::vector<hwc2_display_t> displays;
-    uint32_t maxCnt;
-
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt));
-
-    while (displays.size() < maxCnt) {
-        uint32_t width = 1920, height = 1080;
-        android_pixel_format_t desiredFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-        hwc2_display_t display;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(width, height,
-                    &desiredFormat, &display, &err));
-
-        EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_UNSUPPORTED)
-                << "returned wrong error code";
-        if (err != HWC2_ERROR_NONE)
-            break;
-
-        displays.push_back(display);
-    }
-
-    for (hwc2_display_t display : displays) {
-        EXPECT_NO_FATAL_FAILURE(destroyVirtualDisplay(display));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set an output buffer for a virtual
- * display. */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    Hwc2TestVirtualDisplay* testVirtualDisplay) {
-
-                buffer_handle_t handle;
-                android::base::unique_fd acquireFence;
-
-                if (testVirtualDisplay->getOutputBuffer(&handle, &acquireFence) >= 0)
-                    EXPECT_NO_FATAL_FAILURE(test->setOutputBuffer(display,
-                            handle, acquireFence));
-            }));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an output buffer for a bad display */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER_bad_display)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t /*display*/,
-                    Hwc2TestVirtualDisplay* testVirtualDisplay) {
-
-                hwc2_display_t badDisplay;
-                buffer_handle_t handle;
-                android::base::unique_fd acquireFence;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getBadDisplay(&badDisplay));
-
-                if (testVirtualDisplay->getOutputBuffer(&handle, &acquireFence) < 0)
-                    return;
-
-                ASSERT_NO_FATAL_FAILURE(test->setOutputBuffer(badDisplay,
-                        handle, acquireFence, &err));
-                EXPECT_TRUE(err == HWC2_ERROR_BAD_DISPLAY)
-                        << "returned wrong error code";
-            }));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid output buffer. */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    Hwc2TestVirtualDisplay* /*testVirtualDisplay*/) {
-
-                const buffer_handle_t handle = nullptr;
-                uint32_t releaseFence = -1;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setOutputBuffer(display, handle,
-                        releaseFence, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER)
-                        << "returned wrong error code";
-            }));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an output buffer for non virtual
- * display */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER_unsupported)
-{
-    for (auto display : mDisplays) {
-        Hwc2TestVirtualDisplay testVirtualDisplay(Hwc2TestCoverage::Complete);
-
-        do {
-            buffer_handle_t handle;
-            android::base::unique_fd acquireFence;
-            hwc2_error_t err = HWC2_ERROR_NONE;
-
-            if (testVirtualDisplay.getOutputBuffer(&handle, &acquireFence) < 0)
-                continue;
-
-            ASSERT_NO_FATAL_FAILURE(setOutputBuffer(display, handle,
-                    acquireFence, &err));
-            EXPECT_EQ(err, HWC2_ERROR_UNSUPPORTED) << "returned wrong error code";
-
-        } while (testVirtualDisplay.advance());
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can dump debug information. */
-TEST_F(Hwc2Test, DUMP)
-{
-    std::string buffer;
-
-    ASSERT_NO_FATAL_FAILURE(dump(&buffer));
-}
-
-/*
- * TODO(b/64724708): Hwc2TestPropertyName::BufferArea MUST be default for all
- * virtual display tests as we don't handle this case correctly.
- *
- * Only default dataspace is supported in our drawing code.
- */
-const std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>
-        virtualDisplayExceptions =
-        {{Hwc2TestPropertyName::BufferArea, Hwc2TestCoverage::Default},
-        {Hwc2TestPropertyName::Dataspace, Hwc2TestCoverage::Default}};
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with default coverage on a
- * virtual display. */
-TEST_F(Hwc2Test, PRESENT_VIRTUAL_DISPLAY_default_1)
-{
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    const size_t layerCnt = 1;
-    ASSERT_NO_FATAL_FAILURE(createAndPresentVirtualDisplay(layerCnt, coverage,
-            virtualDisplayExceptions));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with basic coverage on a
- * virtual display. */
-TEST_F(Hwc2Test, PRESENT_VIRTUAL_DISPLAY_basic_1)
-{
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Basic;
-    const size_t layerCnt = 1;
-    ASSERT_NO_FATAL_FAILURE(createAndPresentVirtualDisplay(layerCnt, coverage,
-            virtualDisplayExceptions));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with default coverage on a
- * virtual display. */
-TEST_F(Hwc2Test, PRESENT_VIRTUAL_DISPLAY_default_2)
-{
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    const size_t layerCnt = 2;
-    ASSERT_NO_FATAL_FAILURE(createAndPresentVirtualDisplay(layerCnt, coverage,
-            virtualDisplayExceptions));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 3 layers with default coverage on a
- * virtual display. */
-TEST_F(Hwc2Test, PRESENT_VIRTUAL_DISPLAY_default_3)
-{
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    const size_t layerCnt = 3;
-    ASSERT_NO_FATAL_FAILURE(createAndPresentVirtualDisplay(layerCnt, coverage,
-            virtualDisplayExceptions));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 4 layers with default coverage on a
- * virtual display. */
-TEST_F(Hwc2Test, PRESENT_VIRTUAL_DISPLAY_default_4)
-{
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    const size_t layerCnt = 4;
-    ASSERT_NO_FATAL_FAILURE(createAndPresentVirtualDisplay(layerCnt, coverage,
-            virtualDisplayExceptions));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 5 layers with default coverage on a
- * virtual display. */
-TEST_F(Hwc2Test, PRESENT_VIRTUAL_DISPLAY_default_5)
-{
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    const size_t layerCnt = 5;
-    ASSERT_NO_FATAL_FAILURE(createAndPresentVirtualDisplay(layerCnt, coverage,
-            virtualDisplayExceptions));
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp
deleted file mode 100644
index 648456295..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp
+++ /dev/null
@@ -1,791 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <mutex>
-#include <array>
-#include <sstream>
-#include <algorithm>
-
-#include <gui/Surface.h>
-#include <gui/BufferItemConsumer.h>
-
-#include <ui/GraphicBuffer.h>
-#include <android/hardware/graphics/common/1.0/types.h>
-#include <math/vec4.h>
-
-#include <GLES3/gl3.h>
-#include <SkImageEncoder.h>
-#include <SkStream.h>
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestLayers.h"
-
-using namespace android;
-using android::hardware::graphics::common::V1_0::BufferUsage;
-
-/* Returns a fence from egl */
-typedef void (*FenceCallback)(int32_t fence, void* callbackArgs);
-
-/* Returns fence to fence generator */
-static void setFence(int32_t fence, void* fenceGenerator);
-
-
-/* Used to receive the surfaces and fences from egl. The egl buffers are thrown
- * away. The fences are sent to the requester via a callback */
-class Hwc2TestSurfaceManager {
-public:
-    /* Listens for a new frame, detaches the buffer and returns the fence
-     * through saved callback. */
-    class BufferListener : public ConsumerBase::FrameAvailableListener {
-    public:
-        BufferListener(sp<IGraphicBufferConsumer> consumer,
-                FenceCallback callback, void* callbackArgs)
-            : mConsumer(consumer),
-              mCallback(callback),
-              mCallbackArgs(callbackArgs) { }
-
-        void onFrameAvailable(const BufferItem& /*item*/)
-        {
-            BufferItem item;
-
-            if (mConsumer->acquireBuffer(&item, 0))
-                return;
-            if (mConsumer->detachBuffer(item.mSlot))
-                return;
-
-            mCallback(item.mFence->dup(), mCallbackArgs);
-        }
-
-    private:
-        sp<IGraphicBufferConsumer> mConsumer;
-        FenceCallback mCallback;
-        void* mCallbackArgs;
-    };
-
-    /* Creates a buffer listener that waits on a new frame from the buffer
-     * queue. */
-    void initialize(const Area& bufferArea, android_pixel_format_t format,
-            FenceCallback callback, void* callbackArgs)
-    {
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-
-        consumer->setDefaultBufferSize(bufferArea.width, bufferArea.height);
-        consumer->setDefaultBufferFormat(format);
-
-        mBufferItemConsumer = new BufferItemConsumer(consumer, 0);
-
-        mListener = new BufferListener(consumer, callback, callbackArgs);
-        mBufferItemConsumer->setFrameAvailableListener(mListener);
-
-        mSurface = new Surface(producer, true);
-    }
-
-    /* Used by Egl manager. The surface is never displayed. */
-    sp<Surface> getSurface() const
-    {
-        return mSurface;
-    }
-
-private:
-    sp<BufferItemConsumer> mBufferItemConsumer;
-    sp<BufferListener> mListener;
-    /* Used by Egl manager. The surface is never displayed */
-    sp<Surface> mSurface;
-};
-
-
-/* Used to generate valid fences. It is not possible to create a dummy sync
- * fence for testing. Egl can generate buffers along with a valid fence.
- * The buffer cannot be guaranteed to be the same format across all devices so
- * a CPU filled buffer is used instead. The Egl fence is used along with the
- * CPU filled buffer. */
-class Hwc2TestEglManager {
-public:
-    Hwc2TestEglManager()
-        : mEglDisplay(EGL_NO_DISPLAY),
-          mEglSurface(EGL_NO_SURFACE),
-          mEglContext(EGL_NO_CONTEXT) { }
-
-    ~Hwc2TestEglManager()
-    {
-        cleanup();
-    }
-
-    int initialize(sp<Surface> surface)
-    {
-        mSurface = surface;
-
-        mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        if (mEglDisplay == EGL_NO_DISPLAY) return false;
-
-        EGLint major;
-        EGLint minor;
-        if (!eglInitialize(mEglDisplay, &major, &minor)) {
-            ALOGW("Could not initialize EGL");
-            return false;
-        }
-
-        /* We're going to use a 1x1 pbuffer surface later on
-         * The configuration distance doesn't really matter for what we're
-         * trying to do */
-        EGLint configAttrs[] = {
-                EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-                EGL_RED_SIZE, 8,
-                EGL_GREEN_SIZE, 8,
-                EGL_BLUE_SIZE, 8,
-                EGL_ALPHA_SIZE, 0,
-                EGL_DEPTH_SIZE, 24,
-                EGL_STENCIL_SIZE, 0,
-                EGL_NONE
-        };
-
-        EGLConfig configs[1];
-        EGLint configCnt;
-        if (!eglChooseConfig(mEglDisplay, configAttrs, configs, 1,
-                &configCnt)) {
-            ALOGW("Could not select EGL configuration");
-            eglReleaseThread();
-            eglTerminate(mEglDisplay);
-            return false;
-        }
-
-        if (configCnt <= 0) {
-            ALOGW("Could not find EGL configuration");
-            eglReleaseThread();
-            eglTerminate(mEglDisplay);
-            return false;
-        }
-
-        /* These objects are initialized below but the default "null" values are
-         * used to cleanup properly at any point in the initialization sequence */
-        EGLint attrs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
-        mEglContext = eglCreateContext(mEglDisplay, configs[0], EGL_NO_CONTEXT,
-                attrs);
-        if (mEglContext == EGL_NO_CONTEXT) {
-            ALOGW("Could not create EGL context");
-            cleanup();
-            return false;
-        }
-
-        EGLint surfaceAttrs[] = { EGL_NONE };
-        mEglSurface = eglCreateWindowSurface(mEglDisplay, configs[0],
-                mSurface.get(), surfaceAttrs);
-        if (mEglSurface == EGL_NO_SURFACE) {
-            ALOGW("Could not create EGL surface");
-            cleanup();
-            return false;
-        }
-
-        if (!eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-            ALOGW("Could not change current EGL context");
-            cleanup();
-            return false;
-        }
-
-        return true;
-    }
-
-    void makeCurrent() const
-    {
-        eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext);
-    }
-
-    void present() const
-    {
-        eglSwapBuffers(mEglDisplay, mEglSurface);
-    }
-
-private:
-    void cleanup()
-    {
-        if (mEglDisplay == EGL_NO_DISPLAY)
-            return;
-        if (mEglSurface != EGL_NO_SURFACE)
-            eglDestroySurface(mEglDisplay, mEglSurface);
-        if (mEglContext != EGL_NO_CONTEXT)
-            eglDestroyContext(mEglDisplay, mEglContext);
-
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                EGL_NO_CONTEXT);
-        eglReleaseThread();
-        eglTerminate(mEglDisplay);
-    }
-
-    sp<Surface> mSurface;
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurface;
-    EGLContext mEglContext;
-};
-
-
-static const std::array<vec2, 4> triangles = {{
-    {  1.0f,  1.0f },
-    { -1.0f,  1.0f },
-    {  1.0f, -1.0f },
-    { -1.0f, -1.0f },
-}};
-
-class Hwc2TestFenceGenerator {
-public:
-
-    Hwc2TestFenceGenerator()
-    {
-        mSurfaceManager.initialize({1, 1}, HAL_PIXEL_FORMAT_RGBA_8888,
-                setFence, this);
-
-        if (!mEglManager.initialize(mSurfaceManager.getSurface()))
-            return;
-
-        mEglManager.makeCurrent();
-
-        glClearColor(0.0, 0.0, 0.0, 1.0);
-        glEnableVertexAttribArray(0);
-    }
-
-    ~Hwc2TestFenceGenerator()
-    {
-        if (mFence >= 0)
-            close(mFence);
-        mFence = -1;
-
-        mEglManager.makeCurrent();
-    }
-
-    /* It is not possible to simply generate a fence. The easiest way is to
-     * generate a buffer using egl and use the associated fence. The buffer
-     * cannot be guaranteed to be a certain format across all devices using this
-     * method. Instead the buffer is generated using the CPU */
-    int32_t get()
-    {
-        if (mFence >= 0) {
-            return dup(mFence);
-        }
-
-        std::unique_lock<std::mutex> lock(mMutex);
-
-        /* If the pending is still set to false and times out, we cannot recover.
-         * Set an error and return */
-        while (mPending != false) {
-            if (mCv.wait_for(lock, std::chrono::seconds(2)) == std::cv_status::timeout)
-                return -ETIME;
-        }
-
-        /* Generate a fence. The fence will be returned through the setFence
-         * callback */
-        mEglManager.makeCurrent();
-
-        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, triangles.data());
-        glClear(GL_COLOR_BUFFER_BIT);
-
-        mEglManager.present();
-
-        /* Wait for the setFence callback */
-        while (mPending != true) {
-            if (mCv.wait_for(lock, std::chrono::seconds(2)) == std::cv_status::timeout)
-                return -ETIME;
-        }
-
-        mPending = false;
-
-        return dup(mFence);
-    }
-
-    /* Callback that sets the fence */
-    void set(int32_t fence)
-    {
-        mFence = fence;
-        mPending = true;
-
-        mCv.notify_all();
-    }
-
-private:
-
-    Hwc2TestSurfaceManager mSurfaceManager;
-    Hwc2TestEglManager mEglManager;
-
-    std::mutex mMutex;
-    std::condition_variable mCv;
-
-    int32_t mFence = -1;
-    bool mPending = false;
-};
-
-
-static void setFence(int32_t fence, void* fenceGenerator)
-{
-    static_cast<Hwc2TestFenceGenerator*>(fenceGenerator)->set(fence);
-}
-
-
-/* Sets the pixel of a buffer given the location, format, stride and color.
- * Currently only supports RGBA_8888 */
-static void setColor(int32_t x, int32_t y,
-        android_pixel_format_t format, uint32_t stride, uint8_t* img, uint8_t r,
-        uint8_t g, uint8_t b, uint8_t a)
-{
-       switch (format) {
-       case HAL_PIXEL_FORMAT_RGBA_8888:
-           img[(y * stride + x) * 4 + 0] = r;
-           img[(y * stride + x) * 4 + 1] = g;
-           img[(y * stride + x) * 4 + 2] = b;
-           img[(y * stride + x) * 4 + 3] = a;
-           break;
-       default:
-           break;
-       }
-}
-
-Hwc2TestBuffer::Hwc2TestBuffer()
-    : mFenceGenerator(new Hwc2TestFenceGenerator()) { }
-
-Hwc2TestBuffer::~Hwc2TestBuffer() = default;
-
-/* When the buffer changes sizes, save the new size and invalidate the current
- * buffer */
-void Hwc2TestBuffer::updateBufferArea(const Area& bufferArea)
-{
-    if (mBufferArea.width == bufferArea.width
-            && mBufferArea.height == bufferArea.height)
-        return;
-
-    mBufferArea.width = bufferArea.width;
-    mBufferArea.height = bufferArea.height;
-
-    mValidBuffer = false;
-}
-
-/* Returns a valid buffer handle and fence. The handle is filled using the CPU
- * to ensure the correct format across all devices. The fence is created using
- * egl. */
-int Hwc2TestBuffer::get(buffer_handle_t* outHandle, int32_t* outFence)
-{
-    if (mBufferArea.width == -1 || mBufferArea.height == -1)
-        return -EINVAL;
-
-    /* If the current buffer is valid, the previous buffer can be reused.
-     * Otherwise, create new buffer */
-    if (!mValidBuffer) {
-        int ret = generateBuffer();
-        if (ret)
-            return ret;
-    }
-
-    *outFence = mFenceGenerator->get();
-    *outHandle = mHandle;
-
-    mValidBuffer = true;
-
-    return 0;
-}
-
-/* CPU fills a buffer to guarantee the correct buffer format across all
- * devices */
-int Hwc2TestBuffer::generateBuffer()
-{
-    /* Create new graphic buffer with correct dimensions */
-    mGraphicBuffer = new GraphicBuffer(mBufferArea.width, mBufferArea.height,
-            mFormat, BufferUsage::CPU_READ_OFTEN | BufferUsage::CPU_WRITE_OFTEN |
-            BufferUsage::COMPOSER_OVERLAY, "hwc2_test_buffer");
-
-    int ret = mGraphicBuffer->initCheck();
-    if (ret) {
-        return ret;
-    }
-    if (!mGraphicBuffer->handle) {
-        return -EINVAL;
-    }
-
-    /* Locks the buffer for writing */
-    uint8_t* img;
-    mGraphicBuffer->lock(static_cast<uint32_t>(BufferUsage::CPU_WRITE_OFTEN),
-            (void**)(&img));
-
-    uint32_t stride = mGraphicBuffer->getStride();
-
-    /* Iterate from the top row of the buffer to the bottom row */
-    for (int32_t y = 0; y < mBufferArea.height; y++) {
-
-        /* Will be used as R, G and B values for pixel colors */
-        uint8_t max = 255;
-        uint8_t min = 0;
-
-        /* Divide the rows into 3 sections. The first section will contain
-         * the lighest colors. The last section will contain the darkest
-         * colors. */
-        if (y < mBufferArea.height * 1.0 / 3.0) {
-            min = 255 / 2;
-        } else if (y >= mBufferArea.height * 2.0 / 3.0) {
-            max = 255 / 2;
-        }
-
-        /* Divide the columns into 3 sections. The first section is red,
-         * the second is green and the third is blue */
-        int32_t x = 0;
-        for (; x < mBufferArea.width / 3; x++) {
-            setColor(x, y, mFormat, stride, img, max, min, min, 255);
-        }
-
-        for (; x < mBufferArea.width * 2 / 3; x++) {
-            setColor(x, y, mFormat, stride, img, min, max, min, 255);
-        }
-
-        for (; x < mBufferArea.width; x++) {
-            setColor(x, y, mFormat, stride, img, min, min, max, 255);
-        }
-    }
-
-    /* Unlock the buffer for reading */
-    mGraphicBuffer->unlock();
-
-    mHandle = mGraphicBuffer->handle;
-
-    return 0;
-}
-
-
-Hwc2TestClientTargetBuffer::Hwc2TestClientTargetBuffer()
-    : mFenceGenerator(new Hwc2TestFenceGenerator()) { }
-
-Hwc2TestClientTargetBuffer::~Hwc2TestClientTargetBuffer() { }
-
-/* Generates a buffer from layersToDraw.
- * Takes into account the individual layer properties such as
- * transform, blend mode, source crop, etc. */
-static void compositeBufferFromLayers(
-        const android::sp<android::GraphicBuffer>& graphicBuffer,
-        android_pixel_format_t format, const Area& bufferArea,
-        const Hwc2TestLayers* testLayers,
-        const std::set<hwc2_layer_t>* layersToDraw,
-        const std::set<hwc2_layer_t>* clearLayers)
-{
-    /* Locks the buffer for writing */
-    uint8_t* img;
-    graphicBuffer->lock(static_cast<uint32_t>(BufferUsage::CPU_WRITE_OFTEN),
-            (void**)(&img));
-
-    uint32_t stride = graphicBuffer->getStride();
-
-    float bWDiv3 = bufferArea.width / 3;
-    float bW2Div3 = bufferArea.width * 2 / 3;
-    float bHDiv3 = bufferArea.height / 3;
-    float bH2Div3 = bufferArea.height * 2 / 3;
-
-    /* Cycle through every pixel in the buffer and determine what color it
-     * should be. */
-    for (int32_t y = 0; y < bufferArea.height; y++) {
-        for (int32_t x = 0; x < bufferArea.width; x++) {
-
-            uint8_t r = 0, g = 0, b = 0;
-            float a = 0.0f;
-
-            /* Cycle through each layer from back to front and
-             * update the pixel color. */
-            for (auto layer = layersToDraw->rbegin();
-                    layer != layersToDraw->rend(); ++layer) {
-
-                const hwc_rect_t df = testLayers->getDisplayFrame(*layer);
-
-                float dfL = df.left;
-                float dfT = df.top;
-                float dfR = df.right;
-                float dfB = df.bottom;
-
-                /* If the pixel location falls outside of the layer display
-                 * frame, skip the layer. */
-                if (x < dfL || x >= dfR || y < dfT || y >= dfB)
-                    continue;
-
-                /* If the device has requested the layer be clear, clear
-                 * the pixel and continue. */
-                if (clearLayers->count(*layer) != 0) {
-                    r = 0;
-                    g = 0;
-                    b = 0;
-                    a = 0.0f;
-                    continue;
-                }
-
-                float planeAlpha = testLayers->getPlaneAlpha(*layer);
-
-                /* If the layer is a solid color, fill the color and
-                 * continue. */
-                if (testLayers->getComposition(*layer)
-                        == HWC2_COMPOSITION_SOLID_COLOR) {
-                    const auto color = testLayers->getColor(*layer);
-                    r = color.r;
-                    g = color.g;
-                    b = color.b;
-                    a = color.a * planeAlpha;
-                    continue;
-                }
-
-                float xPos = x;
-                float yPos = y;
-
-                hwc_transform_t transform = testLayers->getTransform(*layer);
-
-                float dfW = dfR - dfL;
-                float dfH = dfB - dfT;
-
-                /* If a layer has a transform, find which location on the
-                 * layer will end up in the current pixel location. We
-                 * can calculate the color of the current pixel using that
-                 * location. */
-                if (transform > 0) {
-                    /* Change origin to be the center of the layer. */
-                    xPos = xPos - dfL - dfW / 2.0;
-                    yPos = yPos - dfT - dfH / 2.0;
-
-                    /* Flip Horizontal by reflecting across the y axis. */
-                    if (transform & HWC_TRANSFORM_FLIP_H)
-                        xPos = -xPos;
-
-                    /* Flip vertical by reflecting across the x axis. */
-                    if (transform & HWC_TRANSFORM_FLIP_V)
-                        yPos = -yPos;
-
-                    /* Rotate 90 by using a basic linear algebra rotation
-                     * and scaling the result so the display frame remains
-                     * the same. For example, a buffer of size 100x50 should
-                     * rotate 90 degress but remain the same dimension
-                     * (100x50) at the end of the transformation. */
-                    if (transform & HWC_TRANSFORM_ROT_90) {
-                        float tmp = xPos;
-                        xPos = yPos * dfW / dfH;
-                        yPos = -tmp * dfH / dfW;
-                    }
-
-                    /* Change origin back to the top left corner of the
-                     * layer. */
-                    xPos = xPos + dfL + dfW / 2.0;
-                    yPos = yPos + dfT + dfH / 2.0;
-                }
-
-                hwc_frect_t sc = testLayers->getSourceCrop(*layer);
-                float scL = sc.left, scT = sc.top;
-
-                float dfWDivScW = dfW / (sc.right - scL);
-                float dfHDivScH = dfH / (sc.bottom - scT);
-
-                float max = 255, min = 0;
-
-                /* Choose the pixel color. Similar to generateBuffer,
-                 * each layer will be divided into 3x3 colors. Because
-                 * both the source crop and display frame must be taken into
-                 * account, the formulas are more complicated.
-                 *
-                 * If the source crop and display frame were not taken into
-                 * account, we would simply divide the buffer into three
-                 * sections by height. Each section would get one color.
-                 * For example the formula for the first section would be:
-                 *
-                 * if (yPos < bufferArea.height / 3)
-                 *        //Select first section color
-                 *
-                 * However the pixel color is chosen based on the source
-                 * crop and displayed based on the display frame.
-                 *
-                 * If the display frame top was 0 and the source crop height
-                 * and display frame height were the same. The only factor
-                 * would be the source crop top. To calculate the new
-                 * section boundary, the section boundary would be moved up
-                 * by the height of the source crop top. The formula would
-                 * be:
-                 * if (yPos < (bufferArea.height / 3 - sourceCrop.top)
-                 *        //Select first section color
-                 *
-                 * If the display frame top could also vary but source crop
-                 * and display frame heights were the same, the formula
-                 * would be:
-                 * if (yPos < (bufferArea.height / 3 - sourceCrop.top
-                 *              + displayFrameTop)
-                 *        //Select first section color
-                 *
-                 * If the heights were not the same, the conversion between
-                 * the source crop and display frame dimensions must be
-                 * taken into account. The formula would be:
-                 * if (yPos < ((bufferArea.height / 3) - sourceCrop.top)
-                 *              * displayFrameHeight / sourceCropHeight
-                 *              + displayFrameTop)
-                 *        //Select first section color
-                 */
-                if (yPos < ((bHDiv3) - scT) * dfHDivScH + dfT) {
-                    min = 255 / 2;
-                } else if (yPos >= ((bH2Div3) - scT) * dfHDivScH + dfT) {
-                    max = 255 / 2;
-                }
-
-                uint8_t rCur = min, gCur = min, bCur = min;
-                float aCur = 1.0f;
-
-                /* This further divides the color sections from 3 to 3x3.
-                 * The math behind it follows the same logic as the previous
-                 * comment */
-                if (xPos < ((bWDiv3) - scL) * (dfWDivScW) + dfL) {
-                    rCur = max;
-                } else if (xPos < ((bW2Div3) - scL) * (dfWDivScW) + dfL) {
-                    gCur = max;
-                } else {
-                    bCur = max;
-                }
-
-
-                /* Blend the pixel color with the previous layers' pixel
-                 * colors using the plane alpha and blend mode. The final
-                 * pixel color is chosen using the plane alpha and blend
-                 * mode formulas found in hwcomposer2.h */
-                hwc2_blend_mode_t blendMode = testLayers->getBlendMode(*layer);
-
-                if (blendMode == HWC2_BLEND_MODE_PREMULTIPLIED) {
-                    rCur *= planeAlpha;
-                    gCur *= planeAlpha;
-                    bCur *= planeAlpha;
-                }
-
-                aCur *= planeAlpha;
-
-                if (blendMode == HWC2_BLEND_MODE_PREMULTIPLIED) {
-                    r = rCur + r * (1.0 - aCur);
-                    g = gCur + g * (1.0 - aCur);
-                    b = bCur + b * (1.0 - aCur);
-                    a = aCur + a * (1.0 - aCur);
-                } else if (blendMode == HWC2_BLEND_MODE_COVERAGE) {
-                    r = rCur * aCur + r * (1.0 - aCur);
-                    g = gCur * aCur + g * (1.0 - aCur);
-                    b = bCur * aCur + b * (1.0 - aCur);
-                    a = aCur * aCur + a * (1.0 - aCur);
-                } else {
-                    r = rCur;
-                    g = gCur;
-                    b = bCur;
-                    a = aCur;
-                }
-            }
-
-            /* Set the pixel color */
-            setColor(x, y, format, stride, img, r, g, b, a * 255);
-        }
-    }
-
-    graphicBuffer->unlock();
-}
-
-/* Generates a client target buffer using the layers assigned for client
- * composition. Takes into account the individual layer properties such as
- * transform, blend mode, source crop, etc. */
-int Hwc2TestClientTargetBuffer::get(buffer_handle_t* outHandle,
-        int32_t* outFence, const Area& bufferArea,
-        const Hwc2TestLayers* testLayers,
-        const std::set<hwc2_layer_t>* clientLayers,
-        const std::set<hwc2_layer_t>* clearLayers)
-{
-    /* Create new graphic buffer with correct dimensions */
-    mGraphicBuffer = new GraphicBuffer(bufferArea.width, bufferArea.height,
-            mFormat, BufferUsage::CPU_READ_OFTEN | BufferUsage::CPU_WRITE_OFTEN |
-            BufferUsage::COMPOSER_OVERLAY, "hwc2_test_buffer");
-
-    int ret = mGraphicBuffer->initCheck();
-    if (ret)
-        return ret;
-
-    if (!mGraphicBuffer->handle)
-        return -EINVAL;
-
-    compositeBufferFromLayers(mGraphicBuffer, mFormat, bufferArea, testLayers,
-            clientLayers, clearLayers);
-
-    *outFence = mFenceGenerator->get();
-    *outHandle = mGraphicBuffer->handle;
-
-    return 0;
-}
-
-void Hwc2TestVirtualBuffer::updateBufferArea(const Area& bufferArea)
-{
-    mBufferArea.width = bufferArea.width;
-    mBufferArea.height = bufferArea.height;
-}
-
-bool Hwc2TestVirtualBuffer::writeBufferToFile(std::string path)
-{
-    SkFILEWStream file(path.c_str());
-    const SkImageInfo info = SkImageInfo::Make(mBufferArea.width,
-            mBufferArea.height, SkColorType::kRGBA_8888_SkColorType,
-            SkAlphaType::kPremul_SkAlphaType);
-
-    uint8_t* img;
-    mGraphicBuffer->lock(static_cast<uint32_t>(BufferUsage::CPU_WRITE_OFTEN),
-            (void**)(&img));
-
-    SkPixmap pixmap(info, img, mGraphicBuffer->getStride());
-    bool result = file.isValid() && SkEncodeImage(&file, pixmap,
-            SkEncodedImageFormat::kPNG, 100);
-
-    mGraphicBuffer->unlock();
-    return result;
-}
-
-/* Generates a buffer that holds the expected result of compositing all of our
- * layers */
-int Hwc2TestExpectedBuffer::generateExpectedBuffer(
-        const Hwc2TestLayers* testLayers,
-        const std::vector<hwc2_layer_t>* allLayers,
-        const std::set<hwc2_layer_t>* clearLayers)
-{
-    mGraphicBuffer = new GraphicBuffer(mBufferArea.width, mBufferArea.height,
-            mFormat, BufferUsage::CPU_READ_OFTEN | BufferUsage::CPU_WRITE_OFTEN,
-            "hwc2_test_buffer");
-
-    int ret = mGraphicBuffer->initCheck();
-    if (ret)
-        return ret;
-
-    if (!mGraphicBuffer->handle)
-        return -EINVAL;
-
-    const std::set<hwc2_layer_t> allLayerSet(allLayers->begin(),
-            allLayers->end());
-
-    compositeBufferFromLayers(mGraphicBuffer, mFormat, mBufferArea, testLayers,
-            &allLayerSet, clearLayers);
-
-    return 0;
-}
-
-int Hwc2TestOutputBuffer::getOutputBuffer(buffer_handle_t* outHandle,
-        int32_t* outFence)
-{
-    if (mBufferArea.width == -1 || mBufferArea.height == -1)
-        return -EINVAL;
-
-    mGraphicBuffer = new GraphicBuffer(mBufferArea.width, mBufferArea.height,
-            mFormat, BufferUsage::CPU_READ_OFTEN |
-            BufferUsage::GPU_RENDER_TARGET, "hwc2_test_buffer");
-
-    int ret = mGraphicBuffer->initCheck();
-    if (ret)
-        return ret;
-
-    if (!mGraphicBuffer->handle)
-        return -EINVAL;
-
-    *outFence = -1;
-    *outHandle = mGraphicBuffer->handle;
-
-    return 0;
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h b/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h
deleted file mode 100644
index fd54fef2d..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_BUFFER_H
-#define _HWC2_TEST_BUFFER_H
-
-#include <android-base/unique_fd.h>
-#include <set>
-
-#include <hardware/hwcomposer2.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include "Hwc2TestProperties.h"
-
-class Hwc2TestFenceGenerator;
-class Hwc2TestLayers;
-
-class Hwc2TestBuffer {
-public:
-    Hwc2TestBuffer();
-    ~Hwc2TestBuffer();
-
-    void updateBufferArea(const Area& bufferArea);
-
-    int  get(buffer_handle_t* outHandle, int32_t* outFence);
-
-protected:
-    int generateBuffer();
-
-    android::sp<android::GraphicBuffer> mGraphicBuffer;
-
-    std::unique_ptr<Hwc2TestFenceGenerator> mFenceGenerator;
-
-    Area mBufferArea = {-1, -1};
-    const android_pixel_format_t mFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-
-    bool mValidBuffer = false;
-    buffer_handle_t mHandle = nullptr;
-};
-
-
-class Hwc2TestClientTargetBuffer {
-public:
-    Hwc2TestClientTargetBuffer();
-    ~Hwc2TestClientTargetBuffer();
-
-    int  get(buffer_handle_t* outHandle, int32_t* outFence,
-            const Area& bufferArea, const Hwc2TestLayers* testLayers,
-            const std::set<hwc2_layer_t>* clientLayers,
-            const std::set<hwc2_layer_t>* clearLayers);
-
-protected:
-    android::sp<android::GraphicBuffer> mGraphicBuffer;
-
-    std::unique_ptr<Hwc2TestFenceGenerator> mFenceGenerator;
-
-    const android_pixel_format_t mFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-};
-
-
-class Hwc2TestVirtualBuffer {
-public:
-    void updateBufferArea(const Area& bufferArea);
-
-    bool writeBufferToFile(std::string path);
-
-    android::sp<android::GraphicBuffer>& graphicBuffer()
-    {
-        return mGraphicBuffer;
-    }
-
-protected:
-    android::sp<android::GraphicBuffer> mGraphicBuffer;
-
-    Area mBufferArea = {-1, -1};
-
-    const android_pixel_format_t mFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-};
-
-
-class Hwc2TestExpectedBuffer : public Hwc2TestVirtualBuffer {
-public:
-    int generateExpectedBuffer(const Hwc2TestLayers* testLayers,
-            const std::vector<hwc2_layer_t>* allLayers,
-            const std::set<hwc2_layer_t>* clearLayers);
-};
-
-
-class Hwc2TestOutputBuffer : public Hwc2TestVirtualBuffer {
-public:
-    int getOutputBuffer(buffer_handle_t* outHandle, int32_t* outFence);
-};
-
-#endif /* ifndef _HWC2_TEST_BUFFER_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp
deleted file mode 100644
index 14c60a7d2..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-
-#include <ui/Rect.h>
-
-#include "Hwc2TestClientTarget.h"
-
-int Hwc2TestClientTarget::getBuffer(const Hwc2TestLayers& testLayers,
-        const std::set<hwc2_layer_t>& clientLayers,
-        const std::set<hwc2_layer_t>& clearLayers, bool flipClientTarget,
-        const Area& displayArea, buffer_handle_t* outHandle,
-        int32_t* outAcquireFence)
-{
-    if (!flipClientTarget) {
-        bool needsClientTarget = false;
-
-        for (auto clientLayer : clientLayers) {
-            if (testLayers.getVisibleRegion(clientLayer).numRects > 0) {
-                needsClientTarget = true;
-                break;
-            }
-        }
-
-        if (!needsClientTarget) {
-           *outHandle = nullptr;
-           *outAcquireFence = -1;
-           return 0;
-        }
-    }
-
-    return mBuffer.get(outHandle, outAcquireFence, displayArea,
-            &testLayers, &clientLayers, &clearLayers);
-}
-
-
-Hwc2TestClientTargetSupport::Hwc2TestClientTargetSupport(
-        Hwc2TestCoverage coverage, const Area& displayArea)
-    : mBufferArea(coverage, displayArea),
-      mDataspace(coverage),
-      mSurfaceDamage(coverage)
-{
-    mBufferArea.setDependent(&mSurfaceDamage);
-}
-
-std::string Hwc2TestClientTargetSupport::dump() const
-{
-    std::stringstream dmp;
-
-    dmp << "client target: \n";
-
-    for (auto property : properties) {
-        dmp << property->dump();
-    }
-
-    return dmp.str();
-}
-
-void Hwc2TestClientTargetSupport::reset()
-{
-    for (auto property : properties) {
-        property->reset();
-    }
-}
-
-bool Hwc2TestClientTargetSupport::advance()
-{
-    for (auto property : properties) {
-        if (property->advance())
-            return true;
-    }
-    return false;
-}
-
-Area Hwc2TestClientTargetSupport::getBufferArea() const
-{
-    return mBufferArea.get();
-}
-
-android::ui::Dataspace Hwc2TestClientTargetSupport::getDataspace() const
-{
-    return mDataspace.get();
-}
-
-const hwc_region_t Hwc2TestClientTargetSupport::getSurfaceDamage() const
-{
-    return mSurfaceDamage.get();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h b/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h
deleted file mode 100644
index 6f4090f32..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_CLIENT_TARGET_H
-#define _HWC2_TEST_CLIENT_TARGET_H
-
-#include <set>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestProperties.h"
-#include "Hwc2TestLayers.h"
-
-/* Generates client target buffers from client composition layers */
-class Hwc2TestClientTarget {
-public:
-    int getBuffer(const Hwc2TestLayers& layers,
-            const std::set<hwc2_layer_t>& clientLayers,
-            const std::set<hwc2_layer_t>& clearLayers,
-            bool clearClientTarget, const Area& displayArea,
-            buffer_handle_t* outHandle, int32_t* outAcquireFence);
-
-private:
-    Hwc2TestClientTargetBuffer mBuffer;
-};
-
-/* Generates valid client targets to test which ones the device will support */
-class Hwc2TestClientTargetSupport {
-public:
-    Hwc2TestClientTargetSupport(Hwc2TestCoverage coverage,
-            const Area& displayArea);
-
-    std::string dump() const;
-
-    void reset();
-    bool advance();
-
-    Area getBufferArea() const;
-    android::ui::Dataspace getDataspace() const;
-    const hwc_region_t getSurfaceDamage() const;
-
-private:
-    std::array<Hwc2TestContainer*, 3> properties = {{
-        &mDataspace, &mSurfaceDamage, &mBufferArea
-    }};
-
-    Hwc2TestBufferArea mBufferArea;
-    Hwc2TestDataspace mDataspace;
-    Hwc2TestSurfaceDamage mSurfaceDamage;
-};
-
-#endif /* ifndef _HWC2_TEST_CLIENT_TARGET_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp
deleted file mode 100644
index c1c9cc8f5..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-
-#include "Hwc2TestLayer.h"
-
-Hwc2TestCoverage getCoverage(Hwc2TestPropertyName property,
-        Hwc2TestCoverage coverage, const std::unordered_map<Hwc2TestPropertyName,
-        Hwc2TestCoverage>& coverageExceptions) {
-    auto exception = coverageExceptions.find(property);
-    return (exception != coverageExceptions.end())? exception->second : coverage;
-}
-
-Hwc2TestLayer::Hwc2TestLayer(Hwc2TestCoverage coverage,
-        const Area& displayArea)
-    : Hwc2TestLayer(coverage, displayArea,
-            std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>()) { }
-
-Hwc2TestLayer::Hwc2TestLayer(Hwc2TestCoverage coverage,
-        const Area& displayArea, const std::unordered_map<Hwc2TestPropertyName,
-        Hwc2TestCoverage>& coverageExceptions)
-    : mBlendMode(getCoverage(Hwc2TestPropertyName::BlendMode, coverage,
-           coverageExceptions)),
-      mBufferArea(getCoverage(Hwc2TestPropertyName::BufferArea, coverage,
-           coverageExceptions), displayArea),
-      mColor(getCoverage(Hwc2TestPropertyName::Color, coverage,
-           coverageExceptions)),
-      mComposition(getCoverage(Hwc2TestPropertyName::Composition, coverage,
-           coverageExceptions)),
-      mDataspace(getCoverage(Hwc2TestPropertyName::Dataspace, coverage,
-           coverageExceptions)),
-      mDisplayFrame(getCoverage(Hwc2TestPropertyName::DisplayFrame, coverage,
-           coverageExceptions), displayArea),
-      mPlaneAlpha(getCoverage(Hwc2TestPropertyName::PlaneAlpha, coverage,
-           coverageExceptions)),
-      mSourceCrop(getCoverage(Hwc2TestPropertyName::SourceCrop, coverage,
-           coverageExceptions)),
-      mSurfaceDamage(getCoverage(Hwc2TestPropertyName::SurfaceDamage, coverage,
-           coverageExceptions)),
-      mTransform(getCoverage(Hwc2TestPropertyName::Transform, coverage,
-           coverageExceptions))
-{
-    mBufferArea.setDependent(&mBuffer);
-    mBufferArea.setDependent(&mSourceCrop);
-    mBufferArea.setDependent(&mSurfaceDamage);
-    mBlendMode.setDependent(&mColor);
-}
-
-std::string Hwc2TestLayer::dump() const
-{
-    std::stringstream dmp;
-
-    dmp << "layer: \n";
-
-    for (auto property : mProperties) {
-        dmp << property->dump();
-    }
-
-    dmp << mVisibleRegion.dump();
-    dmp << "\tz order: " << mZOrder << "\n";
-
-    return dmp.str();
-}
-
-int Hwc2TestLayer::getBuffer(buffer_handle_t* outHandle,
-        android::base::unique_fd* outAcquireFence)
-{
-    int32_t acquireFence;
-    int ret = mBuffer.get(outHandle, &acquireFence);
-    outAcquireFence->reset(acquireFence);
-    return ret;
-}
-
-int Hwc2TestLayer::getBuffer(buffer_handle_t* outHandle,
-        int32_t* outAcquireFence)
-{
-    return mBuffer.get(outHandle, outAcquireFence);
-}
-
-void Hwc2TestLayer::setZOrder(uint32_t zOrder)
-{
-    mZOrder = zOrder;
-}
-
-void Hwc2TestLayer::setVisibleRegion(const android::Region& region)
-{
-    return mVisibleRegion.set(region);
-}
-
-void Hwc2TestLayer::reset()
-{
-    mVisibleRegion.release();
-
-    for (auto property : mProperties) {
-        property->reset();
-    }
-}
-
-bool Hwc2TestLayer::advance()
-{
-    for (auto property : mProperties) {
-        if (property->isSupported(mComposition.get()))
-            if (property->advance())
-                return true;
-    }
-    return false;
-}
-
-hwc2_blend_mode_t Hwc2TestLayer::getBlendMode() const
-{
-    return mBlendMode.get();
-}
-
-Area Hwc2TestLayer::getBufferArea() const
-{
-    return mBufferArea.get();
-}
-
-hwc_color_t Hwc2TestLayer::getColor() const
-{
-    return mColor.get();
-}
-
-hwc2_composition_t Hwc2TestLayer::getComposition() const
-{
-    return mComposition.get();
-}
-
-/* The cursor position corresponds to {displayFrame.left, displayFrame.top} */
-hwc_rect_t Hwc2TestLayer::getCursorPosition() const
-{
-    return mDisplayFrame.get();
-}
-
-android::ui::Dataspace Hwc2TestLayer::getDataspace() const
-{
-    return mDataspace.get();
-}
-
-hwc_rect_t Hwc2TestLayer::getDisplayFrame() const
-{
-    return mDisplayFrame.get();
-}
-
-float Hwc2TestLayer::getPlaneAlpha() const
-{
-    return mPlaneAlpha.get();
-}
-
-hwc_frect_t Hwc2TestLayer::getSourceCrop() const
-{
-    return mSourceCrop.get();
-}
-
-hwc_region_t Hwc2TestLayer::getSurfaceDamage() const
-{
-    return mSurfaceDamage.get();
-}
-
-hwc_transform_t Hwc2TestLayer::getTransform() const
-{
-    return mTransform.get();
-}
-
-hwc_region_t Hwc2TestLayer::getVisibleRegion() const
-{
-    return mVisibleRegion.get();
-}
-
-uint32_t Hwc2TestLayer::getZOrder() const
-{
-    return mZOrder;
-}
-
-bool Hwc2TestLayer::advanceBlendMode()
-{
-    return mBlendMode.advance();
-}
-
-bool Hwc2TestLayer::advanceBufferArea()
-{
-    return mBufferArea.advance();
-}
-
-bool Hwc2TestLayer::advanceColor()
-{
-    return mColor.advance();
-}
-
-bool Hwc2TestLayer::advanceComposition()
-{
-    return mComposition.advance();
-}
-
-bool Hwc2TestLayer::advanceCursorPosition()
-{
-    return mDisplayFrame.advance();
-}
-
-bool Hwc2TestLayer::advanceDataspace()
-{
-    return mDataspace.advance();
-}
-
-bool Hwc2TestLayer::advanceDisplayFrame()
-{
-    return mDisplayFrame.advance();
-}
-
-bool Hwc2TestLayer::advancePlaneAlpha()
-{
-    return mPlaneAlpha.advance();
-}
-
-bool Hwc2TestLayer::advanceSourceCrop()
-{
-    return mSourceCrop.advance();
-}
-
-bool Hwc2TestLayer::advanceSurfaceDamage()
-{
-    return mSurfaceDamage.advance();
-}
-
-bool Hwc2TestLayer::advanceTransform()
-{
-    return mTransform.advance();
-}
-
-bool Hwc2TestLayer::advanceVisibleRegion()
-{
-    if (mPlaneAlpha.advance())
-        return true;
-    return mDisplayFrame.advance();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h b/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h
deleted file mode 100644
index 29ae52180..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_LAYER_H
-#define _HWC2_TEST_LAYER_H
-
-#include <android-base/unique_fd.h>
-#include <unordered_map>
-
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestProperties.h"
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-class Hwc2TestLayer {
-public:
-    Hwc2TestLayer(Hwc2TestCoverage coverage, const Area& displayArea);
-
-    Hwc2TestLayer(Hwc2TestCoverage coverage, const Area& displayArea,
-            const std::unordered_map<Hwc2TestPropertyName,
-            Hwc2TestCoverage>& coverage_exceptions);
-
-    std::string dump() const;
-
-    int getBuffer(buffer_handle_t* outHandle,
-            android::base::unique_fd* outAcquireFence);
-    int getBuffer(buffer_handle_t* outHandle, int32_t* outAcquireFence);
-
-    void setZOrder(uint32_t zOrder);
-    void setVisibleRegion(const android::Region& region);
-
-    void reset();
-    bool advance();
-
-    hwc2_blend_mode_t      getBlendMode() const;
-    Area                   getBufferArea() const;
-    hwc_color_t            getColor() const;
-    hwc2_composition_t     getComposition() const;
-    hwc_rect_t             getCursorPosition() const;
-    android::ui::Dataspace     getDataspace() const;
-    hwc_rect_t             getDisplayFrame() const;
-    float                  getPlaneAlpha() const;
-    hwc_frect_t            getSourceCrop() const;
-    hwc_region_t           getSurfaceDamage() const;
-    hwc_transform_t        getTransform() const;
-    hwc_region_t           getVisibleRegion() const;
-    uint32_t               getZOrder() const;
-
-    bool advanceBlendMode();
-    bool advanceBufferArea();
-    bool advanceColor();
-    bool advanceComposition();
-    bool advanceCursorPosition();
-    bool advanceDataspace();
-    bool advanceDisplayFrame();
-    bool advancePlaneAlpha();
-    bool advanceSourceCrop();
-    bool advanceSurfaceDamage();
-    bool advanceTransform();
-    bool advanceVisibleRegion();
-
-private:
-    std::array<Hwc2TestContainer*, 10> mProperties = {{
-        &mTransform, &mColor, &mDataspace, &mPlaneAlpha, &mSourceCrop,
-        &mSurfaceDamage, &mBlendMode, &mBufferArea, &mDisplayFrame,
-        &mComposition
-    }};
-
-    Hwc2TestBuffer mBuffer;
-
-    Hwc2TestBlendMode mBlendMode;
-    Hwc2TestBufferArea mBufferArea;
-    Hwc2TestColor mColor;
-    Hwc2TestComposition mComposition;
-    Hwc2TestDataspace mDataspace;
-    Hwc2TestDisplayFrame mDisplayFrame;
-    Hwc2TestPlaneAlpha mPlaneAlpha;
-    Hwc2TestSourceCrop mSourceCrop;
-    Hwc2TestSurfaceDamage mSurfaceDamage;
-    Hwc2TestTransform mTransform;
-    Hwc2TestVisibleRegion mVisibleRegion;
-
-    uint32_t mZOrder = UINT32_MAX;
-};
-
-#endif /* ifndef _HWC2_TEST_LAYER_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp
deleted file mode 100644
index 90127a130..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp
+++ /dev/null
@@ -1,281 +0,0 @@
-/* * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-#include <gtest/gtest.h>
-
-#include "Hwc2TestLayers.h"
-
-Hwc2TestLayers::Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-        Hwc2TestCoverage coverage, const Area& displayArea)
-    : Hwc2TestLayers(layers, coverage, displayArea,
-            std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>()) { }
-
-Hwc2TestLayers::Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-        Hwc2TestCoverage coverage, const Area& displayArea,
-        const std::unordered_map<Hwc2TestPropertyName,
-        Hwc2TestCoverage>& coverageExceptions)
-    : mDisplayArea(displayArea)
-{
-    for (auto layer : layers) {
-        mTestLayers.emplace(std::piecewise_construct,
-                std::forward_as_tuple(layer),
-                std::forward_as_tuple(coverage, displayArea, coverageExceptions));
-    }
-
-    /* Iterate over the layers in order and assign z orders in the same order.
-     * This allows us to iterate over z orders in the same way when computing
-     * visible regions */
-    uint32_t nextZOrder = layers.size();
-
-    for (auto& testLayer : mTestLayers) {
-        testLayer.second.setZOrder(nextZOrder--);
-    }
-
-    setVisibleRegions();
-}
-
-std::string Hwc2TestLayers::dump() const
-{
-    std::stringstream dmp;
-    for (auto& testLayer : mTestLayers) {
-        dmp << testLayer.second.dump();
-    }
-    return dmp.str();
-}
-
-void Hwc2TestLayers::reset()
-{
-    for (auto& testLayer : mTestLayers) {
-        testLayer.second.reset();
-    }
-
-    setVisibleRegions();
-}
-
-bool Hwc2TestLayers::advance()
-{
-    auto itr = mTestLayers.begin();
-    bool optimized;
-
-    while (itr != mTestLayers.end()) {
-        if (itr->second.advance()) {
-            optimized = setVisibleRegions();
-            if (!mOptimize || optimized)
-                return true;
-            itr = mTestLayers.begin();
-        } else {
-            itr->second.reset();
-            ++itr;
-        }
-    }
-    return false;
-}
-
-bool Hwc2TestLayers::advanceVisibleRegions()
-{
-    auto itr = mTestLayers.begin();
-    bool optimized;
-
-    while (itr != mTestLayers.end()) {
-        if (itr->second.advanceVisibleRegion()) {
-            optimized = setVisibleRegions();
-            if (!mOptimize || optimized)
-                return true;
-            itr = mTestLayers.begin();
-        } else {
-            itr->second.reset();
-            ++itr;
-        }
-    }
-    return false;
-}
-
-/* Removes layouts that do not cover the entire display.
- * Also removes layouts where a layer is completely blocked from view.
- */
-bool Hwc2TestLayers::optimizeLayouts()
-{
-    mOptimize = true;
-
-    if (setVisibleRegions())
-        return true;
-    return advance();
-}
-
-bool Hwc2TestLayers::contains(hwc2_layer_t layer) const
-{
-    return mTestLayers.count(layer) != 0;
-}
-
-int Hwc2TestLayers::getBuffer(hwc2_layer_t layer, buffer_handle_t* outHandle,
-        int32_t* outAcquireFence)
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getBuffer(outHandle, outAcquireFence);
-}
-
-hwc2_blend_mode_t Hwc2TestLayers::getBlendMode(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getBlendMode();
-}
-
-Area Hwc2TestLayers::getBufferArea(hwc2_layer_t layer) const
-{
-    auto testLayer = mTestLayers.find(layer);
-    if (testLayer == mTestLayers.end())
-        [] () { GTEST_FAIL(); }();
-    return testLayer->second.getBufferArea();
-}
-
-hwc_color_t Hwc2TestLayers::getColor(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getColor();
-}
-
-hwc2_composition_t Hwc2TestLayers::getComposition(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getComposition();
-}
-
-hwc_rect_t Hwc2TestLayers::getCursorPosition(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getCursorPosition();
-}
-
-android::ui::Dataspace Hwc2TestLayers::getDataspace(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getDataspace();
-}
-
-hwc_rect_t Hwc2TestLayers::getDisplayFrame(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getDisplayFrame();
-}
-
-float Hwc2TestLayers::getPlaneAlpha(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getPlaneAlpha();
-}
-
-hwc_frect_t Hwc2TestLayers::getSourceCrop(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getSourceCrop();
-}
-
-hwc_region_t Hwc2TestLayers::getSurfaceDamage(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getSurfaceDamage();
-}
-
-hwc_transform_t Hwc2TestLayers::getTransform(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getTransform();
-}
-
-hwc_region_t Hwc2TestLayers::getVisibleRegion(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getVisibleRegion();
-}
-
-uint32_t Hwc2TestLayers::getZOrder(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getZOrder();
-}
-
-/* Sets the visible regions for a display. Returns false if the layers do not
- * cover the entire display or if a layer is not visible */
-bool Hwc2TestLayers::setVisibleRegions()
-{
-    /* The region of the display that is covered by layers above the current
-     * layer */
-    android::Region aboveOpaqueLayers;
-
-    bool optimized = true;
-
-    /* Iterate over test layers from max z order to min z order. */
-    for (auto& testLayer : mTestLayers) {
-        android::Region visibleRegion;
-
-        /* Set the visible region of this layer */
-        const hwc_rect_t displayFrame = testLayer.second.getDisplayFrame();
-
-        visibleRegion.set(android::Rect(displayFrame.left, displayFrame.top,
-                displayFrame.right, displayFrame.bottom));
-
-        /* Remove the area covered by opaque layers above this layer
-         * from this layer's visible region */
-        visibleRegion.subtractSelf(aboveOpaqueLayers);
-
-        testLayer.second.setVisibleRegion(visibleRegion);
-
-        /* If a layer is not visible, return false */
-        if (visibleRegion.isEmpty())
-            optimized = false;
-
-        /* If this layer is opaque, store the region it covers */
-        if (testLayer.second.getPlaneAlpha() == 1.0f)
-            aboveOpaqueLayers.orSelf(visibleRegion);
-    }
-
-    /* If the opaque region does not cover the entire display return false */
-    if (!aboveOpaqueLayers.isRect())
-        return false;
-
-    const auto rect = aboveOpaqueLayers.begin();
-    if (rect->left != 0 || rect->top != 0 || rect->right != mDisplayArea.width
-            || rect->bottom != mDisplayArea.height)
-        return false;
-
-    return optimized;
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h b/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h
deleted file mode 100644
index 909dd486e..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_LAYERS_H
-#define _HWC2_TEST_LAYERS_H
-
-#include <map>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestProperties.h"
-#include "Hwc2TestLayer.h"
-
-class Hwc2TestLayers {
-public:
-    Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestCoverage coverage, const Area& displayArea);
-
-    Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestCoverage coverage, const Area& displayArea,
-            const std::unordered_map<Hwc2TestPropertyName,
-            Hwc2TestCoverage>& coverageExceptions);
-
-    std::string dump() const;
-
-    void reset();
-
-    bool advance();
-    bool advanceVisibleRegions();
-
-    /* Test cases with multiple layers and property values can take quite some
-     * time to run. A significant amount of time can be spent on test cases
-     * where one layer is changing property values but is not visible. To
-     * decrease runtime, this function can be called. Removes layouts where a
-     * layer is completely blocked from view. It also removes layouts that do
-     * not cover the entire display.*/
-    bool optimizeLayouts();
-
-    bool contains(hwc2_layer_t layer) const;
-
-    int  getBuffer(hwc2_layer_t layer, buffer_handle_t* outHandle,
-            int32_t* outAcquireFence);
-
-    hwc2_blend_mode_t      getBlendMode(hwc2_layer_t layer) const;
-    Area                   getBufferArea(hwc2_layer_t layer) const;
-    hwc_color_t            getColor(hwc2_layer_t layer) const;
-    hwc2_composition_t     getComposition(hwc2_layer_t layer) const;
-    hwc_rect_t             getCursorPosition(hwc2_layer_t layer) const;
-    android::ui::Dataspace     getDataspace(hwc2_layer_t layer) const;
-    hwc_rect_t             getDisplayFrame(hwc2_layer_t layer) const;
-    android_pixel_format_t getFormat(hwc2_layer_t layer) const;
-    float                  getPlaneAlpha(hwc2_layer_t layer) const;
-    hwc_frect_t            getSourceCrop(hwc2_layer_t layer) const;
-    hwc_region_t           getSurfaceDamage(hwc2_layer_t layer) const;
-    hwc_transform_t        getTransform(hwc2_layer_t layer) const;
-    hwc_region_t           getVisibleRegion(hwc2_layer_t layer) const;
-    uint32_t               getZOrder(hwc2_layer_t layer) const;
-
-private:
-    bool setVisibleRegions();
-
-    std::map<hwc2_layer_t, Hwc2TestLayer> mTestLayers;
-
-    Area mDisplayArea;
-
-    bool mOptimize = false;
-};
-
-#endif /* ifndef _HWC2_TEST_LAYERS_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.cpp
deleted file mode 100644
index 904b927ab..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-#include <android/hardware/graphics/common/1.0/types.h>
-
-#include "Hwc2TestPixelComparator.h"
-
-using android::hardware::graphics::common::V1_0::BufferUsage;
-
-uint32_t ComparatorResult::getPixel(int32_t x, int32_t y, uint32_t stride,
-        uint8_t* img) const
-{
-    uint32_t r = img[(y * stride + x) * 4 + 0];
-    uint32_t g = img[(y * stride + x) * 4 + 1];
-    uint32_t b = img[(y * stride + x) * 4 + 2];
-    uint32_t a = img[(y * stride + x) * 4 + 3];
-
-    uint32_t pixel = 0;
-    pixel |= r;
-    pixel |= g << 8;
-    pixel |= b << 16;
-    pixel |= a << 24;
-    return pixel;
-}
-
-void ComparatorResult::CompareBuffers(
-        android::sp<android::GraphicBuffer>& resultBuffer,
-        android::sp<android::GraphicBuffer>& expectedBuffer)
-{
-    uint8_t* resultBufferImg;
-    uint8_t* expectedBufferImg;
-    resultBuffer->lock(static_cast<uint32_t>(BufferUsage::CPU_READ_OFTEN),
-            (void**)(&resultBufferImg));
-
-    expectedBuffer->lock(static_cast<uint32_t>(BufferUsage::CPU_READ_OFTEN),
-            (void**)(&expectedBufferImg));
-    mComparisons.clear();
-    int32_t mDifferentPixelCount = 0;
-    int32_t mBlankPixelCount = 0;
-
-    for (uint32_t y = 0; y < resultBuffer->getHeight(); y++) {
-        for (uint32_t x = 0; x < resultBuffer->getWidth(); x++) {
-            uint32_t result = getPixel(x, y, resultBuffer->getStride(),
-                    resultBufferImg);
-            uint32_t expected = getPixel(x, y, expectedBuffer->getStride(),
-                    expectedBufferImg);
-
-            if (result == 0)
-                mBlankPixelCount++;
-
-            if (result != expected)
-                mDifferentPixelCount++;
-
-            mComparisons.emplace_back(std::make_tuple(x, y, result, expected));
-        }
-    }
-    resultBuffer->unlock();
-    expectedBuffer->unlock();
-}
-
-std::string ComparatorResult::pixelDiff(uint32_t x, uint32_t y,
-        uint32_t resultPixel, uint32_t expectedPixel) const
-{
-    uint32_t resultAlpha = (resultPixel >> 24) & 0xFF;
-    uint32_t resultBlue = (resultPixel >> 16) & 0xFF;
-    uint32_t resultGreen = (resultPixel >> 8) & 0xFF;
-    uint32_t resultRed = resultPixel & 0xFF;
-
-    uint32_t expectedAlpha = (expectedPixel >> 24) & 0xFF;
-    uint32_t expectedBlue = (expectedPixel >> 16) & 0xFF;
-    uint32_t expectedGreen = (expectedPixel >> 8) & 0xFF;
-    uint32_t expectedRed = expectedPixel & 0xFF;
-
-    std::ostringstream stream;
-
-    stream << "x: " << x << " y: " << y << std::endl;
-    stream << std::hex;
-    stream << "Result pixel:   " << resultRed << "|" << resultGreen << "|"
-           << resultBlue << "|" << resultAlpha << std::endl;
-
-    stream << "Expected pixel: " << expectedRed << "|" << expectedGreen << "|"
-           << expectedBlue << "|" << expectedAlpha << std::endl;
-
-    return stream.str();
-}
-
-std::string ComparatorResult::dumpComparison() const
-{
-    std::ostringstream stream;
-    stream << "Number of different pixels: " << mDifferentPixelCount;
-
-    for (const auto& comparison : mComparisons) {
-        if (std::get<2>(comparison) != std::get<3>(comparison))
-            stream << pixelDiff(std::get<0>(comparison),
-                    std::get<1>(comparison), std::get<2>(comparison),
-                    std::get<3>(comparison));
-    }
-    return stream.str();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.h b/services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.h
deleted file mode 100644
index 55fa93694..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestPixelComparator.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef _HWC2_TEST_PIXEL_COMPARATOR_H
-#define _HWC2_TEST_PIXEL_COMPARATOR_H
-
-#include <ui/GraphicBuffer.h>
-#include <cstdint>
-#include <string>
-#include <utility>
-#include <vector>
-
-class ComparatorResult {
-public:
-    static ComparatorResult& get()
-    {
-        static ComparatorResult instance;
-        return instance;
-    }
-
-    void CompareBuffers(android::sp<android::GraphicBuffer>& resultBuffer,
-            android::sp<android::GraphicBuffer>& expectedBuffer);
-
-    std::string dumpComparison() const;
-
-    ComparatorResult(const ComparatorResult&) = delete;
-    ComparatorResult(ComparatorResult&&) = delete;
-    ComparatorResult& operator=(ComparatorResult const&) = delete;
-    ComparatorResult& operator=(ComparatorResult&&) = delete;
-
-    int32_t getDifferentPixelCount() const { return mDifferentPixelCount; }
-    int32_t getBlankPixelCount() const { return mBlankPixelCount; }
-
-private:
-    ComparatorResult() = default;
-    uint32_t getPixel(int32_t x, int32_t y, uint32_t stride, uint8_t* img) const;
-    std::string pixelDiff(uint32_t x, uint32_t y, uint32_t resultPixel,
-            uint32_t expectedPixel) const;
-
-    int32_t mDifferentPixelCount;
-    int32_t mBlankPixelCount;
-    /* std::tuple<X coordinate, Y coordinate, resultPixel, expectedPixel> */
-    std::vector<std::tuple<uint32_t, uint32_t, uint32_t, uint32_t>>
-            mComparisons;
-};
-
-#endif /* ifndef _HWC2_TEST_PIXEL_COMPARATOR_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp
deleted file mode 100644
index c5b92d066..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp
+++ /dev/null
@@ -1,782 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-#include <cutils/log.h>
-#include <ui/Rect.h>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestProperties.h"
-
-Hwc2TestBufferArea::Hwc2TestBufferArea(Hwc2TestCoverage coverage,
-        const Area& displayArea)
-    : Hwc2TestProperty(mBufferAreas, mCompositionSupport),
-      mScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicScalars:
-            mDefaultScalars),
-      mDisplayArea(displayArea)
-{
-    update();
-}
-
-std::string Hwc2TestBufferArea::dump() const
-{
-    std::stringstream dmp;
-    const Area& curr = get();
-    dmp << "\tbuffer area: width " << curr.width << ", height " << curr.height
-            << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestBufferArea::setDependent(Hwc2TestBuffer* buffer)
-{
-    mBuffer = buffer;
-    if (buffer) {
-        buffer->updateBufferArea(get());
-    }
-}
-
-void Hwc2TestBufferArea::setDependent(Hwc2TestSourceCrop* sourceCrop)
-{
-    mSourceCrop = sourceCrop;
-    if (mSourceCrop) {
-        mSourceCrop->updateBufferArea(get());
-    }
-}
-
-void Hwc2TestBufferArea::setDependent(Hwc2TestSurfaceDamage* surfaceDamage)
-{
-    mSurfaceDamage = surfaceDamage;
-    if (mSurfaceDamage) {
-        mSurfaceDamage->updateBufferArea(get());
-    }
-}
-
-void Hwc2TestBufferArea::update()
-{
-    mBufferAreas.clear();
-
-    if (mDisplayArea.width == 0 && mDisplayArea.height == 0) {
-        mBufferAreas.push_back({0, 0});
-        return;
-    }
-
-    for (auto scalar : mScalars) {
-        mBufferAreas.push_back({static_cast<int32_t>(scalar * mDisplayArea.width),
-                static_cast<int32_t>(scalar * mDisplayArea.height)});
-    }
-
-    updateDependents();
-}
-
-void Hwc2TestBufferArea::updateDependents()
-{
-    const Area& curr = get();
-
-    if (mBuffer)
-        mBuffer->updateBufferArea(curr);
-    if (mSourceCrop)
-        mSourceCrop->updateBufferArea(curr);
-    if (mSurfaceDamage)
-        mSurfaceDamage->updateBufferArea(curr);
-}
-
-const std::vector<float> Hwc2TestBufferArea::mDefaultScalars = {
-    1.0f,
-};
-
-const std::vector<float> Hwc2TestBufferArea::mBasicScalars = {
-    1.0f, 0.5f,
-};
-
-const std::vector<float> Hwc2TestBufferArea::mCompleteScalars = {
-    1.0f, 0.75f, 0.5f
-};
-
-
-Hwc2TestBlendMode::Hwc2TestBlendMode(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompleteBlendModes, mBasicBlendModes,
-            mDefaultBlendModes, mCompositionSupport) { }
-
-std::string Hwc2TestBlendMode::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tblend mode: " << getBlendModeName(get()) << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestBlendMode::setDependent(Hwc2TestColor* color)
-{
-    mColor = color;
-    updateDependents();
-}
-
-void Hwc2TestBlendMode::updateDependents()
-{
-    if (mColor)
-        mColor->updateBlendMode(get());
-}
-
-const std::vector<hwc2_blend_mode_t> Hwc2TestBlendMode::mDefaultBlendModes = {
-    HWC2_BLEND_MODE_NONE,
-};
-
-const std::vector<hwc2_blend_mode_t> Hwc2TestBlendMode::mBasicBlendModes = {
-    HWC2_BLEND_MODE_NONE,
-    HWC2_BLEND_MODE_PREMULTIPLIED,
-};
-
-const std::vector<hwc2_blend_mode_t> Hwc2TestBlendMode::mCompleteBlendModes = {
-    HWC2_BLEND_MODE_NONE,
-    HWC2_BLEND_MODE_PREMULTIPLIED,
-    HWC2_BLEND_MODE_COVERAGE,
-};
-
-
-Hwc2TestColor::Hwc2TestColor(Hwc2TestCoverage coverage,
-        hwc2_blend_mode_t blendMode)
-    : Hwc2TestProperty(mColors, mCompositionSupport),
-      mBaseColors((coverage == Hwc2TestCoverage::Complete)? mCompleteBaseColors:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicBaseColors:
-            mDefaultBaseColors),
-      mBlendMode(blendMode)
-{
-    update();
-}
-
-std::string Hwc2TestColor::dump() const
-{
-    std::stringstream dmp;
-    const hwc_color_t& color = get();
-    dmp << "\tcolor: r " << std::to_string(color.r) << ", g "
-            << std::to_string(color.g) << ", b " << std::to_string(color.b)
-            << ", a " << std::to_string(color.a) << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestColor::updateBlendMode(hwc2_blend_mode_t blendMode)
-{
-    mBlendMode = blendMode;
-    update();
-}
-
-void Hwc2TestColor::update()
-{
-    if (mBlendMode != HWC2_BLEND_MODE_PREMULTIPLIED) {
-        mColors = mBaseColors;
-        return;
-    }
-
-    mColors.clear();
-
-    for (const hwc_color_t& baseColor : mBaseColors) {
-        if (baseColor.a >= baseColor.r && baseColor.a >= baseColor.g
-                && baseColor.a >= baseColor.b) {
-            mColors.push_back(baseColor);
-        }
-    }
-
-}
-
-const std::vector<hwc_color_t> Hwc2TestColor::mDefaultBaseColors = {
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-};
-
-const std::vector<hwc_color_t> Hwc2TestColor::mBasicBaseColors = {
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-    {        0,         0,         0,         0},
-};
-
-const std::vector<hwc_color_t> Hwc2TestColor::mCompleteBaseColors = {
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX,         0},
-    {UINT8_MAX, UINT8_MAX,         0, UINT8_MAX},
-    {UINT8_MAX, UINT8_MAX,         0,         0},
-    {UINT8_MAX,         0, UINT8_MAX, UINT8_MAX},
-    {UINT8_MAX,         0, UINT8_MAX,         0},
-    {UINT8_MAX,         0,         0, UINT8_MAX},
-    {UINT8_MAX,         0,         0,         0},
-    {        0, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-    {        0, UINT8_MAX, UINT8_MAX,         0},
-    {        0, UINT8_MAX,         0, UINT8_MAX},
-    {        0, UINT8_MAX,         0,         0},
-    {        0,         0, UINT8_MAX, UINT8_MAX},
-    {        0,         0, UINT8_MAX,         0},
-    {        0,         0,         0, UINT8_MAX},
-    {        0,         0,         0,         0},
-};
-
-
-Hwc2TestComposition::Hwc2TestComposition(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompleteCompositions, mBasicCompositions,
-            mDefaultCompositions, mCompositionSupport) { }
-
-std::string Hwc2TestComposition::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tcomposition: " << getCompositionName(get()) << "\n";
-    return dmp.str();
-}
-
-const std::vector<hwc2_composition_t> Hwc2TestComposition::mDefaultCompositions = {
-    HWC2_COMPOSITION_DEVICE,
-};
-
-const std::vector<hwc2_composition_t> Hwc2TestComposition::mBasicCompositions = {
-    HWC2_COMPOSITION_CLIENT,
-    HWC2_COMPOSITION_DEVICE,
-};
-
-const std::vector<hwc2_composition_t> Hwc2TestComposition::mCompleteCompositions = {
-    HWC2_COMPOSITION_CLIENT,
-    HWC2_COMPOSITION_DEVICE,
-    HWC2_COMPOSITION_SOLID_COLOR,
-    HWC2_COMPOSITION_CURSOR,
-    HWC2_COMPOSITION_SIDEBAND,
-};
-
-
-Hwc2TestDataspace::Hwc2TestDataspace(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, completeDataspaces, basicDataspaces,
-            defaultDataspaces, mCompositionSupport) { }
-
-std::string Hwc2TestDataspace::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tdataspace: " << static_cast<int32_t>(get()) << "\n";
-    return dmp.str();
-}
-
-const std::vector<android::ui::Dataspace> Hwc2TestDataspace::defaultDataspaces = {
-    android::ui::Dataspace::UNKNOWN,
-};
-
-const std::vector<android::ui::Dataspace> Hwc2TestDataspace::basicDataspaces = {
-    android::ui::Dataspace::UNKNOWN,
-    android::ui::Dataspace::V0_SRGB,
-};
-
-const std::vector<android::ui::Dataspace> Hwc2TestDataspace::completeDataspaces = {
-    android::ui::Dataspace::UNKNOWN,
-    android::ui::Dataspace::ARBITRARY,
-    android::ui::Dataspace::STANDARD_SHIFT,
-    android::ui::Dataspace::STANDARD_MASK,
-    android::ui::Dataspace::STANDARD_UNSPECIFIED,
-    android::ui::Dataspace::STANDARD_BT709,
-    android::ui::Dataspace::STANDARD_BT601_625,
-    android::ui::Dataspace::STANDARD_BT601_625_UNADJUSTED,
-    android::ui::Dataspace::STANDARD_BT601_525,
-    android::ui::Dataspace::STANDARD_BT601_525_UNADJUSTED,
-    android::ui::Dataspace::STANDARD_BT2020,
-    android::ui::Dataspace::STANDARD_BT2020_CONSTANT_LUMINANCE,
-    android::ui::Dataspace::STANDARD_BT470M,
-    android::ui::Dataspace::STANDARD_FILM,
-    android::ui::Dataspace::TRANSFER_SHIFT,
-    android::ui::Dataspace::TRANSFER_MASK,
-    android::ui::Dataspace::TRANSFER_UNSPECIFIED,
-    android::ui::Dataspace::TRANSFER_LINEAR,
-    android::ui::Dataspace::TRANSFER_SRGB,
-    android::ui::Dataspace::TRANSFER_SMPTE_170M,
-    android::ui::Dataspace::TRANSFER_GAMMA2_2,
-    android::ui::Dataspace::TRANSFER_GAMMA2_8,
-    android::ui::Dataspace::TRANSFER_ST2084,
-    android::ui::Dataspace::TRANSFER_HLG,
-    android::ui::Dataspace::RANGE_SHIFT,
-    android::ui::Dataspace::RANGE_MASK,
-    android::ui::Dataspace::RANGE_UNSPECIFIED,
-    android::ui::Dataspace::RANGE_FULL,
-    android::ui::Dataspace::RANGE_LIMITED,
-    android::ui::Dataspace::SRGB_LINEAR,
-    android::ui::Dataspace::V0_SRGB_LINEAR,
-    android::ui::Dataspace::SRGB,
-    android::ui::Dataspace::V0_SRGB,
-    android::ui::Dataspace::JFIF,
-    android::ui::Dataspace::V0_JFIF,
-    android::ui::Dataspace::BT601_625,
-    android::ui::Dataspace::V0_BT601_625,
-    android::ui::Dataspace::BT601_525,
-    android::ui::Dataspace::V0_BT601_525,
-    android::ui::Dataspace::BT709,
-    android::ui::Dataspace::V0_BT709,
-    android::ui::Dataspace::DEPTH,
-};
-
-
-Hwc2TestDisplayDimension::Hwc2TestDisplayDimension(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(
-            (coverage == Hwc2TestCoverage::Complete)? mCompleteDisplayDimensions:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicDisplayDimensions:
-            mDefaultDisplayDimensions, mCompositionSupport) { }
-
-std::string Hwc2TestDisplayDimension::dump() const
-{
-    std::stringstream dmp;
-    const UnsignedArea& curr = get();
-    dmp << "\tdisplay dimension: " << curr.width<< " x " << curr.height<< "\n";
-    return dmp.str();
-}
-
-void Hwc2TestDisplayDimension::setDependent(Hwc2TestVirtualBuffer* buffer)
-{
-    mBuffers.insert(buffer);
-    updateDependents();
-}
-
-void Hwc2TestDisplayDimension::updateDependents()
-{
-    const UnsignedArea& curr = get();
-
-    for (Hwc2TestVirtualBuffer* buffer : mBuffers)
-        buffer->updateBufferArea({static_cast<int32_t>(curr.width),
-                static_cast<int32_t>(curr.height)});
-}
-
-const std::vector<UnsignedArea>
-        Hwc2TestDisplayDimension::mDefaultDisplayDimensions = {
-    {1920, 1080},
-};
-
-const std::vector<UnsignedArea>
-        Hwc2TestDisplayDimension::mBasicDisplayDimensions = {
-    {640, 480},
-    {1280, 720},
-    {1920, 1080},
-    {1920, 1200},
-};
-
-const std::vector<UnsignedArea>
-        Hwc2TestDisplayDimension::mCompleteDisplayDimensions = {
-    {320, 240},
-    {480, 320},
-    {640, 480},
-    {1280, 720},
-    {1920, 1080},
-    {1920, 1200},
-    {2560, 1440},
-    {2560, 1600},
-    {3840, 2160},
-    {4096, 2160},
-};
-
-
-Hwc2TestDisplayFrame::Hwc2TestDisplayFrame(Hwc2TestCoverage coverage,
-        const Area& displayArea)
-    : Hwc2TestProperty(mDisplayFrames, mCompositionSupport),
-      mFrectScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteFrectScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicFrectScalars:
-            mDefaultFrectScalars),
-      mDisplayArea(displayArea)
-{
-    update();
-}
-
-std::string Hwc2TestDisplayFrame::dump() const
-{
-    std::stringstream dmp;
-    const hwc_rect_t& displayFrame = get();
-    dmp << "\tdisplay frame: left " << displayFrame.left << ", top "
-            << displayFrame.top << ", right " << displayFrame.right
-            << ", bottom " << displayFrame.bottom << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestDisplayFrame::update()
-{
-    mDisplayFrames.clear();
-
-    if (mDisplayArea.width == 0 && mDisplayArea.height == 0) {
-        mDisplayFrames.push_back({0, 0, 0, 0});
-        return;
-    }
-
-    for (const auto& frectScalar : mFrectScalars) {
-        mDisplayFrames.push_back({
-                static_cast<int>(frectScalar.left * mDisplayArea.width),
-                static_cast<int>(frectScalar.top * mDisplayArea.height),
-                static_cast<int>(frectScalar.right * mDisplayArea.width),
-                static_cast<int>(frectScalar.bottom * mDisplayArea.height)});
-    }
-}
-
-const std::vector<hwc_frect_t> Hwc2TestDisplayFrame::mDefaultFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestDisplayFrame::mBasicFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.0, 1.0, 0.05},
-    {0.0, 0.95, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestDisplayFrame::mCompleteFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.05, 1.0, 0.95},
-    {0.0, 0.05, 1.0, 1.0},
-    {0.0, 0.0, 1.0, 0.05},
-    {0.0, 0.95, 1.0, 1.0},
-    {0.25, 0.0, 0.75, 0.35},
-    {0.25, 0.25, 0.75, 0.75},
-};
-
-
-Hwc2TestPlaneAlpha::Hwc2TestPlaneAlpha(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompletePlaneAlphas, mBasicPlaneAlphas,
-            mDefaultPlaneAlphas, mCompositionSupport) { }
-
-std::string Hwc2TestPlaneAlpha::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tplane alpha: " << get() << "\n";
-    return dmp.str();
-}
-
-const std::vector<float> Hwc2TestPlaneAlpha::mDefaultPlaneAlphas = {
-    1.0f,
-};
-
-const std::vector<float> Hwc2TestPlaneAlpha::mBasicPlaneAlphas = {
-    1.0f, 0.0f,
-};
-
-const std::vector<float> Hwc2TestPlaneAlpha::mCompletePlaneAlphas = {
-    1.0f, 0.75f, 0.5f, 0.25f, 0.0f,
-};
-
-
-Hwc2TestSourceCrop::Hwc2TestSourceCrop(Hwc2TestCoverage coverage,
-        const Area& bufferArea)
-    : Hwc2TestProperty(mSourceCrops, mCompositionSupport),
-      mFrectScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteFrectScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicFrectScalars:
-            mDefaultFrectScalars),
-      mBufferArea(bufferArea)
-{
-    update();
-}
-
-std::string Hwc2TestSourceCrop::dump() const
-{
-    std::stringstream dmp;
-    const hwc_frect_t& sourceCrop = get();
-    dmp << "\tsource crop: left " << sourceCrop.left << ", top "
-            << sourceCrop.top << ", right " << sourceCrop.right << ", bottom "
-            << sourceCrop.bottom << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestSourceCrop::updateBufferArea(const Area& bufferArea)
-{
-    mBufferArea = bufferArea;
-    update();
-}
-
-void Hwc2TestSourceCrop::update()
-{
-    mSourceCrops.clear();
-
-    if (mBufferArea.width == 0 && mBufferArea.height == 0) {
-        mSourceCrops.push_back({0, 0, 0, 0});
-        return;
-    }
-
-    for (const auto& frectScalar : mFrectScalars) {
-        mSourceCrops.push_back({
-                frectScalar.left * mBufferArea.width,
-                frectScalar.top * mBufferArea.height,
-                frectScalar.right * mBufferArea.width,
-                frectScalar.bottom * mBufferArea.height});
-    }
-}
-
-const std::vector<hwc_frect_t> Hwc2TestSourceCrop::mDefaultFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestSourceCrop::mBasicFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.0, 0.5, 0.5},
-    {0.5, 0.5, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestSourceCrop::mCompleteFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.0, 0.5, 0.5},
-    {0.5, 0.5, 1.0, 1.0},
-    {0.0, 0.0, 0.25, 0.25},
-    {0.25, 0.25, 0.75, 0.75},
-};
-
-
-Hwc2TestSurfaceDamage::Hwc2TestSurfaceDamage(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(mSurfaceDamages, mCompositionSupport),
-      mRegionScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteRegionScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicRegionScalars:
-            mDefaultRegionScalars)
-{
-    update();
-}
-
-Hwc2TestSurfaceDamage::~Hwc2TestSurfaceDamage()
-{
-    freeSurfaceDamages();
-}
-
-std::string Hwc2TestSurfaceDamage::dump() const
-{
-    std::stringstream dmp;
-
-    const hwc_region_t& curr = get();
-    dmp << "\tsurface damage: region count " << curr.numRects << "\n";
-    for (size_t i = 0; i < curr.numRects; i++) {
-        const hwc_rect_t& rect = curr.rects[i];
-        dmp << "\t\trect: left " << rect.left << ", top " << rect.top
-                << ", right " << rect.right << ", bottom " << rect.bottom << "\n";
-    }
-
-    return dmp.str();
-}
-
-void Hwc2TestSurfaceDamage::updateBufferArea(const Area& bufferArea)
-{
-    mBufferArea = bufferArea;
-    update();
-}
-
-void Hwc2TestSurfaceDamage::update()
-{
-    freeSurfaceDamages();
-
-    if (mBufferArea.width == 0 && mBufferArea.height == 0) {
-        mSurfaceDamages.push_back({0, nullptr});
-        return;
-    }
-
-    hwc_region_t damage;
-
-    for (const auto& regionScalar : mRegionScalars) {
-        damage.numRects = regionScalar.size();
-
-        if (damage.numRects > 0) {
-            hwc_rect_t* rects = new hwc_rect_t[damage.numRects];
-            if (!rects) {
-                ALOGW("failed to allocate new hwc_rect_t array");
-                continue;
-            }
-
-            for (size_t i = 0; i < damage.numRects; i++) {
-                rects[i].left = regionScalar[i].left * mBufferArea.width;
-                rects[i].top = regionScalar[i].top * mBufferArea.height;
-                rects[i].right = regionScalar[i].right * mBufferArea.width;
-                rects[i].bottom = regionScalar[i].bottom * mBufferArea.height;
-            }
-
-            damage.rects = static_cast<hwc_rect_t const*>(rects);
-        } else {
-            damage.rects = nullptr;
-        }
-
-        mSurfaceDamages.push_back(damage);
-    }
-}
-
-void Hwc2TestSurfaceDamage::freeSurfaceDamages()
-{
-    for (const auto& surfaceDamage : mSurfaceDamages) {
-        if (surfaceDamage.numRects > 0 && surfaceDamage.rects)
-            delete[] surfaceDamage.rects;
-    }
-    mSurfaceDamages.clear();
-}
-
-const std::vector<std::vector<hwc_frect_t>> Hwc2TestSurfaceDamage::mDefaultRegionScalars = {
-    {{}},
-};
-
-const std::vector<std::vector<hwc_frect_t>> Hwc2TestSurfaceDamage::mBasicRegionScalars = {
-    {{}},
-    {{0.0, 0.0, 1.0, 1.0}},
-};
-
-const std::vector<std::vector<hwc_frect_t>> Hwc2TestSurfaceDamage::mCompleteRegionScalars = {
-    {{}},
-    {{0.0, 0.0, 1.0, 1.0}},
-    {{0.0, 0.0, 0.5, 0.5}, {0.5, 0.5, 1.0, 1.0}},
-};
-
-
-Hwc2TestTransform::Hwc2TestTransform(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompleteTransforms, mBasicTransforms,
-            mDefaultTransforms, mCompositionSupport) { }
-
-std::string Hwc2TestTransform::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\ttransform: " << getTransformName(get()) << "\n";
-    return dmp.str();
-}
-
-const std::vector<hwc_transform_t> Hwc2TestTransform::mDefaultTransforms = {
-    static_cast<hwc_transform_t>(0),
-};
-
-const std::vector<hwc_transform_t> Hwc2TestTransform::mBasicTransforms = {
-    static_cast<hwc_transform_t>(0),
-    HWC_TRANSFORM_FLIP_H,
-    HWC_TRANSFORM_FLIP_V,
-    HWC_TRANSFORM_ROT_90,
-};
-
-const std::vector<hwc_transform_t> Hwc2TestTransform::mCompleteTransforms = {
-    static_cast<hwc_transform_t>(0),
-    HWC_TRANSFORM_FLIP_H,
-    HWC_TRANSFORM_FLIP_V,
-    HWC_TRANSFORM_ROT_90,
-    HWC_TRANSFORM_ROT_180,
-    HWC_TRANSFORM_ROT_270,
-    HWC_TRANSFORM_FLIP_H_ROT_90,
-    HWC_TRANSFORM_FLIP_V_ROT_90,
-};
-
-
-Hwc2TestVisibleRegion::~Hwc2TestVisibleRegion()
-{
-    release();
-}
-
-std::string Hwc2TestVisibleRegion::dump() const
-{
-    std::stringstream dmp;
-
-    const hwc_region_t& curr = get();
-    dmp << "\tvisible region: region count " << curr.numRects << "\n";
-    for (size_t i = 0; i < curr.numRects; i++) {
-        const hwc_rect_t& rect = curr.rects[i];
-        dmp << "\t\trect: left " << rect.left << ", top " << rect.top
-                << ", right " << rect.right << ", bottom " << rect.bottom << "\n";
-    }
-
-    return dmp.str();
-}
-
-void Hwc2TestVisibleRegion::set(const android::Region& visibleRegion)
-{
-    release();
-
-    size_t size = 0;
-    const android::Rect* rects = visibleRegion.getArray(&size);
-
-    mVisibleRegion.numRects = size;
-    mVisibleRegion.rects = nullptr;
-
-    if (size > 0) {
-        hwc_rect_t* hwcRects = new hwc_rect_t[size];
-        for (size_t i = 0; i < size; i++) {
-            hwcRects[i].left = rects[i].left;
-            hwcRects[i].top = rects[i].top;
-            hwcRects[i].right = rects[i].right;
-            hwcRects[i].bottom = rects[i].bottom;
-        }
-        mVisibleRegion.rects = hwcRects;
-    }
-}
-
-hwc_region_t Hwc2TestVisibleRegion::get() const
-{
-    return mVisibleRegion;
-}
-
-void Hwc2TestVisibleRegion::release()
-{
-    if (mVisibleRegion.numRects > 0 && mVisibleRegion.rects)
-        delete[] mVisibleRegion.rects;
-    mVisibleRegion.rects = nullptr;
-    mVisibleRegion.numRects = 0;
-}
-
-/* Identifies which layer properties are supported by each composition type.
- * hwc2_composition_t values range from:
- *  HWC2_COMPOSITION_INVALID = 0,
- *  HWC2_COMPOSITION_CLIENT = 1,
- *  HWC2_COMPOSITION_DEVICE = 2,
- *  HWC2_COMPOSITION_SOLID_COLOR = 3,
- *  HWC2_COMPOSITION_CURSOR = 4,
- *  HWC2_COMPOSITION_SIDEBAND = 5,
- *
- * Each property array can be indexed by a hwc2_composition_t value.
- * By using an array instead of a more complex data structure, runtimes for
- * some test cases showed a noticeable improvement.
- */
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestBufferArea::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestBlendMode::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestColor::mCompositionSupport = {{
-    false,   false,   false,   true,    false,   false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestComposition::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestDataspace::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestDisplayDimension::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestDisplayFrame::mCompositionSupport = {{
-    false,   true,    true,    true,    false,   true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestPlaneAlpha::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestSourceCrop::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestSurfaceDamage::mCompositionSupport = {{
-    false,   false,   true,    false,   true,    false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestTransform::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    true,
-}};
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h b/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h
deleted file mode 100644
index d7082f3cb..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h
+++ /dev/null
@@ -1,386 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_PROPERTIES_H
-#define _HWC2_TEST_PROPERTIES_H
-
-#include <array>
-#include <vector>
-
-#include <ui/GraphicTypes.h>
-#include <ui/Region.h>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-enum class Hwc2TestCoverage {
-    Default = 0,
-    Basic,
-    Complete,
-};
-
-enum class Hwc2TestPropertyName {
-    BlendMode = 1,
-    BufferArea,
-    Color,
-    Composition,
-    CursorPosition,
-    Dataspace,
-    DisplayFrame,
-    PlaneAlpha,
-    SourceCrop,
-    SurfaceDamage,
-    Transform,
-};
-
-typedef struct {
-    int32_t width;
-    int32_t height;
-} Area;
-
-
-typedef struct {
-    uint32_t width;
-    uint32_t height;
-} UnsignedArea;
-
-
-class Hwc2TestContainer {
-public:
-    virtual ~Hwc2TestContainer() = default;
-
-    /* Resets the container */
-    virtual void reset() = 0;
-
-    /* Attempts to advance to the next valid value. Returns true if one can be
-     * found */
-    virtual bool advance() = 0;
-
-    virtual std::string dump() const = 0;
-
-    /* Returns true if the container supports the given composition type */
-    virtual bool isSupported(hwc2_composition_t composition) = 0;
-};
-
-
-template <class T>
-class Hwc2TestProperty : public Hwc2TestContainer {
-public:
-    Hwc2TestProperty(Hwc2TestCoverage coverage,
-            const std::vector<T>& completeList, const std::vector<T>& basicList,
-            const std::vector<T>& defaultList,
-            const std::array<bool, 6>& compositionSupport)
-        : Hwc2TestProperty((coverage == Hwc2TestCoverage::Complete)? completeList:
-                (coverage == Hwc2TestCoverage::Basic)? basicList : defaultList,
-                compositionSupport) { }
-
-    Hwc2TestProperty(const std::vector<T>& list,
-            const std::array<bool, 6>& compositionSupport)
-        : mList(list),
-          mCompositionSupport(compositionSupport) { }
-
-    void reset() override
-    {
-        mListIdx = 0;
-    }
-
-    bool advance() override
-    {
-        if (mListIdx + 1 < mList.size()) {
-            mListIdx++;
-            updateDependents();
-            return true;
-        }
-        reset();
-        updateDependents();
-        return false;
-    }
-
-    T get() const
-    {
-        return mList.at(mListIdx);
-    }
-
-    virtual bool isSupported(hwc2_composition_t composition)
-    {
-        return mCompositionSupport.at(composition);
-    }
-
-protected:
-    /* If a derived class has dependents, override this function */
-    virtual void updateDependents() { }
-
-    const std::vector<T>& mList;
-    size_t mListIdx = 0;
-
-    const std::array<bool, 6>& mCompositionSupport;
-};
-
-class Hwc2TestBuffer;
-class Hwc2TestSourceCrop;
-class Hwc2TestSurfaceDamage;
-
-class Hwc2TestBufferArea : public Hwc2TestProperty<Area> {
-public:
-    Hwc2TestBufferArea(Hwc2TestCoverage coverage, const Area& displayArea);
-
-    std::string dump() const override;
-
-    void setDependent(Hwc2TestBuffer* buffer);
-    void setDependent(Hwc2TestSourceCrop* sourceCrop);
-    void setDependent(Hwc2TestSurfaceDamage* surfaceDamage);
-
-protected:
-    void update();
-    void updateDependents() override;
-
-    const std::vector<float>& mScalars;
-    static const std::vector<float> mDefaultScalars;
-    static const std::vector<float> mBasicScalars;
-    static const std::vector<float> mCompleteScalars;
-
-    Area mDisplayArea;
-
-    Hwc2TestBuffer* mBuffer = nullptr;
-    Hwc2TestSourceCrop* mSourceCrop = nullptr;
-    Hwc2TestSurfaceDamage* mSurfaceDamage = nullptr;
-
-    std::vector<Area> mBufferAreas;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestColor;
-
-class Hwc2TestBlendMode : public Hwc2TestProperty<hwc2_blend_mode_t> {
-public:
-    Hwc2TestBlendMode(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-    void setDependent(Hwc2TestColor* color);
-
-protected:
-    void updateDependents() override;
-
-    Hwc2TestColor* mColor = nullptr;
-
-    static const std::vector<hwc2_blend_mode_t> mDefaultBlendModes;
-    static const std::vector<hwc2_blend_mode_t> mBasicBlendModes;
-    static const std::vector<hwc2_blend_mode_t> mCompleteBlendModes;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestColor : public Hwc2TestProperty<hwc_color_t> {
-public:
-    Hwc2TestColor(Hwc2TestCoverage coverage,
-            hwc2_blend_mode_t blendMode = HWC2_BLEND_MODE_NONE);
-
-    std::string dump() const override;
-
-    void updateBlendMode(hwc2_blend_mode_t blendMode);
-
-protected:
-    void update();
-
-    std::vector<hwc_color_t> mBaseColors;
-    static const std::vector<hwc_color_t> mDefaultBaseColors;
-    static const std::vector<hwc_color_t> mBasicBaseColors;
-    static const std::vector<hwc_color_t> mCompleteBaseColors;
-
-    hwc2_blend_mode_t mBlendMode;
-
-    std::vector<hwc_color_t> mColors;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestComposition : public Hwc2TestProperty<hwc2_composition_t> {
-public:
-    Hwc2TestComposition(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<hwc2_composition_t> mDefaultCompositions;
-    static const std::vector<hwc2_composition_t> mBasicCompositions;
-    static const std::vector<hwc2_composition_t> mCompleteCompositions;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestDataspace : public Hwc2TestProperty<android::ui::Dataspace> {
-public:
-    Hwc2TestDataspace(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<android::ui::Dataspace> defaultDataspaces;
-    static const std::vector<android::ui::Dataspace> basicDataspaces;
-    static const std::vector<android::ui::Dataspace> completeDataspaces;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-class Hwc2TestVirtualBuffer;
-
-class Hwc2TestDisplayDimension : public Hwc2TestProperty<UnsignedArea> {
-public:
-    Hwc2TestDisplayDimension(Hwc2TestCoverage coverage);
-
-    std::string dump() const;
-
-    void setDependent(Hwc2TestVirtualBuffer* buffer);
-
-private:
-    void updateDependents();
-
-    std::set<Hwc2TestVirtualBuffer*> mBuffers;
-
-    static const std::vector<UnsignedArea> mDefaultDisplayDimensions;
-    static const std::vector<UnsignedArea> mBasicDisplayDimensions;
-    static const std::vector<UnsignedArea> mCompleteDisplayDimensions;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestDisplayFrame : public Hwc2TestProperty<hwc_rect_t> {
-public:
-    Hwc2TestDisplayFrame(Hwc2TestCoverage coverage, const Area& displayArea);
-
-    std::string dump() const override;
-
-protected:
-    void update();
-
-    const std::vector<hwc_frect_t>& mFrectScalars;
-    const static std::vector<hwc_frect_t> mDefaultFrectScalars;
-    const static std::vector<hwc_frect_t> mBasicFrectScalars;
-    const static std::vector<hwc_frect_t> mCompleteFrectScalars;
-
-    Area mDisplayArea;
-
-    std::vector<hwc_rect_t> mDisplayFrames;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestPlaneAlpha : public Hwc2TestProperty<float> {
-public:
-    Hwc2TestPlaneAlpha(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<float> mDefaultPlaneAlphas;
-    static const std::vector<float> mBasicPlaneAlphas;
-    static const std::vector<float> mCompletePlaneAlphas;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestSourceCrop : public Hwc2TestProperty<hwc_frect_t> {
-public:
-    Hwc2TestSourceCrop(Hwc2TestCoverage coverage, const Area& bufferArea = {0, 0});
-
-    std::string dump() const override;
-
-    void updateBufferArea(const Area& bufferArea);
-
-protected:
-    void update();
-
-    const std::vector<hwc_frect_t>& mFrectScalars;
-    const static std::vector<hwc_frect_t> mDefaultFrectScalars;
-    const static std::vector<hwc_frect_t> mBasicFrectScalars;
-    const static std::vector<hwc_frect_t> mCompleteFrectScalars;
-
-    Area mBufferArea;
-
-    std::vector<hwc_frect_t> mSourceCrops;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestSurfaceDamage : public Hwc2TestProperty<hwc_region_t> {
-public:
-    Hwc2TestSurfaceDamage(Hwc2TestCoverage coverage);
-    ~Hwc2TestSurfaceDamage();
-
-    std::string dump() const override;
-
-    void updateBufferArea(const Area& bufferArea);
-
-protected:
-    void update();
-    void freeSurfaceDamages();
-
-    const std::vector<std::vector<hwc_frect_t>> &mRegionScalars;
-    const static std::vector<std::vector<hwc_frect_t>> mDefaultRegionScalars;
-    const static std::vector<std::vector<hwc_frect_t>> mBasicRegionScalars;
-    const static std::vector<std::vector<hwc_frect_t>> mCompleteRegionScalars;
-
-    Area mBufferArea = {0, 0};
-
-    std::vector<hwc_region_t> mSurfaceDamages;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestTransform : public Hwc2TestProperty<hwc_transform_t> {
-public:
-    Hwc2TestTransform(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<hwc_transform_t> mDefaultTransforms;
-    static const std::vector<hwc_transform_t> mBasicTransforms;
-    static const std::vector<hwc_transform_t> mCompleteTransforms;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestVisibleRegion {
-public:
-    ~Hwc2TestVisibleRegion();
-
-    std::string dump() const;
-
-    void set(const android::Region& visibleRegion);
-    hwc_region_t get() const;
-    void release();
-
-protected:
-    hwc_region_t mVisibleRegion = {0, nullptr};
-};
-
-#endif /* ifndef _HWC2_TEST_PROPERTIES_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp
deleted file mode 100644
index e6cceb82e..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-#include <sys/stat.h>
-
-#include "Hwc2TestVirtualDisplay.h"
-
-#define DIR_NAME "images"
-
-Hwc2TestVirtualDisplay::Hwc2TestVirtualDisplay(
-        Hwc2TestCoverage coverage)
-    : mDisplayDimension(coverage)
-{
-    mDisplayDimension.setDependent(&mOutputBuffer);
-    mDisplayDimension.setDependent(&mExpectedBuffer);
-}
-
-std::string Hwc2TestVirtualDisplay::dump() const
-{
-    std::stringstream dmp;
-
-    dmp << "virtual display: \n";
-
-    mDisplayDimension.dump();
-
-    return dmp.str();
-}
-
-int Hwc2TestVirtualDisplay::getOutputBuffer(buffer_handle_t* outHandle,
-        android::base::unique_fd* outAcquireFence)
-{
-    int32_t acquireFence;
-    int ret = mOutputBuffer.getOutputBuffer(outHandle, &acquireFence);
-    outAcquireFence->reset(acquireFence);
-    return ret;
-}
-
-void Hwc2TestVirtualDisplay::reset()
-{
-    return mDisplayDimension.reset();
-}
-
-bool Hwc2TestVirtualDisplay::advance()
-{
-    return mDisplayDimension.advance();
-}
-
-UnsignedArea Hwc2TestVirtualDisplay::getDisplayDimension() const
-{
-    return mDisplayDimension.get();
-}
-
-int Hwc2TestVirtualDisplay::verifyOutputBuffer(const Hwc2TestLayers* testLayers,
-        const std::vector<hwc2_layer_t>* allLayers,
-        const std::set<hwc2_layer_t>* clearLayers)
-{
-    int ret = mExpectedBuffer.generateExpectedBuffer(testLayers, allLayers,
-            clearLayers);
-    if (ret)
-        return ret;
-
-    ComparatorResult::get().CompareBuffers(mOutputBuffer.graphicBuffer(),
-        mExpectedBuffer.graphicBuffer());
-
-    return 0;
-}
-
-int Hwc2TestVirtualDisplay::writeBuffersToFile(std::string name)
-{
-    std::ostringstream expectedPath;
-    std::ostringstream resultPath;
-    int ret = mkdir(DIR_NAME, DEFFILEMODE);
-    if (ret && errno != EEXIST)
-        return ret;
-
-    expectedPath << DIR_NAME << "/expected-" << name << ".png";
-    resultPath << DIR_NAME << "/result-" << name << ".png";
-
-    if (!mExpectedBuffer.writeBufferToFile(expectedPath.str()) ||
-            !mOutputBuffer.writeBufferToFile(resultPath.str()))
-        return -1;
-
-    return 0;
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h b/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h
deleted file mode 100644
index 10c8ef0f1..000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_VIRTUAL_DISPLAY_H
-#define _HWC2_TEST_VIRTUAL_DISPLAY_H
-
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestPixelComparator.h"
-#include "Hwc2TestProperties.h"
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-class Hwc2TestVirtualDisplay {
-public:
-    Hwc2TestVirtualDisplay(Hwc2TestCoverage coverage);
-
-    std::string dump() const;
-
-    int getOutputBuffer(buffer_handle_t* outHandle,
-            android::base::unique_fd* outAcquireFence);
-
-    int verifyOutputBuffer(const Hwc2TestLayers* testLayers,
-            const std::vector<hwc2_layer_t>* allLayers,
-            const std::set<hwc2_layer_t>* clearLayers);
-
-    int writeBuffersToFile(std::string name);
-    void reset();
-    bool advance();
-
-    UnsignedArea getDisplayDimension() const;
-
-private:
-    Hwc2TestOutputBuffer mOutputBuffer;
-    Hwc2TestExpectedBuffer mExpectedBuffer;
-    Hwc2TestDisplayDimension mDisplayDimension;
-};
-
-#endif /* ifndef _HWC2_TEST_VIRTUAL_DISPLAY_H */
diff --git a/services/surfaceflinger/tests/unittests/Android.bp b/services/surfaceflinger/tests/unittests/Android.bp
deleted file mode 100644
index 39761dd9a..000000000
--- a/services/surfaceflinger/tests/unittests/Android.bp
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_test {
-    name: "libsurfaceflinger_unittest",
-    tags: ["test"],
-    defaults: ["libsurfaceflinger_defaults"],
-    test_suites: ["device-tests"],
-    srcs: [
-        ":libsurfaceflinger_sources",
-        "DisplayTransactionTest.cpp",
-        "EventControlThreadTest.cpp",
-        "EventThreadTest.cpp",
-        "mock/DisplayHardware/MockComposer.cpp",
-        "mock/DisplayHardware/MockDisplaySurface.cpp",
-        "mock/gui/MockGraphicBufferConsumer.cpp",
-        "mock/gui/MockGraphicBufferProducer.cpp",
-        "mock/MockEventControlThread.cpp",
-        "mock/MockEventThread.cpp",
-        "mock/MockMessageQueue.cpp",
-        "mock/MockNativeWindowSurface.cpp",
-        "mock/MockSurfaceInterceptor.cpp",
-        "mock/RenderEngine/MockRenderEngine.cpp",
-        "mock/system/window/MockNativeWindow.cpp",
-    ],
-    static_libs: [
-        "libgmock",
-    ],
-    header_libs: [
-        "libsurfaceflinger_headers",
-    ],
-}
diff --git a/services/surfaceflinger/tests/unittests/AndroidTest.xml b/services/surfaceflinger/tests/unittests/AndroidTest.xml
deleted file mode 100644
index 5e8b03bde..000000000
--- a/services/surfaceflinger/tests/unittests/AndroidTest.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2018 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Config for libsurfaceflinger_unittest">
-    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
-        <option name="cleanup" value="true" />
-        <option name="push" value="libsurfaceflinger_unittest->/data/local/tmp/libsurfaceflinger_unittest" />
-    </target_preparer>
-    <option name="test-suite-tag" value="apct" />
-    <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp" />
-        <option name="module-name" value="libsurfaceflinger_unittest" />
-    </test>
-</configuration>
diff --git a/services/surfaceflinger/tests/unittests/AsyncCallRecorder.h b/services/surfaceflinger/tests/unittests/AsyncCallRecorder.h
deleted file mode 100644
index 2245ee1a8..000000000
--- a/services/surfaceflinger/tests/unittests/AsyncCallRecorder.h
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <chrono>
-#include <deque>
-#include <mutex>
-#include <optional>
-#include <thread>
-#include <tuple>
-#include <type_traits>
-#include <utility>
-
-#include <android-base/thread_annotations.h>
-
-namespace android {
-
-// This class helps record calls made by another thread when they are made
-// asynchronously, with no other way for the tests to verify that the calls have
-// been made.
-//
-// A normal Google Mock recorder, while thread safe, does not allow you to wait
-// for asynchronous calls to be made.
-//
-// Usage:
-//
-// In the test, use a Google Mock expectation to invoke an instance of the
-// recorder:
-//
-//     AsyncCallRecorder<void(int)> recorder;
-//
-//     EXPECT_CALL(someMock, someFunction(_)).
-//             .WillRepeatedly(Invoke(recorder.getInvocable()));
-//
-// Then you can invoke the functionality being tested:
-//
-//     threadUnderTest.doSomethingAsync()
-//
-// And afterwards make a number of assertions using the recorder:
-//
-//     // Wait for one call (with reasonable default timeout), and get the args
-//     // as a std::tuple inside a std::optional.
-//     auto args = recorder.waitForCall();
-//     // The returned std::optional will have a value if the recorder function
-//     // was called.
-//     ASSERT_TRUE(args.has_value());
-//     // The arguments can be checked if needed using standard tuple
-//     // operations.
-//     EXPECT_EQ(123, std::get<0>(args.value()));
-//
-// Alternatively maybe you want to assert that a call was not made.
-//
-//     EXPECT_FALSE(recorder.waitForUnexpectedCall().has_value());
-//
-// However this check uses a really short timeout so as not to block the test
-// unnecessarily. And it could be possible for the check to return false and
-// then the recorder could observe a call being made after.
-template <typename Func>
-class AsyncCallRecorder;
-
-template <typename... Args>
-class AsyncCallRecorder<void (*)(Args...)> {
-public:
-    // For the tests, we expect the wait for an expected change to be signaled
-    // to be much shorter than this.
-    static constexpr std::chrono::milliseconds DEFAULT_CALL_EXPECTED_TIMEOUT{10};
-
-    // The wait here is tricky. We don't expect a change, but we don't want to
-    // wait forever (or for longer than the typical test function runtime). As
-    // even the simplest Google Test can take 1ms (1000us) to run, we wait for
-    // half that time.
-    static constexpr std::chrono::microseconds UNEXPECTED_CALL_TIMEOUT{500};
-
-    using ArgTuple = std::tuple<std::remove_cv_t<std::remove_reference_t<Args>>...>;
-
-    void recordCall(Args... args) {
-        std::lock_guard<std::mutex> lock(mMutex);
-        mCalls.emplace_back(std::make_tuple(args...));
-        mCondition.notify_all();
-    }
-
-    // Returns a functor which can be used with the Google Mock Invoke()
-    // function, or as a std::function to record calls.
-    auto getInvocable() {
-        return [this](Args... args) { recordCall(args...); };
-    }
-
-    // Returns a set of arguments as a std::optional<std::tuple<...>> for the
-    // oldest call, waiting for the given timeout if necessary if there are no
-    // arguments in the FIFO.
-    std::optional<ArgTuple> waitForCall(
-            std::chrono::microseconds timeout = DEFAULT_CALL_EXPECTED_TIMEOUT)
-            NO_THREAD_SAFETY_ANALYSIS {
-        std::unique_lock<std::mutex> lock(mMutex);
-
-        // Wait if necessary for us to have a record from a call.
-        mCondition.wait_for(lock, timeout,
-                            [this]() NO_THREAD_SAFETY_ANALYSIS { return !mCalls.empty(); });
-
-        // Return the arguments from the oldest call, if one was made
-        bool called = !mCalls.empty();
-        std::optional<ArgTuple> result;
-        if (called) {
-            result.emplace(std::move(mCalls.front()));
-            mCalls.pop_front();
-        }
-        return result;
-    }
-
-    // Waits using a small default timeout for when a call is not expected to be
-    // made. The returned std::optional<std:tuple<...>> should not have a value
-    // except if a set of arguments was unexpectedly received because a call was
-    // actually made.
-    //
-    // Note this function uses a small timeout to not block test execution, and
-    // it is possible the code under test could make the call AFTER the timeout
-    // expires.
-    std::optional<ArgTuple> waitForUnexpectedCall() { return waitForCall(UNEXPECTED_CALL_TIMEOUT); }
-
-private:
-    std::mutex mMutex;
-    std::condition_variable mCondition;
-    std::deque<ArgTuple> mCalls GUARDED_BY(mMutex);
-};
-
-// Like AsyncCallRecorder, but for when the function being invoked
-// asynchronously is expected to return a value.
-//
-// This helper allows a single constant return value to be set to be returned by
-// all calls that were made.
-template <typename Func>
-class AsyncCallRecorderWithCannedReturn;
-
-template <typename Ret, typename... Args>
-class AsyncCallRecorderWithCannedReturn<Ret (*)(Args...)>
-      : public AsyncCallRecorder<void (*)(Args...)> {
-public:
-    explicit AsyncCallRecorderWithCannedReturn(Ret returnvalue) : mReturnValue(returnvalue) {}
-
-    auto getInvocable() {
-        return [this](Args... args) {
-            this->recordCall(args...);
-            return mReturnValue;
-        };
-    }
-
-private:
-    const Ret mReturnValue;
-};
-
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/DisplayTransactionTest.cpp b/services/surfaceflinger/tests/unittests/DisplayTransactionTest.cpp
deleted file mode 100644
index 9b308bfcc..000000000
--- a/services/surfaceflinger/tests/unittests/DisplayTransactionTest.cpp
+++ /dev/null
@@ -1,2798 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#undef LOG_TAG
-#define LOG_TAG "LibSurfaceFlingerUnittests"
-
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
-#include <log/log.h>
-
-#include "TestableSurfaceFlinger.h"
-#include "mock/DisplayHardware/MockComposer.h"
-#include "mock/DisplayHardware/MockDisplaySurface.h"
-#include "mock/MockEventControlThread.h"
-#include "mock/MockEventThread.h"
-#include "mock/MockMessageQueue.h"
-#include "mock/MockNativeWindowSurface.h"
-#include "mock/MockSurfaceInterceptor.h"
-#include "mock/RenderEngine/MockRenderEngine.h"
-#include "mock/gui/MockGraphicBufferConsumer.h"
-#include "mock/gui/MockGraphicBufferProducer.h"
-#include "mock/system/window/MockNativeWindow.h"
-
-namespace android {
-namespace {
-
-using testing::_;
-using testing::ByMove;
-using testing::DoAll;
-using testing::Mock;
-using testing::Return;
-using testing::SetArgPointee;
-
-using android::Hwc2::ColorMode;
-using android::Hwc2::Error;
-using android::Hwc2::Hdr;
-using android::Hwc2::IComposer;
-using android::Hwc2::IComposerClient;
-using android::Hwc2::PerFrameMetadataKey;
-using android::Hwc2::RenderIntent;
-
-using FakeDisplayDeviceInjector = TestableSurfaceFlinger::FakeDisplayDeviceInjector;
-using FakeHwcDisplayInjector = TestableSurfaceFlinger::FakeHwcDisplayInjector;
-using HotplugEvent = TestableSurfaceFlinger::HotplugEvent;
-using HWC2Display = TestableSurfaceFlinger::HWC2Display;
-
-constexpr int32_t DEFAULT_REFRESH_RATE = 16'666'666;
-constexpr int32_t DEFAULT_DPI = 320;
-constexpr int DEFAULT_VIRTUAL_DISPLAY_SURFACE_FORMAT = HAL_PIXEL_FORMAT_RGB_565;
-
-constexpr int HWC_POWER_MODE_LEET = 1337; // An out of range power mode value
-
-/* ------------------------------------------------------------------------
- * Boolean avoidance
- *
- * To make calls and template instantiations more readable, we define some
- * local enums along with an implicit bool conversion.
- */
-
-#define BOOL_SUBSTITUTE(TYPENAME) enum class TYPENAME : bool { FALSE = false, TRUE = true };
-
-BOOL_SUBSTITUTE(Critical);
-BOOL_SUBSTITUTE(Async);
-BOOL_SUBSTITUTE(Secure);
-
-/* ------------------------------------------------------------------------
- *
- */
-
-class DisplayTransactionTest : public testing::Test {
-public:
-    DisplayTransactionTest();
-    ~DisplayTransactionTest() override;
-
-    // --------------------------------------------------------------------
-    // Mock/Fake injection
-
-    void injectMockComposer(int virtualDisplayCount);
-    void injectFakeBufferQueueFactory();
-    void injectFakeNativeWindowSurfaceFactory();
-
-    // --------------------------------------------------------------------
-    // Postcondition helpers
-
-    bool hasHwcDisplay(hwc2_display_t displayId);
-    bool hasTransactionFlagSet(int flag);
-    bool hasDisplayDevice(sp<IBinder> displayToken);
-    sp<DisplayDevice> getDisplayDevice(sp<IBinder> displayToken);
-    bool hasCurrentDisplayState(sp<IBinder> displayToken);
-    const DisplayDeviceState& getCurrentDisplayState(sp<IBinder> displayToken);
-    bool hasDrawingDisplayState(sp<IBinder> displayToken);
-    const DisplayDeviceState& getDrawingDisplayState(sp<IBinder> displayToken);
-
-    // --------------------------------------------------------------------
-    // Test instances
-
-    TestableSurfaceFlinger mFlinger;
-    mock::EventThread* mEventThread = new mock::EventThread();
-    mock::EventControlThread* mEventControlThread = new mock::EventControlThread();
-
-    // These mocks are created by the test, but are destroyed by SurfaceFlinger
-    // by virtue of being stored into a std::unique_ptr. However we still need
-    // to keep a reference to them for use in setting up call expectations.
-    RE::mock::RenderEngine* mRenderEngine = new RE::mock::RenderEngine();
-    Hwc2::mock::Composer* mComposer = nullptr;
-    mock::MessageQueue* mMessageQueue = new mock::MessageQueue();
-    mock::SurfaceInterceptor* mSurfaceInterceptor = new mock::SurfaceInterceptor();
-
-    // These mocks are created only when expected to be created via a factory.
-    sp<mock::GraphicBufferConsumer> mConsumer;
-    sp<mock::GraphicBufferProducer> mProducer;
-    mock::NativeWindowSurface* mNativeWindowSurface = nullptr;
-    sp<mock::NativeWindow> mNativeWindow;
-    RE::mock::Surface* mRenderSurface = nullptr;
-};
-
-DisplayTransactionTest::DisplayTransactionTest() {
-    const ::testing::TestInfo* const test_info =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGD("**** Setting up for %s.%s\n", test_info->test_case_name(), test_info->name());
-
-    // Default to no wide color display support configured
-    mFlinger.mutableHasWideColorDisplay() = false;
-    mFlinger.mutableDisplayColorSetting() = DisplayColorSetting::UNMANAGED;
-
-    // Default to using HWC virtual displays
-    mFlinger.mutableUseHwcVirtualDisplays() = true;
-
-    mFlinger.setCreateBufferQueueFunction([](auto, auto, auto) {
-        ADD_FAILURE() << "Unexpected request to create a buffer queue.";
-    });
-
-    mFlinger.setCreateNativeWindowSurface([](auto) {
-        ADD_FAILURE() << "Unexpected request to create a native window surface.";
-        return nullptr;
-    });
-
-    mFlinger.mutableEventControlThread().reset(mEventControlThread);
-    mFlinger.mutableEventThread().reset(mEventThread);
-    mFlinger.mutableEventQueue().reset(mMessageQueue);
-    mFlinger.setupRenderEngine(std::unique_ptr<RE::RenderEngine>(mRenderEngine));
-    mFlinger.mutableInterceptor().reset(mSurfaceInterceptor);
-
-    injectMockComposer(0);
-}
-
-DisplayTransactionTest::~DisplayTransactionTest() {
-    const ::testing::TestInfo* const test_info =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGD("**** Tearing down after %s.%s\n", test_info->test_case_name(), test_info->name());
-}
-
-void DisplayTransactionTest::injectMockComposer(int virtualDisplayCount) {
-    mComposer = new Hwc2::mock::Composer();
-    EXPECT_CALL(*mComposer, getCapabilities())
-            .WillOnce(Return(std::vector<IComposer::Capability>()));
-    EXPECT_CALL(*mComposer, getMaxVirtualDisplayCount()).WillOnce(Return(virtualDisplayCount));
-    mFlinger.setupComposer(std::unique_ptr<Hwc2::Composer>(mComposer));
-
-    Mock::VerifyAndClear(mComposer);
-}
-
-void DisplayTransactionTest::injectFakeBufferQueueFactory() {
-    // This setup is only expected once per test.
-    ASSERT_TRUE(mConsumer == nullptr && mProducer == nullptr);
-
-    mConsumer = new mock::GraphicBufferConsumer();
-    mProducer = new mock::GraphicBufferProducer();
-
-    mFlinger.setCreateBufferQueueFunction([this](auto outProducer, auto outConsumer, bool) {
-        *outProducer = mProducer;
-        *outConsumer = mConsumer;
-    });
-}
-
-void DisplayTransactionTest::injectFakeNativeWindowSurfaceFactory() {
-    // This setup is only expected once per test.
-    ASSERT_TRUE(mNativeWindowSurface == nullptr);
-
-    mNativeWindowSurface = new mock::NativeWindowSurface();
-    mNativeWindow = new mock::NativeWindow();
-
-    mFlinger.setCreateNativeWindowSurface(
-            [this](auto) { return std::unique_ptr<NativeWindowSurface>(mNativeWindowSurface); });
-}
-
-bool DisplayTransactionTest::hasHwcDisplay(hwc2_display_t displayId) {
-    return mFlinger.mutableHwcDisplaySlots().count(displayId) == 1;
-}
-
-bool DisplayTransactionTest::hasTransactionFlagSet(int flag) {
-    return mFlinger.mutableTransactionFlags() & flag;
-}
-
-bool DisplayTransactionTest::hasDisplayDevice(sp<IBinder> displayToken) {
-    return mFlinger.mutableDisplays().indexOfKey(displayToken) >= 0;
-}
-
-sp<DisplayDevice> DisplayTransactionTest::getDisplayDevice(sp<IBinder> displayToken) {
-    return mFlinger.mutableDisplays().valueFor(displayToken);
-}
-
-bool DisplayTransactionTest::hasCurrentDisplayState(sp<IBinder> displayToken) {
-    return mFlinger.mutableCurrentState().displays.indexOfKey(displayToken) >= 0;
-}
-
-const DisplayDeviceState& DisplayTransactionTest::getCurrentDisplayState(sp<IBinder> displayToken) {
-    return mFlinger.mutableCurrentState().displays.valueFor(displayToken);
-}
-
-bool DisplayTransactionTest::hasDrawingDisplayState(sp<IBinder> displayToken) {
-    return mFlinger.mutableDrawingState().displays.indexOfKey(displayToken) >= 0;
-}
-
-const DisplayDeviceState& DisplayTransactionTest::getDrawingDisplayState(sp<IBinder> displayToken) {
-    return mFlinger.mutableDrawingState().displays.valueFor(displayToken);
-}
-
-/* ------------------------------------------------------------------------
- *
- */
-
-template <DisplayDevice::DisplayType type, DisplayDevice::DisplayType hwcId, int width, int height,
-          Critical critical, Async async, Secure secure, int grallocUsage>
-struct DisplayVariant {
-    // The display width and height
-    static constexpr int WIDTH = width;
-    static constexpr int HEIGHT = height;
-
-    static constexpr int GRALLOC_USAGE = grallocUsage;
-
-    // The type for this display
-    static constexpr DisplayDevice::DisplayType TYPE = type;
-    static constexpr DisplayDevice::DisplayType HWCOMPOSER_ID = hwcId;
-
-    // When creating native window surfaces for the framebuffer, whether those should be critical
-    static constexpr Critical CRITICAL = critical;
-
-    // When creating native window surfaces for the framebuffer, whether those should be async
-    static constexpr Async ASYNC = async;
-
-    // Whether the display should be treated as secure
-    static constexpr Secure SECURE = secure;
-
-    static auto makeFakeExistingDisplayInjector(DisplayTransactionTest* test) {
-        auto injector = FakeDisplayDeviceInjector(test->mFlinger, TYPE, HWCOMPOSER_ID);
-        injector.setSecure(static_cast<bool>(SECURE));
-        return injector;
-    }
-
-    // Called by tests to set up any native window creation call expectations.
-    static void setupNativeWindowSurfaceCreationCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mNativeWindowSurface, getNativeWindow())
-                .WillOnce(Return(test->mNativeWindow));
-        EXPECT_CALL(*test->mNativeWindow, perform(19)).WillRepeatedly(Return(NO_ERROR));
-
-        // For simplicity, we only expect to create a single render surface for
-        // each test.
-        ASSERT_TRUE(test->mRenderSurface == nullptr);
-        test->mRenderSurface = new RE::mock::Surface();
-        EXPECT_CALL(*test->mRenderEngine, createSurface())
-                .WillOnce(Return(ByMove(std::unique_ptr<RE::Surface>(test->mRenderSurface))));
-        EXPECT_CALL(*test->mRenderSurface, setAsync(static_cast<bool>(ASYNC))).Times(1);
-        EXPECT_CALL(*test->mRenderSurface, setCritical(static_cast<bool>(CRITICAL))).Times(1);
-        EXPECT_CALL(*test->mRenderSurface, setNativeWindow(test->mNativeWindow.get())).Times(1);
-        EXPECT_CALL(*test->mRenderSurface, queryWidth()).WillOnce(Return(WIDTH));
-        EXPECT_CALL(*test->mRenderSurface, queryHeight()).WillOnce(Return(HEIGHT));
-    }
-
-    static void setupFramebufferConsumerBufferQueueCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mConsumer, consumerConnect(_, false)).WillOnce(Return(NO_ERROR));
-        EXPECT_CALL(*test->mConsumer, setConsumerName(_)).WillRepeatedly(Return(NO_ERROR));
-        EXPECT_CALL(*test->mConsumer, setConsumerUsageBits(GRALLOC_USAGE))
-                .WillRepeatedly(Return(NO_ERROR));
-        EXPECT_CALL(*test->mConsumer, setDefaultBufferSize(WIDTH, HEIGHT))
-                .WillRepeatedly(Return(NO_ERROR));
-        EXPECT_CALL(*test->mConsumer, setMaxAcquiredBufferCount(_))
-                .WillRepeatedly(Return(NO_ERROR));
-    }
-
-    static void setupFramebufferProducerBufferQueueCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mProducer, allocateBuffers(0, 0, 0, 0)).WillRepeatedly(Return());
-    }
-};
-
-template <hwc2_display_t hwcDisplayId, HWC2::DisplayType hwcDisplayType, typename DisplayVariant>
-struct HwcDisplayVariant {
-    // The display id supplied by the HWC
-    static constexpr hwc2_display_t HWC_DISPLAY_ID = hwcDisplayId;
-
-    // The HWC display type
-    static constexpr HWC2::DisplayType HWC_DISPLAY_TYPE = hwcDisplayType;
-
-    // The HWC active configuration id
-    static constexpr int HWC_ACTIVE_CONFIG_ID = 2001;
-
-    static void injectPendingHotplugEvent(DisplayTransactionTest* test,
-                                          HWC2::Connection connection) {
-        test->mFlinger.mutablePendingHotplugEvents().emplace_back(
-                HotplugEvent{HWC_DISPLAY_ID, connection});
-    }
-
-    // Called by tests to inject a HWC display setup
-    static void injectHwcDisplay(DisplayTransactionTest* test) {
-        FakeHwcDisplayInjector(DisplayVariant::TYPE, HWC_DISPLAY_TYPE)
-                .setHwcDisplayId(HWC_DISPLAY_ID)
-                .setWidth(DisplayVariant::WIDTH)
-                .setHeight(DisplayVariant::HEIGHT)
-                .setActiveConfig(HWC_ACTIVE_CONFIG_ID)
-                .inject(&test->mFlinger, test->mComposer);
-    }
-
-    static void setupHwcHotplugCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getDisplayType(HWC_DISPLAY_ID, _))
-                .WillOnce(DoAll(SetArgPointee<1>(static_cast<IComposerClient::DisplayType>(
-                                        HWC_DISPLAY_TYPE)),
-                                Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer, setClientTargetSlotCount(_)).WillOnce(Return(Error::NONE));
-        EXPECT_CALL(*test->mComposer, getDisplayConfigs(HWC_DISPLAY_ID, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<unsigned>{HWC_ACTIVE_CONFIG_ID}),
-                                Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer,
-                    getDisplayAttribute(HWC_DISPLAY_ID, HWC_ACTIVE_CONFIG_ID,
-                                        IComposerClient::Attribute::WIDTH, _))
-                .WillOnce(DoAll(SetArgPointee<3>(DisplayVariant::WIDTH), Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer,
-                    getDisplayAttribute(HWC_DISPLAY_ID, HWC_ACTIVE_CONFIG_ID,
-                                        IComposerClient::Attribute::HEIGHT, _))
-                .WillOnce(DoAll(SetArgPointee<3>(DisplayVariant::HEIGHT), Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer,
-                    getDisplayAttribute(HWC_DISPLAY_ID, HWC_ACTIVE_CONFIG_ID,
-                                        IComposerClient::Attribute::VSYNC_PERIOD, _))
-                .WillOnce(DoAll(SetArgPointee<3>(DEFAULT_REFRESH_RATE), Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer,
-                    getDisplayAttribute(HWC_DISPLAY_ID, HWC_ACTIVE_CONFIG_ID,
-                                        IComposerClient::Attribute::DPI_X, _))
-                .WillOnce(DoAll(SetArgPointee<3>(DEFAULT_DPI), Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer,
-                    getDisplayAttribute(HWC_DISPLAY_ID, HWC_ACTIVE_CONFIG_ID,
-                                        IComposerClient::Attribute::DPI_Y, _))
-                .WillOnce(DoAll(SetArgPointee<3>(DEFAULT_DPI), Return(Error::NONE)));
-    }
-
-    // Called by tests to set up HWC call expectations
-    static void setupHwcGetActiveConfigCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getActiveConfig(HWC_DISPLAY_ID, _))
-                .WillRepeatedly(DoAll(SetArgPointee<1>(HWC_ACTIVE_CONFIG_ID), Return(Error::NONE)));
-    }
-};
-
-struct NonHwcDisplayVariant {
-    static void injectHwcDisplay(DisplayTransactionTest*) {}
-
-    static void setupHwcGetActiveConfigCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getActiveConfig(_, _)).Times(0);
-    }
-};
-
-// Physical displays are expected to be synchronous, secure, and have a HWC display for output.
-constexpr uint32_t GRALLOC_USAGE_PHYSICAL_DISPLAY =
-        GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_FB;
-
-template <hwc2_display_t hwcDisplayId, DisplayDevice::DisplayType type, int width, int height,
-          Critical critical>
-struct PhysicalDisplayVariant
-      : public DisplayVariant<type, type, width, height, critical, Async::FALSE, Secure::TRUE,
-                              GRALLOC_USAGE_PHYSICAL_DISPLAY>,
-        public HwcDisplayVariant<hwcDisplayId, HWC2::DisplayType::Physical,
-                                 DisplayVariant<type, type, width, height, critical, Async::FALSE,
-                                                Secure::TRUE, GRALLOC_USAGE_PHYSICAL_DISPLAY>> {};
-
-// An invalid display
-using InvalidDisplayVariant =
-        DisplayVariant<DisplayDevice::DISPLAY_ID_INVALID, DisplayDevice::DISPLAY_ID_INVALID, 0, 0,
-                       Critical::FALSE, Async::FALSE, Secure::FALSE, 0>;
-
-// A primary display is a physical display that is critical
-using PrimaryDisplayVariant =
-        PhysicalDisplayVariant<1001, DisplayDevice::DISPLAY_PRIMARY, 3840, 2160, Critical::TRUE>;
-
-// An external display is physical display that is not critical.
-using ExternalDisplayVariant =
-        PhysicalDisplayVariant<1002, DisplayDevice::DISPLAY_EXTERNAL, 1920, 1280, Critical::FALSE>;
-
-using TertiaryDisplayVariant =
-        PhysicalDisplayVariant<1003, DisplayDevice::DISPLAY_EXTERNAL, 1600, 1200, Critical::FALSE>;
-
-// A virtual display not supported by the HWC.
-constexpr uint32_t GRALLOC_USAGE_NONHWC_VIRTUAL_DISPLAY = 0;
-
-template <int width, int height, Secure secure>
-struct NonHwcVirtualDisplayVariant
-      : public DisplayVariant<DisplayDevice::DISPLAY_VIRTUAL, DisplayDevice::DISPLAY_ID_INVALID,
-                              width, height, Critical::FALSE, Async::TRUE, secure,
-                              GRALLOC_USAGE_NONHWC_VIRTUAL_DISPLAY>,
-        public NonHwcDisplayVariant {
-    using Base = DisplayVariant<DisplayDevice::DISPLAY_VIRTUAL, DisplayDevice::DISPLAY_ID_INVALID,
-                                width, height, Critical::FALSE, Async::TRUE, secure,
-                                GRALLOC_USAGE_NONHWC_VIRTUAL_DISPLAY>;
-
-    static void setupNativeWindowSurfaceCreationCallExpectations(DisplayTransactionTest* test) {
-        Base::setupNativeWindowSurfaceCreationCallExpectations(test);
-        EXPECT_CALL(*test->mNativeWindow, setSwapInterval(0)).Times(1);
-    }
-};
-
-// A virtual display supported by the HWC.
-constexpr uint32_t GRALLOC_USAGE_HWC_VIRTUAL_DISPLAY = GRALLOC_USAGE_HW_COMPOSER;
-
-template <int width, int height, Secure secure>
-struct HwcVirtualDisplayVariant
-      : public DisplayVariant<DisplayDevice::DISPLAY_VIRTUAL, DisplayDevice::DISPLAY_VIRTUAL, width,
-                              height, Critical::FALSE, Async::TRUE, secure,
-                              GRALLOC_USAGE_HWC_VIRTUAL_DISPLAY>,
-        public HwcDisplayVariant<1010, HWC2::DisplayType::Virtual,
-                                 NonHwcVirtualDisplayVariant<width, height, secure>> {
-    using Base =
-            DisplayVariant<DisplayDevice::DISPLAY_VIRTUAL, DisplayDevice::DISPLAY_VIRTUAL, width,
-                           height, Critical::FALSE, Async::TRUE, secure, GRALLOC_USAGE_HW_COMPOSER>;
-    using Self = HwcVirtualDisplayVariant<width, height, secure>;
-
-    static void setupNativeWindowSurfaceCreationCallExpectations(DisplayTransactionTest* test) {
-        Base::setupNativeWindowSurfaceCreationCallExpectations(test);
-        EXPECT_CALL(*test->mNativeWindow, setSwapInterval(0)).Times(1);
-    }
-
-    static void setupHwcVirtualDisplayCreationCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, createVirtualDisplay(Base::WIDTH, Base::HEIGHT, _, _))
-                .WillOnce(DoAll(SetArgPointee<3>(Self::HWC_DISPLAY_ID), Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer, setClientTargetSlotCount(_)).WillOnce(Return(Error::NONE));
-    }
-};
-
-// For this variant, SurfaceFlinger should not configure itself with wide
-// display support, so the display should not be configured for wide-color
-// support.
-struct WideColorSupportNotConfiguredVariant {
-    static constexpr bool WIDE_COLOR_SUPPORTED = false;
-
-    static void injectConfigChange(DisplayTransactionTest* test) {
-        test->mFlinger.mutableHasWideColorDisplay() = false;
-        test->mFlinger.mutableDisplayColorSetting() = DisplayColorSetting::UNMANAGED;
-    }
-
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getColorModes(_, _)).Times(0);
-        EXPECT_CALL(*test->mComposer, getRenderIntents(_, _, _)).Times(0);
-        EXPECT_CALL(*test->mComposer, setColorMode(_, _, _)).Times(0);
-    }
-};
-
-// For this variant, SurfaceFlinger should configure itself with wide display
-// support, and the display should respond with an non-empty list of supported
-// color modes. Wide-color support should be configured.
-template <typename Display>
-struct WideColorP3ColorimetricSupportedVariant {
-    static constexpr bool WIDE_COLOR_SUPPORTED = true;
-
-    static void injectConfigChange(DisplayTransactionTest* test) {
-        test->mFlinger.mutableHasWideColorDisplay() = true;
-        test->mFlinger.mutableDisplayColorSetting() = DisplayColorSetting::UNMANAGED;
-    }
-
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getColorModes(Display::HWC_DISPLAY_ID, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<ColorMode>({ColorMode::DISPLAY_P3})),
-                                Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer,
-                    getRenderIntents(Display::HWC_DISPLAY_ID, ColorMode::DISPLAY_P3, _))
-                .WillOnce(DoAll(SetArgPointee<2>(
-                                        std::vector<RenderIntent>({RenderIntent::COLORIMETRIC})),
-                                Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer,
-                    setColorMode(Display::HWC_DISPLAY_ID, ColorMode::SRGB,
-                                 RenderIntent::COLORIMETRIC))
-                .WillOnce(Return(Error::NONE));
-    }
-};
-
-// For this variant, SurfaceFlinger should configure itself with wide display
-// support, but the display should respond with an empty list of supported color
-// modes. Wide-color support for the display should not be configured.
-template <typename Display>
-struct WideColorNotSupportedVariant {
-    static constexpr bool WIDE_COLOR_SUPPORTED = false;
-
-    static void injectConfigChange(DisplayTransactionTest* test) {
-        test->mFlinger.mutableHasWideColorDisplay() = true;
-    }
-
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getColorModes(Display::HWC_DISPLAY_ID, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<ColorMode>()), Return(Error::NONE)));
-        EXPECT_CALL(*test->mComposer, setColorMode(_, _, _)).Times(0);
-    }
-};
-
-// For this variant, the display is not a HWC display, so no HDR support should
-// be configured.
-struct NonHwcDisplayHdrSupportVariant {
-    static constexpr bool HDR10_SUPPORTED = false;
-    static constexpr bool HDR_HLG_SUPPORTED = false;
-    static constexpr bool HDR_DOLBY_VISION_SUPPORTED = false;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getHdrCapabilities(_, _, _, _, _)).Times(0);
-    }
-};
-
-// For this variant, the composer should respond with a non-empty list of HDR
-// modes containing HDR10, so HDR10 support should be configured.
-template <typename Display>
-struct Hdr10SupportedVariant {
-    static constexpr bool HDR10_SUPPORTED = true;
-    static constexpr bool HDR_HLG_SUPPORTED = false;
-    static constexpr bool HDR_DOLBY_VISION_SUPPORTED = false;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getHdrCapabilities(Display::HWC_DISPLAY_ID, _, _, _, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<Hdr>({Hdr::HDR10})),
-                                Return(Error::NONE)));
-    }
-};
-
-// For this variant, the composer should respond with a non-empty list of HDR
-// modes containing HLG, so HLG support should be configured.
-template <typename Display>
-struct HdrHlgSupportedVariant {
-    static constexpr bool HDR10_SUPPORTED = false;
-    static constexpr bool HDR_HLG_SUPPORTED = true;
-    static constexpr bool HDR_DOLBY_VISION_SUPPORTED = false;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getHdrCapabilities(Display::HWC_DISPLAY_ID, _, _, _, _))
-                .WillOnce(
-                        DoAll(SetArgPointee<1>(std::vector<Hdr>({Hdr::HLG})), Return(Error::NONE)));
-    }
-};
-
-// For this variant, the composer should respond with a non-empty list of HDR
-// modes containing DOLBY_VISION, so DOLBY_VISION support should be configured.
-template <typename Display>
-struct HdrDolbyVisionSupportedVariant {
-    static constexpr bool HDR10_SUPPORTED = false;
-    static constexpr bool HDR_HLG_SUPPORTED = false;
-    static constexpr bool HDR_DOLBY_VISION_SUPPORTED = true;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getHdrCapabilities(Display::HWC_DISPLAY_ID, _, _, _, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<Hdr>({Hdr::DOLBY_VISION})),
-                                Return(Error::NONE)));
-    }
-};
-
-// For this variant, the composer should respond with am empty list of HDR
-// modes, so no HDR support should be configured.
-template <typename Display>
-struct HdrNotSupportedVariant {
-    static constexpr bool HDR10_SUPPORTED = false;
-    static constexpr bool HDR_HLG_SUPPORTED = false;
-    static constexpr bool HDR_DOLBY_VISION_SUPPORTED = false;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getHdrCapabilities(Display::HWC_DISPLAY_ID, _, _, _, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<Hdr>()), Return(Error::NONE)));
-    }
-};
-
-struct NonHwcPerFrameMetadataSupportVariant {
-    static constexpr int PER_FRAME_METADATA_KEYS = 0;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getPerFrameMetadataKeys(_, _)).Times(0);
-    }
-};
-
-template <typename Display>
-struct NoPerFrameMetadataSupportVariant {
-    static constexpr int PER_FRAME_METADATA_KEYS = 0;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getPerFrameMetadataKeys(Display::HWC_DISPLAY_ID, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<PerFrameMetadataKey>()),
-                                Return(Error::NONE)));
-    }
-};
-
-template <typename Display>
-struct Smpte2086PerFrameMetadataSupportVariant {
-    static constexpr int PER_FRAME_METADATA_KEYS = HdrMetadata::Type::SMPTE2086;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getPerFrameMetadataKeys(Display::HWC_DISPLAY_ID, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<PerFrameMetadataKey>({
-                                        PerFrameMetadataKey::DISPLAY_RED_PRIMARY_X,
-                                        PerFrameMetadataKey::DISPLAY_RED_PRIMARY_Y,
-                                        PerFrameMetadataKey::DISPLAY_GREEN_PRIMARY_X,
-                                        PerFrameMetadataKey::DISPLAY_GREEN_PRIMARY_Y,
-                                        PerFrameMetadataKey::DISPLAY_BLUE_PRIMARY_X,
-                                        PerFrameMetadataKey::DISPLAY_BLUE_PRIMARY_Y,
-                                        PerFrameMetadataKey::WHITE_POINT_X,
-                                        PerFrameMetadataKey::WHITE_POINT_Y,
-                                        PerFrameMetadataKey::MAX_LUMINANCE,
-                                        PerFrameMetadataKey::MIN_LUMINANCE,
-                                })),
-                                Return(Error::NONE)));
-    }
-};
-
-template <typename Display>
-struct Cta861_3_PerFrameMetadataSupportVariant {
-    static constexpr int PER_FRAME_METADATA_KEYS = HdrMetadata::Type::CTA861_3;
-    static void setupComposerCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, getPerFrameMetadataKeys(Display::HWC_DISPLAY_ID, _))
-                .WillOnce(DoAll(SetArgPointee<1>(std::vector<PerFrameMetadataKey>({
-                                        PerFrameMetadataKey::MAX_CONTENT_LIGHT_LEVEL,
-                                        PerFrameMetadataKey::MAX_FRAME_AVERAGE_LIGHT_LEVEL,
-                                })),
-                                Return(Error::NONE)));
-    }
-};
-
-/* ------------------------------------------------------------------------
- * Typical display configurations to test
- */
-
-template <typename DisplayPolicy, typename WideColorSupportPolicy, typename HdrSupportPolicy,
-          typename PerFrameMetadataSupportPolicy>
-struct Case {
-    using Display = DisplayPolicy;
-    using WideColorSupport = WideColorSupportPolicy;
-    using HdrSupport = HdrSupportPolicy;
-    using PerFrameMetadataSupport = PerFrameMetadataSupportPolicy;
-};
-
-using SimplePrimaryDisplayCase =
-        Case<PrimaryDisplayVariant, WideColorNotSupportedVariant<PrimaryDisplayVariant>,
-             HdrNotSupportedVariant<PrimaryDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<PrimaryDisplayVariant>>;
-using SimpleExternalDisplayCase =
-        Case<ExternalDisplayVariant, WideColorNotSupportedVariant<ExternalDisplayVariant>,
-             HdrNotSupportedVariant<ExternalDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<ExternalDisplayVariant>>;
-using SimpleTertiaryDisplayCase =
-        Case<TertiaryDisplayVariant, WideColorNotSupportedVariant<TertiaryDisplayVariant>,
-             HdrNotSupportedVariant<TertiaryDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<TertiaryDisplayVariant>>;
-using NonHwcVirtualDisplayCase =
-        Case<NonHwcVirtualDisplayVariant<1024, 768, Secure::FALSE>,
-             WideColorSupportNotConfiguredVariant, NonHwcDisplayHdrSupportVariant,
-             NonHwcPerFrameMetadataSupportVariant>;
-using SimpleHwcVirtualDisplayVariant = HwcVirtualDisplayVariant<1024, 768, Secure::TRUE>;
-using HwcVirtualDisplayCase =
-        Case<SimpleHwcVirtualDisplayVariant, WideColorSupportNotConfiguredVariant,
-             HdrNotSupportedVariant<SimpleHwcVirtualDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<SimpleHwcVirtualDisplayVariant>>;
-using WideColorP3ColorimetricDisplayCase =
-        Case<PrimaryDisplayVariant, WideColorP3ColorimetricSupportedVariant<PrimaryDisplayVariant>,
-             HdrNotSupportedVariant<PrimaryDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<PrimaryDisplayVariant>>;
-using Hdr10DisplayCase =
-        Case<PrimaryDisplayVariant, WideColorNotSupportedVariant<PrimaryDisplayVariant>,
-             Hdr10SupportedVariant<PrimaryDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<PrimaryDisplayVariant>>;
-using HdrHlgDisplayCase =
-        Case<PrimaryDisplayVariant, WideColorNotSupportedVariant<PrimaryDisplayVariant>,
-             HdrHlgSupportedVariant<PrimaryDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<PrimaryDisplayVariant>>;
-using HdrDolbyVisionDisplayCase =
-        Case<PrimaryDisplayVariant, WideColorNotSupportedVariant<PrimaryDisplayVariant>,
-             HdrDolbyVisionSupportedVariant<PrimaryDisplayVariant>,
-             NoPerFrameMetadataSupportVariant<PrimaryDisplayVariant>>;
-using HdrSmpte2086DisplayCase =
-        Case<PrimaryDisplayVariant, WideColorNotSupportedVariant<PrimaryDisplayVariant>,
-             HdrNotSupportedVariant<PrimaryDisplayVariant>,
-             Smpte2086PerFrameMetadataSupportVariant<PrimaryDisplayVariant>>;
-using HdrCta861_3_DisplayCase =
-        Case<PrimaryDisplayVariant, WideColorNotSupportedVariant<PrimaryDisplayVariant>,
-             HdrNotSupportedVariant<PrimaryDisplayVariant>,
-             Cta861_3_PerFrameMetadataSupportVariant<PrimaryDisplayVariant>>;
-using InvalidDisplayCase = Case<InvalidDisplayVariant, WideColorSupportNotConfiguredVariant,
-                                NonHwcDisplayHdrSupportVariant,
-                                NoPerFrameMetadataSupportVariant<InvalidDisplayVariant>>;
-/* ------------------------------------------------------------------------
- *
- * SurfaceFlinger::onHotplugReceived
- */
-
-TEST_F(DisplayTransactionTest, hotplugEnqueuesEventsForDisplayTransaction) {
-    constexpr int currentSequenceId = 123;
-    constexpr hwc2_display_t displayId1 = 456;
-    constexpr hwc2_display_t displayId2 = 654;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // Set the current sequence id for accepted events
-    mFlinger.mutableComposerSequenceId() = currentSequenceId;
-
-    // Set the main thread id so that the current thread does not appear to be
-    // the main thread.
-    mFlinger.mutableMainThreadId() = std::thread::id();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // We expect invalidate() to be invoked once to trigger display transaction
-    // processing.
-    EXPECT_CALL(*mMessageQueue, invalidate()).Times(1);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    // Simulate two hotplug events (a connect and a disconnect)
-    mFlinger.onHotplugReceived(currentSequenceId, displayId1, HWC2::Connection::Connected);
-    mFlinger.onHotplugReceived(currentSequenceId, displayId2, HWC2::Connection::Disconnected);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The display transaction needed flag should be set.
-    EXPECT_TRUE(hasTransactionFlagSet(eDisplayTransactionNeeded));
-
-    // All events should be in the pending event queue.
-    const auto& pendingEvents = mFlinger.mutablePendingHotplugEvents();
-    ASSERT_EQ(2u, pendingEvents.size());
-    EXPECT_EQ(displayId1, pendingEvents[0].display);
-    EXPECT_EQ(HWC2::Connection::Connected, pendingEvents[0].connection);
-    EXPECT_EQ(displayId2, pendingEvents[1].display);
-    EXPECT_EQ(HWC2::Connection::Disconnected, pendingEvents[1].connection);
-}
-
-TEST_F(DisplayTransactionTest, hotplugDiscardsUnexpectedEvents) {
-    constexpr int currentSequenceId = 123;
-    constexpr int otherSequenceId = 321;
-    constexpr hwc2_display_t displayId = 456;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // Set the current sequence id for accepted events
-    mFlinger.mutableComposerSequenceId() = currentSequenceId;
-
-    // Set the main thread id so that the current thread does not appear to be
-    // the main thread.
-    mFlinger.mutableMainThreadId() = std::thread::id();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // We do not expect any calls to invalidate().
-    EXPECT_CALL(*mMessageQueue, invalidate()).Times(0);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    // Call with an unexpected sequence id
-    mFlinger.onHotplugReceived(otherSequenceId, displayId, HWC2::Connection::Invalid);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The display transaction needed flag should not be set
-    EXPECT_FALSE(hasTransactionFlagSet(eDisplayTransactionNeeded));
-
-    // There should be no pending events
-    EXPECT_TRUE(mFlinger.mutablePendingHotplugEvents().empty());
-}
-
-TEST_F(DisplayTransactionTest, hotplugProcessesEnqueuedEventsIfCalledOnMainThread) {
-    constexpr int currentSequenceId = 123;
-    constexpr hwc2_display_t displayId1 = 456;
-
-    // --------------------------------------------------------------------
-    // Note:
-    // --------------------------------------------------------------------
-    // This test case is a bit tricky. We want to verify that
-    // onHotplugReceived() calls processDisplayHotplugEventsLocked(), but we
-    // don't really want to provide coverage for everything the later function
-    // does as there are specific tests for it.
-    // --------------------------------------------------------------------
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // Set the current sequence id for accepted events
-    mFlinger.mutableComposerSequenceId() = currentSequenceId;
-
-    // Set the main thread id so that the current thread does appear to be the
-    // main thread.
-    mFlinger.mutableMainThreadId() = std::this_thread::get_id();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // We expect invalidate() to be invoked once to trigger display transaction
-    // processing.
-    EXPECT_CALL(*mMessageQueue, invalidate()).Times(1);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    // Simulate a disconnect on a display id that is not connected. This should
-    // be enqueued by onHotplugReceived(), and dequeued by
-    // processDisplayHotplugEventsLocked(), but then ignored as invalid.
-    mFlinger.onHotplugReceived(currentSequenceId, displayId1, HWC2::Connection::Disconnected);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The display transaction needed flag should be set.
-    EXPECT_TRUE(hasTransactionFlagSet(eDisplayTransactionNeeded));
-
-    // There should be no event queued on return, as it should have been
-    // processed.
-    EXPECT_TRUE(mFlinger.mutablePendingHotplugEvents().empty());
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::createDisplay
- */
-
-TEST_F(DisplayTransactionTest, createDisplaySetsCurrentStateForNonsecureDisplay) {
-    const String8 name("virtual.test");
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // The call should notify the interceptor that a display was created.
-    EXPECT_CALL(*mSurfaceInterceptor, saveDisplayCreation(_)).Times(1);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    sp<IBinder> displayToken = mFlinger.createDisplay(name, false);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The display should have been added to the current state
-    ASSERT_TRUE(hasCurrentDisplayState(displayToken));
-    const auto& display = getCurrentDisplayState(displayToken);
-    EXPECT_EQ(DisplayDevice::DISPLAY_VIRTUAL, display.type);
-    EXPECT_EQ(false, display.isSecure);
-    EXPECT_EQ(name.string(), display.displayName);
-
-    // --------------------------------------------------------------------
-    // Cleanup conditions
-
-    // Destroying the display invalidates the display state.
-    EXPECT_CALL(*mMessageQueue, invalidate()).Times(1);
-}
-
-TEST_F(DisplayTransactionTest, createDisplaySetsCurrentStateForSecureDisplay) {
-    const String8 name("virtual.test");
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // The call should notify the interceptor that a display was created.
-    EXPECT_CALL(*mSurfaceInterceptor, saveDisplayCreation(_)).Times(1);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    sp<IBinder> displayToken = mFlinger.createDisplay(name, true);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The display should have been added to the current state
-    ASSERT_TRUE(hasCurrentDisplayState(displayToken));
-    const auto& display = getCurrentDisplayState(displayToken);
-    EXPECT_EQ(DisplayDevice::DISPLAY_VIRTUAL, display.type);
-    EXPECT_EQ(true, display.isSecure);
-    EXPECT_EQ(name.string(), display.displayName);
-
-    // --------------------------------------------------------------------
-    // Cleanup conditions
-
-    // Destroying the display invalidates the display state.
-    EXPECT_CALL(*mMessageQueue, invalidate()).Times(1);
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::destroyDisplay
- */
-
-TEST_F(DisplayTransactionTest, destroyDisplayClearsCurrentStateForDisplay) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A virtual display exists
-    auto existing = Case::Display::makeFakeExistingDisplayInjector(this);
-    existing.inject();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // The call should notify the interceptor that a display was created.
-    EXPECT_CALL(*mSurfaceInterceptor, saveDisplayDeletion(_)).Times(1);
-
-    // Destroying the display invalidates the display state.
-    EXPECT_CALL(*mMessageQueue, invalidate()).Times(1);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.destroyDisplay(existing.token());
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The display should have been removed from the current state
-    EXPECT_FALSE(hasCurrentDisplayState(existing.token()));
-
-    // Ths display should still exist in the drawing state
-    EXPECT_TRUE(hasDrawingDisplayState(existing.token()));
-
-    // The display transaction needed flasg should be set
-    EXPECT_TRUE(hasTransactionFlagSet(eDisplayTransactionNeeded));
-}
-
-TEST_F(DisplayTransactionTest, destroyDisplayHandlesUnknownDisplay) {
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    sp<BBinder> displayToken = new BBinder();
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.destroyDisplay(displayToken);
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::resetDisplayState
- */
-
-TEST_F(DisplayTransactionTest, resetDisplayStateClearsState) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // vsync is enabled and available
-    mFlinger.mutablePrimaryHWVsyncEnabled() = true;
-    mFlinger.mutableHWVsyncAvailable() = true;
-
-    // A display exists
-    auto existing = Case::Display::makeFakeExistingDisplayInjector(this);
-    existing.inject();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // The call disable vsyncs
-    EXPECT_CALL(*mEventControlThread, setVsyncEnabled(false)).Times(1);
-
-    // The call clears the current render engine surface
-    EXPECT_CALL(*mRenderEngine, resetCurrentSurface());
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.resetDisplayState();
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // vsyncs should be off and not available.
-    EXPECT_FALSE(mFlinger.mutablePrimaryHWVsyncEnabled());
-    EXPECT_FALSE(mFlinger.mutableHWVsyncAvailable());
-
-    // The display should have been removed from the display map.
-    EXPECT_FALSE(hasDisplayDevice(existing.token()));
-
-    // The display should still exist in the current state
-    EXPECT_TRUE(hasCurrentDisplayState(existing.token()));
-
-    // The display should have been removed from the drawing state
-    EXPECT_FALSE(hasDrawingDisplayState(existing.token()));
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::setupNewDisplayDeviceInternal
- */
-
-class SetupNewDisplayDeviceInternalTest : public DisplayTransactionTest {
-public:
-    template <typename T>
-    void setupNewDisplayDeviceInternalTest();
-};
-
-template <typename Case>
-void SetupNewDisplayDeviceInternalTest::setupNewDisplayDeviceInternalTest() {
-    const sp<BBinder> displayToken = new BBinder();
-    const sp<mock::DisplaySurface> displaySurface = new mock::DisplaySurface();
-    const sp<mock::GraphicBufferProducer> producer = new mock::GraphicBufferProducer();
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // Wide color displays support is configured appropriately
-    Case::WideColorSupport::injectConfigChange(this);
-
-    // The display is setup with the HWC.
-    Case::Display::injectHwcDisplay(this);
-
-    // SurfaceFlinger will use a test-controlled factory for native window
-    // surfaces.
-    injectFakeNativeWindowSurfaceFactory();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // Various native window calls will be made.
-    Case::Display::setupNativeWindowSurfaceCreationCallExpectations(this);
-    Case::Display::setupHwcGetActiveConfigCallExpectations(this);
-    Case::WideColorSupport::setupComposerCallExpectations(this);
-    Case::HdrSupport::setupComposerCallExpectations(this);
-    Case::PerFrameMetadataSupport::setupComposerCallExpectations(this);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    auto state = DisplayDeviceState(Case::Display::TYPE, static_cast<bool>(Case::Display::SECURE));
-    auto device = mFlinger.setupNewDisplayDeviceInternal(displayToken, Case::Display::TYPE, state,
-                                                         displaySurface, producer);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    ASSERT_TRUE(device != nullptr);
-    EXPECT_EQ(Case::Display::TYPE, device->getDisplayType());
-    EXPECT_EQ(static_cast<bool>(Case::Display::SECURE), device->isSecure());
-    EXPECT_EQ(Case::Display::WIDTH, device->getWidth());
-    EXPECT_EQ(Case::Display::HEIGHT, device->getHeight());
-    EXPECT_EQ(Case::WideColorSupport::WIDE_COLOR_SUPPORTED, device->hasWideColorGamut());
-    EXPECT_EQ(Case::HdrSupport::HDR10_SUPPORTED, device->hasHDR10Support());
-    EXPECT_EQ(Case::HdrSupport::HDR_HLG_SUPPORTED, device->hasHLGSupport());
-    EXPECT_EQ(Case::HdrSupport::HDR_DOLBY_VISION_SUPPORTED, device->hasDolbyVisionSupport());
-    // Note: This is not Case::Display::HWC_ACTIVE_CONFIG_ID as the ids are
-    // remapped, and the test only ever sets up one config. If there were an error
-    // looking up the remapped index, device->getActiveConfig() would be -1 instead.
-    EXPECT_EQ(0, device->getActiveConfig());
-    EXPECT_EQ(Case::PerFrameMetadataSupport::PER_FRAME_METADATA_KEYS,
-              device->getSupportedPerFrameMetadata());
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createSimplePrimaryDisplay) {
-    setupNewDisplayDeviceInternalTest<SimplePrimaryDisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createSimpleExternalDisplay) {
-    setupNewDisplayDeviceInternalTest<SimpleExternalDisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createNonHwcVirtualDisplay) {
-    setupNewDisplayDeviceInternalTest<NonHwcVirtualDisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createHwcVirtualDisplay) {
-    // We need to resize this so that the HWC thinks the virtual display
-    // is something it created.
-    mFlinger.mutableHwcDisplayData().resize(3);
-
-    setupNewDisplayDeviceInternalTest<HwcVirtualDisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createWideColorP3Display) {
-    setupNewDisplayDeviceInternalTest<WideColorP3ColorimetricDisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createHdr10Display) {
-    setupNewDisplayDeviceInternalTest<Hdr10DisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createHdrHlgDisplay) {
-    setupNewDisplayDeviceInternalTest<HdrHlgDisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createHdrDolbyVisionDisplay) {
-    setupNewDisplayDeviceInternalTest<HdrDolbyVisionDisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createHdrSmpte2086DisplayCase) {
-    setupNewDisplayDeviceInternalTest<HdrSmpte2086DisplayCase>();
-}
-
-TEST_F(SetupNewDisplayDeviceInternalTest, createHdrCta816_3_DisplayCase) {
-    setupNewDisplayDeviceInternalTest<HdrCta861_3_DisplayCase>();
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::handleTransactionLocked(eDisplayTransactionNeeded)
- */
-
-class HandleTransactionLockedTest : public DisplayTransactionTest {
-public:
-    template <typename Case>
-    void setupCommonPreconditions();
-
-    template <typename Case>
-    void setupCommonCallExpectationsForConnectProcessing();
-
-    template <typename Case>
-    void setupCommonCallExpectationsForDisconnectProcessing();
-
-    template <typename Case>
-    void processesHotplugConnectCommon();
-
-    template <typename Case>
-    void ignoresHotplugConnectCommon();
-
-    template <typename Case>
-    void processesHotplugDisconnectCommon();
-
-    template <typename Case>
-    void verifyDisplayIsConnected(const sp<IBinder>& displayToken);
-
-    template <typename Case>
-    void verifyPhysicalDisplayIsConnected();
-
-    void verifyDisplayIsNotConnected(const sp<IBinder>& displayToken);
-};
-
-template <typename Case>
-void HandleTransactionLockedTest::setupCommonPreconditions() {
-    // Wide color displays support is configured appropriately
-    Case::WideColorSupport::injectConfigChange(this);
-
-    // SurfaceFlinger will use a test-controlled factory for BufferQueues
-    injectFakeBufferQueueFactory();
-
-    // SurfaceFlinger will use a test-controlled factory for native window
-    // surfaces.
-    injectFakeNativeWindowSurfaceFactory();
-}
-
-template <typename Case>
-void HandleTransactionLockedTest::setupCommonCallExpectationsForConnectProcessing() {
-    Case::Display::setupHwcHotplugCallExpectations(this);
-
-    Case::Display::setupFramebufferConsumerBufferQueueCallExpectations(this);
-    Case::Display::setupFramebufferProducerBufferQueueCallExpectations(this);
-    Case::Display::setupNativeWindowSurfaceCreationCallExpectations(this);
-    Case::Display::setupHwcGetActiveConfigCallExpectations(this);
-
-    Case::WideColorSupport::setupComposerCallExpectations(this);
-    Case::HdrSupport::setupComposerCallExpectations(this);
-    Case::PerFrameMetadataSupport::setupComposerCallExpectations(this);
-
-    EXPECT_CALL(*mSurfaceInterceptor, saveDisplayCreation(_)).Times(1);
-    EXPECT_CALL(*mEventThread, onHotplugReceived(Case::Display::TYPE, true)).Times(1);
-}
-
-template <typename Case>
-void HandleTransactionLockedTest::setupCommonCallExpectationsForDisconnectProcessing() {
-    EXPECT_CALL(*mSurfaceInterceptor, saveDisplayDeletion(_)).Times(1);
-    EXPECT_CALL(*mEventThread, onHotplugReceived(Case::Display::TYPE, false)).Times(1);
-}
-
-template <typename Case>
-void HandleTransactionLockedTest::verifyDisplayIsConnected(const sp<IBinder>& displayToken) {
-    // The display device should have been set up in the list of displays.
-    ASSERT_TRUE(hasDisplayDevice(displayToken));
-    const auto& device = getDisplayDevice(displayToken);
-    EXPECT_EQ(static_cast<bool>(Case::Display::SECURE), device->isSecure());
-    EXPECT_EQ(Case::Display::TYPE == DisplayDevice::DISPLAY_PRIMARY, device->isPrimary());
-
-    // The display should have been set up in the current display state
-    ASSERT_TRUE(hasCurrentDisplayState(displayToken));
-    const auto& current = getCurrentDisplayState(displayToken);
-    EXPECT_EQ(Case::Display::TYPE, current.type);
-
-    // The display should have been set up in the drawing display state
-    ASSERT_TRUE(hasDrawingDisplayState(displayToken));
-    const auto& draw = getDrawingDisplayState(displayToken);
-    EXPECT_EQ(Case::Display::TYPE, draw.type);
-}
-
-template <typename Case>
-void HandleTransactionLockedTest::verifyPhysicalDisplayIsConnected() {
-    // HWComposer should have an entry for the display
-    EXPECT_TRUE(hasHwcDisplay(Case::Display::HWC_DISPLAY_ID));
-
-    // The display should be set up as a built-in display.
-    static_assert(0 <= Case::Display::TYPE &&
-                          Case::Display::TYPE < DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES,
-                  "Must use a valid physical display type index for the fixed-size array");
-    auto& displayToken = mFlinger.mutableBuiltinDisplays()[Case::Display::TYPE];
-    ASSERT_TRUE(displayToken != nullptr);
-
-    verifyDisplayIsConnected<Case>(displayToken);
-}
-
-void HandleTransactionLockedTest::verifyDisplayIsNotConnected(const sp<IBinder>& displayToken) {
-    EXPECT_FALSE(hasDisplayDevice(displayToken));
-    EXPECT_FALSE(hasCurrentDisplayState(displayToken));
-    EXPECT_FALSE(hasDrawingDisplayState(displayToken));
-}
-
-template <typename Case>
-void HandleTransactionLockedTest::processesHotplugConnectCommon() {
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    setupCommonPreconditions<Case>();
-
-    // A hotplug connect event is enqueued for a display
-    Case::Display::injectPendingHotplugEvent(this, HWC2::Connection::Connected);
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    EXPECT_CALL(*mComposer, isUsingVrComposer()).WillOnce(Return(false));
-
-    setupCommonCallExpectationsForConnectProcessing<Case>();
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    verifyPhysicalDisplayIsConnected<Case>();
-
-    // --------------------------------------------------------------------
-    // Cleanup conditions
-
-    EXPECT_CALL(*mComposer,
-                setVsyncEnabled(Case::Display::HWC_DISPLAY_ID, IComposerClient::Vsync::DISABLE))
-            .WillOnce(Return(Error::NONE));
-    EXPECT_CALL(*mConsumer, consumerDisconnect()).WillOnce(Return(NO_ERROR));
-}
-
-template <typename Case>
-void HandleTransactionLockedTest::ignoresHotplugConnectCommon() {
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    setupCommonPreconditions<Case>();
-
-    // A hotplug connect event is enqueued for a display
-    Case::Display::injectPendingHotplugEvent(this, HWC2::Connection::Connected);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // HWComposer should not have an entry for the display
-    EXPECT_FALSE(hasHwcDisplay(Case::Display::HWC_DISPLAY_ID));
-}
-
-template <typename Case>
-void HandleTransactionLockedTest::processesHotplugDisconnectCommon() {
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    setupCommonPreconditions<Case>();
-
-    // A hotplug disconnect event is enqueued for a display
-    Case::Display::injectPendingHotplugEvent(this, HWC2::Connection::Disconnected);
-
-    // The display is already completely set up.
-    Case::Display::injectHwcDisplay(this);
-    auto existing = Case::Display::makeFakeExistingDisplayInjector(this);
-    existing.inject();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    EXPECT_CALL(*mComposer, isUsingVrComposer()).WillRepeatedly(Return(false));
-
-    setupCommonCallExpectationsForDisconnectProcessing<Case>();
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // HWComposer should not have an entry for the display
-    EXPECT_FALSE(hasHwcDisplay(Case::Display::HWC_DISPLAY_ID));
-
-    // The display should not be set up as a built-in display.
-    ASSERT_TRUE(0 <= Case::Display::TYPE &&
-                Case::Display::TYPE < DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES);
-    auto displayToken = mFlinger.mutableBuiltinDisplays()[Case::Display::TYPE];
-    EXPECT_TRUE(displayToken == nullptr);
-
-    // The existing token should have been removed
-    verifyDisplayIsNotConnected(existing.token());
-}
-
-TEST_F(HandleTransactionLockedTest, processesHotplugConnectPrimaryDisplay) {
-    processesHotplugConnectCommon<SimplePrimaryDisplayCase>();
-}
-
-TEST_F(HandleTransactionLockedTest,
-       processesHotplugConnectPrimaryDisplayWithExternalAlreadyConnected) {
-    // Inject an external display.
-    ExternalDisplayVariant::injectHwcDisplay(this);
-
-    processesHotplugConnectCommon<SimplePrimaryDisplayCase>();
-}
-
-TEST_F(HandleTransactionLockedTest, processesHotplugConnectExternalDisplay) {
-    // Inject a primary display.
-    PrimaryDisplayVariant::injectHwcDisplay(this);
-
-    processesHotplugConnectCommon<SimpleExternalDisplayCase>();
-}
-
-TEST_F(HandleTransactionLockedTest, ignoresHotplugConnectIfPrimaryAndExternalAlreadyConnected) {
-    // Inject both a primary and external display.
-    PrimaryDisplayVariant::injectHwcDisplay(this);
-    ExternalDisplayVariant::injectHwcDisplay(this);
-
-    EXPECT_CALL(*mComposer, isUsingVrComposer()).WillRepeatedly(Return(false));
-
-    ignoresHotplugConnectCommon<SimpleTertiaryDisplayCase>();
-}
-
-TEST_F(HandleTransactionLockedTest, ignoresHotplugConnectIfExternalForVrComposer) {
-    // Inject a primary display.
-    PrimaryDisplayVariant::injectHwcDisplay(this);
-
-    EXPECT_CALL(*mComposer, isUsingVrComposer()).WillRepeatedly(Return(true));
-
-    ignoresHotplugConnectCommon<SimpleExternalDisplayCase>();
-}
-
-TEST_F(HandleTransactionLockedTest, processHotplugDisconnectPrimaryDisplay) {
-    processesHotplugDisconnectCommon<SimplePrimaryDisplayCase>();
-}
-
-TEST_F(HandleTransactionLockedTest, processHotplugDisconnectExternalDisplay) {
-    processesHotplugDisconnectCommon<SimpleExternalDisplayCase>();
-}
-
-TEST_F(HandleTransactionLockedTest, processesHotplugConnectThenDisconnectPrimary) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    setupCommonPreconditions<Case>();
-
-    // A hotplug connect event is enqueued for a display
-    Case::Display::injectPendingHotplugEvent(this, HWC2::Connection::Connected);
-    // A hotplug disconnect event is also enqueued for the same display
-    Case::Display::injectPendingHotplugEvent(this, HWC2::Connection::Disconnected);
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    EXPECT_CALL(*mComposer, isUsingVrComposer()).WillRepeatedly(Return(false));
-
-    setupCommonCallExpectationsForConnectProcessing<Case>();
-    setupCommonCallExpectationsForDisconnectProcessing<Case>();
-
-    EXPECT_CALL(*mComposer,
-                setVsyncEnabled(Case::Display::HWC_DISPLAY_ID, IComposerClient::Vsync::DISABLE))
-            .WillOnce(Return(Error::NONE));
-    EXPECT_CALL(*mConsumer, consumerDisconnect()).WillOnce(Return(NO_ERROR));
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // HWComposer should not have an entry for the display
-    EXPECT_FALSE(hasHwcDisplay(Case::Display::HWC_DISPLAY_ID));
-
-    // The display should not be set up as a primary built-in display.
-    ASSERT_TRUE(0 <= Case::Display::TYPE &&
-                Case::Display::TYPE < DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES);
-    auto displayToken = mFlinger.mutableBuiltinDisplays()[Case::Display::TYPE];
-    EXPECT_TRUE(displayToken == nullptr);
-}
-
-TEST_F(HandleTransactionLockedTest, processesHotplugDisconnectThenConnectPrimary) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    setupCommonPreconditions<Case>();
-
-    // The display is already completely set up.
-    Case::Display::injectHwcDisplay(this);
-    auto existing = Case::Display::makeFakeExistingDisplayInjector(this);
-    existing.inject();
-
-    // A hotplug disconnect event is enqueued for a display
-    Case::Display::injectPendingHotplugEvent(this, HWC2::Connection::Disconnected);
-    // A hotplug connect event is also enqueued for the same display
-    Case::Display::injectPendingHotplugEvent(this, HWC2::Connection::Connected);
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    EXPECT_CALL(*mComposer, isUsingVrComposer()).WillRepeatedly(Return(false));
-
-    setupCommonCallExpectationsForConnectProcessing<Case>();
-    setupCommonCallExpectationsForDisconnectProcessing<Case>();
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The existing token should have been removed
-    verifyDisplayIsNotConnected(existing.token());
-    static_assert(0 <= Case::Display::TYPE &&
-                          Case::Display::TYPE < DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES,
-                  "Display type must be a built-in display");
-    EXPECT_NE(existing.token(), mFlinger.mutableBuiltinDisplays()[Case::Display::TYPE]);
-
-    // A new display should be connected in its place
-
-    verifyPhysicalDisplayIsConnected<Case>();
-
-    // --------------------------------------------------------------------
-    // Cleanup conditions
-
-    EXPECT_CALL(*mComposer,
-                setVsyncEnabled(Case::Display::HWC_DISPLAY_ID, IComposerClient::Vsync::DISABLE))
-            .WillOnce(Return(Error::NONE));
-    EXPECT_CALL(*mConsumer, consumerDisconnect()).WillOnce(Return(NO_ERROR));
-}
-
-TEST_F(HandleTransactionLockedTest, processesVirtualDisplayAdded) {
-    using Case = HwcVirtualDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // The HWC supports at least one virtual display
-    injectMockComposer(1);
-
-    setupCommonPreconditions<Case>();
-
-    // A virtual display was added to the current state, and it has a
-    // surface(producer)
-    sp<BBinder> displayToken = new BBinder();
-    DisplayDeviceState info(Case::Display::TYPE, static_cast<bool>(Case::Display::SECURE));
-    sp<mock::GraphicBufferProducer> surface{new mock::GraphicBufferProducer()};
-    info.surface = surface;
-    mFlinger.mutableCurrentState().displays.add(displayToken, info);
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    Case::Display::setupFramebufferConsumerBufferQueueCallExpectations(this);
-    Case::Display::setupNativeWindowSurfaceCreationCallExpectations(this);
-
-    EXPECT_CALL(*surface, query(NATIVE_WINDOW_WIDTH, _))
-            .WillRepeatedly(DoAll(SetArgPointee<1>(Case::Display::WIDTH), Return(NO_ERROR)));
-    EXPECT_CALL(*surface, query(NATIVE_WINDOW_HEIGHT, _))
-            .WillRepeatedly(DoAll(SetArgPointee<1>(Case::Display::HEIGHT), Return(NO_ERROR)));
-    EXPECT_CALL(*surface, query(NATIVE_WINDOW_FORMAT, _))
-            .WillRepeatedly(DoAll(SetArgPointee<1>(DEFAULT_VIRTUAL_DISPLAY_SURFACE_FORMAT),
-                                  Return(NO_ERROR)));
-    EXPECT_CALL(*surface, query(NATIVE_WINDOW_CONSUMER_USAGE_BITS, _))
-            .WillRepeatedly(DoAll(SetArgPointee<1>(0), Return(NO_ERROR)));
-
-    EXPECT_CALL(*surface, setAsyncMode(true)).Times(1);
-
-    EXPECT_CALL(*mProducer, connect(_, _, _, _)).Times(1);
-    EXPECT_CALL(*mProducer, disconnect(_, _)).Times(1);
-
-    Case::Display::setupHwcVirtualDisplayCreationCallExpectations(this);
-    Case::WideColorSupport::setupComposerCallExpectations(this);
-    Case::HdrSupport::setupComposerCallExpectations(this);
-    Case::PerFrameMetadataSupport::setupComposerCallExpectations(this);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The display device should have been set up in the list of displays.
-    verifyDisplayIsConnected<Case>(displayToken);
-
-    // --------------------------------------------------------------------
-    // Cleanup conditions
-
-    EXPECT_CALL(*mComposer, destroyVirtualDisplay(Case::Display::HWC_DISPLAY_ID))
-            .WillOnce(Return(Error::NONE));
-    EXPECT_CALL(*mConsumer, consumerDisconnect()).WillOnce(Return(NO_ERROR));
-}
-
-TEST_F(HandleTransactionLockedTest, processesVirtualDisplayAddedWithNoSurface) {
-    using Case = HwcVirtualDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // The HWC supports at least one virtual display
-    injectMockComposer(1);
-
-    setupCommonPreconditions<Case>();
-
-    // A virtual display was added to the current state, but it does not have a
-    // surface.
-    sp<BBinder> displayToken = new BBinder();
-    DisplayDeviceState info(Case::Display::TYPE, static_cast<bool>(Case::Display::SECURE));
-    mFlinger.mutableCurrentState().displays.add(displayToken, info);
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // There will not be a display device set up.
-    EXPECT_FALSE(hasDisplayDevice(displayToken));
-
-    // The drawing display state will be set from the current display state.
-    ASSERT_TRUE(hasDrawingDisplayState(displayToken));
-    const auto& draw = getDrawingDisplayState(displayToken);
-    EXPECT_EQ(Case::Display::TYPE, draw.type);
-}
-
-TEST_F(HandleTransactionLockedTest, processesVirtualDisplayRemoval) {
-    using Case = HwcVirtualDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A virtual display is set up but is removed from the current state.
-    mFlinger.mutableHwcDisplayData().resize(3);
-    Case::Display::injectHwcDisplay(this);
-    auto existing = Case::Display::makeFakeExistingDisplayInjector(this);
-    existing.inject();
-    mFlinger.mutableCurrentState().displays.removeItem(existing.token());
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    EXPECT_CALL(*mComposer, isUsingVrComposer()).WillRepeatedly(Return(false));
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The existing token should have been removed
-    verifyDisplayIsNotConnected(existing.token());
-}
-
-TEST_F(HandleTransactionLockedTest, processesDisplayLayerStackChanges) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    constexpr uint32_t oldLayerStack = 0u;
-    constexpr uint32_t newLayerStack = 123u;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // There is a change to the layerStack state
-    display.mutableDrawingDisplayState().layerStack = oldLayerStack;
-    display.mutableCurrentDisplayState().layerStack = newLayerStack;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    EXPECT_EQ(newLayerStack, display.mutableDisplayDevice()->getLayerStack());
-}
-
-TEST_F(HandleTransactionLockedTest, processesDisplayTransformChanges) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    constexpr int oldTransform = 0;
-    constexpr int newTransform = 2;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // There is a change to the orientation state
-    display.mutableDrawingDisplayState().orientation = oldTransform;
-    display.mutableCurrentDisplayState().orientation = newTransform;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    EXPECT_EQ(newTransform, display.mutableDisplayDevice()->getOrientation());
-}
-
-TEST_F(HandleTransactionLockedTest, processesDisplayViewportChanges) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    const Rect oldViewport(0, 0, 0, 0);
-    const Rect newViewport(0, 0, 123, 456);
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // There is a change to the viewport state
-    display.mutableDrawingDisplayState().viewport = oldViewport;
-    display.mutableCurrentDisplayState().viewport = newViewport;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    EXPECT_EQ(newViewport, display.mutableDisplayDevice()->getViewport());
-}
-
-TEST_F(HandleTransactionLockedTest, processesDisplayFrameChanges) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    const Rect oldFrame(0, 0, 0, 0);
-    const Rect newFrame(0, 0, 123, 456);
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // There is a change to the viewport state
-    display.mutableDrawingDisplayState().frame = oldFrame;
-    display.mutableCurrentDisplayState().frame = newFrame;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    EXPECT_EQ(newFrame, display.mutableDisplayDevice()->getFrame());
-}
-
-TEST_F(HandleTransactionLockedTest, processesDisplayWidthChanges) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    constexpr int oldWidth = 0;
-    constexpr int oldHeight = 10;
-    constexpr int newWidth = 123;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto nativeWindow = new mock::NativeWindow();
-    auto displaySurface = new mock::DisplaySurface();
-    auto renderSurface = new RE::mock::Surface();
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.setNativeWindow(nativeWindow);
-    display.setDisplaySurface(displaySurface);
-    display.setRenderSurface(std::unique_ptr<RE::Surface>(renderSurface));
-    display.inject();
-
-    // There is a change to the viewport state
-    display.mutableDrawingDisplayState().width = oldWidth;
-    display.mutableDrawingDisplayState().height = oldHeight;
-    display.mutableCurrentDisplayState().width = newWidth;
-    display.mutableCurrentDisplayState().height = oldHeight;
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    EXPECT_CALL(*renderSurface, setNativeWindow(nullptr)).Times(1);
-    EXPECT_CALL(*displaySurface, resizeBuffers(newWidth, oldHeight)).Times(1);
-    EXPECT_CALL(*renderSurface, setNativeWindow(nativeWindow)).Times(1);
-    EXPECT_CALL(*renderSurface, queryWidth()).WillOnce(Return(newWidth));
-    EXPECT_CALL(*renderSurface, queryHeight()).WillOnce(Return(oldHeight));
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-}
-
-TEST_F(HandleTransactionLockedTest, processesDisplayHeightChanges) {
-    using Case = NonHwcVirtualDisplayCase;
-
-    constexpr int oldWidth = 0;
-    constexpr int oldHeight = 10;
-    constexpr int newHeight = 123;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto nativeWindow = new mock::NativeWindow();
-    auto displaySurface = new mock::DisplaySurface();
-    auto renderSurface = new RE::mock::Surface();
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.setNativeWindow(nativeWindow);
-    display.setDisplaySurface(displaySurface);
-    display.setRenderSurface(std::unique_ptr<RE::Surface>(renderSurface));
-    display.inject();
-
-    // There is a change to the viewport state
-    display.mutableDrawingDisplayState().width = oldWidth;
-    display.mutableDrawingDisplayState().height = oldHeight;
-    display.mutableCurrentDisplayState().width = oldWidth;
-    display.mutableCurrentDisplayState().height = newHeight;
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    EXPECT_CALL(*renderSurface, setNativeWindow(nullptr)).Times(1);
-    EXPECT_CALL(*displaySurface, resizeBuffers(oldWidth, newHeight)).Times(1);
-    EXPECT_CALL(*renderSurface, setNativeWindow(nativeWindow)).Times(1);
-    EXPECT_CALL(*renderSurface, queryWidth()).WillOnce(Return(oldWidth));
-    EXPECT_CALL(*renderSurface, queryHeight()).WillOnce(Return(newHeight));
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.handleTransactionLocked(eDisplayTransactionNeeded);
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::setDisplayStateLocked
- */
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedDoesNothingWithUnknownDisplay) {
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // We have an unknown display token not associated with a known display
-    sp<BBinder> displayToken = new BBinder();
-
-    // The requested display state references the unknown display.
-    DisplayState state;
-    state.what = DisplayState::eLayerStackChanged;
-    state.token = displayToken;
-    state.layerStack = 456;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags are empty
-    EXPECT_EQ(0u, flags);
-
-    // The display token still doesn't match anything known.
-    EXPECT_FALSE(hasCurrentDisplayState(displayToken));
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedDoesNothingWithInvalidDisplay) {
-    using Case = InvalidDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // An invalid display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The invalid display has some state
-    display.mutableCurrentDisplayState().layerStack = 654u;
-
-    // The requested display state tries to change the display state.
-    DisplayState state;
-    state.what = DisplayState::eLayerStackChanged;
-    state.token = display.token();
-    state.layerStack = 456;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags are empty
-    EXPECT_EQ(0u, flags);
-
-    // The current display layer stack value is unchanged.
-    EXPECT_EQ(654u, getCurrentDisplayState(display.token()).layerStack);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedDoesNothingWhenNoChanges) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is already set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // No changes are made to the display
-    DisplayState state;
-    state.what = 0;
-    state.token = display.token();
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags are empty
-    EXPECT_EQ(0u, flags);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedDoesNothingIfSurfaceDidNotChange) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is already set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // There is a surface that can be set.
-    sp<mock::GraphicBufferProducer> surface = new mock::GraphicBufferProducer();
-
-    // The current display state has the surface set
-    display.mutableCurrentDisplayState().surface = surface;
-
-    // The incoming request sets the same surface
-    DisplayState state;
-    state.what = DisplayState::eSurfaceChanged;
-    state.token = display.token();
-    state.surface = surface;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags are empty
-    EXPECT_EQ(0u, flags);
-
-    // The current display state is unchanged.
-    EXPECT_EQ(surface.get(), display.getCurrentDisplayState().surface.get());
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedRequestsUpdateIfSurfaceChanged) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is already set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // There is a surface that can be set.
-    sp<mock::GraphicBufferProducer> surface = new mock::GraphicBufferProducer();
-
-    // The current display state does not have a surface
-    display.mutableCurrentDisplayState().surface = nullptr;
-
-    // The incoming request sets a surface
-    DisplayState state;
-    state.what = DisplayState::eSurfaceChanged;
-    state.token = display.token();
-    state.surface = surface;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags indicate a transaction is needed
-    EXPECT_EQ(eDisplayTransactionNeeded, flags);
-
-    // The current display layer stack state is set to the new value
-    EXPECT_EQ(surface.get(), display.getCurrentDisplayState().surface.get());
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedDoesNothingIfLayerStackDidNotChange) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is already set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The display has a layer stack set
-    display.mutableCurrentDisplayState().layerStack = 456u;
-
-    // The incoming request sets the same layer stack
-    DisplayState state;
-    state.what = DisplayState::eLayerStackChanged;
-    state.token = display.token();
-    state.layerStack = 456u;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags are empty
-    EXPECT_EQ(0u, flags);
-
-    // The current display state is unchanged
-    EXPECT_EQ(456u, display.getCurrentDisplayState().layerStack);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedRequestsUpdateIfLayerStackChanged) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The display has a layer stack set
-    display.mutableCurrentDisplayState().layerStack = 654u;
-
-    // The incoming request sets a different layer stack
-    DisplayState state;
-    state.what = DisplayState::eLayerStackChanged;
-    state.token = display.token();
-    state.layerStack = 456u;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags indicate a transaction is needed
-    EXPECT_EQ(eDisplayTransactionNeeded, flags);
-
-    // The desired display state has been set to the new value.
-    EXPECT_EQ(456u, display.getCurrentDisplayState().layerStack);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedDoesNothingIfProjectionDidNotChange) {
-    using Case = SimplePrimaryDisplayCase;
-    constexpr int initialOrientation = 180;
-    const Rect initialFrame = {1, 2, 3, 4};
-    const Rect initialViewport = {5, 6, 7, 8};
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The current display state projection state is all set
-    display.mutableCurrentDisplayState().orientation = initialOrientation;
-    display.mutableCurrentDisplayState().frame = initialFrame;
-    display.mutableCurrentDisplayState().viewport = initialViewport;
-
-    // The incoming request sets the same projection state
-    DisplayState state;
-    state.what = DisplayState::eDisplayProjectionChanged;
-    state.token = display.token();
-    state.orientation = initialOrientation;
-    state.frame = initialFrame;
-    state.viewport = initialViewport;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags are empty
-    EXPECT_EQ(0u, flags);
-
-    // The current display state is unchanged
-    EXPECT_EQ(initialOrientation, display.getCurrentDisplayState().orientation);
-
-    EXPECT_EQ(initialFrame, display.getCurrentDisplayState().frame);
-    EXPECT_EQ(initialViewport, display.getCurrentDisplayState().viewport);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedRequestsUpdateIfOrientationChanged) {
-    using Case = SimplePrimaryDisplayCase;
-    constexpr int initialOrientation = 90;
-    constexpr int desiredOrientation = 180;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The current display state has an orientation set
-    display.mutableCurrentDisplayState().orientation = initialOrientation;
-
-    // The incoming request sets a different orientation
-    DisplayState state;
-    state.what = DisplayState::eDisplayProjectionChanged;
-    state.token = display.token();
-    state.orientation = desiredOrientation;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags indicate a transaction is needed
-    EXPECT_EQ(eDisplayTransactionNeeded, flags);
-
-    // The current display state has the new value.
-    EXPECT_EQ(desiredOrientation, display.getCurrentDisplayState().orientation);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedRequestsUpdateIfFrameChanged) {
-    using Case = SimplePrimaryDisplayCase;
-    const Rect initialFrame = {0, 0, 0, 0};
-    const Rect desiredFrame = {5, 6, 7, 8};
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The current display state does not have a frame
-    display.mutableCurrentDisplayState().frame = initialFrame;
-
-    // The incoming request sets a frame
-    DisplayState state;
-    state.what = DisplayState::eDisplayProjectionChanged;
-    state.token = display.token();
-    state.frame = desiredFrame;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags indicate a transaction is needed
-    EXPECT_EQ(eDisplayTransactionNeeded, flags);
-
-    // The current display state has the new value.
-    EXPECT_EQ(desiredFrame, display.getCurrentDisplayState().frame);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedRequestsUpdateIfViewportChanged) {
-    using Case = SimplePrimaryDisplayCase;
-    const Rect initialViewport = {0, 0, 0, 0};
-    const Rect desiredViewport = {5, 6, 7, 8};
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The current display state does not have a viewport
-    display.mutableCurrentDisplayState().viewport = initialViewport;
-
-    // The incoming request sets a viewport
-    DisplayState state;
-    state.what = DisplayState::eDisplayProjectionChanged;
-    state.token = display.token();
-    state.viewport = desiredViewport;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags indicate a transaction is needed
-    EXPECT_EQ(eDisplayTransactionNeeded, flags);
-
-    // The current display state has the new value.
-    EXPECT_EQ(desiredViewport, display.getCurrentDisplayState().viewport);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedDoesNothingIfSizeDidNotChange) {
-    using Case = SimplePrimaryDisplayCase;
-    constexpr uint32_t initialWidth = 1024;
-    constexpr uint32_t initialHeight = 768;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The current display state has a size set
-    display.mutableCurrentDisplayState().width = initialWidth;
-    display.mutableCurrentDisplayState().height = initialHeight;
-
-    // The incoming request sets the same display size
-    DisplayState state;
-    state.what = DisplayState::eDisplaySizeChanged;
-    state.token = display.token();
-    state.width = initialWidth;
-    state.height = initialHeight;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags are empty
-    EXPECT_EQ(0u, flags);
-
-    // The current display state is unchanged
-    EXPECT_EQ(initialWidth, display.getCurrentDisplayState().width);
-    EXPECT_EQ(initialHeight, display.getCurrentDisplayState().height);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedRequestsUpdateIfWidthChanged) {
-    using Case = SimplePrimaryDisplayCase;
-    constexpr uint32_t initialWidth = 0;
-    constexpr uint32_t desiredWidth = 1024;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The display does not yet have a width
-    display.mutableCurrentDisplayState().width = initialWidth;
-
-    // The incoming request sets a display width
-    DisplayState state;
-    state.what = DisplayState::eDisplaySizeChanged;
-    state.token = display.token();
-    state.width = desiredWidth;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags indicate a transaction is needed
-    EXPECT_EQ(eDisplayTransactionNeeded, flags);
-
-    // The current display state has the new value.
-    EXPECT_EQ(desiredWidth, display.getCurrentDisplayState().width);
-}
-
-TEST_F(DisplayTransactionTest, setDisplayStateLockedRequestsUpdateIfHeightChanged) {
-    using Case = SimplePrimaryDisplayCase;
-    constexpr uint32_t initialHeight = 0;
-    constexpr uint32_t desiredHeight = 768;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A display is set up
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The display does not yet have a height
-    display.mutableCurrentDisplayState().height = initialHeight;
-
-    // The incoming request sets a display height
-    DisplayState state;
-    state.what = DisplayState::eDisplaySizeChanged;
-    state.token = display.token();
-    state.height = desiredHeight;
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    uint32_t flags = mFlinger.setDisplayStateLocked(state);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The returned flags indicate a transaction is needed
-    EXPECT_EQ(eDisplayTransactionNeeded, flags);
-
-    // The current display state has the new value.
-    EXPECT_EQ(desiredHeight, display.getCurrentDisplayState().height);
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::onInitializeDisplays
- */
-
-TEST_F(DisplayTransactionTest, onInitializeDisplaysSetsUpPrimaryDisplay) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A primary display is set up
-    Case::Display::injectHwcDisplay(this);
-    auto primaryDisplay = Case::Display::makeFakeExistingDisplayInjector(this);
-    primaryDisplay.inject();
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    // We expect the surface interceptor to possibly be used, but we treat it as
-    // disabled since it is called as a side effect rather than directly by this
-    // function.
-    EXPECT_CALL(*mSurfaceInterceptor, isEnabled()).WillOnce(Return(false));
-
-    // We expect a call to get the active display config.
-    Case::Display::setupHwcGetActiveConfigCallExpectations(this);
-
-    // We expect invalidate() to be invoked once to trigger display transaction
-    // processing.
-    EXPECT_CALL(*mMessageQueue, invalidate()).Times(1);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.onInitializeDisplays();
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    // The primary display should have a current state
-    ASSERT_TRUE(hasCurrentDisplayState(primaryDisplay.token()));
-    const auto& primaryDisplayState = getCurrentDisplayState(primaryDisplay.token());
-    // The layer stack state should be set to zero
-    EXPECT_EQ(0u, primaryDisplayState.layerStack);
-    // The orientation state should be set to zero
-    EXPECT_EQ(0, primaryDisplayState.orientation);
-
-    // The frame state should be set to INVALID
-    EXPECT_EQ(Rect::INVALID_RECT, primaryDisplayState.frame);
-
-    // The viewport state should be set to INVALID
-    EXPECT_EQ(Rect::INVALID_RECT, primaryDisplayState.viewport);
-
-    // The width and height should both be zero
-    EXPECT_EQ(0u, primaryDisplayState.width);
-    EXPECT_EQ(0u, primaryDisplayState.height);
-
-    // The display should be set to HWC_POWER_MODE_NORMAL
-    ASSERT_TRUE(hasDisplayDevice(primaryDisplay.token()));
-    auto displayDevice = primaryDisplay.mutableDisplayDevice();
-    EXPECT_EQ(HWC_POWER_MODE_NORMAL, displayDevice->getPowerMode());
-
-    // The display refresh period should be set in the frame tracker.
-    FrameStats stats;
-    mFlinger.getAnimFrameTracker().getStats(&stats);
-    EXPECT_EQ(DEFAULT_REFRESH_RATE, stats.refreshPeriodNano);
-
-    // The display transaction needed flag should be set.
-    EXPECT_TRUE(hasTransactionFlagSet(eDisplayTransactionNeeded));
-
-    // The compositor timing should be set to default values
-    const auto& compositorTiming = mFlinger.getCompositorTiming();
-    EXPECT_EQ(-DEFAULT_REFRESH_RATE, compositorTiming.deadline);
-    EXPECT_EQ(DEFAULT_REFRESH_RATE, compositorTiming.interval);
-    EXPECT_EQ(DEFAULT_REFRESH_RATE, compositorTiming.presentLatency);
-}
-
-/* ------------------------------------------------------------------------
- * SurfaceFlinger::setPowerModeInternal
- */
-
-// Used when we simulate a display that supports doze.
-struct DozeIsSupportedVariant {
-    static constexpr bool DOZE_SUPPORTED = true;
-    static constexpr IComposerClient::PowerMode ACTUAL_POWER_MODE_FOR_DOZE =
-            IComposerClient::PowerMode::DOZE;
-    static constexpr IComposerClient::PowerMode ACTUAL_POWER_MODE_FOR_DOZE_SUSPEND =
-            IComposerClient::PowerMode::DOZE_SUSPEND;
-};
-
-// Used when we simulate a display that does not support doze.
-struct DozeNotSupportedVariant {
-    static constexpr bool DOZE_SUPPORTED = false;
-    static constexpr IComposerClient::PowerMode ACTUAL_POWER_MODE_FOR_DOZE =
-            IComposerClient::PowerMode::ON;
-    static constexpr IComposerClient::PowerMode ACTUAL_POWER_MODE_FOR_DOZE_SUSPEND =
-            IComposerClient::PowerMode::ON;
-};
-
-struct EventThreadBaseSupportedVariant {
-    static void setupEventAndEventControlThreadNoCallExpectations(DisplayTransactionTest* test) {
-        // The event control thread should not be notified.
-        EXPECT_CALL(*test->mEventControlThread, setVsyncEnabled(_)).Times(0);
-
-        // The event thread should not be notified.
-        EXPECT_CALL(*test->mEventThread, onScreenReleased()).Times(0);
-        EXPECT_CALL(*test->mEventThread, onScreenAcquired()).Times(0);
-    }
-};
-
-struct EventThreadNotSupportedVariant : public EventThreadBaseSupportedVariant {
-    static void setupAcquireAndEnableVsyncCallExpectations(DisplayTransactionTest* test) {
-        // These calls are only expected for the primary display.
-
-        // Instead expect no calls.
-        setupEventAndEventControlThreadNoCallExpectations(test);
-    }
-
-    static void setupReleaseAndDisableVsyncCallExpectations(DisplayTransactionTest* test) {
-        // These calls are only expected for the primary display.
-
-        // Instead expect no calls.
-        setupEventAndEventControlThreadNoCallExpectations(test);
-    }
-};
-
-struct EventThreadIsSupportedVariant : public EventThreadBaseSupportedVariant {
-    static void setupAcquireAndEnableVsyncCallExpectations(DisplayTransactionTest* test) {
-        // The event control thread should be notified to enable vsyncs
-        EXPECT_CALL(*test->mEventControlThread, setVsyncEnabled(true)).Times(1);
-
-        // The event thread should be notified that the screen was acquired.
-        EXPECT_CALL(*test->mEventThread, onScreenAcquired()).Times(1);
-    }
-
-    static void setupReleaseAndDisableVsyncCallExpectations(DisplayTransactionTest* test) {
-        // There should be a call to setVsyncEnabled(false)
-        EXPECT_CALL(*test->mEventControlThread, setVsyncEnabled(false)).Times(1);
-
-        // The event thread should not be notified that the screen was released.
-        EXPECT_CALL(*test->mEventThread, onScreenReleased()).Times(1);
-    }
-};
-
-// --------------------------------------------------------------------
-// Note:
-//
-// There are a large number of transitions we could test, however we only test a
-// selected subset which provides complete test coverage of the implementation.
-// --------------------------------------------------------------------
-
-template <int initialPowerMode, int targetPowerMode>
-struct TransitionVariantCommon {
-    static constexpr auto INITIAL_POWER_MODE = initialPowerMode;
-    static constexpr auto TARGET_POWER_MODE = targetPowerMode;
-
-    static void verifyPostconditions(DisplayTransactionTest*) {}
-};
-
-struct TransitionOffToOnVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_OFF, HWC_POWER_MODE_NORMAL> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::ON);
-        Case::EventThread::setupAcquireAndEnableVsyncCallExpectations(test);
-        Case::setupRepaintEverythingCallExpectations(test);
-    }
-
-    static void verifyPostconditions(DisplayTransactionTest* test) {
-        EXPECT_TRUE(test->mFlinger.getVisibleRegionsDirty());
-        EXPECT_TRUE(test->mFlinger.getHasPoweredOff());
-    }
-};
-
-struct TransitionOffToDozeSuspendVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_OFF, HWC_POWER_MODE_DOZE_SUSPEND> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE_SUSPEND);
-        Case::EventThread::setupEventAndEventControlThreadNoCallExpectations(test);
-        Case::setupRepaintEverythingCallExpectations(test);
-    }
-
-    static void verifyPostconditions(DisplayTransactionTest* test) {
-        EXPECT_TRUE(test->mFlinger.getVisibleRegionsDirty());
-        EXPECT_TRUE(test->mFlinger.getHasPoweredOff());
-    }
-};
-
-struct TransitionOnToOffVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_NORMAL, HWC_POWER_MODE_OFF> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupReleaseAndDisableVsyncCallExpectations(test);
-        Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::OFF);
-    }
-
-    static void verifyPostconditions(DisplayTransactionTest* test) {
-        EXPECT_TRUE(test->mFlinger.getVisibleRegionsDirty());
-    }
-};
-
-struct TransitionDozeSuspendToOffVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_DOZE_SUSPEND, HWC_POWER_MODE_OFF> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupEventAndEventControlThreadNoCallExpectations(test);
-        Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::OFF);
-    }
-
-    static void verifyPostconditions(DisplayTransactionTest* test) {
-        EXPECT_TRUE(test->mFlinger.getVisibleRegionsDirty());
-    }
-};
-
-struct TransitionOnToDozeVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_NORMAL, HWC_POWER_MODE_DOZE> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupEventAndEventControlThreadNoCallExpectations(test);
-        Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE);
-    }
-};
-
-struct TransitionDozeSuspendToDozeVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_DOZE_SUSPEND, HWC_POWER_MODE_DOZE> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupAcquireAndEnableVsyncCallExpectations(test);
-        Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE);
-    }
-};
-
-struct TransitionDozeToOnVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_DOZE, HWC_POWER_MODE_NORMAL> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupEventAndEventControlThreadNoCallExpectations(test);
-        Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::ON);
-    }
-};
-
-struct TransitionDozeSuspendToOnVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_DOZE_SUSPEND, HWC_POWER_MODE_NORMAL> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupAcquireAndEnableVsyncCallExpectations(test);
-        Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::ON);
-    }
-};
-
-struct TransitionOnToDozeSuspendVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_NORMAL, HWC_POWER_MODE_DOZE_SUSPEND> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupReleaseAndDisableVsyncCallExpectations(test);
-        Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE_SUSPEND);
-    }
-};
-
-struct TransitionOnToUnknownVariant
-      : public TransitionVariantCommon<HWC_POWER_MODE_NORMAL, HWC_POWER_MODE_LEET> {
-    template <typename Case>
-    static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupEventAndEventControlThreadNoCallExpectations(test);
-        Case::setupNoComposerPowerModeCallExpectations(test);
-    }
-};
-
-// --------------------------------------------------------------------
-// Note:
-//
-// Rather than testing the cartesian product of of
-// DozeIsSupported/DozeNotSupported with all other options, we use one for one
-// display type, and the other for another display type.
-// --------------------------------------------------------------------
-
-template <typename DisplayVariant, typename DozeVariant, typename EventThreadVariant,
-          typename TransitionVariant>
-struct DisplayPowerCase {
-    using Display = DisplayVariant;
-    using Doze = DozeVariant;
-    using EventThread = EventThreadVariant;
-    using Transition = TransitionVariant;
-
-    static auto injectDisplayWithInitialPowerMode(DisplayTransactionTest* test, int mode) {
-        Display::injectHwcDisplay(test);
-        auto display = Display::makeFakeExistingDisplayInjector(test);
-        display.inject();
-        display.mutableDisplayDevice()->setPowerMode(mode);
-        return display;
-    }
-
-    static void setInitialPrimaryHWVsyncEnabled(DisplayTransactionTest* test, bool enabled) {
-        test->mFlinger.mutablePrimaryHWVsyncEnabled() = enabled;
-    }
-
-    static void setupRepaintEverythingCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mMessageQueue, invalidate()).Times(1);
-    }
-
-    static void setupSurfaceInterceptorCallExpectations(DisplayTransactionTest* test, int mode) {
-        EXPECT_CALL(*test->mSurfaceInterceptor, isEnabled()).WillOnce(Return(true));
-        EXPECT_CALL(*test->mSurfaceInterceptor, savePowerModeUpdate(_, mode)).Times(1);
-    }
-
-    static void setupComposerCallExpectations(DisplayTransactionTest* test,
-                                              IComposerClient::PowerMode mode) {
-        // Any calls to get the active config will return a default value.
-        EXPECT_CALL(*test->mComposer, getActiveConfig(Display::HWC_DISPLAY_ID, _))
-                .WillRepeatedly(DoAll(SetArgPointee<1>(Display::HWC_ACTIVE_CONFIG_ID),
-                                      Return(Error::NONE)));
-
-        // Any calls to get whether the display supports dozing will return the value set by the
-        // policy variant.
-        EXPECT_CALL(*test->mComposer, getDozeSupport(Display::HWC_DISPLAY_ID, _))
-                .WillRepeatedly(DoAll(SetArgPointee<1>(Doze::DOZE_SUPPORTED), Return(Error::NONE)));
-
-        EXPECT_CALL(*test->mComposer, setPowerMode(Display::HWC_DISPLAY_ID, mode)).Times(1);
-    }
-
-    static void setupNoComposerPowerModeCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(*test->mComposer, setPowerMode(Display::HWC_DISPLAY_ID, _)).Times(0);
-    }
-};
-
-// A sample configuration for the primary display.
-// In addition to having event thread support, we emulate doze support.
-template <typename TransitionVariant>
-using PrimaryDisplayPowerCase = DisplayPowerCase<PrimaryDisplayVariant, DozeIsSupportedVariant,
-                                                 EventThreadIsSupportedVariant, TransitionVariant>;
-
-// A sample configuration for the external display.
-// In addition to not having event thread support, we emulate not having doze
-// support.
-template <typename TransitionVariant>
-using ExternalDisplayPowerCase =
-        DisplayPowerCase<ExternalDisplayVariant, DozeNotSupportedVariant,
-                         EventThreadNotSupportedVariant, TransitionVariant>;
-
-class SetPowerModeInternalTest : public DisplayTransactionTest {
-public:
-    template <typename Case>
-    void transitionDisplayCommon();
-};
-
-template <int PowerMode>
-struct PowerModeInitialVSyncEnabled : public std::false_type {};
-
-template <>
-struct PowerModeInitialVSyncEnabled<HWC_POWER_MODE_NORMAL> : public std::true_type {};
-
-template <>
-struct PowerModeInitialVSyncEnabled<HWC_POWER_MODE_DOZE> : public std::true_type {};
-
-template <typename Case>
-void SetPowerModeInternalTest::transitionDisplayCommon() {
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    auto display =
-            Case::injectDisplayWithInitialPowerMode(this, Case::Transition::INITIAL_POWER_MODE);
-    Case::setInitialPrimaryHWVsyncEnabled(this,
-                                          PowerModeInitialVSyncEnabled<
-                                                  Case::Transition::INITIAL_POWER_MODE>::value);
-
-    // --------------------------------------------------------------------
-    // Call Expectations
-
-    Case::setupSurfaceInterceptorCallExpectations(this, Case::Transition::TARGET_POWER_MODE);
-    Case::Transition::template setupCallExpectations<Case>(this);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.setPowerModeInternal(display.mutableDisplayDevice(),
-                                  Case::Transition::TARGET_POWER_MODE);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    Case::Transition::verifyPostconditions(this);
-}
-
-TEST_F(SetPowerModeInternalTest, setPowerModeInternalDoesNothingIfNoChange) {
-    using Case = SimplePrimaryDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // A primary display device is set up
-    Case::Display::injectHwcDisplay(this);
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The diplay is already set to HWC_POWER_MODE_NORMAL
-    display.mutableDisplayDevice()->setPowerMode(HWC_POWER_MODE_NORMAL);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.setPowerModeInternal(display.mutableDisplayDevice(), HWC_POWER_MODE_NORMAL);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    EXPECT_EQ(HWC_POWER_MODE_NORMAL, display.mutableDisplayDevice()->getPowerMode());
-}
-
-TEST_F(SetPowerModeInternalTest, setPowerModeInternalJustSetsInternalStateIfVirtualDisplay) {
-    using Case = HwcVirtualDisplayCase;
-
-    // --------------------------------------------------------------------
-    // Preconditions
-
-    // We need to resize this so that the HWC thinks the virtual display
-    // is something it created.
-    mFlinger.mutableHwcDisplayData().resize(3);
-
-    // A virtual display device is set up
-    Case::Display::injectHwcDisplay(this);
-    auto display = Case::Display::makeFakeExistingDisplayInjector(this);
-    display.inject();
-
-    // The display is set to HWC_POWER_MODE_OFF
-    getDisplayDevice(display.token())->setPowerMode(HWC_POWER_MODE_OFF);
-
-    // --------------------------------------------------------------------
-    // Invocation
-
-    mFlinger.setPowerModeInternal(display.mutableDisplayDevice(), HWC_POWER_MODE_NORMAL);
-
-    // --------------------------------------------------------------------
-    // Postconditions
-
-    EXPECT_EQ(HWC_POWER_MODE_NORMAL, display.mutableDisplayDevice()->getPowerMode());
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOffToOnPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionOffToOnVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOffToDozeSuspendPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionOffToDozeSuspendVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToOffPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionOnToOffVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeSuspendToOffPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionDozeSuspendToOffVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToDozePrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionOnToDozeVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeSuspendToDozePrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionDozeSuspendToDozeVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeToOnPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionDozeToOnVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeSuspendToOnPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionDozeSuspendToOnVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToDozeSuspendPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionOnToDozeSuspendVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToUnknownPrimaryDisplay) {
-    transitionDisplayCommon<PrimaryDisplayPowerCase<TransitionOnToUnknownVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOffToOnExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionOffToOnVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOffToDozeSuspendExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionOffToDozeSuspendVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToOffExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionOnToOffVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeSuspendToOffExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionDozeSuspendToOffVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToDozeExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionOnToDozeVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeSuspendToDozeExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionDozeSuspendToDozeVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeToOnExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionDozeToOnVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromDozeSuspendToOnExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionDozeSuspendToOnVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToDozeSuspendExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionOnToDozeSuspendVariant>>();
-}
-
-TEST_F(SetPowerModeInternalTest, transitionsDisplayFromOnToUnknownExternalDisplay) {
-    transitionDisplayCommon<ExternalDisplayPowerCase<TransitionOnToUnknownVariant>>();
-}
-
-} // namespace
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/EventControlThreadTest.cpp b/services/surfaceflinger/tests/unittests/EventControlThreadTest.cpp
deleted file mode 100644
index b34645463..000000000
--- a/services/surfaceflinger/tests/unittests/EventControlThreadTest.cpp
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#undef LOG_TAG
-#define LOG_TAG "LibSurfaceFlingerUnittests"
-
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
-#include <log/log.h>
-
-#include "AsyncCallRecorder.h"
-#include "EventControlThread.h"
-
-namespace android {
-namespace {
-
-using namespace std::chrono_literals;
-using testing::_;
-
-class EventControlThreadTest : public testing::Test {
-protected:
-    EventControlThreadTest();
-    ~EventControlThreadTest() override;
-
-    void createThread();
-
-    void expectVSyncEnableCallbackCalled(bool enable);
-
-    AsyncCallRecorder<void (*)(bool)> mVSyncSetEnabledCallRecorder;
-
-    std::unique_ptr<EventControlThread> mThread;
-};
-
-EventControlThreadTest::EventControlThreadTest() {
-    const ::testing::TestInfo* const test_info =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGD("**** Setting up for %s.%s\n", test_info->test_case_name(), test_info->name());
-}
-
-EventControlThreadTest::~EventControlThreadTest() {
-    const ::testing::TestInfo* const test_info =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGD("**** Tearing down after %s.%s\n", test_info->test_case_name(), test_info->name());
-}
-
-void EventControlThreadTest::createThread() {
-    mThread = std::make_unique<android::impl::EventControlThread>(
-            mVSyncSetEnabledCallRecorder.getInvocable());
-}
-
-void EventControlThreadTest::expectVSyncEnableCallbackCalled(bool expectedEnabled) {
-    auto args = mVSyncSetEnabledCallRecorder.waitForCall();
-    ASSERT_TRUE(args.has_value());
-    EXPECT_EQ(std::get<0>(args.value()), expectedEnabled);
-}
-
-/* ------------------------------------------------------------------------
- * Test cases
- */
-
-TEST_F(EventControlThreadTest, signalsVSyncDisabledOnStartup) {
-    createThread();
-
-    // On thread start, there should be an automatic explicit call to disable
-    // vsyncs
-    expectVSyncEnableCallbackCalled(false);
-}
-
-TEST_F(EventControlThreadTest, signalsVSyncDisabledOnce) {
-    createThread();
-    expectVSyncEnableCallbackCalled(false);
-
-    mThread->setVsyncEnabled(false);
-
-    EXPECT_FALSE(mVSyncSetEnabledCallRecorder.waitForUnexpectedCall().has_value());
-}
-
-TEST_F(EventControlThreadTest, signalsVSyncEnabledThenDisabled) {
-    createThread();
-    expectVSyncEnableCallbackCalled(false);
-
-    mThread->setVsyncEnabled(true);
-
-    expectVSyncEnableCallbackCalled(true);
-
-    mThread->setVsyncEnabled(false);
-
-    expectVSyncEnableCallbackCalled(false);
-}
-
-TEST_F(EventControlThreadTest, signalsVSyncEnabledOnce) {
-    createThread();
-    expectVSyncEnableCallbackCalled(false);
-
-    mThread->setVsyncEnabled(true);
-
-    expectVSyncEnableCallbackCalled(true);
-
-    mThread->setVsyncEnabled(true);
-
-    EXPECT_FALSE(mVSyncSetEnabledCallRecorder.waitForUnexpectedCall().has_value());
-}
-
-} // namespace
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/EventThreadTest.cpp b/services/surfaceflinger/tests/unittests/EventThreadTest.cpp
deleted file mode 100644
index 80fdb8026..000000000
--- a/services/surfaceflinger/tests/unittests/EventThreadTest.cpp
+++ /dev/null
@@ -1,422 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#undef LOG_TAG
-#define LOG_TAG "LibSurfaceFlingerUnittests"
-
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
-#include <log/log.h>
-
-#include <utils/Errors.h>
-
-#include "AsyncCallRecorder.h"
-#include "EventThread.h"
-
-using namespace std::chrono_literals;
-using namespace std::placeholders;
-
-using testing::_;
-using testing::Invoke;
-
-namespace android {
-namespace {
-
-class MockVSyncSource : public VSyncSource {
-public:
-    MOCK_METHOD1(setVSyncEnabled, void(bool));
-    MOCK_METHOD1(setCallback, void(VSyncSource::Callback*));
-    MOCK_METHOD1(setPhaseOffset, void(nsecs_t));
-};
-
-} // namespace
-
-class EventThreadTest : public testing::Test {
-protected:
-    class MockEventThreadConnection : public android::impl::EventThread::Connection {
-    public:
-        explicit MockEventThreadConnection(android::impl::EventThread* eventThread)
-              : android::impl::EventThread::Connection(eventThread) {}
-        MOCK_METHOD1(postEvent, status_t(const DisplayEventReceiver::Event& event));
-    };
-
-    using ConnectionEventRecorder =
-            AsyncCallRecorderWithCannedReturn<status_t (*)(const DisplayEventReceiver::Event&)>;
-
-    EventThreadTest();
-    ~EventThreadTest() override;
-
-    void createThread();
-    sp<MockEventThreadConnection> createConnection(ConnectionEventRecorder& recorder);
-
-    void expectVSyncSetEnabledCallReceived(bool expectedState);
-    void expectVSyncSetPhaseOffsetCallReceived(nsecs_t expectedPhaseOffset);
-    VSyncSource::Callback* expectVSyncSetCallbackCallReceived();
-    void expectInterceptCallReceived(nsecs_t expectedTimestamp);
-    void expectVsyncEventReceivedByConnection(const char* name,
-                                              ConnectionEventRecorder& connectionEventRecorder,
-                                              nsecs_t expectedTimestamp, unsigned expectedCount);
-    void expectVsyncEventReceivedByConnection(nsecs_t expectedTimestamp, unsigned expectedCount);
-    void expectHotplugEventReceivedByConnection(int expectedDisplayType, bool expectedConnected);
-
-    AsyncCallRecorder<void (*)(bool)> mVSyncSetEnabledCallRecorder;
-    AsyncCallRecorder<void (*)(VSyncSource::Callback*)> mVSyncSetCallbackCallRecorder;
-    AsyncCallRecorder<void (*)(nsecs_t)> mVSyncSetPhaseOffsetCallRecorder;
-    AsyncCallRecorder<void (*)()> mResyncCallRecorder;
-    AsyncCallRecorder<void (*)(nsecs_t)> mInterceptVSyncCallRecorder;
-    ConnectionEventRecorder mConnectionEventCallRecorder{0};
-
-    MockVSyncSource mVSyncSource;
-    std::unique_ptr<android::impl::EventThread> mThread;
-    sp<MockEventThreadConnection> mConnection;
-};
-
-EventThreadTest::EventThreadTest() {
-    const ::testing::TestInfo* const test_info =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGD("**** Setting up for %s.%s\n", test_info->test_case_name(), test_info->name());
-
-    EXPECT_CALL(mVSyncSource, setVSyncEnabled(_))
-            .WillRepeatedly(Invoke(mVSyncSetEnabledCallRecorder.getInvocable()));
-
-    EXPECT_CALL(mVSyncSource, setCallback(_))
-            .WillRepeatedly(Invoke(mVSyncSetCallbackCallRecorder.getInvocable()));
-
-    EXPECT_CALL(mVSyncSource, setPhaseOffset(_))
-            .WillRepeatedly(Invoke(mVSyncSetPhaseOffsetCallRecorder.getInvocable()));
-
-    createThread();
-    mConnection = createConnection(mConnectionEventCallRecorder);
-}
-
-EventThreadTest::~EventThreadTest() {
-    const ::testing::TestInfo* const test_info =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGD("**** Tearing down after %s.%s\n", test_info->test_case_name(), test_info->name());
-}
-
-void EventThreadTest::createThread() {
-    mThread =
-            std::make_unique<android::impl::EventThread>(&mVSyncSource,
-                                                         mResyncCallRecorder.getInvocable(),
-                                                         mInterceptVSyncCallRecorder.getInvocable(),
-                                                         "unit-test-event-thread");
-}
-
-sp<EventThreadTest::MockEventThreadConnection> EventThreadTest::createConnection(
-        ConnectionEventRecorder& recorder) {
-    sp<MockEventThreadConnection> connection = new MockEventThreadConnection(mThread.get());
-    EXPECT_CALL(*connection, postEvent(_)).WillRepeatedly(Invoke(recorder.getInvocable()));
-    return connection;
-}
-
-void EventThreadTest::expectVSyncSetEnabledCallReceived(bool expectedState) {
-    auto args = mVSyncSetEnabledCallRecorder.waitForCall();
-    ASSERT_TRUE(args.has_value());
-    EXPECT_EQ(expectedState, std::get<0>(args.value()));
-}
-
-void EventThreadTest::expectVSyncSetPhaseOffsetCallReceived(nsecs_t expectedPhaseOffset) {
-    auto args = mVSyncSetPhaseOffsetCallRecorder.waitForCall();
-    ASSERT_TRUE(args.has_value());
-    EXPECT_EQ(expectedPhaseOffset, std::get<0>(args.value()));
-}
-
-VSyncSource::Callback* EventThreadTest::expectVSyncSetCallbackCallReceived() {
-    auto callbackSet = mVSyncSetCallbackCallRecorder.waitForCall();
-    return callbackSet.has_value() ? std::get<0>(callbackSet.value()) : nullptr;
-}
-
-void EventThreadTest::expectInterceptCallReceived(nsecs_t expectedTimestamp) {
-    auto args = mInterceptVSyncCallRecorder.waitForCall();
-    ASSERT_TRUE(args.has_value());
-    EXPECT_EQ(expectedTimestamp, std::get<0>(args.value()));
-}
-
-void EventThreadTest::expectVsyncEventReceivedByConnection(
-        const char* name, ConnectionEventRecorder& connectionEventRecorder,
-        nsecs_t expectedTimestamp, unsigned expectedCount) {
-    auto args = connectionEventRecorder.waitForCall();
-    ASSERT_TRUE(args.has_value()) << name << " did not receive an event for timestamp "
-                                  << expectedTimestamp;
-    const auto& event = std::get<0>(args.value());
-    EXPECT_EQ(DisplayEventReceiver::DISPLAY_EVENT_VSYNC, event.header.type)
-            << name << " did not get the correct event for timestamp " << expectedTimestamp;
-    EXPECT_EQ(expectedTimestamp, event.header.timestamp)
-            << name << " did not get the expected timestamp for timestamp " << expectedTimestamp;
-    EXPECT_EQ(expectedCount, event.vsync.count)
-            << name << " did not get the expected count for timestamp " << expectedTimestamp;
-}
-
-void EventThreadTest::expectVsyncEventReceivedByConnection(nsecs_t expectedTimestamp,
-                                                           unsigned expectedCount) {
-    expectVsyncEventReceivedByConnection("mConnectionEventCallRecorder",
-                                         mConnectionEventCallRecorder, expectedTimestamp,
-                                         expectedCount);
-}
-
-void EventThreadTest::expectHotplugEventReceivedByConnection(int expectedDisplayType,
-                                                             bool expectedConnected) {
-    auto args = mConnectionEventCallRecorder.waitForCall();
-    ASSERT_TRUE(args.has_value());
-    const auto& event = std::get<0>(args.value());
-    EXPECT_EQ(DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG, event.header.type);
-    EXPECT_EQ(static_cast<unsigned>(expectedDisplayType), event.header.id);
-    EXPECT_EQ(expectedConnected, event.hotplug.connected);
-}
-
-namespace {
-
-/* ------------------------------------------------------------------------
- * Test cases
- */
-
-TEST_F(EventThreadTest, canCreateAndDestroyThreadWithNoEventsSent) {
-    EXPECT_FALSE(mVSyncSetEnabledCallRecorder.waitForUnexpectedCall().has_value());
-    EXPECT_FALSE(mVSyncSetCallbackCallRecorder.waitForCall(0us).has_value());
-    EXPECT_FALSE(mVSyncSetPhaseOffsetCallRecorder.waitForCall(0us).has_value());
-    EXPECT_FALSE(mResyncCallRecorder.waitForCall(0us).has_value());
-    EXPECT_FALSE(mInterceptVSyncCallRecorder.waitForCall(0us).has_value());
-    EXPECT_FALSE(mConnectionEventCallRecorder.waitForCall(0us).has_value());
-}
-
-TEST_F(EventThreadTest, requestNextVsyncPostsASingleVSyncEventToTheConnection) {
-    // Signal that we want the next vsync event to be posted to the connection
-    mThread->requestNextVsync(mConnection);
-
-    // EventThread should immediately request a resync.
-    EXPECT_TRUE(mResyncCallRecorder.waitForCall().has_value());
-
-    // EventThread should enable vsync callbacks, and set a callback interface
-    // pointer to use them with the VSync source.
-    expectVSyncSetEnabledCallReceived(true);
-    auto callback = expectVSyncSetCallbackCallReceived();
-    ASSERT_TRUE(callback);
-
-    // Use the received callback to signal a first vsync event.
-    // The interceptor should receive the event, as well as the connection.
-    callback->onVSyncEvent(123);
-    expectInterceptCallReceived(123);
-    expectVsyncEventReceivedByConnection(123, 1u);
-
-    // Use the received callback to signal a second vsync event.
-    // The interceptor should receive the event, but the the connection should
-    // not as it was only interested in the first.
-    callback->onVSyncEvent(456);
-    expectInterceptCallReceived(456);
-    EXPECT_FALSE(mConnectionEventCallRecorder.waitForUnexpectedCall().has_value());
-
-    // EventThread should also detect that at this point that it does not need
-    // any more vsync events, and should disable their generation.
-    expectVSyncSetEnabledCallReceived(false);
-}
-
-TEST_F(EventThreadTest, setVsyncRateZeroPostsNoVSyncEventsToThatConnection) {
-    // Create a first connection, register it, and request a vsync rate of zero.
-    ConnectionEventRecorder firstConnectionEventRecorder{0};
-    sp<MockEventThreadConnection> firstConnection = createConnection(firstConnectionEventRecorder);
-    mThread->setVsyncRate(0, firstConnection);
-
-    // By itself, this should not enable vsync events
-    EXPECT_FALSE(mVSyncSetEnabledCallRecorder.waitForUnexpectedCall().has_value());
-    EXPECT_FALSE(mVSyncSetCallbackCallRecorder.waitForCall(0us).has_value());
-
-    // However if there is another connection which wants events at a nonzero rate.....
-    ConnectionEventRecorder secondConnectionEventRecorder{0};
-    sp<MockEventThreadConnection> secondConnection =
-            createConnection(secondConnectionEventRecorder);
-    mThread->setVsyncRate(1, secondConnection);
-
-    // EventThread should enable vsync callbacks, and set a callback interface
-    // pointer to use them with the VSync source.
-    expectVSyncSetEnabledCallReceived(true);
-    auto callback = expectVSyncSetCallbackCallReceived();
-    ASSERT_TRUE(callback);
-
-    // Send a vsync event. EventThread should then make a call to the
-    // interceptor, and the second connection. The first connection should not
-    // get the event.
-    callback->onVSyncEvent(123);
-    expectInterceptCallReceived(123);
-    EXPECT_FALSE(firstConnectionEventRecorder.waitForUnexpectedCall().has_value());
-    expectVsyncEventReceivedByConnection("secondConnection", secondConnectionEventRecorder, 123,
-                                         1u);
-}
-
-TEST_F(EventThreadTest, setVsyncRateOnePostsAllEventsToThatConnection) {
-    mThread->setVsyncRate(1, mConnection);
-
-    // EventThread should enable vsync callbacks, and set a callback interface
-    // pointer to use them with the VSync source.
-    expectVSyncSetEnabledCallReceived(true);
-    auto callback = expectVSyncSetCallbackCallReceived();
-    ASSERT_TRUE(callback);
-
-    // Send a vsync event. EventThread should then make a call to the
-    // interceptor, and the connection.
-    callback->onVSyncEvent(123);
-    expectInterceptCallReceived(123);
-    expectVsyncEventReceivedByConnection(123, 1u);
-
-    // A second event should go to the same places.
-    callback->onVSyncEvent(456);
-    expectInterceptCallReceived(456);
-    expectVsyncEventReceivedByConnection(456, 2u);
-
-    // A third event should go to the same places.
-    callback->onVSyncEvent(789);
-    expectInterceptCallReceived(789);
-    expectVsyncEventReceivedByConnection(789, 3u);
-}
-
-TEST_F(EventThreadTest, setVsyncRateTwoPostsEveryOtherEventToThatConnection) {
-    mThread->setVsyncRate(2, mConnection);
-
-    // EventThread should enable vsync callbacks, and set a callback interface
-    // pointer to use them with the VSync source.
-    expectVSyncSetEnabledCallReceived(true);
-    auto callback = expectVSyncSetCallbackCallReceived();
-    ASSERT_TRUE(callback);
-
-    // The first event will be seen by the interceptor, and not the connection.
-    callback->onVSyncEvent(123);
-    expectInterceptCallReceived(123);
-    EXPECT_FALSE(mConnectionEventCallRecorder.waitForUnexpectedCall().has_value());
-
-    // The second event will be seen by the interceptor and the connection.
-    callback->onVSyncEvent(456);
-    expectInterceptCallReceived(456);
-    expectVsyncEventReceivedByConnection(456, 2u);
-
-    // The third event will be seen by the interceptor, and not the connection.
-    callback->onVSyncEvent(789);
-    expectInterceptCallReceived(789);
-    EXPECT_FALSE(mConnectionEventCallRecorder.waitForUnexpectedCall().has_value());
-
-    // The fourth event will be seen by the interceptor and the connection.
-    callback->onVSyncEvent(101112);
-    expectInterceptCallReceived(101112);
-    expectVsyncEventReceivedByConnection(101112, 4u);
-}
-
-TEST_F(EventThreadTest, connectionsRemovedIfInstanceDestroyed) {
-    mThread->setVsyncRate(1, mConnection);
-
-    // EventThread should enable vsync callbacks, and set a callback interface
-    // pointer to use them with the VSync source.
-    expectVSyncSetEnabledCallReceived(true);
-    auto callback = expectVSyncSetCallbackCallReceived();
-    ASSERT_TRUE(callback);
-
-    // Destroy the only (strong) reference to the connection.
-    mConnection = nullptr;
-
-    // The first event will be seen by the interceptor, and not the connection.
-    callback->onVSyncEvent(123);
-    expectInterceptCallReceived(123);
-    EXPECT_FALSE(mConnectionEventCallRecorder.waitForUnexpectedCall().has_value());
-
-    // EventThread should disable vsync callbacks
-    expectVSyncSetEnabledCallReceived(false);
-}
-
-TEST_F(EventThreadTest, connectionsRemovedIfEventDeliveryError) {
-    ConnectionEventRecorder errorConnectionEventRecorder{NO_MEMORY};
-    sp<MockEventThreadConnection> errorConnection = createConnection(errorConnectionEventRecorder);
-    mThread->setVsyncRate(1, errorConnection);
-
-    // EventThread should enable vsync callbacks, and set a callback interface
-    // pointer to use them with the VSync source.
-    expectVSyncSetEnabledCallReceived(true);
-    auto callback = expectVSyncSetCallbackCallReceived();
-    ASSERT_TRUE(callback);
-
-    // The first event will be seen by the interceptor, and by the connection,
-    // which then returns an error.
-    callback->onVSyncEvent(123);
-    expectInterceptCallReceived(123);
-    expectVsyncEventReceivedByConnection("errorConnection", errorConnectionEventRecorder, 123, 1u);
-
-    // A subsequent event will be seen by the interceptor and not by the
-    // connection.
-    callback->onVSyncEvent(456);
-    expectInterceptCallReceived(456);
-    EXPECT_FALSE(errorConnectionEventRecorder.waitForUnexpectedCall().has_value());
-
-    // EventThread should disable vsync callbacks with the second event
-    expectVSyncSetEnabledCallReceived(false);
-}
-
-TEST_F(EventThreadTest, eventsDroppedIfNonfatalEventDeliveryError) {
-    ConnectionEventRecorder errorConnectionEventRecorder{WOULD_BLOCK};
-    sp<MockEventThreadConnection> errorConnection = createConnection(errorConnectionEventRecorder);
-    mThread->setVsyncRate(1, errorConnection);
-
-    // EventThread should enable vsync callbacks, and set a callback interface
-    // pointer to use them with the VSync source.
-    expectVSyncSetEnabledCallReceived(true);
-    auto callback = expectVSyncSetCallbackCallReceived();
-    ASSERT_TRUE(callback);
-
-    // The first event will be seen by the interceptor, and by the connection,
-    // which then returns an non-fatal error.
-    callback->onVSyncEvent(123);
-    expectInterceptCallReceived(123);
-    expectVsyncEventReceivedByConnection("errorConnection", errorConnectionEventRecorder, 123, 1u);
-
-    // A subsequent event will be seen by the interceptor, and by the connection,
-    // which still then returns an non-fatal error.
-    callback->onVSyncEvent(456);
-    expectInterceptCallReceived(456);
-    expectVsyncEventReceivedByConnection("errorConnection", errorConnectionEventRecorder, 456, 2u);
-
-    // EventThread will not disable vsync callbacks as the errors are non-fatal.
-    EXPECT_FALSE(mVSyncSetEnabledCallRecorder.waitForUnexpectedCall().has_value());
-}
-
-TEST_F(EventThreadTest, setPhaseOffsetForwardsToVSyncSource) {
-    mThread->setPhaseOffset(321);
-    expectVSyncSetPhaseOffsetCallReceived(321);
-}
-
-TEST_F(EventThreadTest, postHotplugPrimaryDisconnect) {
-    mThread->onHotplugReceived(DisplayDevice::DISPLAY_PRIMARY, false);
-    expectHotplugEventReceivedByConnection(DisplayDevice::DISPLAY_PRIMARY, false);
-}
-
-TEST_F(EventThreadTest, postHotplugPrimaryConnect) {
-    mThread->onHotplugReceived(DisplayDevice::DISPLAY_PRIMARY, true);
-    expectHotplugEventReceivedByConnection(DisplayDevice::DISPLAY_PRIMARY, true);
-}
-
-TEST_F(EventThreadTest, postHotplugExternalDisconnect) {
-    mThread->onHotplugReceived(DisplayDevice::DISPLAY_EXTERNAL, false);
-    expectHotplugEventReceivedByConnection(DisplayDevice::DISPLAY_EXTERNAL, false);
-}
-
-TEST_F(EventThreadTest, postHotplugExternalConnect) {
-    mThread->onHotplugReceived(DisplayDevice::DISPLAY_EXTERNAL, true);
-    expectHotplugEventReceivedByConnection(DisplayDevice::DISPLAY_EXTERNAL, true);
-}
-
-TEST_F(EventThreadTest, postHotplugVirtualDisconnectIsFilteredOut) {
-    mThread->onHotplugReceived(DisplayDevice::DISPLAY_VIRTUAL, false);
-    EXPECT_FALSE(mConnectionEventCallRecorder.waitForUnexpectedCall().has_value());
-}
-
-} // namespace
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h b/services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h
deleted file mode 100644
index f1556d8bc..000000000
--- a/services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include "DisplayDevice.h"
-#include "SurfaceFlinger.h"
-
-namespace android {
-
-class EventThread;
-
-namespace RE {
-class RenderEngine;
-}
-
-namespace Hwc2 {
-class Composer;
-}
-
-class TestableSurfaceFlinger {
-public:
-    // Extend this as needed for accessing SurfaceFlinger private (and public)
-    // functions.
-
-    void setupRenderEngine(std::unique_ptr<RE::RenderEngine> renderEngine) {
-        mFlinger->getBE().mRenderEngine = std::move(renderEngine);
-    }
-
-    void setupComposer(std::unique_ptr<Hwc2::Composer> composer) {
-        mFlinger->getBE().mHwc.reset(new HWComposer(std::move(composer)));
-    }
-
-    using CreateBufferQueueFunction = SurfaceFlinger::CreateBufferQueueFunction;
-    void setCreateBufferQueueFunction(CreateBufferQueueFunction f) {
-        mFlinger->mCreateBufferQueue = f;
-    }
-
-    using CreateNativeWindowSurfaceFunction = SurfaceFlinger::CreateNativeWindowSurfaceFunction;
-    void setCreateNativeWindowSurface(CreateNativeWindowSurfaceFunction f) {
-        mFlinger->mCreateNativeWindowSurface = f;
-    }
-
-    using HotplugEvent = SurfaceFlinger::HotplugEvent;
-
-    /* ------------------------------------------------------------------------
-     * Forwarding for functions being tested
-     */
-
-    auto createDisplay(const String8& displayName, bool secure) {
-        return mFlinger->createDisplay(displayName, secure);
-    }
-
-    auto destroyDisplay(const sp<IBinder>& display) { return mFlinger->destroyDisplay(display); }
-
-    auto resetDisplayState() { return mFlinger->resetDisplayState(); }
-
-    auto setupNewDisplayDeviceInternal(const wp<IBinder>& display, int hwcId,
-                                       const DisplayDeviceState& state,
-                                       const sp<DisplaySurface>& dispSurface,
-                                       const sp<IGraphicBufferProducer>& producer) {
-        return mFlinger->setupNewDisplayDeviceInternal(display, hwcId, state, dispSurface,
-                                                       producer);
-    }
-
-    auto handleTransactionLocked(uint32_t transactionFlags) {
-        return mFlinger->handleTransactionLocked(transactionFlags);
-    }
-
-    auto onHotplugReceived(int32_t sequenceId, hwc2_display_t display,
-                           HWC2::Connection connection) {
-        return mFlinger->onHotplugReceived(sequenceId, display, connection);
-    }
-
-    auto setDisplayStateLocked(const DisplayState& s) { return mFlinger->setDisplayStateLocked(s); }
-
-    auto onInitializeDisplays() { return mFlinger->onInitializeDisplays(); }
-
-    auto setPowerModeInternal(const sp<DisplayDevice>& hw, int mode, bool stateLockHeld = false) {
-        return mFlinger->setPowerModeInternal(hw, mode, stateLockHeld);
-    }
-
-    /* ------------------------------------------------------------------------
-     * Read-only access to private data to assert post-conditions.
-     */
-
-    const auto& getAnimFrameTracker() const { return mFlinger->mAnimFrameTracker; }
-    const auto& getHasPoweredOff() const { return mFlinger->mHasPoweredOff; }
-    const auto& getHWVsyncAvailable() const { return mFlinger->mHWVsyncAvailable; }
-    const auto& getVisibleRegionsDirty() const { return mFlinger->mVisibleRegionsDirty; }
-
-    const auto& getCompositorTiming() const { return mFlinger->getBE().mCompositorTiming; }
-
-    /* ------------------------------------------------------------------------
-     * Read-write access to private data to set up preconditions and assert
-     * post-conditions.
-     */
-
-    auto& mutableHasWideColorDisplay() { return SurfaceFlinger::hasWideColorDisplay; }
-
-    auto& mutableBuiltinDisplays() { return mFlinger->mBuiltinDisplays; }
-    auto& mutableCurrentState() { return mFlinger->mCurrentState; }
-    auto& mutableDisplays() { return mFlinger->mDisplays; }
-    auto& mutableDisplayColorSetting() { return mFlinger->mDisplayColorSetting; }
-    auto& mutableDrawingState() { return mFlinger->mDrawingState; }
-    auto& mutableEventControlThread() { return mFlinger->mEventControlThread; }
-    auto& mutableEventQueue() { return mFlinger->mEventQueue; }
-    auto& mutableEventThread() { return mFlinger->mEventThread; }
-    auto& mutableHWVsyncAvailable() { return mFlinger->mHWVsyncAvailable; }
-    auto& mutableInterceptor() { return mFlinger->mInterceptor; }
-    auto& mutableMainThreadId() { return mFlinger->mMainThreadId; }
-    auto& mutablePendingHotplugEvents() { return mFlinger->mPendingHotplugEvents; }
-    auto& mutablePrimaryHWVsyncEnabled() { return mFlinger->mPrimaryHWVsyncEnabled; }
-    auto& mutableTransactionFlags() { return mFlinger->mTransactionFlags; }
-    auto& mutableUseHwcVirtualDisplays() { return mFlinger->mUseHwcVirtualDisplays; }
-
-    auto& mutableComposerSequenceId() { return mFlinger->getBE().mComposerSequenceId; }
-    auto& mutableHwcDisplayData() { return mFlinger->getBE().mHwc->mDisplayData; }
-    auto& mutableHwcDisplaySlots() { return mFlinger->getBE().mHwc->mHwcDisplaySlots; }
-
-    ~TestableSurfaceFlinger() {
-        // All these pointer and container clears help ensure that GMock does
-        // not report a leaked object, since the SurfaceFlinger instance may
-        // still be referenced by something despite our best efforts to destroy
-        // it after each test is done.
-        mutableDisplays().clear();
-        mutableEventControlThread().reset();
-        mutableEventQueue().reset();
-        mutableEventThread().reset();
-        mutableInterceptor().reset();
-        mFlinger->getBE().mHwc.reset();
-        mFlinger->getBE().mRenderEngine.reset();
-    }
-
-    /* ------------------------------------------------------------------------
-     * Wrapper classes for Read-write access to private data to set up
-     * preconditions and assert post-conditions.
-     */
-
-    struct HWC2Display : public HWC2::Display {
-        HWC2Display(Hwc2::Composer& composer,
-                    const std::unordered_set<HWC2::Capability>& capabilities, hwc2_display_t id,
-                    HWC2::DisplayType type)
-              : HWC2::Display(composer, capabilities, id, type) {}
-        ~HWC2Display() {
-            // Prevents a call to disable vsyncs.
-            mType = HWC2::DisplayType::Invalid;
-        }
-
-        auto& mutableIsConnected() { return this->mIsConnected; }
-        auto& mutableConfigs() { return this->mConfigs; }
-    };
-
-    class FakeHwcDisplayInjector {
-    public:
-        static constexpr hwc2_display_t DEFAULT_HWC_DISPLAY_ID = 1000;
-        static constexpr int32_t DEFAULT_WIDTH = 1920;
-        static constexpr int32_t DEFAULT_HEIGHT = 1280;
-        static constexpr int32_t DEFAULT_REFRESH_RATE = 16'666'666;
-        static constexpr int32_t DEFAULT_DPI = 320;
-        static constexpr int32_t DEFAULT_ACTIVE_CONFIG = 0;
-
-        FakeHwcDisplayInjector(DisplayDevice::DisplayType type, HWC2::DisplayType hwcDisplayType)
-              : mType(type), mHwcDisplayType(hwcDisplayType) {}
-
-        auto& setHwcDisplayId(hwc2_display_t displayId) {
-            mHwcDisplayId = displayId;
-            return *this;
-        }
-
-        auto& setWidth(int32_t width) {
-            mWidth = width;
-            return *this;
-        }
-
-        auto& setHeight(int32_t height) {
-            mHeight = height;
-            return *this;
-        }
-
-        auto& setRefreshRate(int32_t refreshRate) {
-            mRefreshRate = refreshRate;
-            return *this;
-        }
-
-        auto& setDpiX(int32_t dpi) {
-            mDpiX = dpi;
-            return *this;
-        }
-
-        auto& setDpiY(int32_t dpi) {
-            mDpiY = dpi;
-            return *this;
-        }
-
-        auto& setActiveConfig(int32_t config) {
-            mActiveConfig = config;
-            return *this;
-        }
-
-        auto& addCapability(HWC2::Capability cap) {
-            mCapabilities.emplace(cap);
-            return *this;
-        }
-
-        void inject(TestableSurfaceFlinger* flinger, Hwc2::Composer* composer) {
-            auto display = std::make_unique<HWC2Display>(*composer, mCapabilities, mHwcDisplayId,
-                                                         mHwcDisplayType);
-
-            auto config = HWC2::Display::Config::Builder(*display, mActiveConfig);
-            config.setWidth(mWidth);
-            config.setHeight(mHeight);
-            config.setVsyncPeriod(mRefreshRate);
-            config.setDpiX(mDpiX);
-            config.setDpiY(mDpiY);
-            display->mutableConfigs().emplace(mActiveConfig, config.build());
-            display->mutableIsConnected() = true;
-
-            ASSERT_TRUE(flinger->mutableHwcDisplayData().size() > static_cast<size_t>(mType));
-            flinger->mutableHwcDisplayData()[mType].reset();
-            flinger->mutableHwcDisplayData()[mType].hwcDisplay = display.get();
-            flinger->mutableHwcDisplaySlots().emplace(mHwcDisplayId, mType);
-
-            flinger->mFakeHwcDisplays.push_back(std::move(display));
-        }
-
-    private:
-        DisplayDevice::DisplayType mType;
-        HWC2::DisplayType mHwcDisplayType;
-        hwc2_display_t mHwcDisplayId = DEFAULT_HWC_DISPLAY_ID;
-        int32_t mWidth = DEFAULT_WIDTH;
-        int32_t mHeight = DEFAULT_HEIGHT;
-        int32_t mRefreshRate = DEFAULT_REFRESH_RATE;
-        int32_t mDpiX = DEFAULT_DPI;
-        int32_t mDpiY = DEFAULT_DPI;
-        int32_t mActiveConfig = DEFAULT_ACTIVE_CONFIG;
-        std::unordered_set<HWC2::Capability> mCapabilities;
-    };
-
-    class FakeDisplayDeviceInjector {
-    public:
-        FakeDisplayDeviceInjector(TestableSurfaceFlinger& flinger, DisplayDevice::DisplayType type,
-                                  int hwcId)
-              : mFlinger(flinger), mType(type), mHwcId(hwcId) {}
-
-        sp<IBinder> token() const { return mDisplayToken; }
-
-        DisplayDeviceState& mutableDrawingDisplayState() {
-            return mFlinger.mutableDrawingState().displays.editValueFor(mDisplayToken);
-        }
-
-        DisplayDeviceState& mutableCurrentDisplayState() {
-            return mFlinger.mutableCurrentState().displays.editValueFor(mDisplayToken);
-        }
-
-        const auto& getDrawingDisplayState() {
-            return mFlinger.mutableDrawingState().displays.valueFor(mDisplayToken);
-        }
-
-        const auto& getCurrentDisplayState() {
-            return mFlinger.mutableCurrentState().displays.valueFor(mDisplayToken);
-        }
-
-        auto& mutableDisplayDevice() { return mFlinger.mutableDisplays().valueFor(mDisplayToken); }
-
-        auto& setNativeWindow(const sp<ANativeWindow>& nativeWindow) {
-            mNativeWindow = nativeWindow;
-            return *this;
-        }
-
-        auto& setDisplaySurface(const sp<DisplaySurface>& displaySurface) {
-            mDisplaySurface = displaySurface;
-            return *this;
-        }
-
-        auto& setRenderSurface(std::unique_ptr<RE::Surface> renderSurface) {
-            mRenderSurface = std::move(renderSurface);
-            return *this;
-        }
-
-        auto& setSecure(bool secure) {
-            mSecure = secure;
-            return *this;
-        }
-
-        sp<DisplayDevice> inject() {
-            std::unordered_map<ui::ColorMode, std::vector<ui::RenderIntent>> hdrAndRenderIntents;
-            sp<DisplayDevice> device =
-                    new DisplayDevice(mFlinger.mFlinger.get(), mType, mHwcId, mSecure, mDisplayToken,
-                                      mNativeWindow, mDisplaySurface, std::move(mRenderSurface), 0,
-                                      0, false, HdrCapabilities(), 0, hdrAndRenderIntents,
-                                      HWC_POWER_MODE_NORMAL);
-            mFlinger.mutableDisplays().add(mDisplayToken, device);
-
-            DisplayDeviceState state(mType, mSecure);
-            mFlinger.mutableCurrentState().displays.add(mDisplayToken, state);
-            mFlinger.mutableDrawingState().displays.add(mDisplayToken, state);
-
-            if (mType >= DisplayDevice::DISPLAY_PRIMARY && mType < DisplayDevice::DISPLAY_VIRTUAL) {
-                mFlinger.mutableBuiltinDisplays()[mType] = mDisplayToken;
-            }
-
-            return device;
-        }
-
-    private:
-        TestableSurfaceFlinger& mFlinger;
-        sp<BBinder> mDisplayToken = new BBinder();
-        DisplayDevice::DisplayType mType;
-        int mHwcId;
-        sp<ANativeWindow> mNativeWindow;
-        sp<DisplaySurface> mDisplaySurface;
-        std::unique_ptr<RE::Surface> mRenderSurface;
-        bool mSecure = false;
-    };
-
-    sp<SurfaceFlinger> mFlinger = new SurfaceFlinger(SurfaceFlinger::SkipInitialization);
-
-    // We need to keep a reference to these so they are properly destroyed.
-    std::vector<std::unique_ptr<HWC2Display>> mFakeHwcDisplays;
-};
-
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.cpp b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.cpp
deleted file mode 100644
index 7ed57b9d9..000000000
--- a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.cpp
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/DisplayHardware/MockComposer.h"
-
-namespace android {
-namespace Hwc2 {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-Composer::Composer() = default;
-Composer::~Composer() = default;
-
-} // namespace mock
-} // namespace Hwc2
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h
deleted file mode 100644
index 267670aca..000000000
--- a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "DisplayHardware/ComposerHal.h"
-
-namespace android {
-
-class GraphicBuffer;
-
-namespace Hwc2 {
-namespace mock {
-
-using android::hardware::graphics::common::V1_0::ColorTransform;
-using android::hardware::graphics::common::V1_0::Hdr;
-using android::hardware::graphics::common::V1_0::Transform;
-using android::hardware::graphics::common::V1_1::ColorMode;
-using android::hardware::graphics::common::V1_1::Dataspace;
-using android::hardware::graphics::common::V1_1::PixelFormat;
-using android::hardware::graphics::common::V1_1::RenderIntent;
-
-using android::hardware::graphics::composer::V2_1::Config;
-using android::hardware::graphics::composer::V2_1::Display;
-using android::hardware::graphics::composer::V2_1::Error;
-using android::hardware::graphics::composer::V2_1::IComposer;
-using android::hardware::graphics::composer::V2_1::IComposerCallback;
-using android::hardware::graphics::composer::V2_1::Layer;
-using android::hardware::graphics::composer::V2_2::IComposerClient;
-
-class Composer : public Hwc2::Composer {
-public:
-    Composer();
-    ~Composer() override;
-
-    MOCK_METHOD0(getCapabilities, std::vector<IComposer::Capability>());
-    MOCK_METHOD0(dumpDebugInfo, std::string());
-    MOCK_METHOD1(registerCallback, void(const sp<IComposerCallback>&));
-    MOCK_METHOD0(isRemote, bool());
-    MOCK_METHOD0(resetCommands, void());
-    MOCK_METHOD0(executeCommands, Error());
-    MOCK_METHOD0(getMaxVirtualDisplayCount, uint32_t());
-    MOCK_CONST_METHOD0(isUsingVrComposer, bool());
-    MOCK_METHOD4(createVirtualDisplay, Error(uint32_t, uint32_t, PixelFormat*, Display*));
-    MOCK_METHOD1(destroyVirtualDisplay, Error(Display));
-    MOCK_METHOD1(acceptDisplayChanges, Error(Display));
-    MOCK_METHOD2(createLayer, Error(Display, Layer* outLayer));
-    MOCK_METHOD2(destroyLayer, Error(Display, Layer));
-    MOCK_METHOD2(getActiveConfig, Error(Display, Config*));
-    MOCK_METHOD3(getChangedCompositionTypes,
-                 Error(Display, std::vector<Layer>*, std::vector<IComposerClient::Composition>*));
-    MOCK_METHOD2(getColorModes, Error(Display, std::vector<ColorMode>*));
-    MOCK_METHOD4(getDisplayAttribute,
-                 Error(Display, Config config, IComposerClient::Attribute, int32_t*));
-    MOCK_METHOD2(getDisplayConfigs, Error(Display, std::vector<Config>*));
-    MOCK_METHOD2(getDisplayName, Error(Display, std::string*));
-    MOCK_METHOD4(getDisplayRequests,
-                 Error(Display, uint32_t*, std::vector<Layer>*, std::vector<uint32_t>*));
-    MOCK_METHOD2(getDisplayType, Error(Display, IComposerClient::DisplayType*));
-    MOCK_METHOD2(getDozeSupport, Error(Display, bool*));
-    MOCK_METHOD5(getHdrCapabilities, Error(Display, std::vector<Hdr>*, float*, float*, float*));
-    MOCK_METHOD2(getPerFrameMetadataKeys,
-                 Error(Display, std::vector<IComposerClient::PerFrameMetadataKey>*));
-    MOCK_METHOD2(getDataspaceSaturationMatrix, Error(Dataspace, mat4*));
-    MOCK_METHOD3(getReleaseFences, Error(Display, std::vector<Layer>*, std::vector<int>*));
-    MOCK_METHOD2(presentDisplay, Error(Display, int*));
-    MOCK_METHOD2(setActiveConfig, Error(Display, Config));
-    MOCK_METHOD6(setClientTarget,
-                 Error(Display, uint32_t, const sp<GraphicBuffer>&, int, Dataspace,
-                       const std::vector<IComposerClient::Rect>&));
-    MOCK_METHOD3(setColorMode, Error(Display, ColorMode, RenderIntent));
-    MOCK_METHOD3(setColorTransform, Error(Display, const float*, ColorTransform));
-    MOCK_METHOD3(setOutputBuffer, Error(Display, const native_handle_t*, int));
-    MOCK_METHOD2(setPowerMode, Error(Display, IComposerClient::PowerMode));
-    MOCK_METHOD2(setVsyncEnabled, Error(Display, IComposerClient::Vsync));
-    MOCK_METHOD1(setClientTargetSlotCount, Error(Display));
-    MOCK_METHOD3(validateDisplay, Error(Display, uint32_t*, uint32_t*));
-    MOCK_METHOD5(presentOrValidateDisplay, Error(Display, uint32_t*, uint32_t*, int*, uint32_t*));
-    MOCK_METHOD4(setCursorPosition, Error(Display, Layer, int32_t, int32_t));
-    MOCK_METHOD5(setLayerBuffer, Error(Display, Layer, uint32_t, const sp<GraphicBuffer>&, int));
-    MOCK_METHOD3(setLayerSurfaceDamage,
-                 Error(Display, Layer, const std::vector<IComposerClient::Rect>&));
-    MOCK_METHOD3(setLayerBlendMode, Error(Display, Layer, IComposerClient::BlendMode));
-    MOCK_METHOD3(setLayerColor, Error(Display, Layer, const IComposerClient::Color&));
-    MOCK_METHOD3(setLayerCompositionType, Error(Display, Layer, IComposerClient::Composition));
-    MOCK_METHOD3(setLayerDataspace, Error(Display, Layer, Dataspace));
-    MOCK_METHOD3(setLayerPerFrameMetadata,
-                 Error(Display, Layer, const std::vector<IComposerClient::PerFrameMetadata>&));
-    MOCK_METHOD3(setLayerDisplayFrame, Error(Display, Layer, const IComposerClient::Rect&));
-    MOCK_METHOD3(setLayerPlaneAlpha, Error(Display, Layer, float));
-    MOCK_METHOD3(setLayerSidebandStream, Error(Display, Layer, const native_handle_t*));
-    MOCK_METHOD3(setLayerSourceCrop, Error(Display, Layer, const IComposerClient::FRect&));
-    MOCK_METHOD3(setLayerTransform, Error(Display, Layer, Transform));
-    MOCK_METHOD3(setLayerVisibleRegion,
-                 Error(Display, Layer, const std::vector<IComposerClient::Rect>&));
-    MOCK_METHOD3(setLayerZOrder, Error(Display, Layer, uint32_t));
-    MOCK_METHOD4(setLayerInfo, Error(Display, Layer, uint32_t, uint32_t));
-    MOCK_METHOD3(getRenderIntents, Error(Display, ColorMode, std::vector<RenderIntent>*));
-};
-
-} // namespace mock
-} // namespace Hwc2
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.cpp b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.cpp
deleted file mode 100644
index e6ac6bfb0..000000000
--- a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/DisplayHardware/MockDisplaySurface.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-DisplaySurface::DisplaySurface() = default;
-DisplaySurface::~DisplaySurface() = default;
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.h b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.h
deleted file mode 100644
index d6c9aa46b..000000000
--- a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockDisplaySurface.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include <utils/String8.h>
-
-#include "DisplayHardware/DisplaySurface.h"
-
-namespace android {
-namespace mock {
-
-class DisplaySurface : public android::DisplaySurface {
-public:
-    DisplaySurface();
-    ~DisplaySurface() override;
-
-    MOCK_METHOD1(beginFrame, status_t(bool mustRecompose));
-    MOCK_METHOD1(prepareFrame, status_t(CompositionType compositionType));
-    MOCK_METHOD0(advanceFrame, status_t());
-    MOCK_METHOD0(onFrameCommitted, void());
-    MOCK_CONST_METHOD1(dumpAsString, void(String8& result));
-    MOCK_METHOD2(resizeBuffers, void(uint32_t, uint32_t));
-    MOCK_CONST_METHOD0(getClientTargetAcquireFence, const sp<Fence>&());
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockEventControlThread.cpp b/services/surfaceflinger/tests/unittests/mock/MockEventControlThread.cpp
deleted file mode 100644
index f9bacc8b2..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockEventControlThread.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/MockEventControlThread.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-EventControlThread::EventControlThread() = default;
-EventControlThread::~EventControlThread() = default;
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockEventControlThread.h b/services/surfaceflinger/tests/unittests/mock/MockEventControlThread.h
deleted file mode 100644
index 8ac09a962..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockEventControlThread.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "EventControlThread.h"
-
-namespace android {
-namespace mock {
-
-class EventControlThread : public android::EventControlThread {
-public:
-    EventControlThread();
-    ~EventControlThread() override;
-
-    MOCK_METHOD1(setVsyncEnabled, void(bool));
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockEventThread.cpp b/services/surfaceflinger/tests/unittests/mock/MockEventThread.cpp
deleted file mode 100644
index 408cd35f2..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockEventThread.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/MockEventThread.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-EventThread::EventThread() = default;
-EventThread::~EventThread() = default;
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockEventThread.h b/services/surfaceflinger/tests/unittests/mock/MockEventThread.h
deleted file mode 100644
index e6ea6634c..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockEventThread.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "EventThread.h"
-
-namespace android {
-namespace mock {
-
-class EventThread : public android::EventThread {
-public:
-    EventThread();
-    ~EventThread() override;
-
-    MOCK_CONST_METHOD0(createEventConnection, sp<BnDisplayEventConnection>());
-    MOCK_METHOD0(onScreenReleased, void());
-    MOCK_METHOD0(onScreenAcquired, void());
-    MOCK_METHOD2(onHotplugReceived, void(int, bool));
-    MOCK_CONST_METHOD1(dump, void(String8&));
-    MOCK_METHOD1(setPhaseOffset, void(nsecs_t phaseOffset));
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockMessageQueue.cpp b/services/surfaceflinger/tests/unittests/mock/MockMessageQueue.cpp
deleted file mode 100644
index 97a13e4d3..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockMessageQueue.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/MockMessageQueue.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-MessageQueue::MessageQueue() = default;
-MessageQueue::~MessageQueue() = default;
-
-} // namespace mock
-} // namespace android
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/unittests/mock/MockMessageQueue.h b/services/surfaceflinger/tests/unittests/mock/MockMessageQueue.h
deleted file mode 100644
index cf07cf7ba..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockMessageQueue.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "MessageQueue.h"
-
-namespace android {
-namespace mock {
-
-class MessageQueue : public android::MessageQueue {
-public:
-    MessageQueue();
-    ~MessageQueue() override;
-
-    MOCK_METHOD1(init, void(const sp<SurfaceFlinger>&));
-    MOCK_METHOD1(setEventThread, void(android::EventThread*));
-    MOCK_METHOD0(waitMessage, void());
-    MOCK_METHOD2(postMessage, status_t(const sp<MessageBase>&, nsecs_t));
-    MOCK_METHOD0(invalidate, void());
-    MOCK_METHOD0(refresh, void());
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.cpp b/services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.cpp
deleted file mode 100644
index 25ff39bbd..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/MockNativeWindowSurface.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-NativeWindowSurface::NativeWindowSurface() = default;
-NativeWindowSurface::~NativeWindowSurface() = default;
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.h b/services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.h
deleted file mode 100644
index 88d1a9fc5..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockNativeWindowSurface.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include <system/window.h> // for ANativeWindow
-
-#include "SurfaceFlinger.h" // for base NativeWindowSurface
-
-namespace android {
-namespace mock {
-
-class NativeWindowSurface : public android::NativeWindowSurface {
-public:
-    NativeWindowSurface();
-    ~NativeWindowSurface();
-
-    MOCK_CONST_METHOD0(getNativeWindow, sp<ANativeWindow>());
-    MOCK_METHOD0(preallocateBuffers, void());
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.cpp b/services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.cpp
deleted file mode 100644
index 4129328ba..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/MockSurfaceInterceptor.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-SurfaceInterceptor::SurfaceInterceptor() = default;
-SurfaceInterceptor::~SurfaceInterceptor() = default;
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.h b/services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.h
deleted file mode 100644
index 458b2f3da..000000000
--- a/services/surfaceflinger/tests/unittests/mock/MockSurfaceInterceptor.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "SurfaceInterceptor.h"
-
-namespace android {
-namespace mock {
-
-class SurfaceInterceptor : public android::SurfaceInterceptor {
-public:
-    SurfaceInterceptor();
-    ~SurfaceInterceptor() override;
-
-    MOCK_METHOD2(enable,
-                 void(const SortedVector<sp<Layer>>&,
-                      const DefaultKeyedVector<wp<IBinder>, DisplayDeviceState>&));
-    MOCK_METHOD0(disable, void());
-    MOCK_METHOD0(isEnabled, bool());
-    MOCK_METHOD4(saveTransaction,
-                 void(const Vector<ComposerState>&,
-                      const DefaultKeyedVector<wp<IBinder>, DisplayDeviceState>&,
-                      const Vector<DisplayState>&, uint32_t));
-    MOCK_METHOD1(saveSurfaceCreation, void(const sp<const Layer>&));
-    MOCK_METHOD1(saveSurfaceDeletion, void(const sp<const Layer>&));
-    MOCK_METHOD4(saveBufferUpdate, void(const sp<const Layer>&, uint32_t, uint32_t, uint64_t));
-    MOCK_METHOD1(saveDisplayCreation, void(const DisplayDeviceState&));
-    MOCK_METHOD1(saveDisplayDeletion, void(int32_t));
-    MOCK_METHOD2(savePowerModeUpdate, void(int32_t, int32_t));
-    MOCK_METHOD1(saveVSyncEvent, void(nsecs_t));
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.cpp b/services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.cpp
deleted file mode 100644
index a98beceeb..000000000
--- a/services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/RenderEngine/MockRenderEngine.h"
-
-namespace android {
-namespace RE {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-RenderEngine::RenderEngine() = default;
-RenderEngine::~RenderEngine() = default;
-
-Surface::Surface() = default;
-Surface::~Surface() = default;
-
-Image::Image() = default;
-Image::~Image() = default;
-
-} // namespace mock
-} // namespace RE
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.h b/services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.h
deleted file mode 100644
index ac082933a..000000000
--- a/services/surfaceflinger/tests/unittests/mock/RenderEngine/MockRenderEngine.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include "RenderEngine/Image.h"
-#include "RenderEngine/Mesh.h"
-#include "RenderEngine/RenderEngine.h"
-#include "RenderEngine/Surface.h"
-#include "RenderEngine/Texture.h"
-
-namespace android {
-namespace RE {
-namespace mock {
-
-class RenderEngine : public RE::RenderEngine {
-public:
-    RenderEngine();
-    ~RenderEngine() override;
-
-    MOCK_METHOD0(createSurface, std::unique_ptr<RE::Surface>());
-    MOCK_METHOD0(createImage, std::unique_ptr<RE::Image>());
-    MOCK_CONST_METHOD0(primeCache, void());
-    MOCK_METHOD1(dump, void(String8&));
-    MOCK_CONST_METHOD0(supportsImageCrop, bool());
-    MOCK_CONST_METHOD0(isCurrent, bool());
-    MOCK_METHOD1(setCurrentSurface, bool(const RE::Surface&));
-    MOCK_METHOD0(resetCurrentSurface, void());
-    MOCK_METHOD0(flush, base::unique_fd());
-    MOCK_METHOD0(finish, bool());
-    MOCK_METHOD1(waitFence, bool(base::unique_fd*));
-    bool waitFence(base::unique_fd fd) override { return waitFence(&fd); };
-    MOCK_METHOD4(clearWithColor, void(float, float, float, float));
-    MOCK_METHOD6(fillRegionWithColor, void(const Region&, uint32_t, float, float, float, float));
-    MOCK_METHOD4(setScissor, void(uint32_t, uint32_t, uint32_t, uint32_t));
-    MOCK_METHOD0(disableScissor, void());
-    MOCK_METHOD2(genTextures, void(size_t, uint32_t*));
-    MOCK_METHOD2(deleteTextures, void(size_t, uint32_t const*));
-    MOCK_METHOD2(bindExternalTextureImage, void(uint32_t, const RE::Image&));
-    MOCK_METHOD5(readPixels, void(size_t, size_t, size_t, size_t, uint32_t*));
-    MOCK_CONST_METHOD0(checkErrors, void());
-    MOCK_METHOD6(setViewportAndProjection,
-                 void(size_t, size_t, Rect, size_t, bool, Transform::orientation_flags));
-    MOCK_METHOD4(setupLayerBlending, void(bool, bool, bool, const half4&));
-    MOCK_METHOD1(setupLayerTexturing, void(const Texture&));
-    MOCK_METHOD0(setupLayerBlackedOut, void());
-    MOCK_METHOD4(setupFillWithColor, void(float, float, float, float));
-    MOCK_METHOD1(setupColorTransform, void(const mat4&));
-    MOCK_METHOD1(setSaturationMatrix, void(const mat4&));
-    MOCK_METHOD0(disableTexturing, void());
-    MOCK_METHOD0(disableBlending, void());
-    MOCK_METHOD1(setSourceY410BT2020, void(bool));
-    MOCK_METHOD1(setSourceDataSpace, void(ui::Dataspace));
-    MOCK_METHOD1(setOutputDataSpace, void(ui::Dataspace));
-    MOCK_METHOD1(setDisplayMaxLuminance, void(const float));
-    MOCK_METHOD2(bindNativeBufferAsFrameBuffer,
-                 void(ANativeWindowBuffer*, RE::BindNativeBufferAsFramebuffer*));
-    MOCK_METHOD1(unbindNativeBufferAsFrameBuffer, void(RE::BindNativeBufferAsFramebuffer*));
-    MOCK_METHOD1(drawMesh, void(const Mesh&));
-    MOCK_CONST_METHOD0(getMaxTextureSize, size_t());
-    MOCK_CONST_METHOD0(getMaxViewportDims, size_t());
-};
-
-class Surface : public RE::Surface {
-public:
-    Surface();
-    ~Surface() override;
-
-    MOCK_METHOD1(setCritical, void(bool));
-    MOCK_METHOD1(setAsync, void(bool));
-    MOCK_METHOD1(setNativeWindow, void(ANativeWindow*));
-    MOCK_CONST_METHOD0(swapBuffers, void());
-    MOCK_CONST_METHOD0(queryRedSize, int32_t());
-    MOCK_CONST_METHOD0(queryGreenSize, int32_t());
-    MOCK_CONST_METHOD0(queryBlueSize, int32_t());
-    MOCK_CONST_METHOD0(queryAlphaSize, int32_t());
-    MOCK_CONST_METHOD0(queryWidth, int32_t());
-    MOCK_CONST_METHOD0(queryHeight, int32_t());
-};
-
-class Image : public RE::Image {
-public:
-    Image();
-    ~Image() override;
-
-    MOCK_METHOD4(setNativeWindowBuffer,
-                 bool(ANativeWindowBuffer* buffer, bool isProtected, int32_t cropWidth,
-                      int32_t cropHeight));
-};
-
-} // namespace mock
-} // namespace RE
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.cpp b/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.cpp
deleted file mode 100644
index a17b73f0f..000000000
--- a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/gui/MockGraphicBufferConsumer.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-GraphicBufferConsumer::GraphicBufferConsumer() = default;
-GraphicBufferConsumer::~GraphicBufferConsumer() = default;
-
-} // namespace mock
-} // namespace android
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.h b/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.h
deleted file mode 100644
index 98f24c2d4..000000000
--- a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferConsumer.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include <gui/IGraphicBufferConsumer.h>
-
-#include <utils/RefBase.h>
-
-namespace android {
-namespace mock {
-
-class GraphicBufferConsumer : public BnGraphicBufferConsumer, public virtual android::RefBase {
-public:
-    GraphicBufferConsumer();
-    ~GraphicBufferConsumer() override;
-
-    MOCK_METHOD3(acquireBuffer, status_t(BufferItem*, nsecs_t, uint64_t));
-    MOCK_METHOD1(detachBuffer, status_t(int));
-    MOCK_METHOD2(attachBuffer, status_t(int*, const sp<GraphicBuffer>&));
-    MOCK_METHOD5(releaseBuffer, status_t(int, uint64_t, EGLDisplay, EGLSyncKHR, const sp<Fence>&));
-    MOCK_METHOD2(consumerConnect, status_t(const sp<IConsumerListener>&, bool));
-    MOCK_METHOD0(consumerDisconnect, status_t());
-    MOCK_METHOD1(getReleasedBuffers, status_t(uint64_t*));
-    MOCK_METHOD2(setDefaultBufferSize, status_t(uint32_t, uint32_t));
-    MOCK_METHOD1(setMaxBufferCount, status_t(int));
-    MOCK_METHOD1(setMaxAcquiredBufferCount, status_t(int));
-    MOCK_METHOD1(setConsumerName, status_t(const String8&));
-    MOCK_METHOD1(setDefaultBufferFormat, status_t(PixelFormat));
-    MOCK_METHOD1(setDefaultBufferDataSpace, status_t(android_dataspace));
-    MOCK_METHOD1(setConsumerUsageBits, status_t(uint64_t));
-    MOCK_METHOD1(setConsumerIsProtected, status_t(bool));
-    MOCK_METHOD1(setTransformHint, status_t(uint32_t));
-    MOCK_CONST_METHOD1(getSidebandStream, status_t(sp<NativeHandle>*));
-    MOCK_METHOD2(getOccupancyHistory, status_t(bool, std::vector<OccupancyTracker::Segment>*));
-    MOCK_METHOD0(discardFreeBuffers, status_t());
-    MOCK_CONST_METHOD2(dumpState, status_t(const String8&, String8*));
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.cpp b/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.cpp
deleted file mode 100644
index a7fd667b5..000000000
--- a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/gui/MockGraphicBufferProducer.h"
-
-namespace android {
-namespace mock {
-
-// Explicit default instantiation is recommended.
-GraphicBufferProducer::GraphicBufferProducer() = default;
-GraphicBufferProducer::~GraphicBufferProducer() = default;
-
-} // namespace mock
-} // namespace android
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.h b/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.h
deleted file mode 100644
index c98f39f43..000000000
--- a/services/surfaceflinger/tests/unittests/mock/gui/MockGraphicBufferProducer.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include <gui/IGraphicBufferProducer.h>
-
-#include <utils/RefBase.h>
-
-namespace android {
-namespace mock {
-
-class GraphicBufferProducer : public BnGraphicBufferProducer, public virtual android::RefBase {
-public:
-    GraphicBufferProducer();
-    ~GraphicBufferProducer() override;
-
-    MOCK_METHOD2(requestBuffer, status_t(int, sp<GraphicBuffer>*));
-    MOCK_METHOD1(setMaxDequeuedBufferCount, status_t(int));
-    MOCK_METHOD1(setAsyncMode, status_t(bool));
-    MOCK_METHOD8(dequeueBuffer,
-                 status_t(int*, sp<Fence>*, uint32_t, uint32_t, PixelFormat, uint64_t, uint64_t*,
-                          FrameEventHistoryDelta*));
-    MOCK_METHOD1(detachBuffer, status_t(int));
-    MOCK_METHOD2(detachNextBuffer, status_t(sp<GraphicBuffer>*, sp<Fence>*));
-    MOCK_METHOD2(attachBuffer, status_t(int*, const sp<GraphicBuffer>&));
-    MOCK_METHOD3(queueBuffer, status_t(int, const QueueBufferInput&, QueueBufferOutput*));
-    MOCK_METHOD2(cancelBuffer, status_t(int, const sp<Fence>&));
-    MOCK_METHOD2(query, int(int, int*));
-    MOCK_METHOD4(connect, status_t(const sp<IProducerListener>&, int, bool, QueueBufferOutput*));
-    MOCK_METHOD2(disconnect, status_t(int, DisconnectMode));
-    MOCK_METHOD1(setSidebandStream, status_t(const sp<NativeHandle>&));
-    MOCK_METHOD4(allocateBuffers, void(uint32_t, uint32_t, PixelFormat, uint64_t));
-    MOCK_METHOD1(allowAllocation, status_t(bool));
-    MOCK_METHOD1(setGenerationNumber, status_t(uint32_t));
-    MOCK_CONST_METHOD0(getConsumerName, String8());
-    MOCK_METHOD1(setSharedBufferMode, status_t(bool));
-    MOCK_METHOD1(setAutoRefresh, status_t(bool));
-    MOCK_METHOD1(setDequeueTimeout, status_t(nsecs_t));
-    MOCK_METHOD3(getLastQueuedBuffer, status_t(sp<GraphicBuffer>*, sp<Fence>*, float[16]));
-    MOCK_METHOD1(getFrameTimestamps, void(FrameEventHistoryDelta*));
-    MOCK_CONST_METHOD1(getUniqueId, status_t(uint64_t*));
-    MOCK_CONST_METHOD1(getConsumerUsage, status_t(uint64_t*));
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.cpp b/services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.cpp
deleted file mode 100644
index a490b92a8..000000000
--- a/services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.cpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "mock/system/window/MockNativeWindow.h"
-
-namespace android {
-namespace mock {
-namespace {
-
-int dispatch_setSwapInterval(struct ANativeWindow* window, int interval) {
-    return static_cast<NativeWindow*>(window)->setSwapInterval(interval);
-}
-
-int dispatch_dequeueBuffer_DEPRECATED(struct ANativeWindow* window,
-                                      struct ANativeWindowBuffer** buffer) {
-    return static_cast<NativeWindow*>(window)->dequeueBuffer_DEPRECATED(buffer);
-}
-
-int dispatch_lockBuffer_DEPRECATED(struct ANativeWindow* window,
-                                   struct ANativeWindowBuffer* buffer) {
-    return static_cast<NativeWindow*>(window)->lockBuffer_DEPRECATED(buffer);
-}
-
-int dispatch_queueBuffer_DEPRECATED(struct ANativeWindow* window,
-                                    struct ANativeWindowBuffer* buffer) {
-    return static_cast<NativeWindow*>(window)->queueBuffer_DEPRECATED(buffer);
-}
-
-int dispatch_query(const struct ANativeWindow* window, int what, int* value) {
-    return static_cast<const NativeWindow*>(window)->query(what, value);
-}
-
-int dispatch_perform(struct ANativeWindow* window, int operation, ...) {
-    // TODO: Handle the various operations and their varargs better.
-    return static_cast<NativeWindow*>(window)->perform(operation);
-}
-
-int dispatch_cancelBuffer_DEPRECATED(struct ANativeWindow* window,
-                                     struct ANativeWindowBuffer* buffer) {
-    return static_cast<NativeWindow*>(window)->cancelBuffer_DEPRECATED(buffer);
-}
-
-int dispatch_dequeueBuffer(struct ANativeWindow* window, struct ANativeWindowBuffer** buffer,
-                           int* fenceFd) {
-    return static_cast<NativeWindow*>(window)->dequeueBuffer(buffer, fenceFd);
-}
-
-int dispatch_queueBuffer(struct ANativeWindow* window, struct ANativeWindowBuffer* buffer,
-                         int fenceFd) {
-    return static_cast<NativeWindow*>(window)->queueBuffer(buffer, fenceFd);
-}
-
-int dispatch_cancelBuffer(struct ANativeWindow* window, struct ANativeWindowBuffer* buffer,
-                          int fenceFd) {
-    return static_cast<NativeWindow*>(window)->cancelBuffer(buffer, fenceFd);
-}
-
-} // namespace
-
-NativeWindow::NativeWindow() {
-    // ANativeWindow is a structure with function pointers and not a C++ class.
-    // Set all the pointers to dispatch functions, which will invoke the mock
-    // interface functions.
-    ANativeWindow::setSwapInterval = &dispatch_setSwapInterval;
-    ANativeWindow::dequeueBuffer_DEPRECATED = &dispatch_dequeueBuffer_DEPRECATED;
-    ANativeWindow::lockBuffer_DEPRECATED = &dispatch_lockBuffer_DEPRECATED;
-    ANativeWindow::queueBuffer_DEPRECATED = &dispatch_queueBuffer_DEPRECATED;
-    ANativeWindow::query = &dispatch_query;
-    ANativeWindow::perform = &dispatch_perform;
-    ANativeWindow::cancelBuffer_DEPRECATED = &dispatch_cancelBuffer_DEPRECATED;
-    ANativeWindow::dequeueBuffer = &dispatch_dequeueBuffer;
-    ANativeWindow::queueBuffer = &dispatch_queueBuffer;
-    ANativeWindow::cancelBuffer = &dispatch_cancelBuffer;
-}
-
-// Explicit default instantiation is recommended.
-NativeWindow::~NativeWindow() = default;
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.h b/services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.h
deleted file mode 100644
index 561fd5869..000000000
--- a/services/surfaceflinger/tests/unittests/mock/system/window/MockNativeWindow.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <gmock/gmock.h>
-
-#include <system/window.h>
-
-#include <ui/ANativeObjectBase.h>
-
-namespace android {
-namespace mock {
-
-class NativeWindow : public ANativeObjectBase<ANativeWindow, NativeWindow, RefBase> {
-public:
-    NativeWindow();
-    ~NativeWindow();
-
-    MOCK_METHOD1(setSwapInterval, int(int interval));
-    MOCK_METHOD1(dequeueBuffer_DEPRECATED, int(struct ANativeWindowBuffer**));
-    MOCK_METHOD1(lockBuffer_DEPRECATED, int(struct ANativeWindowBuffer*));
-    MOCK_METHOD1(queueBuffer_DEPRECATED, int(struct ANativeWindowBuffer*));
-    MOCK_CONST_METHOD2(query, int(int, int*));
-    MOCK_METHOD1(perform, int(int));
-    MOCK_METHOD1(cancelBuffer_DEPRECATED, int(struct ANativeWindowBuffer*));
-    MOCK_METHOD2(dequeueBuffer, int(struct ANativeWindowBuffer**, int*));
-    MOCK_METHOD2(queueBuffer, int(struct ANativeWindowBuffer*, int));
-    MOCK_METHOD2(cancelBuffer, int(struct ANativeWindowBuffer*, int));
-};
-
-} // namespace mock
-} // namespace android
diff --git a/services/surfaceflinger/tests/vsync/Android.bp b/services/surfaceflinger/tests/vsync/Android.bp
deleted file mode 100644
index d04efda9e..000000000
--- a/services/surfaceflinger/tests/vsync/Android.bp
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_binary {
-    name: "test-vsync-events",
-    defaults: ["surfaceflinger_defaults"],
-    tags: ["test"],
-    srcs: [
-        "vsync.cpp",
-    ],
-    shared_libs: [
-        "libbinder",
-        "libcutils",
-        "libgui",
-        "libui",
-        "libutils",
-    ]
-
-}
diff --git a/services/surfaceflinger/tests/vsync/vsync.cpp b/services/surfaceflinger/tests/vsync/vsync.cpp
deleted file mode 100644
index a1b45e6ad..000000000
--- a/services/surfaceflinger/tests/vsync/vsync.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android/looper.h>
-#include <gui/DisplayEventReceiver.h>
-#include <utils/Looper.h>
-
-using namespace android;
-
-int receiver(int /*fd*/, int /*events*/, void* data)
-{
-    DisplayEventReceiver* q = (DisplayEventReceiver*)data;
-
-    ssize_t n;
-    DisplayEventReceiver::Event buffer[1];
-
-    static nsecs_t oldTimeStamp = 0;
-
-    while ((n = q->getEvents(buffer, 1)) > 0) {
-        for (int i=0 ; i<n ; i++) {
-            if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) {
-                printf("event vsync: count=%d\t", buffer[i].vsync.count);
-            }
-            if (oldTimeStamp) {
-                float t = float(buffer[i].header.timestamp - oldTimeStamp) / s2ns(1);
-                printf("%f ms (%f Hz)\n", t*1000, 1.0/t);
-            }
-            oldTimeStamp = buffer[i].header.timestamp;
-        }
-    }
-    if (n<0) {
-        printf("error reading events (%s)\n", strerror(-n));
-    }
-    return 1;
-}
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    DisplayEventReceiver myDisplayEvent;
-
-
-    sp<Looper> loop = new Looper(false);
-    loop->addFd(myDisplayEvent.getFd(), 0, ALOOPER_EVENT_INPUT, receiver,
-            &myDisplayEvent);
-
-    myDisplayEvent.setVsyncRate(1);
-
-    do {
-        //printf("about to poll...\n");
-        int32_t ret = loop->pollOnce(-1);
-        switch (ret) {
-            case ALOOPER_POLL_WAKE:
-                //("ALOOPER_POLL_WAKE\n");
-                break;
-            case ALOOPER_POLL_CALLBACK:
-                //("ALOOPER_POLL_CALLBACK\n");
-                break;
-            case ALOOPER_POLL_TIMEOUT:
-                printf("ALOOPER_POLL_TIMEOUT\n");
-                break;
-            case ALOOPER_POLL_ERROR:
-                printf("ALOOPER_POLL_TIMEOUT\n");
-                break;
-            default:
-                printf("ugh? poll returned %d\n", ret);
-                break;
-        }
-    } while (1);
-
-    return 0;
-}
diff --git a/services/surfaceflinger/tests/waitforvsync/Android.bp b/services/surfaceflinger/tests/waitforvsync/Android.bp
deleted file mode 100644
index cb6d0fde0..000000000
--- a/services/surfaceflinger/tests/waitforvsync/Android.bp
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright (C) 2018 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_binary {
-    name: "test-waitforvsync",
-    cflags: [
-        "-Werror",
-    ],
-    srcs: [
-        "waitforvsync.cpp",
-    ],
-    shared_libs: [
-        "libcutils",
-    ]
-}
diff --git a/services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp b/services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp
deleted file mode 100644
index 65eaae58b..000000000
--- a/services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <linux/fb.h>
-#include <errno.h>
-#include <string.h>
-#include <stdio.h>
-#include <unistd.h>
-
-#ifndef FBIO_WAITFORVSYNC
-#define FBIO_WAITFORVSYNC   _IOW('F', 0x20, __u32)
-#endif
-
-int main(int /*argc*/, char** /*argv*/) {
-    int fd = open("/dev/graphics/fb0", O_RDWR);
-    if (fd >= 0) {
-        do {
-            uint32_t crt = 0;
-           int err = ioctl(fd, FBIO_WAITFORVSYNC, &crt);
-           if (err < 0) {
-               printf("FBIO_WAITFORVSYNC error: %s\n", strerror(errno));
-               break;
-           }
-        } while(1);
-        close(fd);
-    }
-    return 0;
-}
-- 
2.11.0

