Subject: [PATCH] Fix leak of file descriptor and memory. 
 1. fds must be explicitly closed if it is not retained by unflatten(). 
 2. must delete handle before setting to NULL.

diff --git a/libs/gui/BufferItem.cpp b/libs/gui/BufferItem.cpp
index 5e3924a..64804af 100644
--- a/libs/gui/BufferItem.cpp
+++ b/libs/gui/BufferItem.cpp
@@ -159,6 +159,9 @@
         void const*& buffer, size_t& size, int const*& fds, size_t& count) {
 
     if (size < sizeof(uint32_t)) {
+        for (size_t i = 0; i < count; i++) {
+            close(fds[i]);
+        }
         return NO_MEMORY;
     }
 
diff --git a/libs/ui/Fence.cpp b/libs/ui/Fence.cpp
index bf24ffb..f668652 100644
--- a/libs/ui/Fence.cpp
+++ b/libs/ui/Fence.cpp
@@ -152,24 +152,29 @@
 }
 
 status_t Fence::unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count) {
+    status_t ret = NO_ERROR;
     if (mFenceFd != -1) {
         // Don't unflatten if we already have a valid fd.
-        return INVALID_OPERATION;
+        ret = INVALID_OPERATION;
+        goto free;
     }
 
     if (size < getFlattenedSize()) {
-        return NO_MEMORY;
+        ret = NO_MEMORY;
+        goto free;
     }
 
     uint32_t numFds;
     FlattenableUtils::read(buffer, size, numFds);
 
     if (numFds > 1) {
-        return BAD_VALUE;
+        ret = BAD_VALUE;
+        goto free;
     }
 
     if (count < numFds) {
-        return NO_MEMORY;
+        ret = NO_MEMORY;
+        goto free;
     }
 
     if (numFds) {
@@ -178,6 +183,14 @@
     }
 
     return NO_ERROR;
+
+free:
+    // If a fd is not retained by unflatten() it must be
+    // explicitly closed.
+    for(size_t i = 0; i < count; i++) {
+        close(fds[i]);
+    }
+    return ret;
 }
 
 } // namespace android
diff --git a/libs/ui/GraphicBuffer.cpp b/libs/ui/GraphicBuffer.cpp
index 4fe0946..d3b6135 100644
--- a/libs/ui/GraphicBuffer.cpp
+++ b/libs/ui/GraphicBuffer.cpp
@@ -331,32 +331,51 @@
 
 status_t GraphicBuffer::unflatten(
         void const*& buffer, size_t& size, int const*& fds, size_t& count) {
-    if (size < 11 * sizeof(int)) return NO_MEMORY;
+    status_t ret = NO_ERROR;
+    int const* buf = NULL;
+    size_t numFds = 0;
+    size_t numInts = 0;
+    const size_t maxNumber = 4096;
+    size_t sizeNeeded = 0;
+    size_t fdCountNeeded = 0;
+    if (size < 11 * sizeof(int)) {
+        ret = NO_MEMORY;
+        goto free;
+    }
 
-    int const* buf = static_cast<int const*>(buffer);
-    if (buf[0] != 'GBFR') return BAD_TYPE;
+    buf = static_cast<int const*>(buffer);
+    if (buf[0] != 'GBFR') {
+        ret = BAD_TYPE;
+        goto free;
+    }
 
-    const size_t numFds  = static_cast<size_t>(buf[9]);
-    const size_t numInts = static_cast<size_t>(buf[10]);
+    numFds = static_cast<size_t>(buf[9]);
+    numInts = static_cast<size_t>(buf[10]);
 
     // Limit the maxNumber to be relatively small. The number of fds or ints
     // should not come close to this number, and the number itself was simply
     // chosen to be high enough to not cause issues and low enough to prevent
     // overflow problems.
-    const size_t maxNumber = 4096;
     if (numFds >= maxNumber || numInts >= (maxNumber - 11)) {
         width = height = stride = format = usage = 0;
         handle = NULL;
         ALOGE("unflatten: numFds or numInts is too large: %zd, %zd",
                 numFds, numInts);
-        return BAD_VALUE;
+        ret = BAD_VALUE;
+        goto free;
     }
 
-    const size_t sizeNeeded = (11 + numInts) * sizeof(int);
-    if (size < sizeNeeded) return NO_MEMORY;
+    sizeNeeded = (11 + numInts) * sizeof(int);
+    if (size < sizeNeeded) {
+        ret = NO_MEMORY;
+        goto free;
+    }
 
-    size_t fdCountNeeded = numFds;
-    if (count < fdCountNeeded) return NO_MEMORY;
+    fdCountNeeded = numFds;
+    if (count < fdCountNeeded) {
+        ret = NO_MEMORY;
+        goto free;
+    }
 
     if (handle) {
         // free previous handle if any
@@ -375,7 +394,8 @@
             width = height = stride = format = usage = 0;
             handle = NULL;
             ALOGE("unflatten: native_handle_create failed");
-            return NO_MEMORY;
+            ret = NO_MEMORY;
+            goto free;
         }
         memcpy(h->data, fds, numFds * sizeof(int));
         memcpy(h->data + numFds, &buf[11], numInts * sizeof(int));
@@ -396,10 +416,13 @@
         status_t err = mBufferMapper.registerBuffer(handle);
         if (err != NO_ERROR) {
             width = height = stride = format = usage = 0;
+            // Must delete handle before setting to NULL
+            native_handle_delete(const_cast<native_handle*>(handle));
             handle = NULL;
             ALOGE("unflatten: registerBuffer failed: %s (%d)",
                     strerror(-err), err);
-            return err;
+            ret = err;
+            goto free;
         }
     }
 
@@ -409,6 +432,14 @@
     count -= numFds;
 
     return NO_ERROR;
+
+free:
+    // If a fd is not retained by unflatten() it must be
+    // explicitly closed.
+    for(size_t i = 0; i < count; i++) {
+        close(fds[i]);
+    }
+    return ret;
 }
 
 // ---------------------------------------------------------------------------
