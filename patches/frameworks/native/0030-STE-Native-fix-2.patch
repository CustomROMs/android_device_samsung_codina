From 906da9dcb39ab9571ea8a7b7db530d6d420b0ab1 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH 30/46] STE Native fix [2]

---
 libs/binder/include/binder/SafeInterface.h    | 8 ++++----
 libs/gui/include/gui/FrameTimestamps.h        | 9 +++++++++
 libs/gui/include/gui/GLConsumer.h             | 1 +
 libs/gui/include/gui/IGraphicBufferProducer.h | 4 ++++
 libs/ui/include/ui/FenceTime.h                | 4 ++++
 5 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/libs/binder/include/binder/SafeInterface.h b/libs/binder/include/binder/SafeInterface.h
index 3bfd462807..38ba7e1a06 100644
--- a/libs/binder/include/binder/SafeInterface.h
+++ b/libs/binder/include/binder/SafeInterface.h
@@ -60,23 +60,23 @@ public:
         return write(parcel, static_cast<typename std::underlying_type<E>::type>(e));
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type read(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type read(
             const Parcel& parcel, T* t) const {
         return callParcel("read(Flattenable)", [&]() { return parcel.read(*t); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type write(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type write(
             Parcel* parcel, const T& t) const {
         return callParcel("write(Flattenable)", [&]() { return parcel->write(t); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type read(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type read(
             const Parcel& parcel, sp<T>* t) const {
         *t = new T{};
         return callParcel("read(sp<Flattenable>)", [&]() { return parcel.read(*(t->get())); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type write(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type write(
             Parcel* parcel, const sp<T>& t) const {
         return callParcel("write(sp<Flattenable>)", [&]() { return parcel->write(*(t.get())); });
     }
diff --git a/libs/gui/include/gui/FrameTimestamps.h b/libs/gui/include/gui/FrameTimestamps.h
index 9716be4bfd..a1c7ee35eb 100644
--- a/libs/gui/include/gui/FrameTimestamps.h
+++ b/libs/gui/include/gui/FrameTimestamps.h
@@ -242,7 +242,11 @@ private:
 // through Binder.
 // Although this may be sent multiple times for the same frame as new
 // timestamps are set, Fences only need to be sent once.
+#ifdef STE_HARDWARE
+class FrameEventsDelta : public Flattenable {
+#else
 class FrameEventsDelta : public Flattenable<FrameEventsDelta> {
+#endif
 friend class ProducerFrameEventHistory;
 public:
     FrameEventsDelta() = default;
@@ -300,8 +304,13 @@ private:
 
 // A collection of updates from consumer to producer that can be sent
 // through Binder.
+#ifdef STE_HARDWARE
+class FrameEventHistoryDelta
+        : public Flattenable {
+#else
 class FrameEventHistoryDelta
         : public Flattenable<FrameEventHistoryDelta> {
+#endif
 
 friend class ConsumerFrameEventHistory;
 friend class ProducerFrameEventHistory;
diff --git a/libs/gui/include/gui/GLConsumer.h b/libs/gui/include/gui/GLConsumer.h
index 87d9e020be..734c80fb09 100644
--- a/libs/gui/include/gui/GLConsumer.h
+++ b/libs/gui/include/gui/GLConsumer.h
@@ -20,6 +20,7 @@
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
+#include <gui/BufferQueue.h>
 #include <gui/BufferQueueDefs.h>
 #include <gui/ConsumerBase.h>
 
diff --git a/libs/gui/include/gui/IGraphicBufferProducer.h b/libs/gui/include/gui/IGraphicBufferProducer.h
index feaf040fcd..7a27c18c55 100644
--- a/libs/gui/include/gui/IGraphicBufferProducer.h
+++ b/libs/gui/include/gui/IGraphicBufferProducer.h
@@ -371,7 +371,11 @@ public:
         bool getFrameTimestamps{false};
     };
 
+#ifdef STE_HARDWARE
+    struct QueueBufferOutput : public Flattenable {
+#else
     struct QueueBufferOutput : public Flattenable<QueueBufferOutput> {
+#endif
         QueueBufferOutput() = default;
 
         // Moveable.
diff --git a/libs/ui/include/ui/FenceTime.h b/libs/ui/include/ui/FenceTime.h
index 871fcf2dfe..83e13cc260 100644
--- a/libs/ui/include/ui/FenceTime.h
+++ b/libs/ui/include/ui/FenceTime.h
@@ -42,7 +42,11 @@ public:
     // consistent for all steps of the flattening process.
     //
     // Not thread safe.
+#ifdef STE_HARDWARE
+    struct Snapshot : public Flattenable {
+#else
     struct Snapshot : public Flattenable<Snapshot> {
+#endif
         enum class State {
             EMPTY,
             FENCE,
-- 
2.17.0

