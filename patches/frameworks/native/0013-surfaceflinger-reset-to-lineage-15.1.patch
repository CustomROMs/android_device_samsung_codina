From c01cd4bbc83ab379ff45f7d4ce878b46434939cc Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sun, 2 Sep 2018 11:05:46 +0300
Subject: [PATCH 13/45] surfaceflinger: reset to lineage-15.1

Change-Id: Ic4ba559e0d6f8d8773fc5c9983b9bc548e7602fe
---
 libs/gui/ISurfaceComposer.cpp                 |   42 -
 libs/gui/include/gui/ISurfaceComposer.h       |    6 -
 libs/gui/tests/Android.bp                     |   51 -
 libs/gui/tests/AndroidTest.xml                |   26 -
 libs/gui/tests/BufferItemConsumer_test.cpp    |  206 -
 libs/gui/tests/BufferQueue_test.cpp           | 1195 -----
 libs/gui/tests/CpuConsumer_test.cpp           |  746 ---
 libs/gui/tests/DisconnectWaiter.h             |   80 -
 libs/gui/tests/DummyConsumer.h                |   27 -
 libs/gui/tests/FillBuffer.cpp                 |  108 -
 libs/gui/tests/FillBuffer.h                   |   43 -
 libs/gui/tests/FrameWaiter.h                  |   52 -
 libs/gui/tests/GLTest.cpp                     |  339 --
 libs/gui/tests/GLTest.h                       |   72 -
 .../gui/tests/IGraphicBufferProducer_test.cpp |  735 ---
 libs/gui/tests/Malicious.cpp                  |  207 -
 libs/gui/tests/MultiTextureConsumer_test.cpp  |  126 -
 libs/gui/tests/StreamSplitter_test.cpp        |  239 -
 libs/gui/tests/SurfaceTextureClient_test.cpp  |  811 ---
 libs/gui/tests/SurfaceTextureFBO.h            |   75 -
 libs/gui/tests/SurfaceTextureFBO_test.cpp     |   91 -
 libs/gui/tests/SurfaceTextureGL.h             |   74 -
 libs/gui/tests/SurfaceTextureGLThreadToGL.h   |  183 -
 .../tests/SurfaceTextureGLThreadToGL_test.cpp |  194 -
 libs/gui/tests/SurfaceTextureGLToGL.h         |   67 -
 libs/gui/tests/SurfaceTextureGLToGL_test.cpp  |  526 --
 libs/gui/tests/SurfaceTextureGL_test.cpp      |  737 ---
 libs/gui/tests/SurfaceTextureMultiContextGL.h |   85 -
 .../SurfaceTextureMultiContextGL_test.cpp     |  461 --
 libs/gui/tests/Surface_test.cpp               | 1587 ------
 libs/gui/tests/TextureRenderer.cpp            |  117 -
 libs/gui/tests/TextureRenderer.h              |   46 -
 services/surfaceflinger/Android.bp            |    2 -
 services/surfaceflinger/Android.mk            |    4 +-
 services/surfaceflinger/DispSync.cpp          |    5 +-
 services/surfaceflinger/DisplayDevice.cpp     |    8 -
 services/surfaceflinger/DisplayDevice.h       |    4 -
 services/surfaceflinger/EventThread.cpp       |    7 +-
 services/surfaceflinger/Layer.cpp             |  107 +-
 services/surfaceflinger/Layer.h               |    8 +-
 services/surfaceflinger/MessageQueue.cpp      |    8 +
 services/surfaceflinger/SurfaceFlinger.h      |   32 +-
 .../surfaceflinger/SurfaceFlinger_hwc1.cpp    |   33 +-
 services/surfaceflinger/Transform.cpp         |   21 -
 services/surfaceflinger/Transform.h           |    1 -
 .../surfaceflinger/main_surfaceflinger.cpp    |    2 +
 services/surfaceflinger/tests/Android.mk      |   44 -
 services/surfaceflinger/tests/AndroidTest.xml |   26 -
 services/surfaceflinger/tests/Stress_test.cpp |   50 -
 .../tests/SurfaceFlinger_test.filter          |    5 -
 .../tests/SurfaceInterceptor_test.cpp         |  864 ----
 .../surfaceflinger/tests/Transaction_test.cpp | 1126 ----
 .../surfaceflinger/tests/fakehwc/Android.bp   |   34 -
 .../tests/fakehwc/FakeComposerClient.cpp      |  617 ---
 .../tests/fakehwc/FakeComposerClient.h        |  148 -
 .../tests/fakehwc/FakeComposerService.cpp     |   54 -
 .../tests/fakehwc/FakeComposerService.h       |   40 -
 .../tests/fakehwc/FakeComposerUtils.cpp       |  183 -
 .../tests/fakehwc/FakeComposerUtils.h         |  119 -
 .../tests/fakehwc/RenderState.h               |   44 -
 .../tests/fakehwc/SFFakeHwc_test.cpp          | 1306 -----
 services/surfaceflinger/tests/hwc2/Android.mk |   54 -
 .../surfaceflinger/tests/hwc2/Hwc2Test.cpp    | 4559 -----------------
 .../tests/hwc2/Hwc2TestBuffer.cpp             |  695 ---
 .../tests/hwc2/Hwc2TestBuffer.h               |   74 -
 .../tests/hwc2/Hwc2TestClientTarget.cpp       |  102 -
 .../tests/hwc2/Hwc2TestClientTarget.h         |   69 -
 .../tests/hwc2/Hwc2TestLayer.cpp              |  249 -
 .../surfaceflinger/tests/hwc2/Hwc2TestLayer.h |  103 -
 .../tests/hwc2/Hwc2TestLayers.cpp             |  281 -
 .../tests/hwc2/Hwc2TestLayers.h               |   86 -
 .../tests/hwc2/Hwc2TestProperties.cpp         |  782 ---
 .../tests/hwc2/Hwc2TestProperties.h           |  384 --
 .../tests/hwc2/Hwc2TestVirtualDisplay.cpp     |   61 -
 .../tests/hwc2/Hwc2TestVirtualDisplay.h       |   49 -
 .../surfaceflinger/tests/vsync/Android.mk     |   20 -
 services/surfaceflinger/tests/vsync/vsync.cpp |   84 -
 .../tests/waitforvsync/Android.mk             |   16 -
 .../tests/waitforvsync/waitforvsync.cpp       |   46 -
 79 files changed, 96 insertions(+), 21874 deletions(-)
 delete mode 100644 libs/gui/tests/Android.bp
 delete mode 100644 libs/gui/tests/AndroidTest.xml
 delete mode 100644 libs/gui/tests/BufferItemConsumer_test.cpp
 delete mode 100644 libs/gui/tests/BufferQueue_test.cpp
 delete mode 100644 libs/gui/tests/CpuConsumer_test.cpp
 delete mode 100644 libs/gui/tests/DisconnectWaiter.h
 delete mode 100644 libs/gui/tests/DummyConsumer.h
 delete mode 100644 libs/gui/tests/FillBuffer.cpp
 delete mode 100644 libs/gui/tests/FillBuffer.h
 delete mode 100644 libs/gui/tests/FrameWaiter.h
 delete mode 100644 libs/gui/tests/GLTest.cpp
 delete mode 100644 libs/gui/tests/GLTest.h
 delete mode 100644 libs/gui/tests/IGraphicBufferProducer_test.cpp
 delete mode 100644 libs/gui/tests/Malicious.cpp
 delete mode 100644 libs/gui/tests/MultiTextureConsumer_test.cpp
 delete mode 100644 libs/gui/tests/StreamSplitter_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureClient_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureFBO.h
 delete mode 100644 libs/gui/tests/SurfaceTextureFBO_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureGLThreadToGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureGLToGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureGLToGL_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureGL_test.cpp
 delete mode 100644 libs/gui/tests/SurfaceTextureMultiContextGL.h
 delete mode 100644 libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp
 delete mode 100644 libs/gui/tests/Surface_test.cpp
 delete mode 100644 libs/gui/tests/TextureRenderer.cpp
 delete mode 100644 libs/gui/tests/TextureRenderer.h
 delete mode 100644 services/surfaceflinger/tests/Android.mk
 delete mode 100644 services/surfaceflinger/tests/AndroidTest.xml
 delete mode 100644 services/surfaceflinger/tests/Stress_test.cpp
 delete mode 100644 services/surfaceflinger/tests/SurfaceFlinger_test.filter
 delete mode 100644 services/surfaceflinger/tests/SurfaceInterceptor_test.cpp
 delete mode 100644 services/surfaceflinger/tests/Transaction_test.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/Android.bp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerClient.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerService.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp
 delete mode 100644 services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/RenderState.h
 delete mode 100644 services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Android.mk
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2Test.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp
 delete mode 100644 services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h
 delete mode 100644 services/surfaceflinger/tests/vsync/Android.mk
 delete mode 100644 services/surfaceflinger/tests/vsync/vsync.cpp
 delete mode 100644 services/surfaceflinger/tests/waitforvsync/Android.mk
 delete mode 100644 services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp

diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index 8e7f814313..0a0d112af6 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -28,7 +28,6 @@
 #include <gui/IGraphicBufferProducer.h>
 #include <gui/ISurfaceComposer.h>
 #include <gui/ISurfaceComposerClient.h>
-#include <gui/LayerDebugInfo.h>
 
 #include <private/gui/LayerState.h>
 
@@ -470,36 +469,6 @@ public:
         return result;
     }
 
-    virtual status_t getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayers) const
-    {
-        if (!outLayers) {
-            return UNEXPECTED_NULL;
-        }
-
-        Parcel data, reply;
-
-        status_t err = data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
-        if (err != NO_ERROR) {
-            return err;
-        }
-
-        err = remote()->transact(BnSurfaceComposer::GET_LAYER_DEBUG_INFO, data, &reply);
-        if (err != NO_ERROR) {
-            return err;
-        }
-
-        int32_t result = 0;
-        err = reply.readInt32(&result);
-        if (err != NO_ERROR) {
-            return err;
-        }
-        if (result != NO_ERROR) {
-            return result;
-        }
-
-        outLayers->clear();
-        return reply.readParcelableVector(outLayers);
-    }
 };
 
 // Out-of-line virtual method definition to trigger vtable emission in this
@@ -794,17 +763,6 @@ status_t BnSurfaceComposer::onTransact(
             }
             return injectVSync(when);
         }
-        case GET_LAYER_DEBUG_INFO: {
-            CHECK_INTERFACE(ISurfaceComposer, data, reply);
-            std::vector<LayerDebugInfo> outLayers;
-            status_t result = getLayerDebugInfo(&outLayers);
-            reply->writeInt32(result);
-            if (result == NO_ERROR)
-            {
-                result = reply->writeParcelableVector(outLayers);
-            }
-            return result;
-        }
         default: {
             return BBinder::onTransact(code, data, reply, flags);
         }
diff --git a/libs/gui/include/gui/ISurfaceComposer.h b/libs/gui/include/gui/ISurfaceComposer.h
index b2267426a8..4b924e186c 100644
--- a/libs/gui/include/gui/ISurfaceComposer.h
+++ b/libs/gui/include/gui/ISurfaceComposer.h
@@ -196,12 +196,6 @@ public:
     virtual status_t enableVSyncInjections(bool enable) = 0;
 
     virtual status_t injectVSync(nsecs_t when) = 0;
-
-    /* Gets the list of active layers in Z order for debugging purposes
-     *
-     * Requires the ACCESS_SURFACE_FLINGER permission.
-     */
-    virtual status_t getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayers) const = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/libs/gui/tests/Android.bp b/libs/gui/tests/Android.bp
deleted file mode 100644
index 908959ce1a..0000000000
--- a/libs/gui/tests/Android.bp
+++ /dev/null
@@ -1,51 +0,0 @@
-// Build the unit tests,
-
-// Build the binary to $(TARGET_OUT_DATA_NATIVE_TESTS)/$(LOCAL_MODULE)
-// to integrate with auto-test framework.
-cc_test {
-    name: "libgui_test",
-    test_suites: ["device-tests"],
-
-    clang: true,
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    srcs: [
-        "BufferItemConsumer_test.cpp",
-        "BufferQueue_test.cpp",
-        "CpuConsumer_test.cpp",
-        "FillBuffer.cpp",
-        "GLTest.cpp",
-        "IGraphicBufferProducer_test.cpp",
-        "Malicious.cpp",
-        "MultiTextureConsumer_test.cpp",
-        "StreamSplitter_test.cpp",
-        "SurfaceTextureClient_test.cpp",
-        "SurfaceTextureFBO_test.cpp",
-        "SurfaceTextureGLThreadToGL_test.cpp",
-        "SurfaceTextureGLToGL_test.cpp",
-        "SurfaceTextureGL_test.cpp",
-        "SurfaceTextureMultiContextGL_test.cpp",
-        "Surface_test.cpp",
-        "TextureRenderer.cpp",
-    ],
-
-    shared_libs: [
-        "android.hardware.configstore@1.0",
-        "android.hardware.configstore-utils",
-        "liblog",
-        "libEGL",
-        "libGLESv1_CM",
-        "libGLESv2",
-        "libbinder",
-        "libcutils",
-        "libgui",
-        "libhidlbase",
-        "libhidltransport",
-        "libui",
-        "libutils",
-        "libnativewindow"
-    ],
-}
diff --git a/libs/gui/tests/AndroidTest.xml b/libs/gui/tests/AndroidTest.xml
deleted file mode 100644
index c02e020be6..0000000000
--- a/libs/gui/tests/AndroidTest.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2017 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Config for libgui_test">
-    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
-        <option name="cleanup" value="true" />
-        <option name="push" value="libgui_test->/data/local/tmp/libgui_test" />
-    </target_preparer>
-    <option name="test-suite-tag" value="apct" />
-    <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp" />
-        <option name="module-name" value="libgui_test" />
-    </test>
-</configuration>
\ No newline at end of file
diff --git a/libs/gui/tests/BufferItemConsumer_test.cpp b/libs/gui/tests/BufferItemConsumer_test.cpp
deleted file mode 100644
index b87cbbdec8..0000000000
--- a/libs/gui/tests/BufferItemConsumer_test.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "BufferItemConsumer_test"
-//#define LOG_NDEBUG 0
-
-#include <gtest/gtest.h>
-#include <gui/BufferItemConsumer.h>
-#include <gui/IProducerListener.h>
-#include <gui/Surface.h>
-
-namespace android {
-
-static constexpr int kWidth = 100;
-static constexpr int kHeight = 100;
-static constexpr int kMaxLockedBuffers = 3;
-static constexpr int kFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-static constexpr int kFrameSleepUs = 30 * 1000;
-
-class BufferItemConsumerTest : public ::testing::Test {
-   protected:
-    struct BufferFreedListener
-        : public BufferItemConsumer::BufferFreedListener {
-        explicit BufferFreedListener(BufferItemConsumerTest* test)
-            : mTest(test) {}
-        void onBufferFreed(const wp<GraphicBuffer>& /* gBuffer */) override {
-            mTest->HandleBufferFreed();
-        }
-        BufferItemConsumerTest* mTest;
-    };
-
-    void SetUp() override {
-        BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-        mBIC =
-            new BufferItemConsumer(mConsumer, kFormat, kMaxLockedBuffers, true);
-        String8 name("BufferItemConsumer_Under_Test");
-        mBIC->setName(name);
-        mBFL = new BufferFreedListener(this);
-        mBIC->setBufferFreedListener(mBFL);
-
-        sp<IProducerListener> producerListener = new DummyProducerListener();
-        IGraphicBufferProducer::QueueBufferOutput bufferOutput;
-        ASSERT_EQ(NO_ERROR,
-                  mProducer->connect(producerListener, NATIVE_WINDOW_API_CPU,
-                                     true, &bufferOutput));
-        ASSERT_EQ(NO_ERROR,
-                  mProducer->setMaxDequeuedBufferCount(kMaxLockedBuffers));
-    }
-
-    int GetFreedBufferCount() {
-        std::lock_guard<std::mutex> lock(mMutex);
-        return mFreedBufferCount;
-    }
-
-    void HandleBufferFreed() {
-        std::lock_guard<std::mutex> lock(mMutex);
-        mFreedBufferCount++;
-        ALOGV("HandleBufferFreed, mFreedBufferCount=%d", mFreedBufferCount);
-    }
-
-    void DequeueBuffer(int* outSlot) {
-        ASSERT_NE(outSlot, nullptr);
-
-        int slot;
-        sp<Fence> outFence;
-        status_t ret = mProducer->dequeueBuffer(&slot, &outFence, kWidth, kHeight, 0, 0,
-                                                nullptr, nullptr);
-        ASSERT_GE(ret, 0);
-
-        ALOGV("dequeueBuffer: slot=%d", slot);
-        if (ret & IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) {
-            ret = mProducer->requestBuffer(slot, &mBuffers[slot]);
-            ASSERT_EQ(NO_ERROR, ret);
-        }
-        *outSlot = slot;
-    }
-
-    void QueueBuffer(int slot) {
-        ALOGV("enqueueBuffer: slot=%d", slot);
-        IGraphicBufferProducer::QueueBufferInput bufferInput(
-            0ULL, true, HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-        IGraphicBufferProducer::QueueBufferOutput bufferOutput;
-        status_t ret = mProducer->queueBuffer(slot, bufferInput, &bufferOutput);
-        ASSERT_EQ(NO_ERROR, ret);
-    }
-
-    void AcquireBuffer(int* outSlot) {
-        ASSERT_NE(outSlot, nullptr);
-        BufferItem buffer;
-        status_t ret = mBIC->acquireBuffer(&buffer, 0, false);
-        ASSERT_EQ(NO_ERROR, ret);
-
-        ALOGV("acquireBuffer: slot=%d", buffer.mSlot);
-        *outSlot = buffer.mSlot;
-    }
-
-    void ReleaseBuffer(int slot) {
-        ALOGV("releaseBuffer: slot=%d", slot);
-        BufferItem buffer;
-        buffer.mSlot = slot;
-        buffer.mGraphicBuffer = mBuffers[slot];
-        status_t ret = mBIC->releaseBuffer(buffer, Fence::NO_FENCE);
-        ASSERT_EQ(NO_ERROR, ret);
-    }
-
-
-    std::mutex mMutex;
-    int mFreedBufferCount{0};
-
-    sp<BufferItemConsumer> mBIC;
-    sp<BufferFreedListener> mBFL;
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-    sp<GraphicBuffer> mBuffers[BufferQueueDefs::NUM_BUFFER_SLOTS];
-};
-
-// Test that detaching buffer from consumer side triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_DetachBufferFromConsumer) {
-    int slot;
-    // Producer: generate a dummy buffer.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-
-    ASSERT_EQ(0, GetFreedBufferCount());
-    // Consumer: acquire the buffer and then detach it.
-    AcquireBuffer(&slot);
-    status_t ret = mBIC->detachBuffer(slot);
-    ASSERT_EQ(NO_ERROR, ret);
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-// Test that detaching buffer from producer side triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_DetachBufferFromProducer) {
-    int slot;
-    // Let buffer go through the cycle at least once.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-    AcquireBuffer(&slot);
-    ReleaseBuffer(slot);
-
-    ASSERT_EQ(0, GetFreedBufferCount());
-
-    // Producer: generate the buffer again.
-    DequeueBuffer(&slot);
-
-    // Producer: detach the buffer.
-    status_t ret = mProducer->detachBuffer(slot);
-    ASSERT_EQ(NO_ERROR, ret);
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-// Test that abandoning BufferItemConsumer triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_AbandonBufferItemConsumer) {
-    int slot;
-    // Let buffer go through the cycle at least once.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-    AcquireBuffer(&slot);
-    ReleaseBuffer(slot);
-
-    // Abandon the BufferItemConsumer.
-    mBIC->abandon();
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-// Test that delete BufferItemConsumer triggers onBufferFreed.
-TEST_F(BufferItemConsumerTest, TriggerBufferFreed_DeleteBufferItemConsumer) {
-    int slot;
-    // Let buffer go through the cycle at least once.
-    DequeueBuffer(&slot);
-    QueueBuffer(slot);
-    AcquireBuffer(&slot);
-    ReleaseBuffer(slot);
-
-    // Delete the BufferItemConsumer.
-    mBIC.clear();
-
-    // Sleep to give some time for callbacks to happen.
-    usleep(kFrameSleepUs);
-    ASSERT_EQ(1, GetFreedBufferCount());
-}
-
-}  // namespace android
diff --git a/libs/gui/tests/BufferQueue_test.cpp b/libs/gui/tests/BufferQueue_test.cpp
deleted file mode 100644
index 9a208593ab..0000000000
--- a/libs/gui/tests/BufferQueue_test.cpp
+++ /dev/null
@@ -1,1195 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "BufferQueue_test"
-//#define LOG_NDEBUG 0
-
-#include "DummyConsumer.h"
-
-#include <gui/BufferItem.h>
-#include <gui/BufferQueue.h>
-#include <gui/IProducerListener.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
-#include <binder/ProcessState.h>
-
-#include <utils/String8.h>
-#include <utils/threads.h>
-
-#include <system/window.h>
-
-#include <gtest/gtest.h>
-
-#include <thread>
-
-using namespace std::chrono_literals;
-
-namespace android {
-
-class BufferQueueTest : public ::testing::Test {
-
-public:
-protected:
-    BufferQueueTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    ~BufferQueueTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    void GetMinUndequeuedBufferCount(int* bufferCount) {
-        ASSERT_TRUE(bufferCount != NULL);
-        ASSERT_EQ(OK, mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-                    bufferCount));
-        ASSERT_GE(*bufferCount, 0);
-    }
-
-    void createBufferQueue() {
-        BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-    }
-
-    void testBufferItem(const IGraphicBufferProducer::QueueBufferInput& input,
-            const BufferItem& item) {
-        int64_t timestamp;
-        bool isAutoTimestamp;
-        android_dataspace dataSpace;
-        Rect crop;
-        int scalingMode;
-        uint32_t transform;
-        sp<Fence> fence;
-
-        input.deflate(&timestamp, &isAutoTimestamp, &dataSpace, &crop,
-                &scalingMode, &transform, &fence, NULL);
-        ASSERT_EQ(timestamp, item.mTimestamp);
-        ASSERT_EQ(isAutoTimestamp, item.mIsAutoTimestamp);
-        ASSERT_EQ(dataSpace, item.mDataSpace);
-        ASSERT_EQ(crop, item.mCrop);
-        ASSERT_EQ(static_cast<uint32_t>(scalingMode), item.mScalingMode);
-        ASSERT_EQ(transform, item.mTransform);
-        ASSERT_EQ(fence, item.mFence);
-    }
-
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-};
-
-static const uint32_t TEST_DATA = 0x12345678u;
-
-// XXX: Tests that fork a process to hold the BufferQueue must run before tests
-// that use a local BufferQueue, or else Binder will get unhappy
-//
-// In one instance this was a crash in the createBufferQueue where the
-// binder call to create a buffer allocator apparently got garbage back.
-// See b/36592665.
-TEST_F(BufferQueueTest, DISABLED_BufferQueueInAnotherProcess) {
-    const String16 PRODUCER_NAME = String16("BQTestProducer");
-    const String16 CONSUMER_NAME = String16("BQTestConsumer");
-
-    pid_t forkPid = fork();
-    ASSERT_NE(forkPid, -1);
-
-    if (forkPid == 0) {
-        // Child process
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        sp<IServiceManager> serviceManager = defaultServiceManager();
-        serviceManager->addService(PRODUCER_NAME, IInterface::asBinder(producer));
-        serviceManager->addService(CONSUMER_NAME, IInterface::asBinder(consumer));
-        ProcessState::self()->startThreadPool();
-        IPCThreadState::self()->joinThreadPool();
-        LOG_ALWAYS_FATAL("Shouldn't be here");
-    }
-
-    sp<IServiceManager> serviceManager = defaultServiceManager();
-    sp<IBinder> binderProducer =
-        serviceManager->getService(PRODUCER_NAME);
-    mProducer = interface_cast<IGraphicBufferProducer>(binderProducer);
-    EXPECT_TRUE(mProducer != NULL);
-    sp<IBinder> binderConsumer =
-        serviceManager->getService(CONSUMER_NAME);
-    mConsumer = interface_cast<IGraphicBufferConsumer>(binderConsumer);
-    EXPECT_TRUE(mConsumer != NULL);
-
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK,
-            mProducer->connect(NULL, NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-}
-
-TEST_F(BufferQueueTest, AcquireBuffer_ExceedsMaxAcquireCount_Fails) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-    IGraphicBufferProducer::QueueBufferOutput qbo;
-    mProducer->connect(new DummyProducerListener, NATIVE_WINDOW_API_CPU, false,
-            &qbo);
-    mProducer->setMaxDequeuedBufferCount(3);
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buf;
-    IGraphicBufferProducer::QueueBufferInput qbi(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item;
-
-    for (int i = 0; i < 2; i++) {
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                           nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    }
-
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-
-    // Acquire the third buffer, which should fail.
-    ASSERT_EQ(INVALID_OPERATION, mConsumer->acquireBuffer(&item, 0));
-}
-
-TEST_F(BufferQueueTest, SetMaxAcquiredBufferCountWithIllegalValues_ReturnsError) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    EXPECT_EQ(OK, mConsumer->setMaxBufferCount(10));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(10));
-
-    IGraphicBufferProducer::QueueBufferOutput qbo;
-    mProducer->connect(new DummyProducerListener, NATIVE_WINDOW_API_CPU, false,
-            &qbo);
-    mProducer->setMaxDequeuedBufferCount(3);
-
-    int minBufferCount;
-    ASSERT_NO_FATAL_FAILURE(GetMinUndequeuedBufferCount(&minBufferCount));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(
-                minBufferCount - 1));
-
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(0));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(-3));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(
-            BufferQueue::MAX_MAX_ACQUIRED_BUFFERS+1));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(100));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buf;
-    IGraphicBufferProducer::QueueBufferInput qbi(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item;
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(3));
-    for (int i = 0; i < 3; i++) {
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                           nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    }
-
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxAcquiredBufferCount(2));
-}
-
-TEST_F(BufferQueueTest, SetMaxAcquiredBufferCountWithLegalValues_Succeeds) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    IGraphicBufferProducer::QueueBufferOutput qbo;
-    mProducer->connect(new DummyProducerListener, NATIVE_WINDOW_API_CPU, false,
-            &qbo);
-    mProducer->setMaxDequeuedBufferCount(2);
-
-    int minBufferCount;
-    ASSERT_NO_FATAL_FAILURE(GetMinUndequeuedBufferCount(&minBufferCount));
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(1));
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(2));
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(minBufferCount));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buf;
-    IGraphicBufferProducer::QueueBufferInput qbi(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item;
-
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(3));
-
-    for (int i = 0; i < 2; i++) {
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(&slot, &fence, 1, 1, 0, GRALLOC_USAGE_SW_READ_OFTEN,
-                                           nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buf));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, qbi, &qbo));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    }
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(
-            BufferQueue::MAX_MAX_ACQUIRED_BUFFERS));
-}
-
-TEST_F(BufferQueueTest, SetMaxBufferCountWithLegalValues_Succeeds) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    // Test shared buffer mode
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(1));
-}
-
-TEST_F(BufferQueueTest, SetMaxBufferCountWithIllegalValues_ReturnsError) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    mConsumer->consumerConnect(dc, false);
-
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxBufferCount(0));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxBufferCount(
-            BufferQueue::NUM_BUFFER_SLOTS + 1));
-
-    EXPECT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(5));
-    EXPECT_EQ(BAD_VALUE, mConsumer->setMaxBufferCount(3));
-}
-
-TEST_F(BufferQueueTest, DetachAndReattachOnProducerSide) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(-1)); // Index too low
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(
-                BufferQueueDefs::NUM_BUFFER_SLOTS)); // Index too high
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(0)); // Not dequeued
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(slot)); // Not requested
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    ASSERT_EQ(OK, mProducer->detachBuffer(slot));
-    ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(slot)); // Not dequeued
-
-    sp<GraphicBuffer> safeToClobberBuffer;
-    // Can no longer request buffer from this slot
-    ASSERT_EQ(BAD_VALUE, mProducer->requestBuffer(slot, &safeToClobberBuffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    int newSlot;
-    ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(NULL, safeToClobberBuffer));
-    ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(&newSlot, NULL));
-
-    ASSERT_EQ(OK, mProducer->attachBuffer(&newSlot, buffer));
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(newSlot, input, &output));
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-}
-
-TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(-1)); // Index too low
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(
-            BufferQueueDefs::NUM_BUFFER_SLOTS)); // Index too high
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(0)); // Not acquired
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-
-    ASSERT_EQ(OK, mConsumer->detachBuffer(item.mSlot));
-    ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(item.mSlot)); // Not acquired
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(
-            GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-
-    int newSlot;
-    sp<GraphicBuffer> safeToClobberBuffer;
-    ASSERT_EQ(BAD_VALUE, mConsumer->attachBuffer(NULL, safeToClobberBuffer));
-    ASSERT_EQ(BAD_VALUE, mConsumer->attachBuffer(&newSlot, NULL));
-    ASSERT_EQ(OK, mConsumer->attachBuffer(&newSlot, item.mGraphicBuffer));
-
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(newSlot, 0, EGL_NO_DISPLAY,
-            EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, buffer->unlock());
-}
-
-TEST_F(BufferQueueTest, MoveFromConsumerToProducer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-    ASSERT_EQ(OK, mConsumer->detachBuffer(item.mSlot));
-
-    int newSlot;
-    ASSERT_EQ(OK, mProducer->attachBuffer(&newSlot, item.mGraphicBuffer));
-    ASSERT_EQ(OK, mProducer->queueBuffer(newSlot, input, &output));
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-}
-
-TEST_F(BufferQueueTest, TestDisallowingAllocation) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    static const uint32_t WIDTH = 320;
-    static const uint32_t HEIGHT = 240;
-
-    ASSERT_EQ(OK, mConsumer->setDefaultBufferSize(WIDTH, HEIGHT));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    // This should return an error since it would require an allocation
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-    ASSERT_EQ(WOULD_BLOCK,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-
-    // This should succeed, now that we've lifted the prohibition
-    ASSERT_EQ(OK, mProducer->allowAllocation(true));
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                       nullptr, nullptr));
-
-    // Release the previous buffer back to the BufferQueue
-    mProducer->cancelBuffer(slot, fence);
-
-    // This should fail since we're requesting a different size
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-    ASSERT_EQ(WOULD_BLOCK,
-              mProducer->dequeueBuffer(&slot, &fence, WIDTH * 2, HEIGHT * 2, 0,
-                                       GRALLOC_USAGE_SW_WRITE_OFTEN, nullptr, nullptr));
-}
-
-TEST_F(BufferQueueTest, TestGenerationNumbers) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    ASSERT_EQ(OK, mProducer->setGenerationNumber(1));
-
-    // Get one buffer to play with
-    int slot;
-    sp<Fence> fence;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    // Ensure that the generation number we set propagates to allocated buffers
-    ASSERT_EQ(1U, buffer->getGenerationNumber());
-
-    ASSERT_EQ(OK, mProducer->detachBuffer(slot));
-
-    ASSERT_EQ(OK, mProducer->setGenerationNumber(2));
-
-    // These should fail, since we've changed the generation number on the queue
-    int outSlot;
-    ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(&outSlot, buffer));
-    ASSERT_EQ(BAD_VALUE, mConsumer->attachBuffer(&outSlot, buffer));
-
-    buffer->setGenerationNumber(2);
-
-    // This should succeed now that we've changed the buffer's generation number
-    ASSERT_EQ(OK, mProducer->attachBuffer(&outSlot, buffer));
-
-    ASSERT_EQ(OK, mProducer->detachBuffer(outSlot));
-
-    // This should also succeed with the new generation number
-    ASSERT_EQ(OK, mConsumer->attachBuffer(&outSlot, buffer));
-}
-
-TEST_F(BufferQueueTest, TestSharedBufferModeWithoutAutoRefresh) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    ASSERT_EQ(OK, mProducer->setSharedBufferMode(true));
-
-    // Get a buffer
-    int sharedSlot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&sharedSlot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(sharedSlot, &buffer));
-
-    // Queue the buffer
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-
-    // Repeatedly queue and dequeue a buffer from the producer side, it should
-    // always return the same one. And we won't run out of buffers because it's
-    // always the same one and because async mode gets enabled.
-    int slot;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(sharedSlot, slot);
-        ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-    }
-
-    // acquire the buffer
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(sharedSlot, item.mSlot);
-    testBufferItem(input, item);
-    ASSERT_EQ(true, item.mQueuedBuffer);
-    ASSERT_EQ(false, item.mAutoRefresh);
-
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // attempt to acquire a second time should return no buffer available
-    ASSERT_EQ(IGraphicBufferConsumer::NO_BUFFER_AVAILABLE,
-            mConsumer->acquireBuffer(&item, 0));
-}
-
-TEST_F(BufferQueueTest, TestSharedBufferModeWithAutoRefresh) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    ASSERT_EQ(OK, mProducer->setSharedBufferMode(true));
-    ASSERT_EQ(OK, mProducer->setAutoRefresh(true));
-
-    // Get a buffer
-    int sharedSlot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&sharedSlot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(sharedSlot, &buffer));
-
-    // Queue the buffer
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-
-    // Repeatedly acquire and release a buffer from the consumer side, it should
-    // always return the same one.
-    BufferItem item;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(sharedSlot, item.mSlot);
-        testBufferItem(input, item);
-        ASSERT_EQ(i == 0, item.mQueuedBuffer);
-        ASSERT_EQ(true, item.mAutoRefresh);
-
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    }
-
-    // Repeatedly queue and dequeue a buffer from the producer side, it should
-    // always return the same one.
-    int slot;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(sharedSlot, slot);
-        ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-    }
-
-    // Repeatedly acquire and release a buffer from the consumer side, it should
-    // always return the same one. First grabbing them from the queue and then
-    // when the queue is empty, returning the shared buffer.
-    for (int i = 0; i < 10; i++) {
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(sharedSlot, item.mSlot);
-        ASSERT_EQ(0, item.mTimestamp);
-        ASSERT_EQ(false, item.mIsAutoTimestamp);
-        ASSERT_EQ(HAL_DATASPACE_UNKNOWN, item.mDataSpace);
-        ASSERT_EQ(Rect(0, 0, 1, 1), item.mCrop);
-        ASSERT_EQ(NATIVE_WINDOW_SCALING_MODE_FREEZE, item.mScalingMode);
-        ASSERT_EQ(0u, item.mTransform);
-        ASSERT_EQ(Fence::NO_FENCE, item.mFence);
-        ASSERT_EQ(i == 0, item.mQueuedBuffer);
-        ASSERT_EQ(true, item.mAutoRefresh);
-
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    }
-}
-
-TEST_F(BufferQueueTest, TestSharedBufferModeUsingAlreadyDequeuedBuffer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    // Dequeue a buffer
-    int sharedSlot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&sharedSlot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->requestBuffer(sharedSlot, &buffer));
-
-    // Enable shared buffer mode
-    ASSERT_EQ(OK, mProducer->setSharedBufferMode(true));
-
-    // Queue the buffer
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-
-    // Repeatedly queue and dequeue a buffer from the producer side, it should
-    // always return the same one. And we won't run out of buffers because it's
-    // always the same one and because async mode gets enabled.
-    int slot;
-    for (int i = 0; i < 5; i++) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(sharedSlot, slot);
-        ASSERT_EQ(OK, mProducer->queueBuffer(sharedSlot, input, &output));
-    }
-
-    // acquire the buffer
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(sharedSlot, item.mSlot);
-    testBufferItem(input, item);
-    ASSERT_EQ(true, item.mQueuedBuffer);
-    ASSERT_EQ(false, item.mAutoRefresh);
-
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // attempt to acquire a second time should return no buffer available
-    ASSERT_EQ(IGraphicBufferConsumer::NO_BUFFER_AVAILABLE,
-            mConsumer->acquireBuffer(&item, 0));
-}
-
-TEST_F(BufferQueueTest, TestTimeouts) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    // Fill up the queue. Since the controlledByApp flags are set to true, this
-    // queue should be in non-blocking mode, and we should be recycling the same
-    // two buffers
-    for (int i = 0; i < 5; ++i) {
-        int slot = BufferQueue::INVALID_BUFFER_SLOT;
-        sp<Fence> fence = Fence::NO_FENCE;
-        auto result = mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr);
-        if (i < 2) {
-            ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-                    result);
-        } else {
-            ASSERT_EQ(OK, result);
-        }
-        sp<GraphicBuffer> buffer;
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-        IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-                HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-                NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-        IGraphicBufferProducer::QueueBufferOutput output{};
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    }
-
-    const auto TIMEOUT = ms2ns(250);
-    mProducer->setDequeueTimeout(TIMEOUT);
-
-    // Setting a timeout will change the BufferQueue into blocking mode (with
-    // one droppable buffer in the queue and one free from the previous
-    // dequeue/queues), so dequeue and queue two more buffers: one to replace
-    // the current droppable buffer, and a second to max out the buffer count
-    sp<GraphicBuffer> buffer; // Save a buffer to attach later
-    for (int i = 0; i < 2; ++i) {
-        int slot = BufferQueue::INVALID_BUFFER_SLOT;
-        sp<Fence> fence = Fence::NO_FENCE;
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-        IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-                HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-                NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    }
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    auto startTime = systemTime();
-    ASSERT_EQ(TIMED_OUT, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_GE(systemTime() - startTime, TIMEOUT);
-
-    // We're technically attaching the same buffer multiple times (since we
-    // queued it previously), but that doesn't matter for this test
-    startTime = systemTime();
-    ASSERT_EQ(TIMED_OUT, mProducer->attachBuffer(&slot, buffer));
-    ASSERT_GE(systemTime() - startTime, TIMEOUT);
-}
-
-TEST_F(BufferQueueTest, CanAttachWhileDisallowingAllocation) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> sourceFence;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &sourceFence, 0, 0, 0, 0, nullptr, nullptr));
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    ASSERT_EQ(OK, mProducer->detachBuffer(slot));
-
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-
-    slot = BufferQueue::INVALID_BUFFER_SLOT;
-    ASSERT_EQ(OK, mProducer->attachBuffer(&slot, buffer));
-}
-
-TEST_F(BufferQueueTest, CanRetrieveLastQueuedBuffer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    // Dequeue and queue the first buffer, storing the handle
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    sp<GraphicBuffer> firstBuffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &firstBuffer));
-
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Dequeue a second buffer
-    slot = BufferQueue::INVALID_BUFFER_SLOT;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    sp<GraphicBuffer> secondBuffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &secondBuffer));
-
-    // Ensure it's a new buffer
-    ASSERT_NE(firstBuffer->getNativeBuffer()->handle,
-            secondBuffer->getNativeBuffer()->handle);
-
-    // Queue the second buffer
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Acquire and release both buffers
-    for (size_t i = 0; i < 2; ++i) {
-        BufferItem item;
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    }
-
-    // Make sure we got the second buffer back
-    sp<GraphicBuffer> returnedBuffer;
-    sp<Fence> returnedFence;
-    float transform[16];
-    ASSERT_EQ(OK,
-            mProducer->getLastQueuedBuffer(&returnedBuffer, &returnedFence,
-            transform));
-    ASSERT_EQ(secondBuffer->getNativeBuffer()->handle,
-            returnedBuffer->getNativeBuffer()->handle);
-}
-
-TEST_F(BufferQueueTest, TestOccupancyHistory) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item{};
-
-    // Preallocate, dequeue, request, and cancel 3 buffers so we don't get
-    // BUFFER_NEEDS_REALLOCATION below
-    int slots[3] = {};
-    mProducer->setMaxDequeuedBufferCount(3);
-    for (size_t i = 0; i < 3; ++i) {
-        status_t result =
-                mProducer->dequeueBuffer(&slots[i], &fence, 0, 0, 0, 0, nullptr, nullptr);
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-        ASSERT_EQ(OK, mProducer->requestBuffer(slots[i], &buffer));
-    }
-    for (size_t i = 0; i < 3; ++i) {
-        ASSERT_EQ(OK, mProducer->cancelBuffer(slots[i], Fence::NO_FENCE));
-    }
-
-    // Create 3 segments
-
-    // The first segment is a two-buffer segment, so we only put one buffer into
-    // the queue at a time
-    for (size_t i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-        std::this_thread::sleep_for(16ms);
-    }
-
-    // Sleep between segments
-    std::this_thread::sleep_for(500ms);
-
-    // The second segment is a double-buffer segment. It starts the same as the
-    // two-buffer segment, but then at the end, we put two buffers in the queue
-    // at the same time before draining it.
-    for (size_t i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-        std::this_thread::sleep_for(16ms);
-    }
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    std::this_thread::sleep_for(16ms);
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Sleep between segments
-    std::this_thread::sleep_for(500ms);
-
-    // The third segment is a triple-buffer segment, so the queue is switching
-    // between one buffer and two buffers deep.
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    for (size_t i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-        ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-        ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-        ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-        std::this_thread::sleep_for(16ms);
-    }
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Now we read the segments
-    std::vector<OccupancyTracker::Segment> history;
-    ASSERT_EQ(OK, mConsumer->getOccupancyHistory(false, &history));
-
-    // Since we didn't force a flush, we should only get the first two segments
-    // (since the third segment hasn't been closed out by the appearance of a
-    // new segment yet)
-    ASSERT_EQ(2u, history.size());
-
-    // The first segment (which will be history[1], since the newest segment
-    // should be at the front of the vector) should be a two-buffer segment,
-    // which implies that the occupancy average should be between 0 and 1, and
-    // usedThirdBuffer should be false
-    const auto& firstSegment = history[1];
-    ASSERT_EQ(5u, firstSegment.numFrames);
-    ASSERT_LT(0, firstSegment.occupancyAverage);
-    ASSERT_GT(1, firstSegment.occupancyAverage);
-    ASSERT_EQ(false, firstSegment.usedThirdBuffer);
-
-    // The second segment should be a double-buffered segment, which implies that
-    // the occupancy average should be between 0 and 1, but usedThirdBuffer
-    // should be true
-    const auto& secondSegment = history[0];
-    ASSERT_EQ(7u, secondSegment.numFrames);
-    ASSERT_LT(0, secondSegment.occupancyAverage);
-    ASSERT_GT(1, secondSegment.occupancyAverage);
-    ASSERT_EQ(true, secondSegment.usedThirdBuffer);
-
-    // If we read the segments again without flushing, we shouldn't get any new
-    // segments
-    ASSERT_EQ(OK, mConsumer->getOccupancyHistory(false, &history));
-    ASSERT_EQ(0u, history.size());
-
-    // Read the segments again, this time forcing a flush so we get the third
-    // segment
-    ASSERT_EQ(OK, mConsumer->getOccupancyHistory(true, &history));
-    ASSERT_EQ(1u, history.size());
-
-    // This segment should be a triple-buffered segment, which implies that the
-    // occupancy average should be between 1 and 2, and usedThirdBuffer should
-    // be true
-    const auto& thirdSegment = history[0];
-    ASSERT_EQ(6u, thirdSegment.numFrames);
-    ASSERT_LT(1, thirdSegment.occupancyAverage);
-    ASSERT_GT(2, thirdSegment.occupancyAverage);
-    ASSERT_EQ(true, thirdSegment.usedThirdBuffer);
-}
-
-TEST_F(BufferQueueTest, TestDiscardFreeBuffers) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, false));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item{};
-
-    // Preallocate, dequeue, request, and cancel 4 buffers so we don't get
-    // BUFFER_NEEDS_REALLOCATION below
-    int slots[4] = {};
-    mProducer->setMaxDequeuedBufferCount(4);
-    for (size_t i = 0; i < 4; ++i) {
-        status_t result =
-                mProducer->dequeueBuffer(&slots[i], &fence, 0, 0, 0, 0, nullptr, nullptr);
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-        ASSERT_EQ(OK, mProducer->requestBuffer(slots[i], &buffer));
-    }
-    for (size_t i = 0; i < 4; ++i) {
-        ASSERT_EQ(OK, mProducer->cancelBuffer(slots[i], Fence::NO_FENCE));
-    }
-
-    // Get buffers in all states: dequeued, filled, acquired, free
-
-    // Fill 3 buffers
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    // Dequeue 1 buffer
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-
-    // Acquire and free 1 buffer
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-    // Acquire 1 buffer, leaving 1 filled buffer in queue
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-
-    // Now discard the free buffers
-    ASSERT_EQ(OK, mConsumer->discardFreeBuffers());
-
-    // Check no free buffers in dump
-    String8 dumpString;
-    mConsumer->dumpState(String8{}, &dumpString);
-
-    // Parse the dump to ensure that all buffer slots that are FREE also
-    // have a null GraphicBuffer
-    // Fragile - assumes the following format for the dump for a buffer entry:
-    // ":%p\][^:]*state=FREE" where %p is the buffer pointer in hex.
-    ssize_t idx = dumpString.find("state=FREE");
-    while (idx != -1) {
-        ssize_t bufferPtrIdx = idx - 1;
-        while (bufferPtrIdx > 0) {
-            if (dumpString[bufferPtrIdx] == ':') {
-                bufferPtrIdx++;
-                break;
-            }
-            bufferPtrIdx--;
-        }
-        ASSERT_GT(bufferPtrIdx, 0) << "Can't parse queue dump to validate";
-        ssize_t nullPtrIdx = dumpString.find("0x0]", bufferPtrIdx);
-        ASSERT_EQ(bufferPtrIdx, nullPtrIdx) << "Free buffer not discarded";
-        idx = dumpString.find("FREE", idx + 1);
-    }
-}
-
-TEST_F(BufferQueueTest, TestBufferReplacedInQueueBuffer) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-    ASSERT_EQ(OK, mConsumer->setMaxAcquiredBufferCount(1));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-        HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-        NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    BufferItem item{};
-
-    // Preallocate, dequeue, request, and cancel 2 buffers so we don't get
-    // BUFFER_NEEDS_REALLOCATION below
-    int slots[2] = {};
-    ASSERT_EQ(OK, mProducer->setMaxDequeuedBufferCount(2));
-    for (size_t i = 0; i < 2; ++i) {
-        status_t result =
-                mProducer->dequeueBuffer(&slots[i], &fence, 0, 0, 0, 0, nullptr, nullptr);
-        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-        ASSERT_EQ(OK, mProducer->requestBuffer(slots[i], &buffer));
-    }
-    for (size_t i = 0; i < 2; ++i) {
-        ASSERT_EQ(OK, mProducer->cancelBuffer(slots[i], Fence::NO_FENCE));
-    }
-
-    // Fill 2 buffers without consumer consuming them. Verify that all
-    // queued buffer returns proper bufferReplaced flag
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(false, output.bufferReplaced);
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-    ASSERT_EQ(true, output.bufferReplaced);
-}
-
-TEST_F(BufferQueueTest, TestStaleBufferHandleSentAfterDisconnect) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<IProducerListener> dummyListener(new DummyProducerListener);
-    ASSERT_EQ(OK, mProducer->connect(dummyListener, NATIVE_WINDOW_API_CPU,
-            true, &output));
-
-    int slot = BufferQueue::INVALID_BUFFER_SLOT;
-    sp<Fence> fence = Fence::NO_FENCE;
-    sp<GraphicBuffer> buffer = nullptr;
-    IGraphicBufferProducer::QueueBufferInput input(0ull, true,
-            HAL_DATASPACE_UNKNOWN, Rect::INVALID_RECT,
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-
-    // Dequeue, request, and queue one buffer
-    status_t result = mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr);
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, result);
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Acquire and release the buffer. Upon acquiring, the buffer handle should
-    // be non-null since this is the first time we've acquired this slot.
-    BufferItem item;
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(slot, item.mSlot);
-    ASSERT_NE(nullptr, item.mGraphicBuffer.get());
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Dequeue and queue the buffer again
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Acquire and release the buffer again. Upon acquiring, the buffer handle
-    // should be null since this is not the first time we've acquired this slot.
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(slot, item.mSlot);
-    ASSERT_EQ(nullptr, item.mGraphicBuffer.get());
-    ASSERT_EQ(OK, mConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // Dequeue and queue the buffer again
-    ASSERT_EQ(OK, mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, 0, nullptr, nullptr));
-    ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
-
-    // Disconnect the producer end. This should clear all of the slots and mark
-    // the buffer in the queue as stale.
-    ASSERT_EQ(OK, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-
-    // Acquire the buffer again. Upon acquiring, the buffer handle should not be
-    // null since the queued buffer should have been marked as stale, which
-    // should trigger the BufferQueue to resend the buffer handle.
-    ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
-    ASSERT_EQ(slot, item.mSlot);
-    ASSERT_NE(nullptr, item.mGraphicBuffer.get());
-}
-
-TEST_F(BufferQueueTest, TestProducerConnectDisconnect) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<IProducerListener> dummyListener(new DummyProducerListener);
-    ASSERT_EQ(NO_INIT, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, mProducer->connect(
-            dummyListener, NATIVE_WINDOW_API_CPU, true, &output));
-    ASSERT_EQ(BAD_VALUE, mProducer->connect(
-            dummyListener, NATIVE_WINDOW_API_MEDIA, true, &output));
-
-    ASSERT_EQ(BAD_VALUE, mProducer->disconnect(NATIVE_WINDOW_API_MEDIA));
-    ASSERT_EQ(OK, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_INIT, mProducer->disconnect(NATIVE_WINDOW_API_CPU));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/CpuConsumer_test.cpp b/libs/gui/tests/CpuConsumer_test.cpp
deleted file mode 100644
index 588e54142f..0000000000
--- a/libs/gui/tests/CpuConsumer_test.cpp
+++ /dev/null
@@ -1,746 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "CpuConsumer_test"
-//#define LOG_NDEBUG 0
-//#define LOG_NNDEBUG 0
-
-#ifdef LOG_NNDEBUG
-#define ALOGVV(...) ALOGV(__VA_ARGS__)
-#else
-#define ALOGVV(...) ((void)0)
-#endif
-
-#include <gtest/gtest.h>
-#include <gui/CpuConsumer.h>
-#include <gui/Surface.h>
-#include <ui/GraphicBuffer.h>
-#include <utils/String8.h>
-#include <utils/Thread.h>
-#include <utils/Mutex.h>
-#include <utils/Condition.h>
-
-#include <vector>
-#define CPU_CONSUMER_TEST_FORMAT_RAW 0
-#define CPU_CONSUMER_TEST_FORMAT_Y8 0
-#define CPU_CONSUMER_TEST_FORMAT_Y16 0
-#define CPU_CONSUMER_TEST_FORMAT_RGBA_8888 1
-
-namespace android {
-
-struct CpuConsumerTestParams {
-    uint32_t width;
-    uint32_t height;
-    int maxLockedBuffers;
-    PixelFormat format;
-};
-
-::std::ostream& operator<<(::std::ostream& os, const CpuConsumerTestParams& p) {
-    return os << "[ (" << p.width << ", " << p.height << "), B:"
-              << p.maxLockedBuffers << ", F:0x"
-              << ::std::hex << p.format << "]";
-}
-
-class CpuConsumerTest : public ::testing::TestWithParam<CpuConsumerTestParams> {
-protected:
-
-    virtual void SetUp() {
-        const ::testing::TestInfo* const test_info =
-                ::testing::UnitTest::GetInstance()->current_test_info();
-        CpuConsumerTestParams params = GetParam();
-        ALOGV("** Starting test %s (%d x %d, %d, 0x%x)",
-                test_info->name(),
-                params.width, params.height,
-                params.maxLockedBuffers, params.format);
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        mCC = new CpuConsumer(consumer, params.maxLockedBuffers);
-        String8 name("CpuConsumer_Under_Test");
-        mCC->setName(name);
-        mSTC = new Surface(producer);
-        mANW = mSTC;
-    }
-
-    virtual void TearDown() {
-        mANW.clear();
-        mSTC.clear();
-        mCC.clear();
-    }
-
-    class FrameWaiter : public CpuConsumer::FrameAvailableListener {
-    public:
-        FrameWaiter():
-                mPendingFrames(0) {
-        }
-
-        void waitForFrame() {
-            Mutex::Autolock lock(mMutex);
-            while (mPendingFrames == 0) {
-                mCondition.wait(mMutex);
-            }
-            mPendingFrames--;
-        }
-
-        virtual void onFrameAvailable(const BufferItem&) {
-            Mutex::Autolock lock(mMutex);
-            mPendingFrames++;
-            mCondition.signal();
-        }
-
-        int mPendingFrames;
-        Mutex mMutex;
-        Condition mCondition;
-    };
-
-    // Note that SurfaceTexture will lose the notifications
-    // onBuffersReleased and onFrameAvailable as there is currently
-    // no way to forward the events.  This DisconnectWaiter will not let the
-    // disconnect finish until finishDisconnect() is called.  It will
-    // also block until a disconnect is called
-    class DisconnectWaiter : public BufferQueue::ConsumerListener {
-    public:
-        DisconnectWaiter () :
-            mWaitForDisconnect(false),
-            mPendingFrames(0) {
-        }
-
-        void waitForFrame() {
-            Mutex::Autolock lock(mMutex);
-            while (mPendingFrames == 0) {
-                mFrameCondition.wait(mMutex);
-            }
-            mPendingFrames--;
-        }
-
-        virtual void onFrameAvailable(const BufferItem&) {
-            Mutex::Autolock lock(mMutex);
-            mPendingFrames++;
-            mFrameCondition.signal();
-        }
-
-        virtual void onBuffersReleased() {
-            Mutex::Autolock lock(mMutex);
-            while (!mWaitForDisconnect) {
-                mDisconnectCondition.wait(mMutex);
-            }
-        }
-
-        void finishDisconnect() {
-            Mutex::Autolock lock(mMutex);
-            mWaitForDisconnect = true;
-            mDisconnectCondition.signal();
-        }
-
-    private:
-        Mutex mMutex;
-
-        bool mWaitForDisconnect;
-        Condition mDisconnectCondition;
-
-        int mPendingFrames;
-        Condition mFrameCondition;
-    };
-
-    sp<CpuConsumer> mCC;
-    sp<Surface> mSTC;
-    sp<ANativeWindow> mANW;
-};
-
-#define ASSERT_NO_ERROR(err, msg) \
-    ASSERT_EQ(NO_ERROR, err) << (msg) << strerror(-(err))
-
-void checkPixel(const CpuConsumer::LockedBuffer &buf,
-        uint32_t x, uint32_t y, uint32_t r, uint32_t g=0, uint32_t b=0) {
-    // Ignores components that don't exist for given pixel
-    switch(buf.format) {
-        case HAL_PIXEL_FORMAT_RAW16: {
-            String8 msg;
-            uint16_t *bPtr = (uint16_t*)buf.data;
-            bPtr += y * buf.stride + x;
-            // GRBG Bayer mosaic; only check the matching channel
-            switch( ((y & 1) << 1) | (x & 1) ) {
-                case 0: // G
-                case 3: // G
-                    EXPECT_EQ(g, *bPtr);
-                    break;
-                case 1: // R
-                    EXPECT_EQ(r, *bPtr);
-                    break;
-                case 2: // B
-                    EXPECT_EQ(b, *bPtr);
-                    break;
-            }
-            break;
-        }
-        // ignores g,b
-        case HAL_PIXEL_FORMAT_Y8: {
-            uint8_t *bPtr = (uint8_t*)buf.data;
-            bPtr += y * buf.stride + x;
-            EXPECT_EQ(r, *bPtr) << "at x = " << x << " y = " << y;
-            break;
-        }
-        // ignores g,b
-        case HAL_PIXEL_FORMAT_Y16: {
-            // stride is in pixels, not in bytes
-            uint16_t *bPtr = ((uint16_t*)buf.data) + y * buf.stride + x;
-
-            EXPECT_EQ(r, *bPtr) << "at x = " << x << " y = " << y;
-            break;
-        }
-        case HAL_PIXEL_FORMAT_RGBA_8888: {
-            const int bytesPerPixel = 4;
-            uint8_t *bPtr = (uint8_t*)buf.data;
-            bPtr += (y * buf.stride + x) * bytesPerPixel;
-
-            EXPECT_EQ(r, bPtr[0]) << "at x = " << x << " y = " << y;
-            EXPECT_EQ(g, bPtr[1]) << "at x = " << x << " y = " << y;
-            EXPECT_EQ(b, bPtr[2]) << "at x = " << x << " y = " << y;
-            break;
-        }
-        default: {
-            ADD_FAILURE() << "Unknown format for check:" << buf.format;
-            break;
-        }
-    }
-}
-
-// Fill a YV12 buffer with a multi-colored checkerboard pattern
-void fillYV12Buffer(uint8_t* buf, int w, int h, int stride);
-
-// Fill a Y8/Y16 buffer with a multi-colored checkerboard pattern
-template <typename T> // T == uint8_t or uint16_t
-void fillGreyscaleBuffer(T* buf, int w, int h, int stride, int bpp) {
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-    const int yuvTexOffsetY = 0;
-
-    ASSERT_TRUE(bpp == 8 || bpp == 16);
-    ASSERT_TRUE(sizeof(T)*8 == bpp);
-
-    // stride is in pixels, not in bytes
-    int yuvTexStrideY = stride;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            int parityX = (x / blockWidth) & 1;
-            int parityY = (y / blockHeight) & 1;
-            T intensity = (parityX ^ parityY) ? 63 : 191;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = intensity;
-        }
-    }
-}
-
-inline uint8_t chooseColorRgba8888(int blockX, int blockY, uint8_t channel) {
-    const int colorVariations = 3;
-    uint8_t color = ((blockX % colorVariations) + (blockY % colorVariations))
-                        % (colorVariations) == channel ? 191: 63;
-
-    return color;
-}
-
-// Fill a RGBA8888 buffer with a multi-colored checkerboard pattern
-void fillRgba8888Buffer(uint8_t* buf, int w, int h, int stride)
-{
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-    const int bytesPerPixel = 4;
-
-    // stride is in pixels, not in bytes
-    for (int x = 0; x < w; ++x) {
-        for (int y = 0; y < h; ++y) {
-            int blockX = (x / blockWidth);
-            int blockY = (y / blockHeight);
-
-            uint8_t r = chooseColorRgba8888(blockX, blockY, 0);
-            uint8_t g = chooseColorRgba8888(blockX, blockY, 1);
-            uint8_t b = chooseColorRgba8888(blockX, blockY, 2);
-
-            buf[(y*stride + x)*bytesPerPixel + 0] = r;
-            buf[(y*stride + x)*bytesPerPixel + 1] = g;
-            buf[(y*stride + x)*bytesPerPixel + 2] = b;
-            buf[(y*stride + x)*bytesPerPixel + 3] = 255;
-        }
-    }
-}
-
-// Fill a RAW sensor buffer with a multi-colored checkerboard pattern.
-// Assumes GRBG mosaic ordering. Result should be a grid in a 2x2 pattern
-// of [ R, B; G, W]
-void fillBayerRawBuffer(uint8_t* buf, int w, int h, int stride) {
-    ALOGVV("fillBayerRawBuffer: %p with %d x %d, stride %d", buf, w, h ,stride);
-    // Blocks need to be even-width/height, aim for 8-wide otherwise
-    const int blockWidth = (w > 16 ? w / 8 : 2) & ~0x1;
-    const int blockHeight = (h > 16 ? h / 8 : 2) & ~0x1;
-    for (int y = 0; y < h; y+=2) {
-        uint16_t *bPtr1 = ((uint16_t*)buf) + stride*y;
-        uint16_t *bPtr2 = bPtr1 + stride;
-        for (int x = 0; x < w; x+=2) {
-            int blockX = (x / blockWidth ) & 1;
-            int blockY = (y / blockHeight) & 1;
-            unsigned short r = (blockX == blockY) ? 1000 : 200;
-            unsigned short g = blockY ? 1000: 200;
-            unsigned short b = blockX ? 1000: 200;
-            // GR row
-            *bPtr1++ = g;
-            *bPtr1++ = r;
-            // BG row
-            *bPtr2++ = b;
-            *bPtr2++ = g;
-        }
-    }
-
-}
-
-template<typename T> // uint8_t or uint16_t
-void checkGreyscaleBuffer(const CpuConsumer::LockedBuffer &buf) {
-    uint32_t w = buf.width;
-    uint32_t h = buf.height;
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-
-    // Top-left square is bright
-    checkPixel(buf, 0, 0, 191);
-    checkPixel(buf, 1, 0, 191);
-    checkPixel(buf, 0, 1, 191);
-    checkPixel(buf, 1, 1, 191);
-
-    // One-right square is dark
-    checkPixel(buf, blockWidth,     0, 63);
-    checkPixel(buf, blockWidth + 1, 0, 63);
-    checkPixel(buf, blockWidth,     1, 63);
-    checkPixel(buf, blockWidth + 1, 1, 63);
-
-    // One-down square is dark
-    checkPixel(buf, 0, blockHeight, 63);
-    checkPixel(buf, 1, blockHeight, 63);
-    checkPixel(buf, 0, blockHeight + 1, 63);
-    checkPixel(buf, 1, blockHeight + 1, 63);
-
-    // One-diag square is bright
-    checkPixel(buf, blockWidth,     blockHeight, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight, 191);
-    checkPixel(buf, blockWidth,     blockHeight + 1, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight + 1, 191);
-
-    // Test bottom-right pixel
-    const int maxBlockX = ((w-1 + (blockWidth-1)) / blockWidth) & 0x1;
-    const int maxBlockY = ((h-1 + (blockHeight-1)) / blockHeight) & 0x1;
-    uint32_t pixelValue = ((maxBlockX % 2) == (maxBlockY % 2)) ? 191 : 63;
-    checkPixel(buf, w-1, h-1, pixelValue);
-}
-
-void checkRgba8888Buffer(const CpuConsumer::LockedBuffer &buf) {
-    uint32_t w = buf.width;
-    uint32_t h = buf.height;
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-
-    // Top-left square is bright red
-    checkPixel(buf, 0, 0, 191, 63, 63);
-    checkPixel(buf, 1, 0, 191, 63, 63);
-    checkPixel(buf, 0, 1, 191, 63, 63);
-    checkPixel(buf, 1, 1, 191, 63, 63);
-
-    // One-right square is bright green
-    checkPixel(buf, blockWidth,     0, 63, 191, 63);
-    checkPixel(buf, blockWidth + 1, 0, 63, 191, 63);
-    checkPixel(buf, blockWidth,     1, 63, 191, 63);
-    checkPixel(buf, blockWidth + 1, 1, 63, 191, 63);
-
-    // One-down square is bright green
-    checkPixel(buf, 0, blockHeight, 63, 191, 63);
-    checkPixel(buf, 1, blockHeight, 63, 191, 63);
-    checkPixel(buf, 0, blockHeight + 1, 63, 191, 63);
-    checkPixel(buf, 1, blockHeight + 1, 63, 191, 63);
-
-    // One-diag square is bright blue
-    checkPixel(buf, blockWidth,     blockHeight, 63, 63, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight, 63, 63, 191);
-    checkPixel(buf, blockWidth,     blockHeight + 1, 63, 63, 191);
-    checkPixel(buf, blockWidth + 1, blockHeight + 1, 63, 63, 191);
-
-    // Test bottom-right pixel
-    {
-        const int maxBlockX = ((w-1) / blockWidth);
-        const int maxBlockY = ((h-1) / blockHeight);
-        uint8_t r = chooseColorRgba8888(maxBlockX, maxBlockY, 0);
-        uint8_t g = chooseColorRgba8888(maxBlockX, maxBlockY, 1);
-        uint8_t b = chooseColorRgba8888(maxBlockX, maxBlockY, 2);
-        checkPixel(buf, w-1, h-1, r, g, b);
-    }
-}
-
-void checkBayerRawBuffer(const CpuConsumer::LockedBuffer &buf) {
-    uint32_t w = buf.width;
-    uint32_t h = buf.height;
-    const int blockWidth = (w > 16 ? w / 8 : 2) & ~0x1;
-    const int blockHeight = (h > 16 ? h / 8 : 2) & ~0x1;
-
-    // Top-left square is red
-    checkPixel(buf, 0, 0, 1000, 200, 200);
-    checkPixel(buf, 1, 0, 1000, 200, 200);
-    checkPixel(buf, 0, 1, 1000, 200, 200);
-    checkPixel(buf, 1, 1, 1000, 200, 200);
-
-    // One-right square is blue
-    checkPixel(buf, blockWidth,     0, 200, 200, 1000);
-    checkPixel(buf, blockWidth + 1, 0, 200, 200, 1000);
-    checkPixel(buf, blockWidth,     1, 200, 200, 1000);
-    checkPixel(buf, blockWidth + 1, 1, 200, 200, 1000);
-
-    // One-down square is green
-    checkPixel(buf, 0, blockHeight, 200, 1000, 200);
-    checkPixel(buf, 1, blockHeight, 200, 1000, 200);
-    checkPixel(buf, 0, blockHeight + 1, 200, 1000, 200);
-    checkPixel(buf, 1, blockHeight + 1, 200, 1000, 200);
-
-    // One-diag square is white
-    checkPixel(buf, blockWidth,     blockHeight, 1000, 1000, 1000);
-    checkPixel(buf, blockWidth + 1, blockHeight, 1000, 1000, 1000);
-    checkPixel(buf, blockWidth,     blockHeight + 1, 1000, 1000, 1000);
-    checkPixel(buf, blockWidth + 1, blockHeight + 1, 1000, 1000, 1000);
-
-    // Test bottom-right pixel
-    const int maxBlockX = ((w-1) / blockWidth) & 0x1;
-    const int maxBlockY = ((w-1) / blockHeight) & 0x1;
-    unsigned short maxR = (maxBlockX == maxBlockY) ? 1000 : 200;
-    unsigned short maxG = maxBlockY ? 1000: 200;
-    unsigned short maxB = maxBlockX ? 1000: 200;
-    checkPixel(buf, w-1, h-1, maxR, maxG, maxB);
-}
-
-void checkAnyBuffer(const CpuConsumer::LockedBuffer &buf, int format) {
-    switch (format) {
-        case HAL_PIXEL_FORMAT_RAW16:
-            checkBayerRawBuffer(buf);
-            break;
-        case HAL_PIXEL_FORMAT_Y8:
-            checkGreyscaleBuffer<uint8_t>(buf);
-            break;
-        case HAL_PIXEL_FORMAT_Y16:
-            checkGreyscaleBuffer<uint16_t>(buf);
-            break;
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-            checkRgba8888Buffer(buf);
-            break;
-    }
-}
-
-// Configures the ANativeWindow producer-side interface based on test parameters
-void configureANW(const sp<ANativeWindow>& anw,
-        const CpuConsumerTestParams& params,
-        int maxBufferSlack) {
-    status_t err;
-    err = native_window_api_connect(anw.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_NO_ERROR(err, "connect error: ");
-
-    err = native_window_set_buffers_dimensions(anw.get(),
-            params.width, params.height);
-    ASSERT_NO_ERROR(err, "set_buffers_dimensions error: ");
-
-    err = native_window_set_buffers_format(anw.get(), params.format);
-    ASSERT_NO_ERROR(err, "set_buffers_format error: ");
-
-    err = native_window_set_usage(anw.get(),
-            GRALLOC_USAGE_SW_WRITE_OFTEN);
-    ASSERT_NO_ERROR(err, "set_usage error: ");
-
-    int minUndequeuedBuffers;
-    err = anw.get()->query(anw.get(),
-            NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-            &minUndequeuedBuffers);
-    ASSERT_NO_ERROR(err, "query error: ");
-
-    ALOGVV("Setting buffer count to %d",
-            maxBufferSlack + 1 + minUndequeuedBuffers);
-    err = native_window_set_buffer_count(anw.get(),
-            maxBufferSlack + 1 + minUndequeuedBuffers);
-    ASSERT_NO_ERROR(err, "set_buffer_count error: ");
-
-}
-
-// Produce one frame of image data; assumes format and resolution configuration
-// is already done.
-void produceOneFrame(const sp<ANativeWindow>& anw,
-        const CpuConsumerTestParams& params,
-        int64_t timestamp, uint32_t *stride) {
-    status_t err;
-    ANativeWindowBuffer* anb;
-    ALOGVV("Dequeue buffer from %p", anw.get());
-    err = native_window_dequeue_buffer_and_wait(anw.get(), &anb);
-    ASSERT_NO_ERROR(err, "dequeueBuffer error: ");
-
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    *stride = buf->getStride();
-    uint8_t* img = NULL;
-
-    ALOGVV("Lock buffer from %p for write", anw.get());
-    err = buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    ASSERT_NO_ERROR(err, "lock error: ");
-
-    switch (params.format) {
-        case HAL_PIXEL_FORMAT_YV12:
-            fillYV12Buffer(img, params.width, params.height, *stride);
-            break;
-        case HAL_PIXEL_FORMAT_RAW16:
-            fillBayerRawBuffer(img, params.width, params.height, buf->getStride());
-            break;
-        case HAL_PIXEL_FORMAT_Y8:
-            fillGreyscaleBuffer<uint8_t>(img, params.width, params.height,
-                                         buf->getStride(), /*bpp*/8);
-            break;
-        case HAL_PIXEL_FORMAT_Y16:
-            fillGreyscaleBuffer<uint16_t>((uint16_t*)img, params.width,
-                                          params.height, buf->getStride(),
-                                          /*bpp*/16);
-            break;
-        case HAL_PIXEL_FORMAT_RGBA_8888:
-            fillRgba8888Buffer(img, params.width, params.height, buf->getStride());
-            break;
-        default:
-            FAIL() << "Unknown pixel format under test!";
-            break;
-    }
-    ALOGVV("Unlock buffer from %p", anw.get());
-    err = buf->unlock();
-    ASSERT_NO_ERROR(err, "unlock error: ");
-
-    ALOGVV("Set timestamp to %p", anw.get());
-    err = native_window_set_buffers_timestamp(anw.get(), timestamp);
-    ASSERT_NO_ERROR(err, "set_buffers_timestamp error: ");
-
-    ALOGVV("Queue buffer to %p", anw.get());
-    err = anw->queueBuffer(anw.get(), buf->getNativeBuffer(), -1);
-    ASSERT_NO_ERROR(err, "queueBuffer error:");
-};
-
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
-// supported on all devices.
-TEST_P(CpuConsumerTest, FromCpuSingle) {
-    status_t err;
-    CpuConsumerTestParams params = GetParam();
-
-    // Set up
-
-    ASSERT_NO_FATAL_FAILURE(configureANW(mANW, params, 1));
-
-    // Produce
-
-    const int64_t time = 12345678L;
-    uint32_t stride;
-    ASSERT_NO_FATAL_FAILURE(produceOneFrame(mANW, params, time,
-                    &stride));
-
-    // Consume
-
-    CpuConsumer::LockedBuffer b;
-    err = mCC->lockNextBuffer(&b);
-    ASSERT_NO_ERROR(err, "getNextBuffer error: ");
-
-    ASSERT_TRUE(b.data != NULL);
-    EXPECT_EQ(params.width,  b.width);
-    EXPECT_EQ(params.height, b.height);
-    EXPECT_EQ(params.format, b.format);
-    EXPECT_EQ(stride, b.stride);
-    EXPECT_EQ(time, b.timestamp);
-
-    checkAnyBuffer(b, GetParam().format);
-    mCC->unlockBuffer(b);
-}
-
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
-// supported on all devices.
-TEST_P(CpuConsumerTest, FromCpuManyInQueue) {
-    status_t err;
-    CpuConsumerTestParams params = GetParam();
-
-    const int numInQueue = 5;
-    // Set up
-
-    ASSERT_NO_FATAL_FAILURE(configureANW(mANW, params, numInQueue));
-
-    // Produce
-
-    const int64_t time[numInQueue] = { 1L, 2L, 3L, 4L, 5L};
-    uint32_t stride[numInQueue];
-
-    for (int i = 0; i < numInQueue; i++) {
-        ALOGV("Producing frame %d", i);
-        ASSERT_NO_FATAL_FAILURE(produceOneFrame(mANW, params, time[i],
-                        &stride[i]));
-    }
-
-    // Consume
-
-    for (int i = 0; i < numInQueue; i++) {
-        ALOGV("Consuming frame %d", i);
-        CpuConsumer::LockedBuffer b;
-        err = mCC->lockNextBuffer(&b);
-        ASSERT_NO_ERROR(err, "getNextBuffer error: ");
-
-        ASSERT_TRUE(b.data != NULL);
-        EXPECT_EQ(params.width,  b.width);
-        EXPECT_EQ(params.height, b.height);
-        EXPECT_EQ(params.format, b.format);
-        EXPECT_EQ(stride[i], b.stride);
-        EXPECT_EQ(time[i], b.timestamp);
-
-        checkAnyBuffer(b, GetParam().format);
-
-        mCC->unlockBuffer(b);
-    }
-}
-
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
-// supported on all devices.
-TEST_P(CpuConsumerTest, FromCpuLockMax) {
-    status_t err;
-    CpuConsumerTestParams params = GetParam();
-
-    // Set up
-
-    ASSERT_NO_FATAL_FAILURE(configureANW(mANW, params, params.maxLockedBuffers + 1));
-
-    // Produce
-
-    const int64_t time = 1234L;
-    uint32_t stride;
-
-    for (int i = 0; i < params.maxLockedBuffers + 1; i++) {
-        ALOGV("Producing frame %d", i);
-        ASSERT_NO_FATAL_FAILURE(produceOneFrame(mANW, params, time,
-                        &stride));
-    }
-
-    // Consume
-
-    std::vector<CpuConsumer::LockedBuffer> b(params.maxLockedBuffers);
-    for (int i = 0; i < params.maxLockedBuffers; i++) {
-        ALOGV("Locking frame %d", i);
-        err = mCC->lockNextBuffer(&b[i]);
-        ASSERT_NO_ERROR(err, "getNextBuffer error: ");
-
-        ASSERT_TRUE(b[i].data != NULL);
-        EXPECT_EQ(params.width,  b[i].width);
-        EXPECT_EQ(params.height, b[i].height);
-        EXPECT_EQ(params.format, b[i].format);
-        EXPECT_EQ(stride, b[i].stride);
-        EXPECT_EQ(time, b[i].timestamp);
-
-        checkAnyBuffer(b[i], GetParam().format);
-    }
-
-    ALOGV("Locking frame %d (too many)", params.maxLockedBuffers);
-    CpuConsumer::LockedBuffer bTooMuch;
-    err = mCC->lockNextBuffer(&bTooMuch);
-    ASSERT_TRUE(err == NOT_ENOUGH_DATA) << "Allowing too many locks";
-
-    ALOGV("Unlocking frame 0");
-    err = mCC->unlockBuffer(b[0]);
-    ASSERT_NO_ERROR(err, "Could not unlock buffer 0: ");
-
-    ALOGV("Locking frame %d (should work now)", params.maxLockedBuffers);
-    err = mCC->lockNextBuffer(&bTooMuch);
-    ASSERT_NO_ERROR(err, "Did not allow new lock after unlock");
-
-    ASSERT_TRUE(bTooMuch.data != NULL);
-    EXPECT_EQ(params.width,  bTooMuch.width);
-    EXPECT_EQ(params.height, bTooMuch.height);
-    EXPECT_EQ(params.format, bTooMuch.format);
-    EXPECT_EQ(stride, bTooMuch.stride);
-    EXPECT_EQ(time, bTooMuch.timestamp);
-
-    checkAnyBuffer(bTooMuch, GetParam().format);
-
-    ALOGV("Unlocking extra buffer");
-    err = mCC->unlockBuffer(bTooMuch);
-    ASSERT_NO_ERROR(err, "Could not unlock extra buffer: ");
-
-    ALOGV("Locking frame %d (no more available)", params.maxLockedBuffers + 1);
-    err = mCC->lockNextBuffer(&b[0]);
-    ASSERT_EQ(BAD_VALUE, err) << "Not out of buffers somehow";
-
-    for (int i = 1; i < params.maxLockedBuffers; i++) {
-        mCC->unlockBuffer(b[i]);
-    }
-}
-
-CpuConsumerTestParams y8TestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_Y8},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_Y8},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_Y8},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_Y8},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_Y8},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_Y8},
-};
-
-CpuConsumerTestParams y16TestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_Y16},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_Y16},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_Y16},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_Y16},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_Y16},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_Y16},
-};
-
-CpuConsumerTestParams rawTestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_RAW16},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_RAW16},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_RAW16},
-};
-
-CpuConsumerTestParams rgba8888TestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_RGBA_8888},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_RGBA_8888},
-};
-
-#if CPU_CONSUMER_TEST_FORMAT_Y8
-INSTANTIATE_TEST_CASE_P(Y8Tests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(y8TestSets));
-#endif
-
-#if CPU_CONSUMER_TEST_FORMAT_Y16
-INSTANTIATE_TEST_CASE_P(Y16Tests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(y16TestSets));
-#endif
-
-#if CPU_CONSUMER_TEST_FORMAT_RAW
-INSTANTIATE_TEST_CASE_P(RawTests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(rawTestSets));
-#endif
-
-#if CPU_CONSUMER_TEST_FORMAT_RGBA_8888
-INSTANTIATE_TEST_CASE_P(Rgba8888Tests,
-        CpuConsumerTest,
-        ::testing::ValuesIn(rgba8888TestSets));
-#endif
-
-
-
-} // namespace android
diff --git a/libs/gui/tests/DisconnectWaiter.h b/libs/gui/tests/DisconnectWaiter.h
deleted file mode 100644
index 6e6915b299..0000000000
--- a/libs/gui/tests/DisconnectWaiter.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_DISCONNECT_WAITER_H
-#define ANDROID_DISCONNECT_WAITER_H
-
-#include <gui/IConsumerListener.h>
-
-#include <utils/Condition.h>
-#include <utils/Mutex.h>
-
-namespace android {
-
-// Note that GLConsumer will lose the notifications
-// onBuffersReleased and onFrameAvailable as there is currently
-// no way to forward the events.  This DisconnectWaiter will not let the
-// disconnect finish until finishDisconnect() is called.  It will
-// also block until a disconnect is called
-class DisconnectWaiter : public BnConsumerListener {
-public:
-    DisconnectWaiter () :
-        mWaitForDisconnect(false),
-        mPendingFrames(0) {
-    }
-
-    void waitForFrame() {
-        Mutex::Autolock lock(mMutex);
-        while (mPendingFrames == 0) {
-            mFrameCondition.wait(mMutex);
-        }
-        mPendingFrames--;
-    }
-
-    virtual void onFrameAvailable(const BufferItem& /* item */) {
-        Mutex::Autolock lock(mMutex);
-        mPendingFrames++;
-        mFrameCondition.signal();
-    }
-
-    virtual void onBuffersReleased() {
-        Mutex::Autolock lock(mMutex);
-        while (!mWaitForDisconnect) {
-            mDisconnectCondition.wait(mMutex);
-        }
-    }
-
-    virtual void onSidebandStreamChanged() {}
-
-    void finishDisconnect() {
-        Mutex::Autolock lock(mMutex);
-        mWaitForDisconnect = true;
-        mDisconnectCondition.signal();
-    }
-
-private:
-    Mutex mMutex;
-
-    bool mWaitForDisconnect;
-    Condition mDisconnectCondition;
-
-    int mPendingFrames;
-    Condition mFrameCondition;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/DummyConsumer.h b/libs/gui/tests/DummyConsumer.h
deleted file mode 100644
index 502bdf981b..0000000000
--- a/libs/gui/tests/DummyConsumer.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gui/IConsumerListener.h>
-
-namespace android {
-
-struct DummyConsumer : public BnConsumerListener {
-    void onFrameAvailable(const BufferItem& /* item */) override {}
-    void onBuffersReleased() override {}
-    void onSidebandStreamChanged() override {}
-};
-
-} // namespace android
diff --git a/libs/gui/tests/FillBuffer.cpp b/libs/gui/tests/FillBuffer.cpp
deleted file mode 100644
index ccd674fcb8..0000000000
--- a/libs/gui/tests/FillBuffer.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "FillBuffer.h"
-
-#include <ui/GraphicBuffer.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-void fillYV12Buffer(uint8_t* buf, int w, int h, int stride) {
-    const int blockWidth = w > 16 ? w / 16 : 1;
-    const int blockHeight = h > 16 ? h / 16 : 1;
-    const int yuvTexOffsetY = 0;
-    int yuvTexStrideY = stride;
-    int yuvTexOffsetV = yuvTexStrideY * h;
-    int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf;
-    int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * h/2;
-    int yuvTexStrideU = yuvTexStrideV;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            int parityX = (x / blockWidth) & 1;
-            int parityY = (y / blockHeight) & 1;
-            unsigned char intensity = (parityX ^ parityY) ? 63 : 191;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = intensity;
-            if (x < w / 2 && y < h / 2) {
-                buf[yuvTexOffsetU + (y * yuvTexStrideU) + x] = intensity;
-                if (x * 2 < w / 2 && y * 2 < h / 2) {
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + (y*2 * yuvTexStrideV) + x*2 + 1] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 0] =
-                    buf[yuvTexOffsetV + ((y*2+1) * yuvTexStrideV) + x*2 + 1] =
-                        intensity;
-                }
-            }
-        }
-    }
-}
-
-void fillYV12BufferRect(uint8_t* buf, int w, int h, int stride,
-        const android_native_rect_t& rect) {
-    const int yuvTexOffsetY = 0;
-    int yuvTexStrideY = stride;
-    int yuvTexOffsetV = yuvTexStrideY * h;
-    int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf;
-    int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * h/2;
-    int yuvTexStrideU = yuvTexStrideV;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            bool inside = rect.left <= x && x < rect.right &&
-                    rect.top <= y && y < rect.bottom;
-            buf[yuvTexOffsetY + (y * yuvTexStrideY) + x] = inside ? 240 : 64;
-            if (x < w / 2 && y < h / 2) {
-                bool inside = rect.left <= 2*x && 2*x < rect.right &&
-                        rect.top <= 2*y && 2*y < rect.bottom;
-                buf[yuvTexOffsetU + (y * yuvTexStrideU) + x] = 16;
-                buf[yuvTexOffsetV + (y * yuvTexStrideV) + x] =
-                        inside ? 16 : 255;
-            }
-        }
-    }
-}
-
-void fillRGBA8Buffer(uint8_t* buf, int w, int h, int stride) {
-    const size_t PIXEL_SIZE = 4;
-    for (int x = 0; x < w; x++) {
-        for (int y = 0; y < h; y++) {
-            off_t offset = (y * stride + x) * PIXEL_SIZE;
-            for (int c = 0; c < 4; c++) {
-                int parityX = (x / (1 << (c+2))) & 1;
-                int parityY = (y / (1 << (c+2))) & 1;
-                buf[offset + c] = (parityX ^ parityY) ? 231 : 35;
-            }
-        }
-    }
-}
-
-void produceOneRGBA8Frame(const sp<ANativeWindow>& anw) {
-    android_native_buffer_t* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(anw.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    uint8_t* img = NULL;
-    ASSERT_EQ(NO_ERROR, buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN,
-            (void**)(&img)));
-    fillRGBA8Buffer(img, buf->getWidth(), buf->getHeight(), buf->getStride());
-    ASSERT_EQ(NO_ERROR, buf->unlock());
-    ASSERT_EQ(NO_ERROR, anw->queueBuffer(anw.get(), buf->getNativeBuffer(),
-            -1));
-}
-} // namespace android
diff --git a/libs/gui/tests/FillBuffer.h b/libs/gui/tests/FillBuffer.h
deleted file mode 100644
index b584179318..0000000000
--- a/libs/gui/tests/FillBuffer.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_FILL_BUFFER_H
-#define ANDROID_FILL_BUFFER_H
-
-#include <system/window.h>
-#include <utils/StrongPointer.h>
-
-namespace android {
-
-// Fill a YV12 buffer with a multi-colored checkerboard pattern
-void fillYV12Buffer(uint8_t* buf, int w, int h, int stride);
-
-// Fill a YV12 buffer with red outside a given rectangle and green inside it.
-void fillYV12BufferRect(uint8_t* buf, int w, int h, int stride,
-        const android_native_rect_t& rect);
-
-void fillRGBA8Buffer(uint8_t* buf, int w, int h, int stride);
-
-// Produce a single RGBA8 frame by filling a buffer with a checkerboard pattern
-// using the CPU.  This assumes that the ANativeWindow is already configured to
-// allow this to be done (e.g. the format is set to RGBA8).
-//
-// Calls to this function should be wrapped in an ASSERT_NO_FATAL_FAILURE().
-void produceOneRGBA8Frame(const sp<ANativeWindow>& anw);
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/FrameWaiter.h b/libs/gui/tests/FrameWaiter.h
deleted file mode 100644
index f78fa001cc..0000000000
--- a/libs/gui/tests/FrameWaiter.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_FRAME_WAITER_H
-#define ANDROID_FRAME_WAITER_H
-
-#include <gui/GLConsumer.h>
-
-namespace android {
-
-class FrameWaiter : public GLConsumer::FrameAvailableListener {
-public:
-    FrameWaiter():
-            mPendingFrames(0) {
-    }
-
-    void waitForFrame() {
-        Mutex::Autolock lock(mMutex);
-        while (mPendingFrames == 0) {
-            mCondition.wait(mMutex);
-        }
-        mPendingFrames--;
-    }
-
-    virtual void onFrameAvailable(const BufferItem& /* item */) {
-        Mutex::Autolock lock(mMutex);
-        mPendingFrames++;
-        mCondition.signal();
-    }
-
-private:
-    int mPendingFrames;
-    Mutex mMutex;
-    Condition mCondition;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/GLTest.cpp b/libs/gui/tests/GLTest.cpp
deleted file mode 100644
index 1739d9c7ca..0000000000
--- a/libs/gui/tests/GLTest.cpp
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "GLTest.h"
-
-#include <gui/Surface.h>
-
-#include <GLES2/gl2.h>
-
-namespace android {
-
-static int abs(int value) {
-    return value > 0 ? value : -value;
-}
-
-void GLTest::SetUp() {
-    const ::testing::TestInfo* const testInfo =
-        ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGV("Begin test: %s.%s", testInfo->test_case_name(), testInfo->name());
-
-    mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    RecordProperty("EglVersionMajor", majorVersion);
-    RecordProperty("EglVersionMinor", minorVersion);
-
-    EGLint numConfigs = 0;
-    EXPECT_TRUE(eglChooseConfig(mEglDisplay, getConfigAttribs(), &mGlConfig, 1,
-            &numConfigs));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    char* displaySecsEnv = getenv("GLTEST_DISPLAY_SECS");
-    if (displaySecsEnv != NULL) {
-        mDisplaySecs = atoi(displaySecsEnv);
-        if (mDisplaySecs < 0) {
-            mDisplaySecs = 0;
-        }
-    } else {
-        mDisplaySecs = 0;
-    }
-
-    if (mDisplaySecs > 0) {
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        mSurfaceControl = mComposerClient->createSurface(
-                String8("Test Surface"), getSurfaceWidth(), getSurfaceHeight(),
-                PIXEL_FORMAT_RGB_888, 0);
-
-        ASSERT_TRUE(mSurfaceControl != NULL);
-        ASSERT_TRUE(mSurfaceControl->isValid());
-
-        SurfaceComposerClient::openGlobalTransaction();
-        ASSERT_EQ(NO_ERROR, mSurfaceControl->setLayer(0x7FFFFFFF));
-        ASSERT_EQ(NO_ERROR, mSurfaceControl->show());
-        SurfaceComposerClient::closeGlobalTransaction();
-
-        sp<ANativeWindow> window = mSurfaceControl->getSurface();
-        mEglSurface = createWindowSurface(mEglDisplay, mGlConfig, window);
-    } else {
-        EGLint pbufferAttribs[] = {
-            EGL_WIDTH, getSurfaceWidth(),
-            EGL_HEIGHT, getSurfaceHeight(),
-            EGL_NONE };
-
-        mEglSurface = eglCreatePbufferSurface(mEglDisplay, mGlConfig,
-                pbufferAttribs);
-    }
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_SURFACE, mEglSurface);
-
-    mEglContext = eglCreateContext(mEglDisplay, mGlConfig, EGL_NO_CONTEXT,
-            getContextAttribs());
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_CONTEXT, mEglContext);
-
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLint w, h;
-    EXPECT_TRUE(eglQuerySurface(mEglDisplay, mEglSurface, EGL_WIDTH, &w));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    EXPECT_TRUE(eglQuerySurface(mEglDisplay, mEglSurface, EGL_HEIGHT, &h));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    RecordProperty("EglSurfaceWidth", w);
-    RecordProperty("EglSurfaceHeight", h);
-
-    glViewport(0, 0, w, h);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-}
-
-void GLTest::TearDown() {
-    // Display the result
-    if (mDisplaySecs > 0 && mEglSurface != EGL_NO_SURFACE) {
-        eglSwapBuffers(mEglDisplay, mEglSurface);
-        sleep(mDisplaySecs);
-    }
-
-    if (mComposerClient != NULL) {
-        mComposerClient->dispose();
-    }
-    if (mEglContext != EGL_NO_CONTEXT) {
-        eglDestroyContext(mEglDisplay, mEglContext);
-    }
-    if (mEglSurface != EGL_NO_SURFACE) {
-        eglDestroySurface(mEglDisplay, mEglSurface);
-    }
-    if (mEglDisplay != EGL_NO_DISPLAY) {
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                EGL_NO_CONTEXT);
-        eglTerminate(mEglDisplay);
-    }
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    const ::testing::TestInfo* const testInfo =
-        ::testing::UnitTest::GetInstance()->current_test_info();
-    ALOGV("End test:   %s.%s", testInfo->test_case_name(), testInfo->name());
-}
-
-EGLint const* GLTest::getConfigAttribs() {
-    static const EGLint sDefaultConfigAttribs[] = {
-        EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE, 8,
-        EGL_GREEN_SIZE, 8,
-        EGL_BLUE_SIZE, 8,
-        EGL_ALPHA_SIZE, 8,
-        EGL_DEPTH_SIZE, 16,
-        EGL_STENCIL_SIZE, 8,
-        EGL_NONE };
-
-    return sDefaultConfigAttribs;
-}
-
-EGLint const* GLTest::getContextAttribs() {
-    static const EGLint sDefaultContextAttribs[] = {
-        EGL_CONTEXT_CLIENT_VERSION, 2,
-        EGL_NONE };
-
-    return sDefaultContextAttribs;
-}
-
-EGLint GLTest::getSurfaceWidth() {
-    return 512;
-}
-
-EGLint GLTest::getSurfaceHeight() {
-    return 512;
-}
-
-EGLSurface GLTest::createWindowSurface(EGLDisplay display, EGLConfig config,
-                                       sp<ANativeWindow>& window) const {
-    return eglCreateWindowSurface(display, config, window.get(), NULL);
-}
-
-::testing::AssertionResult GLTest::checkPixel(int x, int y,
-        int r, int g, int b, int a, int tolerance) {
-    GLubyte pixel[4];
-    String8 msg;
-    glReadPixels(x, y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, pixel);
-    GLenum err = glGetError();
-    if (err != GL_NO_ERROR) {
-        msg += String8::format("error reading pixel: %#x", err);
-        while ((err = glGetError()) != GL_NO_ERROR) {
-            msg += String8::format(", %#x", err);
-        }
-        return ::testing::AssertionFailure(::testing::Message(msg.string()));
-    }
-    if (r >= 0 && abs(r - int(pixel[0])) > tolerance) {
-        msg += String8::format("r(%d isn't %d)", pixel[0], r);
-    }
-    if (g >= 0 && abs(g - int(pixel[1])) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("g(%d isn't %d)", pixel[1], g);
-    }
-    if (b >= 0 && abs(b - int(pixel[2])) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("b(%d isn't %d)", pixel[2], b);
-    }
-    if (a >= 0 && abs(a - int(pixel[3])) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("a(%d isn't %d)", pixel[3], a);
-    }
-    if (!msg.isEmpty()) {
-        return ::testing::AssertionFailure(::testing::Message(msg.string()));
-    } else {
-        return ::testing::AssertionSuccess();
-    }
-}
-
-::testing::AssertionResult GLTest::assertRectEq(const Rect &r1, const Rect &r2,
-                                                int tolerance) {
-    String8 msg;
-
-    if (abs(r1.left - r2.left) > tolerance) {
-        msg += String8::format("left(%d isn't %d)", r1.left, r2.left);
-    }
-    if (abs(r1.top - r2.top) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("top(%d isn't %d)", r1.top, r2.top);
-    }
-    if (abs(r1.right - r2.right) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("right(%d isn't %d)", r1.right, r2.right);
-    }
-    if (abs(r1.bottom - r2.bottom) > tolerance) {
-        if (!msg.isEmpty()) {
-            msg += " ";
-        }
-        msg += String8::format("bottom(%d isn't %d)", r1.bottom, r2.bottom);
-    }
-    if (!msg.isEmpty()) {
-        msg += String8::format(" R1: [%d %d %d %d] R2: [%d %d %d %d]",
-                               r1.left, r1.top, r1.right, r1.bottom,
-                               r2.left, r2.top, r2.right, r2.bottom);
-        fprintf(stderr, "assertRectEq: %s\n", msg.string());
-        return ::testing::AssertionFailure(::testing::Message(msg.string()));
-    } else {
-        return ::testing::AssertionSuccess();
-    }
-}
-
-void GLTest::loadShader(GLenum shaderType, const char* pSource,
-        GLuint* outShader) {
-    GLuint shader = glCreateShader(shaderType);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    if (shader) {
-        glShaderSource(shader, 1, &pSource, NULL);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        glCompileShader(shader);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        GLint compiled = 0;
-        glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        if (!compiled) {
-            GLint infoLen = 0;
-            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
-            ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-            if (infoLen) {
-                char* buf = (char*) malloc(infoLen);
-                if (buf) {
-                    glGetShaderInfoLog(shader, infoLen, NULL, buf);
-                    printf("Shader compile log:\n%s\n", buf);
-                    free(buf);
-                    FAIL();
-                }
-            } else {
-                char* buf = (char*) malloc(0x1000);
-                if (buf) {
-                    glGetShaderInfoLog(shader, 0x1000, NULL, buf);
-                    printf("Shader compile log:\n%s\n", buf);
-                    free(buf);
-                    FAIL();
-                }
-            }
-            glDeleteShader(shader);
-            shader = 0;
-        }
-    }
-    ASSERT_TRUE(shader != 0);
-    *outShader = shader;
-}
-
-void GLTest::createProgram(const char* pVertexSource,
-        const char* pFragmentSource, GLuint* outPgm) {
-    GLuint vertexShader, fragmentShader;
-    {
-        SCOPED_TRACE("compiling vertex shader");
-        ASSERT_NO_FATAL_FAILURE(loadShader(GL_VERTEX_SHADER, pVertexSource,
-                &vertexShader));
-    }
-    {
-        SCOPED_TRACE("compiling fragment shader");
-        ASSERT_NO_FATAL_FAILURE(loadShader(GL_FRAGMENT_SHADER, pFragmentSource,
-                &fragmentShader));
-    }
-
-    GLuint program = glCreateProgram();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    if (program) {
-        glAttachShader(program, vertexShader);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        glAttachShader(program, fragmentShader);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-        glLinkProgram(program);
-        GLint linkStatus = GL_FALSE;
-        glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);
-        if (linkStatus != GL_TRUE) {
-            GLint bufLength = 0;
-            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);
-            if (bufLength) {
-                char* buf = (char*) malloc(bufLength);
-                if (buf) {
-                    glGetProgramInfoLog(program, bufLength, NULL, buf);
-                    printf("Program link log:\n%s\n", buf);
-                    free(buf);
-                    FAIL();
-                }
-            }
-            glDeleteProgram(program);
-            program = 0;
-        }
-    }
-    glDeleteShader(vertexShader);
-    glDeleteShader(fragmentShader);
-    ASSERT_TRUE(program != 0);
-    *outPgm = program;
-}
-
-} // namespace android
diff --git a/libs/gui/tests/GLTest.h b/libs/gui/tests/GLTest.h
deleted file mode 100644
index f0d27a8a34..0000000000
--- a/libs/gui/tests/GLTest.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_GL_TEST_H
-#define ANDROID_GL_TEST_H
-
-#include <gtest/gtest.h>
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <EGL/egl.h>
-#include <GLES/gl.h>
-
-namespace android {
-
-class GLTest : public ::testing::Test {
-public:
-    static void loadShader(GLenum shaderType, const char* pSource,
-            GLuint* outShader);
-    static void createProgram(const char* pVertexSource,
-            const char* pFragmentSource, GLuint* outPgm);
-
-protected:
-    GLTest() :
-            mDisplaySecs(0),
-            mEglDisplay(EGL_NO_DISPLAY),
-            mEglSurface(EGL_NO_SURFACE),
-            mEglContext(EGL_NO_CONTEXT),
-            mGlConfig(NULL) {
-    }
-
-    virtual void SetUp();
-    virtual void TearDown();
-
-    virtual EGLint const* getConfigAttribs();
-    virtual EGLint const* getContextAttribs();
-    virtual EGLint getSurfaceWidth();
-    virtual EGLint getSurfaceHeight();
-    virtual EGLSurface createWindowSurface(EGLDisplay display, EGLConfig config,
-                                           sp<ANativeWindow>& window) const;
-
-    ::testing::AssertionResult checkPixel(int x, int y,
-            int r, int g, int b, int a, int tolerance = 2);
-    ::testing::AssertionResult assertRectEq(const Rect &r1, const Rect &r2,
-            int tolerance = 1);
-
-    int mDisplaySecs;
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mSurfaceControl;
-
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurface;
-    EGLContext mEglContext;
-    EGLConfig  mGlConfig;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/IGraphicBufferProducer_test.cpp b/libs/gui/tests/IGraphicBufferProducer_test.cpp
deleted file mode 100644
index dd23bd4cb2..0000000000
--- a/libs/gui/tests/IGraphicBufferProducer_test.cpp
+++ /dev/null
@@ -1,735 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "IGraphicBufferProducer_test"
-//#define LOG_NDEBUG 0
-
-#include "DummyConsumer.h"
-
-#include <gtest/gtest.h>
-
-#include <utils/String8.h>
-#include <utils/threads.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include <gui/BufferQueue.h>
-#include <gui/IProducerListener.h>
-
-#include <system/window.h>
-
-#include <vector>
-
-#define ASSERT_OK(x) ASSERT_EQ(OK, (x))
-#define EXPECT_OK(x) EXPECT_EQ(OK, (x))
-
-#define TEST_TOKEN ((IProducerListener*)(NULL))
-#define TEST_API NATIVE_WINDOW_API_CPU
-#define TEST_API_OTHER NATIVE_WINDOW_API_EGL // valid API that's not TEST_API
-#define TEST_CONTROLLED_BY_APP false
-#define TEST_PRODUCER_USAGE_BITS (0)
-
-namespace android {
-
-namespace {
-    // Default dimensions before setDefaultBufferSize is called
-    const uint32_t DEFAULT_WIDTH = 1;
-    const uint32_t DEFAULT_HEIGHT = 1;
-
-    // Default format before setDefaultBufferFormat is called
-    const PixelFormat DEFAULT_FORMAT = HAL_PIXEL_FORMAT_RGBA_8888;
-
-    // Default transform hint before setTransformHint is called
-    const uint32_t DEFAULT_TRANSFORM_HINT = 0;
-
-    // TODO: Make these constants in header
-    const int DEFAULT_CONSUMER_USAGE_BITS = 0;
-
-    // Parameters for a generic "valid" input for queueBuffer.
-    const int64_t QUEUE_BUFFER_INPUT_TIMESTAMP = 1384888611;
-    const bool QUEUE_BUFFER_INPUT_IS_AUTO_TIMESTAMP = false;
-    const android_dataspace QUEUE_BUFFER_INPUT_DATASPACE = HAL_DATASPACE_UNKNOWN;
-    const Rect QUEUE_BUFFER_INPUT_RECT = Rect(DEFAULT_WIDTH, DEFAULT_HEIGHT);
-    const int QUEUE_BUFFER_INPUT_SCALING_MODE = 0;
-    const int QUEUE_BUFFER_INPUT_TRANSFORM = 0;
-    const sp<Fence> QUEUE_BUFFER_INPUT_FENCE = Fence::NO_FENCE;
-}; // namespace anonymous
-
-class IGraphicBufferProducerTest : public ::testing::Test {
-protected:
-
-    IGraphicBufferProducerTest() {}
-
-    virtual void SetUp() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-
-        mDC = new DummyConsumer;
-
-        BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-
-        // Test check: Can't connect producer if no consumer yet
-        ASSERT_EQ(NO_INIT, TryConnectProducer());
-
-        // Must connect consumer before producer connects will succeed.
-        ASSERT_OK(mConsumer->consumerConnect(mDC, /*controlledByApp*/false));
-    }
-
-    virtual void TearDown() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    status_t TryConnectProducer() {
-        IGraphicBufferProducer::QueueBufferOutput output;
-        return mProducer->connect(TEST_TOKEN,
-                                  TEST_API,
-                                  TEST_CONTROLLED_BY_APP,
-                                  &output);
-        // TODO: use params to vary token, api, producercontrolledbyapp, etc
-    }
-
-    // Connect to a producer in a 'correct' fashion.
-    //   Precondition: Consumer is connected.
-    void ConnectProducer() {
-        ASSERT_OK(TryConnectProducer());
-    }
-
-    // Create a generic "valid" input for queueBuffer
-    // -- uses the default buffer format, width, etc.
-    static IGraphicBufferProducer::QueueBufferInput CreateBufferInput() {
-        return QueueBufferInputBuilder().build();
-    }
-
-    // Builder pattern to slightly vary *almost* correct input
-    // -- avoids copying and pasting
-    struct QueueBufferInputBuilder {
-        QueueBufferInputBuilder() {
-           timestamp = QUEUE_BUFFER_INPUT_TIMESTAMP;
-           isAutoTimestamp = QUEUE_BUFFER_INPUT_IS_AUTO_TIMESTAMP;
-           dataSpace = QUEUE_BUFFER_INPUT_DATASPACE;
-           crop = QUEUE_BUFFER_INPUT_RECT;
-           scalingMode = QUEUE_BUFFER_INPUT_SCALING_MODE;
-           transform = QUEUE_BUFFER_INPUT_TRANSFORM;
-           fence = QUEUE_BUFFER_INPUT_FENCE;
-        }
-
-        IGraphicBufferProducer::QueueBufferInput build() {
-            return IGraphicBufferProducer::QueueBufferInput(
-                    timestamp,
-                    isAutoTimestamp,
-                    dataSpace,
-                    crop,
-                    scalingMode,
-                    transform,
-                    fence);
-        }
-
-        QueueBufferInputBuilder& setTimestamp(int64_t timestamp) {
-            this->timestamp = timestamp;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setIsAutoTimestamp(bool isAutoTimestamp) {
-            this->isAutoTimestamp = isAutoTimestamp;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setDataSpace(android_dataspace dataSpace) {
-            this->dataSpace = dataSpace;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setCrop(Rect crop) {
-            this->crop = crop;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setScalingMode(int scalingMode) {
-            this->scalingMode = scalingMode;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setTransform(uint32_t transform) {
-            this->transform = transform;
-            return *this;
-        }
-
-        QueueBufferInputBuilder& setFence(sp<Fence> fence) {
-            this->fence = fence;
-            return *this;
-        }
-
-    private:
-        int64_t timestamp;
-        bool isAutoTimestamp;
-        android_dataspace dataSpace;
-        Rect crop;
-        int scalingMode;
-        uint32_t transform;
-        sp<Fence> fence;
-    }; // struct QueueBufferInputBuilder
-
-    // To easily store dequeueBuffer results into containers
-    struct DequeueBufferResult {
-        int slot;
-        sp<Fence> fence;
-    };
-
-    status_t dequeueBuffer(uint32_t w, uint32_t h, uint32_t format, uint32_t usage, DequeueBufferResult* result) {
-        return mProducer->dequeueBuffer(&result->slot, &result->fence, w, h, format, usage,
-                                        nullptr, nullptr);
-    }
-
-    void setupDequeueRequestBuffer(int *slot, sp<Fence> *fence,
-            sp<GraphicBuffer> *buffer)
-    {
-        ASSERT_TRUE(slot != NULL);
-        ASSERT_TRUE(fence != NULL);
-        ASSERT_TRUE(buffer != NULL);
-
-        ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(slot, fence, DEFAULT_WIDTH, DEFAULT_HEIGHT,
-                                                    DEFAULT_FORMAT, TEST_PRODUCER_USAGE_BITS,
-                                                    nullptr, nullptr)));
-
-        EXPECT_LE(0, *slot);
-        EXPECT_GT(BufferQueue::NUM_BUFFER_SLOTS, *slot);
-
-        // Request the buffer (pre-requisite for queueing)
-        ASSERT_OK(mProducer->requestBuffer(*slot, buffer));
-    }
-
-private: // hide from test body
-    sp<DummyConsumer> mDC;
-
-protected: // accessible from test body
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-};
-
-TEST_F(IGraphicBufferProducerTest, ConnectFirst_ReturnsError) {
-    IGraphicBufferProducer::QueueBufferOutput output;
-
-    // NULL output returns BAD_VALUE
-    EXPECT_EQ(BAD_VALUE, mProducer->connect(TEST_TOKEN,
-                                            TEST_API,
-                                            TEST_CONTROLLED_BY_APP,
-                                            /*output*/NULL));
-
-    // Invalid API returns bad value
-    EXPECT_EQ(BAD_VALUE, mProducer->connect(TEST_TOKEN,
-                                            /*api*/0xDEADBEEF,
-                                            TEST_CONTROLLED_BY_APP,
-                                            &output));
-
-    // TODO: get a token from a dead process somehow
-}
-
-TEST_F(IGraphicBufferProducerTest, ConnectAgain_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // Can't connect when there is already a producer connected
-    IGraphicBufferProducer::QueueBufferOutput output;
-    EXPECT_EQ(BAD_VALUE, mProducer->connect(TEST_TOKEN,
-                                            TEST_API,
-                                            TEST_CONTROLLED_BY_APP,
-                                            &output));
-
-    ASSERT_OK(mConsumer->consumerDisconnect());
-    // Can't connect when IGBP is abandoned
-    EXPECT_EQ(NO_INIT, mProducer->connect(TEST_TOKEN,
-                                          TEST_API,
-                                          TEST_CONTROLLED_BY_APP,
-                                          &output));
-}
-
-TEST_F(IGraphicBufferProducerTest, Disconnect_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-}
-
-
-TEST_F(IGraphicBufferProducerTest, Disconnect_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // Must disconnect with same API number
-    ASSERT_EQ(BAD_VALUE, mProducer->disconnect(TEST_API_OTHER));
-    // API must not be out of range
-    ASSERT_EQ(BAD_VALUE, mProducer->disconnect(/*api*/0xDEADBEEF));
-
-    // TODO: somehow kill mProducer so that this returns DEAD_OBJECT
-}
-
-TEST_F(IGraphicBufferProducerTest, Query_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int32_t value = -1;
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_WIDTH, &value));
-    EXPECT_EQ(DEFAULT_WIDTH, static_cast<uint32_t>(value));
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_HEIGHT, &value));
-    EXPECT_EQ(DEFAULT_HEIGHT, static_cast<uint32_t>(value));
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_FORMAT, &value));
-    EXPECT_EQ(DEFAULT_FORMAT, value);
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS, &value));
-    EXPECT_LE(0, value);
-    EXPECT_GE(BufferQueue::NUM_BUFFER_SLOTS, value);
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND, &value));
-    EXPECT_FALSE(value); // Can't run behind when we haven't touched the queue
-
-    EXPECT_OK(mProducer->query(NATIVE_WINDOW_CONSUMER_USAGE_BITS, &value));
-    EXPECT_EQ(DEFAULT_CONSUMER_USAGE_BITS, value);
-
-}
-
-TEST_F(IGraphicBufferProducerTest, Query_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // One past the end of the last 'query' enum value. Update this if we add more enums.
-    const int NATIVE_WINDOW_QUERY_LAST_OFF_BY_ONE = NATIVE_WINDOW_BUFFER_AGE + 1;
-
-    int value;
-    // What was out of range
-    EXPECT_EQ(BAD_VALUE, mProducer->query(/*what*/-1, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(/*what*/0xDEADBEEF, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_QUERY_LAST_OFF_BY_ONE, &value));
-
-    // Some enums from window.h are 'invalid'
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_CONCRETE_TYPE, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_DEFAULT_WIDTH, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_DEFAULT_HEIGHT, &value));
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_TRANSFORM_HINT, &value));
-    // TODO: Consider documented the above enums as unsupported or make a new enum for IGBP
-
-    // Value was NULL
-    EXPECT_EQ(BAD_VALUE, mProducer->query(NATIVE_WINDOW_FORMAT, /*value*/NULL));
-
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // BQ was abandoned
-    EXPECT_EQ(NO_INIT, mProducer->query(NATIVE_WINDOW_FORMAT, &value));
-
-    // TODO: other things in window.h that are supported by Surface::query
-    // but not by BufferQueue::query
-}
-
-// TODO: queue under more complicated situations not involving just a single buffer
-TEST_F(IGraphicBufferProducerTest, Queue_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)));
-
-    EXPECT_LE(0, dequeuedSlot);
-    EXPECT_GT(BufferQueue::NUM_BUFFER_SLOTS, dequeuedSlot);
-
-    // Request the buffer (pre-requisite for queueing)
-    sp<GraphicBuffer> dequeuedBuffer;
-    ASSERT_OK(mProducer->requestBuffer(dequeuedSlot, &dequeuedBuffer));
-
-    // A generic "valid" input
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-
-    // Queue the buffer back into the BQ
-    ASSERT_OK(mProducer->queueBuffer(dequeuedSlot, input, &output));
-
-    {
-        EXPECT_EQ(DEFAULT_WIDTH, output.width);
-        EXPECT_EQ(DEFAULT_HEIGHT, output.height);
-        EXPECT_EQ(DEFAULT_TRANSFORM_HINT, output.transformHint);
-        // Since queueBuffer was called exactly once
-        EXPECT_EQ(1u, output.numPendingBuffers);
-        EXPECT_EQ(2u, output.nextFrameNumber);
-    }
-
-    // Buffer was not in the dequeued state
-    EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-}
-
-TEST_F(IGraphicBufferProducerTest, Queue_ReturnsError) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    // Invalid slot number
-    {
-        // A generic "valid" input
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(/*slot*/-1, input, &output));
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(/*slot*/0xDEADBEEF, input, &output));
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(BufferQueue::NUM_BUFFER_SLOTS,
-                                                    input, &output));
-    }
-
-    // Slot was not in the dequeued state (all slots start out in Free state)
-    {
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(/*slot*/0, input, &output));
-    }
-
-    // Put the slot into the "dequeued" state for the rest of the test
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)));
-
-    // Slot was enqueued without requesting a buffer
-    {
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Request the buffer so that the rest of the tests don't fail on earlier checks.
-    sp<GraphicBuffer> dequeuedBuffer;
-    ASSERT_OK(mProducer->requestBuffer(dequeuedSlot, &dequeuedBuffer));
-
-    // Fence was NULL
-    {
-        sp<Fence> nullFence = NULL;
-
-        IGraphicBufferProducer::QueueBufferInput input =
-                QueueBufferInputBuilder().setFence(nullFence).build();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Scaling mode was unknown
-    {
-        IGraphicBufferProducer::QueueBufferInput input =
-                QueueBufferInputBuilder().setScalingMode(-1).build();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-
-        input = QueueBufferInputBuilder().setScalingMode(0xDEADBEEF).build();
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Crop rect is out of bounds of the buffer dimensions
-    {
-        IGraphicBufferProducer::QueueBufferInput input =
-                QueueBufferInputBuilder().setCrop(Rect(DEFAULT_WIDTH + 1, DEFAULT_HEIGHT + 1))
-                .build();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(BAD_VALUE, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-
-    // Abandon the buffer queue so that the last test fails
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // The buffer queue has been abandoned.
-    {
-        IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-        IGraphicBufferProducer::QueueBufferOutput output;
-
-        EXPECT_EQ(NO_INIT, mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-}
-
-TEST_F(IGraphicBufferProducerTest, CancelBuffer_DoesntCrash) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)));
-
-    // No return code, but at least test that it doesn't blow up...
-    // TODO: add a return code
-    mProducer->cancelBuffer(dequeuedSlot, dequeuedFence);
-}
-
-TEST_F(IGraphicBufferProducerTest, SetMaxDequeuedBufferCount_Succeeds) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    int minUndequeuedBuffers;
-    ASSERT_OK(mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-            &minUndequeuedBuffers));
-
-    const int minBuffers = 1;
-    const int maxBuffers = BufferQueue::NUM_BUFFER_SLOTS - minUndequeuedBuffers;
-
-    ASSERT_OK(mProducer->setAsyncMode(false)) << "async mode: " << false;
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(minBuffers))
-            << "bufferCount: " << minBuffers;
-
-    // Should now be able to dequeue up to minBuffers times
-    DequeueBufferResult result;
-    for (int i = 0; i < minBuffers; ++i) {
-
-        EXPECT_EQ(OK, ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                (dequeueBuffer(DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                              TEST_PRODUCER_USAGE_BITS, &result)))
-                << "iteration: " << i << ", slot: " << result.slot;
-    }
-
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(maxBuffers));
-
-    // queue the first buffer to enable max dequeued buffer count checking
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<GraphicBuffer> buffer;
-    ASSERT_OK(mProducer->requestBuffer(result.slot, &buffer));
-    ASSERT_OK(mProducer->queueBuffer(result.slot, input, &output));
-
-
-    // Should now be able to dequeue up to maxBuffers times
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-    for (int i = 0; i < maxBuffers; ++i) {
-        EXPECT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "iteration: " << i << ", slot: " << dequeuedSlot;
-    }
-
-    // Cancel a buffer, so we can decrease the buffer count
-    ASSERT_OK(mProducer->cancelBuffer(dequeuedSlot, dequeuedFence));
-
-    // Should now be able to decrease the max dequeued count by 1
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(maxBuffers-1));
-}
-
-TEST_F(IGraphicBufferProducerTest, SetMaxDequeuedBufferCount_Fails) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    int minUndequeuedBuffers;
-    ASSERT_OK(mProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
-                               &minUndequeuedBuffers));
-
-    const int minBuffers = 1;
-    const int maxBuffers = BufferQueue::NUM_BUFFER_SLOTS - minUndequeuedBuffers;
-
-    ASSERT_OK(mProducer->setAsyncMode(false)) << "async mode: " << false;
-    // Buffer count was out of range
-    EXPECT_EQ(BAD_VALUE, mProducer->setMaxDequeuedBufferCount(0))
-            << "bufferCount: " << 0;
-    EXPECT_EQ(BAD_VALUE, mProducer->setMaxDequeuedBufferCount(maxBuffers + 1))
-            << "bufferCount: " << maxBuffers + 1;
-
-    // Set max dequeue count to 2
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(2));
-    // Dequeue 2 buffers
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-    for (int i = 0; i < 2; i++) {
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "slot: " << dequeuedSlot;
-    }
-
-    // Client has too many buffers dequeued
-    EXPECT_EQ(BAD_VALUE, mProducer->setMaxDequeuedBufferCount(1))
-            << "bufferCount: " << minBuffers;
-
-    // Abandon buffer queue
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // Fail because the buffer queue was abandoned
-    EXPECT_EQ(NO_INIT, mProducer->setMaxDequeuedBufferCount(minBuffers))
-            << "bufferCount: " << minBuffers;
-
-}
-
-TEST_F(IGraphicBufferProducerTest, SetAsyncMode_Succeeds) {
-    ASSERT_OK(mConsumer->setMaxAcquiredBufferCount(1)) << "maxAcquire: " << 1;
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    ASSERT_OK(mProducer->setAsyncMode(true)) << "async mode: " << true;
-    ASSERT_OK(mProducer->setMaxDequeuedBufferCount(1)) << "maxDequeue: " << 1;
-
-    int dequeuedSlot = -1;
-    sp<Fence> dequeuedFence;
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-    sp<GraphicBuffer> dequeuedBuffer;
-
-    // Should now be able to queue/dequeue as many buffers as we want without
-    // blocking
-    for (int i = 0; i < 5; ++i) {
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "slot : " << dequeuedSlot;
-        ASSERT_OK(mProducer->requestBuffer(dequeuedSlot, &dequeuedBuffer));
-        ASSERT_OK(mProducer->queueBuffer(dequeuedSlot, input, &output));
-    }
-}
-
-TEST_F(IGraphicBufferProducerTest, SetAsyncMode_Fails) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-    // Prerequisite to fail out a valid setBufferCount call
-    {
-        int dequeuedSlot = -1;
-        sp<Fence> dequeuedFence;
-
-        ASSERT_EQ(OK,
-                  ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                          (mProducer->dequeueBuffer(&dequeuedSlot, &dequeuedFence, DEFAULT_WIDTH,
-                                                    DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                                    TEST_PRODUCER_USAGE_BITS, nullptr, nullptr)))
-                << "slot: " << dequeuedSlot;
-    }
-
-    // Abandon buffer queue
-    ASSERT_OK(mConsumer->consumerDisconnect());
-
-    // Fail because the buffer queue was abandoned
-    EXPECT_EQ(NO_INIT, mProducer->setAsyncMode(false)) << "asyncMode: "
-            << false;
-}
-
-TEST_F(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_dequeueBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-
-    ASSERT_EQ(NO_INIT,
-              mProducer->dequeueBuffer(&slot, &fence, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_FORMAT,
-                                       TEST_PRODUCER_USAGE_BITS, nullptr, nullptr));
-}
-
-TEST_F(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_detachNextBuffer) {
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    ASSERT_EQ(NO_INIT, mProducer->detachNextBuffer(&buffer, &fence));
-}
-
-TEST_F(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_requestBuffer) {
-    ASSERT_NO_FATAL_FAILURE(ConnectProducer());
-
-    int slot = -1;
-    sp<Fence> fence;
-
-    ASSERT_EQ(OK,
-              ~IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION &
-                      (mProducer->dequeueBuffer(&slot, &fence, DEFAULT_WIDTH, DEFAULT_HEIGHT,
-                                                DEFAULT_FORMAT, TEST_PRODUCER_USAGE_BITS,
-                                                nullptr, nullptr)));
-
-    EXPECT_LE(0, slot);
-    EXPECT_GT(BufferQueue::NUM_BUFFER_SLOTS, slot);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    sp<GraphicBuffer> buffer;
-
-    ASSERT_EQ(NO_INIT, mProducer->requestBuffer(slot, &buffer));
-}
-
-
-TEST_F(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_detachBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    ASSERT_EQ(NO_INIT, mProducer->detachBuffer(slot));
-}
-
-TEST_F(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_queueBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    // A generic "valid" input
-    IGraphicBufferProducer::QueueBufferInput input = CreateBufferInput();
-    IGraphicBufferProducer::QueueBufferOutput output;
-
-    ASSERT_EQ(NO_INIT, mProducer->queueBuffer(slot, input, &output));
-}
-
-TEST_F(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_cancelBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    ASSERT_EQ(NO_INIT, mProducer->cancelBuffer(slot, fence));
-}
-
-TEST_F(IGraphicBufferProducerTest,
-        DisconnectedProducerReturnsError_attachBuffer) {
-    int slot = -1;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-
-    setupDequeueRequestBuffer(&slot, &fence, &buffer);
-
-    ASSERT_OK(mProducer->detachBuffer(slot));
-
-    ASSERT_OK(mProducer->disconnect(TEST_API));
-
-    ASSERT_EQ(NO_INIT, mProducer->attachBuffer(&slot, buffer));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/Malicious.cpp b/libs/gui/tests/Malicious.cpp
deleted file mode 100644
index bb6b8a59fe..0000000000
--- a/libs/gui/tests/Malicious.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gui/BufferQueue.h>
-#include <gui/IProducerListener.h>
-#include <gui/Surface.h>
-
-#include <android/native_window.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-namespace test {
-
-class ProxyBQP : public BnGraphicBufferProducer {
-public:
-    ProxyBQP(const sp<IGraphicBufferProducer>& producer) : mProducer(producer) {}
-
-    // Pass through calls to mProducer
-    status_t requestBuffer(int slot, sp<GraphicBuffer>* buf) override {
-        return mProducer->requestBuffer(slot, buf);
-    }
-    status_t setMaxDequeuedBufferCount(int maxDequeuedBuffers) override {
-        return mProducer->setMaxDequeuedBufferCount(maxDequeuedBuffers);
-    }
-    status_t setAsyncMode(bool async) override { return mProducer->setAsyncMode(async); }
-    status_t dequeueBuffer(int* slot, sp<Fence>* fence, uint32_t w, uint32_t h, PixelFormat format,
-                           uint64_t usage, uint64_t* outBufferAge,
-                           FrameEventHistoryDelta* outTimestamps) override {
-        return mProducer->dequeueBuffer(slot, fence, w, h, format, usage, outBufferAge,
-                                        outTimestamps);
-    }
-    status_t detachBuffer(int slot) override { return mProducer->detachBuffer(slot); }
-    status_t detachNextBuffer(sp<GraphicBuffer>* outBuffer, sp<Fence>* outFence) override {
-        return mProducer->detachNextBuffer(outBuffer, outFence);
-    }
-    status_t attachBuffer(int* outSlot, const sp<GraphicBuffer>& buffer) override {
-        return mProducer->attachBuffer(outSlot, buffer);
-    }
-    status_t queueBuffer(int slot, const QueueBufferInput& input,
-                         QueueBufferOutput* output) override {
-        return mProducer->queueBuffer(slot, input, output);
-    }
-    status_t cancelBuffer(int slot, const sp<Fence>& fence) override {
-        return mProducer->cancelBuffer(slot, fence);
-    }
-    int query(int what, int* value) override { return mProducer->query(what, value); }
-    status_t connect(const sp<IProducerListener>& listener, int api, bool producerControlledByApp,
-                     QueueBufferOutput* output) override {
-        return mProducer->connect(listener, api, producerControlledByApp, output);
-    }
-    status_t disconnect(int api, DisconnectMode mode) override {
-        return mProducer->disconnect(api, mode);
-    }
-    status_t setSidebandStream(const sp<NativeHandle>& stream) override {
-        return mProducer->setSidebandStream(stream);
-    }
-    void allocateBuffers(uint32_t width, uint32_t height, PixelFormat format,
-                         uint64_t usage) override {
-        mProducer->allocateBuffers(width, height, format, usage);
-    }
-    status_t allowAllocation(bool allow) override { return mProducer->allowAllocation(allow); }
-    status_t setGenerationNumber(uint32_t generationNumber) override {
-        return mProducer->setGenerationNumber(generationNumber);
-    }
-    String8 getConsumerName() const override { return mProducer->getConsumerName(); }
-    status_t setSharedBufferMode(bool sharedBufferMode) override {
-        return mProducer->setSharedBufferMode(sharedBufferMode);
-    }
-    status_t setAutoRefresh(bool autoRefresh) override {
-        return mProducer->setAutoRefresh(autoRefresh);
-    }
-    status_t setDequeueTimeout(nsecs_t timeout) override {
-        return mProducer->setDequeueTimeout(timeout);
-    }
-    status_t getLastQueuedBuffer(sp<GraphicBuffer>* outBuffer, sp<Fence>* outFence,
-                                 float outTransformMatrix[16]) override {
-        return mProducer->getLastQueuedBuffer(outBuffer, outFence, outTransformMatrix);
-    }
-    void getFrameTimestamps(FrameEventHistoryDelta*) override {}
-    status_t getUniqueId(uint64_t* outId) const override { return mProducer->getUniqueId(outId); }
-    status_t getConsumerUsage(uint64_t* outUsage) const override {
-        return mProducer->getConsumerUsage(outUsage);
-    }
-
-protected:
-    sp<IGraphicBufferProducer> mProducer;
-};
-
-class MaliciousBQP : public ProxyBQP {
-public:
-    MaliciousBQP(const sp<IGraphicBufferProducer>& producer) : ProxyBQP(producer) {}
-
-    void beMalicious(int32_t value) { mMaliciousValue = value; }
-
-    void setExpectedSlot(int32_t slot) { mExpectedSlot = slot; }
-
-    // Override dequeueBuffer, optionally corrupting the returned slot number
-    status_t dequeueBuffer(int* buf, sp<Fence>* fence, uint32_t width, uint32_t height,
-                           PixelFormat format, uint64_t usage, uint64_t* outBufferAge,
-                           FrameEventHistoryDelta* outTimestamps) override {
-        EXPECT_EQ(BUFFER_NEEDS_REALLOCATION,
-                  mProducer->dequeueBuffer(buf, fence, width, height, format, usage, outBufferAge,
-                                           outTimestamps));
-        EXPECT_EQ(mExpectedSlot, *buf);
-        if (mMaliciousValue != 0) {
-            *buf = mMaliciousValue;
-            return NO_ERROR;
-        } else {
-            return BUFFER_NEEDS_REALLOCATION;
-        }
-    }
-
-private:
-    int32_t mMaliciousValue = 0;
-    int32_t mExpectedSlot = 0;
-};
-
-class DummyListener : public BnConsumerListener {
-public:
-    void onFrameAvailable(const BufferItem&) override {}
-    void onBuffersReleased() override {}
-    void onSidebandStreamChanged() override {}
-};
-
-sp<MaliciousBQP> getMaliciousBQP() {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<IConsumerListener> listener = new DummyListener;
-    consumer->consumerConnect(listener, false);
-
-    sp<MaliciousBQP> malicious = new MaliciousBQP(producer);
-    return malicious;
-}
-
-TEST(Malicious, Bug36991414Max) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(std::numeric_limits<int32_t>::max());
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-TEST(Malicious, Bug36991414Min) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(std::numeric_limits<int32_t>::min());
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-TEST(Malicious, Bug36991414NegativeOne) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(-1);
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-TEST(Malicious, Bug36991414NumSlots) {
-    sp<MaliciousBQP> malicious = getMaliciousBQP();
-    sp<Surface> surface = new Surface(malicious);
-
-    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, nullptr, false));
-    ANativeWindow_Buffer buffer;
-    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr));
-    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
-
-    malicious->setExpectedSlot(1);
-    malicious->beMalicious(BufferQueueDefs::NUM_BUFFER_SLOTS);
-    ASSERT_EQ(FAILED_TRANSACTION, surface->lock(&buffer, nullptr));
-}
-
-} // namespace test
-} // namespace android
diff --git a/libs/gui/tests/MultiTextureConsumer_test.cpp b/libs/gui/tests/MultiTextureConsumer_test.cpp
deleted file mode 100644
index 3a25ac59ca..0000000000
--- a/libs/gui/tests/MultiTextureConsumer_test.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "MultiTextureConsumer_test"
-//#define LOG_NDEBUG 0
-
-#include "GLTest.h"
-
-#include <gui/GLConsumer.h>
-#include <gui/Surface.h>
-
-#include <android/native_window.h>
-
-#include <GLES/glext.h>
-
-namespace android {
-
-class MultiTextureConsumerTest : public GLTest {
-protected:
-    enum { TEX_ID = 123 };
-
-    virtual void SetUp() {
-        GLTest::SetUp();
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        mGlConsumer = new GLConsumer(consumer, TEX_ID,
-                GLConsumer::TEXTURE_EXTERNAL, true, false);
-        mSurface = new Surface(producer);
-        mANW = mSurface.get();
-
-    }
-    virtual void TearDown() {
-        GLTest::TearDown();
-    }
-    virtual EGLint const* getContextAttribs() {
-        return NULL;
-    }
-    virtual EGLint const* getConfigAttribs() {
-        static EGLint sDefaultConfigAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
-            EGL_RED_SIZE, 8,
-            EGL_GREEN_SIZE, 8,
-            EGL_BLUE_SIZE, 8,
-            EGL_ALPHA_SIZE, 8,
-            EGL_NONE };
-
-        return sDefaultConfigAttribs;
-    }
-    sp<GLConsumer> mGlConsumer;
-    sp<Surface> mSurface;
-    ANativeWindow* mANW;
-};
-
-TEST_F(MultiTextureConsumerTest, EGLImageTargetWorks) {
-    ANativeWindow_Buffer buffer;
-
-    ASSERT_EQ(native_window_set_usage(mANW, GRALLOC_USAGE_SW_WRITE_OFTEN), NO_ERROR);
-    ASSERT_EQ(native_window_set_buffers_format(mANW, HAL_PIXEL_FORMAT_RGBA_8888), NO_ERROR);
-
-    glShadeModel(GL_FLAT);
-    glDisable(GL_DITHER);
-    glDisable(GL_CULL_FACE);
-    glViewport(0, 0, getSurfaceWidth(), getSurfaceHeight());
-    glOrthof(0, getSurfaceWidth(), 0, getSurfaceHeight(), 0, 1);
-    glEnableClientState(GL_VERTEX_ARRAY);
-    glColor4f(1, 1, 1, 1);
-
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, TEX_ID);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-
-    uint32_t texel = 0x80808080;
-    glBindTexture(GL_TEXTURE_2D, TEX_ID+1);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE, &texel);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_2D, TEX_ID+1);
-    glEnable(GL_TEXTURE_2D);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, TEX_ID);
-    glEnable(GL_TEXTURE_EXTERNAL_OES);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-
-    glClear(GL_COLOR_BUFFER_BIT);
-    for (int i=0 ; i<8 ; i++) {
-        mSurface->lock(&buffer, NULL);
-        memset(buffer.bits, (i&7) * 0x20, buffer.stride * buffer.height * 4);
-        mSurface->unlockAndPost();
-
-        mGlConsumer->updateTexImage();
-
-        GLfloat vertices[][2] = { {i*16.0f, 0}, {(i+1)*16.0f, 0}, {(i+1)*16.0f, 16.0f}, {i*16.0f, 16.0f} };
-        glVertexPointer(2, GL_FLOAT, 0, vertices);
-        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    }
-
-    for (int i=0 ; i<8 ; i++) {
-        EXPECT_TRUE(checkPixel(i*16 + 8,  8, i*16, i*16, i*16, i*16, 0));
-    }
-}
-
-} // namespace android
diff --git a/libs/gui/tests/StreamSplitter_test.cpp b/libs/gui/tests/StreamSplitter_test.cpp
deleted file mode 100644
index ad6e051684..0000000000
--- a/libs/gui/tests/StreamSplitter_test.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "StreamSplitter_test"
-//#define LOG_NDEBUG 0
-
-#include <gui/BufferItem.h>
-#include <gui/BufferQueue.h>
-#include <gui/IConsumerListener.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/StreamSplitter.h>
-#include <private/gui/ComposerService.h>
-
-#include <system/window.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-class StreamSplitterTest : public ::testing::Test {
-
-protected:
-    StreamSplitterTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    ~StreamSplitterTest() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-};
-
-struct DummyListener : public BnConsumerListener {
-    virtual void onFrameAvailable(const BufferItem& /* item */) {}
-    virtual void onBuffersReleased() {}
-    virtual void onSidebandStreamChanged() {}
-};
-
-static const uint32_t TEST_DATA = 0x12345678u;
-
-TEST_F(StreamSplitterTest, OneInputOneOutput) {
-    sp<IGraphicBufferProducer> inputProducer;
-    sp<IGraphicBufferConsumer> inputConsumer;
-    BufferQueue::createBufferQueue(&inputProducer, &inputConsumer);
-
-    sp<IGraphicBufferProducer> outputProducer;
-    sp<IGraphicBufferConsumer> outputConsumer;
-    BufferQueue::createBufferQueue(&outputProducer, &outputConsumer);
-    ASSERT_EQ(OK, outputConsumer->consumerConnect(new DummyListener, false));
-
-    sp<StreamSplitter> splitter;
-    status_t status = StreamSplitter::createSplitter(inputConsumer, &splitter);
-    ASSERT_EQ(OK, status);
-    ASSERT_EQ(OK, splitter->addOutput(outputProducer));
-
-    // Never allow the output BufferQueue to allocate a buffer
-    ASSERT_EQ(OK, outputProducer->allowAllocation(false));
-
-    IGraphicBufferProducer::QueueBufferOutput qbOutput;
-    ASSERT_EQ(OK, inputProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &qbOutput));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-    ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
-
-    // Now that we have dequeued/allocated one buffer, prevent any further
-    // allocations
-    ASSERT_EQ(OK, inputProducer->allowAllocation(false));
-
-    BufferItem item;
-    ASSERT_EQ(OK, outputConsumer->acquireBuffer(&item, 0));
-
-    uint32_t* dataOut;
-    ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-            reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
-    ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-
-    ASSERT_EQ(OK, outputConsumer->releaseBuffer(item.mSlot, item.mFrameNumber,
-            EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, Fence::NO_FENCE));
-
-    // This should succeed even with allocation disabled since it will have
-    // received the buffer back from the output BufferQueue
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-}
-
-TEST_F(StreamSplitterTest, OneInputMultipleOutputs) {
-    const int NUM_OUTPUTS = 4;
-
-    sp<IGraphicBufferProducer> inputProducer;
-    sp<IGraphicBufferConsumer> inputConsumer;
-    BufferQueue::createBufferQueue(&inputProducer, &inputConsumer);
-
-    sp<IGraphicBufferProducer> outputProducers[NUM_OUTPUTS] = {};
-    sp<IGraphicBufferConsumer> outputConsumers[NUM_OUTPUTS] = {};
-    for (int output = 0; output < NUM_OUTPUTS; ++output) {
-        BufferQueue::createBufferQueue(&outputProducers[output],
-                &outputConsumers[output]);
-        ASSERT_EQ(OK, outputConsumers[output]->consumerConnect(
-                    new DummyListener, false));
-    }
-
-    sp<StreamSplitter> splitter;
-    status_t status = StreamSplitter::createSplitter(inputConsumer, &splitter);
-    ASSERT_EQ(OK, status);
-    for (int output = 0; output < NUM_OUTPUTS; ++output) {
-        ASSERT_EQ(OK, splitter->addOutput(outputProducers[output]));
-
-        // Never allow the output BufferQueues to allocate a buffer
-        ASSERT_EQ(OK, outputProducers[output]->allowAllocation(false));
-    }
-
-    IGraphicBufferProducer::QueueBufferOutput qbOutput;
-    ASSERT_EQ(OK, inputProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &qbOutput));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-    ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
-
-    uint32_t* dataIn;
-    ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
-            reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
-    ASSERT_EQ(OK, buffer->unlock());
-
-    IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
-
-    // Now that we have dequeued/allocated one buffer, prevent any further
-    // allocations
-    ASSERT_EQ(OK, inputProducer->allowAllocation(false));
-
-    for (int output = 0; output < NUM_OUTPUTS; ++output) {
-        BufferItem item;
-        ASSERT_EQ(OK, outputConsumers[output]->acquireBuffer(&item, 0));
-
-        uint32_t* dataOut;
-        ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
-                    reinterpret_cast<void**>(&dataOut)));
-        ASSERT_EQ(*dataOut, TEST_DATA);
-        ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
-
-        ASSERT_EQ(OK, outputConsumers[output]->releaseBuffer(item.mSlot,
-                    item.mFrameNumber, EGL_NO_DISPLAY, EGL_NO_SYNC_KHR,
-                    Fence::NO_FENCE));
-    }
-
-    // This should succeed even with allocation disabled since it will have
-    // received the buffer back from the output BufferQueues
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-}
-
-TEST_F(StreamSplitterTest, OutputAbandonment) {
-    sp<IGraphicBufferProducer> inputProducer;
-    sp<IGraphicBufferConsumer> inputConsumer;
-    BufferQueue::createBufferQueue(&inputProducer, &inputConsumer);
-
-    sp<IGraphicBufferProducer> outputProducer;
-    sp<IGraphicBufferConsumer> outputConsumer;
-    BufferQueue::createBufferQueue(&outputProducer, &outputConsumer);
-    ASSERT_EQ(OK, outputConsumer->consumerConnect(new DummyListener, false));
-
-    sp<StreamSplitter> splitter;
-    status_t status = StreamSplitter::createSplitter(inputConsumer, &splitter);
-    ASSERT_EQ(OK, status);
-    ASSERT_EQ(OK, splitter->addOutput(outputProducer));
-
-    IGraphicBufferProducer::QueueBufferOutput qbOutput;
-    ASSERT_EQ(OK, inputProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, false, &qbOutput));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-    ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
-
-    // Abandon the output
-    outputConsumer->consumerDisconnect();
-
-    IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
-            NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, Fence::NO_FENCE);
-    ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
-
-    // Input should be abandoned
-    ASSERT_EQ(NO_INIT,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
-                                           nullptr, nullptr));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureClient_test.cpp b/libs/gui/tests/SurfaceTextureClient_test.cpp
deleted file mode 100644
index d5b2f004ed..0000000000
--- a/libs/gui/tests/SurfaceTextureClient_test.cpp
+++ /dev/null
@@ -1,811 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureClient_test"
-//#define LOG_NDEBUG 0
-
-#include <EGL/egl.h>
-#include <GLES2/gl2.h>
-
-#include <gtest/gtest.h>
-#include <gui/GLConsumer.h>
-#include <gui/Surface.h>
-#include <gui/BufferQueue.h>
-#include <system/graphics.h>
-#include <utils/Log.h>
-#include <utils/Thread.h>
-
-extern "C" EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name);
-#define CROP_EXT_STR "EGL_ANDROID_image_crop"
-
-namespace android {
-
-class SurfaceTextureClientTest : public ::testing::Test {
-protected:
-    SurfaceTextureClientTest():
-            mEglDisplay(EGL_NO_DISPLAY),
-            mEglSurface(EGL_NO_SURFACE),
-            mEglContext(EGL_NO_CONTEXT),
-            mEglConfig(NULL) {
-    }
-
-    virtual void SetUp() {
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("Begin test: %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        mST = new GLConsumer(consumer, 123, GLConsumer::TEXTURE_EXTERNAL, true,
-                false);
-        mSTC = new Surface(producer);
-        mANW = mSTC;
-
-        // We need a valid GL context so we can test updateTexImage()
-        // This initializes EGL and create a dummy GL context with a
-        // pbuffer render target.
-        mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-
-        EGLint majorVersion, minorVersion;
-        EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        EGLConfig myConfig;
-        EGLint numConfigs = 0;
-        EXPECT_TRUE(eglChooseConfig(mEglDisplay, getConfigAttribs(),
-                &myConfig, 1, &numConfigs));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        mEglConfig = myConfig;
-        EGLint pbufferAttribs[] = {
-            EGL_WIDTH, 16,
-            EGL_HEIGHT, 16,
-            EGL_NONE };
-        mEglSurface = eglCreatePbufferSurface(mEglDisplay, myConfig, pbufferAttribs);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_SURFACE, mEglSurface);
-
-        mEglContext = eglCreateContext(mEglDisplay, myConfig, EGL_NO_CONTEXT, 0);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mEglContext);
-
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    }
-
-    virtual void TearDown() {
-        mST.clear();
-        mSTC.clear();
-        mANW.clear();
-
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-        eglDestroyContext(mEglDisplay, mEglContext);
-        eglDestroySurface(mEglDisplay, mEglSurface);
-        eglTerminate(mEglDisplay);
-
-        const ::testing::TestInfo* const testInfo =
-            ::testing::UnitTest::GetInstance()->current_test_info();
-        ALOGV("End test:   %s.%s", testInfo->test_case_name(),
-                testInfo->name());
-    }
-
-    virtual EGLint const* getConfigAttribs() {
-        static EGLint sDefaultConfigAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_PBUFFER_BIT | EGL_WINDOW_BIT,
-            EGL_NONE
-        };
-
-        return sDefaultConfigAttribs;
-    }
-
-    sp<GLConsumer> mST;
-    sp<Surface> mSTC;
-    sp<ANativeWindow> mANW;
-
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurface;
-    EGLContext mEglContext;
-    EGLConfig  mEglConfig;
-};
-
-TEST_F(SurfaceTextureClientTest, GetISurfaceTextureIsNotNull) {
-    sp<IGraphicBufferProducer> ist(mSTC->getIGraphicBufferProducer());
-    ASSERT_TRUE(ist != NULL);
-}
-
-TEST_F(SurfaceTextureClientTest, QueuesToWindowCompositorIsFalse) {
-    int result = -123;
-    int err = mANW->query(mANW.get(), NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,
-            &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(0, result);
-}
-
-TEST_F(SurfaceTextureClientTest, ConcreteTypeIsSurfaceTextureClient) {
-    int result = -123;
-    int err = mANW->query(mANW.get(), NATIVE_WINDOW_CONCRETE_TYPE, &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(NATIVE_WINDOW_SURFACE, result);
-}
-
-TEST_F(SurfaceTextureClientTest, EglCreateWindowSurfaceSucceeds) {
-    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_DISPLAY, dpy);
-
-    EGLint majorVersion;
-    EGLint minorVersion;
-    EXPECT_TRUE(eglInitialize(dpy, &majorVersion, &minorVersion));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLConfig myConfig = {0};
-    EGLint numConfigs = 0;
-    EGLint configAttribs[] = {
-        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-        EGL_RED_SIZE, 8,
-        EGL_GREEN_SIZE, 8,
-        EGL_BLUE_SIZE, 8,
-        EGL_ALPHA_SIZE, 8,
-        EGL_DEPTH_SIZE, 16,
-        EGL_STENCIL_SIZE, 8,
-        EGL_NONE };
-    EXPECT_TRUE(eglChooseConfig(dpy, configAttribs, &myConfig, 1,
-            &numConfigs));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLSurface eglSurface = eglCreateWindowSurface(dpy, myConfig, mANW.get(),
-            NULL);
-    EXPECT_NE(EGL_NO_SURFACE, eglSurface);
-    EXPECT_EQ(EGL_SUCCESS, eglGetError());
-
-    if (eglSurface != EGL_NO_SURFACE) {
-        eglDestroySurface(dpy, eglSurface);
-    }
-
-    eglTerminate(dpy);
-}
-
-TEST_F(SurfaceTextureClientTest, EglSwapBuffersAbandonErrorIsEglBadSurface) {
-
-    EGLSurface eglSurface = eglCreateWindowSurface(mEglDisplay, mEglConfig, mANW.get(), NULL);
-    EXPECT_NE(EGL_NO_SURFACE, eglSurface);
-    EXPECT_EQ(EGL_SUCCESS, eglGetError());
-
-    EGLBoolean success = eglMakeCurrent(mEglDisplay, eglSurface, eglSurface, mEglContext);
-    EXPECT_TRUE(success);
-
-    glClear(GL_COLOR_BUFFER_BIT);
-    success = eglSwapBuffers(mEglDisplay, eglSurface);
-    EXPECT_TRUE(success);
-
-    mST->abandon();
-
-    glClear(GL_COLOR_BUFFER_BIT);
-    success = eglSwapBuffers(mEglDisplay, eglSurface);
-    EXPECT_FALSE(success);
-    EXPECT_EQ(EGL_BAD_SURFACE, eglGetError());
-
-    success = eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext);
-    ASSERT_TRUE(success);
-
-    if (eglSurface != EGL_NO_SURFACE) {
-        eglDestroySurface(mEglDisplay, eglSurface);
-    }
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometryInvalidSizesFail) {
-    EXPECT_GT(OK, native_window_set_buffers_dimensions(mANW.get(),  0,  8));
-    EXPECT_GT(OK, native_window_set_buffers_dimensions(mANW.get(),  8,  0));
-}
-
-TEST_F(SurfaceTextureClientTest, DefaultGeometryValues) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometryCanBeSet) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometryDefaultSizeSetFormat) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometrySetSizeDefaultFormat) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometrySizeCanBeUnset) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, BufferGeometrySizeCanBeChangedWithoutFormat) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(1, buf->width);
-    EXPECT_EQ(1, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGB_565, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSetDefaultSize) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    sp<GLConsumer> st(mST);
-    ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, st->setDefaultBufferSize(16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    EXPECT_EQ(16, buf->width);
-    EXPECT_EQ(8, buf->height);
-    EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSetDefaultSizeAfterDequeue) {
-    ANativeWindowBuffer* buf[2];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, mST->setDefaultBufferSize(16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_EQ(16, buf[0]->width);
-    EXPECT_EQ(16, buf[1]->width);
-    EXPECT_EQ(8, buf[0]->height);
-    EXPECT_EQ(8, buf[1]->height);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSetDefaultSizeVsGeometry) {
-    ANativeWindowBuffer* buf[2];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    EXPECT_EQ(OK, mST->setDefaultBufferSize(16, 8));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_EQ(16, buf[0]->width);
-    EXPECT_EQ(16, buf[1]->width);
-    EXPECT_EQ(8, buf[0]->height);
-    EXPECT_EQ(8, buf[1]->height);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 12, 24));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_EQ(12, buf[0]->width);
-    EXPECT_EQ(12, buf[1]->width);
-    EXPECT_EQ(24, buf[0]->height);
-    EXPECT_EQ(24, buf[1]->height);
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureTooManyUpdateTexImage) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, mANW->setSwapInterval(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(OK, mST->updateTexImage());
-
-    ASSERT_EQ(OK, mANW->setSwapInterval(mANW.get(), 1));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(OK, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeSlowRetire) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_NE(buf[1], buf[2]);
-    EXPECT_NE(buf[2], buf[0]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[0]);
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[2]);
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeFastRetire) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_NE(buf[1], buf[2]);
-    EXPECT_NE(buf[2], buf[0]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[0]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[2]);
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeDQQR) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[0]);
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_NE(buf[0], buf[1]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    EXPECT_NE(buf[1], buf[2]);
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[2]);
-}
-
-// XXX: We currently have no hardware that properly handles dequeuing the
-// buffer that is currently bound to the texture.
-TEST_F(SurfaceTextureClientTest, DISABLED_SurfaceTextureSyncModeDequeueCurrent) {
-    android_native_buffer_t* buf[3];
-    android_native_buffer_t* firstBuf;
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &firstBuf));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), firstBuf, -1));
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), firstBuf);
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    EXPECT_NE(buf[0], buf[1]);
-    EXPECT_NE(buf[1], buf[2]);
-    EXPECT_NE(buf[2], buf[0]);
-    EXPECT_EQ(firstBuf, buf[2]);
-}
-
-TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeMinUndequeued) {
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-
-    // We should be able to dequeue all the buffers before we've queued mANWy.
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[2], -1));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-
-    EXPECT_EQ(OK, mST->updateTexImage());
-    EXPECT_EQ(mST->getCurrentBuffer().get(), buf[1]);
-
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-
-    // Once we've queued a buffer, however we should not be able to dequeue more
-    // than (buffer-count - MIN_UNDEQUEUED_BUFFERS), which is 2 in this case.
-    EXPECT_EQ(INVALID_OPERATION,
-            native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[2], -1));
-}
-
-TEST_F(SurfaceTextureClientTest, SetCropCropsCrop) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    android_native_rect_t rect = {-2, -13, 40, 18};
-    native_window_set_crop(mANW.get(), &rect);
-
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 4, 4));
-
-    android_native_buffer_t* buf;
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf, -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    Rect crop = mST->getCurrentCrop();
-    EXPECT_EQ(0, crop.left);
-    EXPECT_EQ(0, crop.top);
-    EXPECT_EQ(4, crop.right);
-    EXPECT_EQ(4, crop.bottom);
-}
-
-// XXX: This is not expected to pass until the synchronization hacks are removed
-// from the SurfaceTexture class.
-TEST_F(SurfaceTextureClientTest, DISABLED_SurfaceTextureSyncModeWaitRetire) {
-    class MyThread : public Thread {
-        sp<GLConsumer> mST;
-        EGLContext ctx;
-        EGLSurface sur;
-        EGLDisplay dpy;
-        bool mBufferRetired;
-        Mutex mLock;
-        virtual bool threadLoop() {
-            eglMakeCurrent(dpy, sur, sur, ctx);
-            usleep(20000);
-            Mutex::Autolock _l(mLock);
-            mST->updateTexImage();
-            mBufferRetired = true;
-            eglMakeCurrent(dpy, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-            return false;
-        }
-    public:
-        explicit MyThread(const sp<GLConsumer>& mST)
-            : mST(mST), mBufferRetired(false) {
-            ctx = eglGetCurrentContext();
-            sur = eglGetCurrentSurface(EGL_DRAW);
-            dpy = eglGetCurrentDisplay();
-            eglMakeCurrent(dpy, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-        }
-        ~MyThread() {
-            eglMakeCurrent(dpy, sur, sur, ctx);
-        }
-        void bufferDequeued() {
-            Mutex::Autolock _l(mLock);
-            EXPECT_EQ(true, mBufferRetired);
-        }
-    };
-
-    android_native_buffer_t* buf[3];
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 3));
-    // dequeue/queue/update so we have a current buffer
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    mST->updateTexImage();
-
-    MyThread* thread = new MyThread(mST);
-    sp<Thread> threadBase(thread);
-
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    thread->run("MyThread");
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[1], -1));
-    //ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[2]));
-    //ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[2], -1));
-    thread->bufferDequeued();
-    thread->requestExitAndWait();
-}
-
-TEST_F(SurfaceTextureClientTest, GetTransformMatrixReturnsVerticalFlip) {
-    android_native_buffer_t* buf[3];
-    float mtx[16] = {};
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-    mST->getTransformMatrix(mtx);
-
-    EXPECT_EQ(1.f, mtx[0]);
-    EXPECT_EQ(0.f, mtx[1]);
-    EXPECT_EQ(0.f, mtx[2]);
-    EXPECT_EQ(0.f, mtx[3]);
-
-    EXPECT_EQ(0.f, mtx[4]);
-    EXPECT_EQ(-1.f, mtx[5]);
-    EXPECT_EQ(0.f, mtx[6]);
-    EXPECT_EQ(0.f, mtx[7]);
-
-    EXPECT_EQ(0.f, mtx[8]);
-    EXPECT_EQ(0.f, mtx[9]);
-    EXPECT_EQ(1.f, mtx[10]);
-    EXPECT_EQ(0.f, mtx[11]);
-
-    EXPECT_EQ(0.f, mtx[12]);
-    EXPECT_EQ(1.f, mtx[13]);
-    EXPECT_EQ(0.f, mtx[14]);
-    EXPECT_EQ(1.f, mtx[15]);
-}
-
-TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffers) {
-    android_native_buffer_t* buf[3];
-    float mtx[16] = {};
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 6)); // frees buffers
-    mST->getTransformMatrix(mtx);
-
-    EXPECT_EQ(1.f, mtx[0]);
-    EXPECT_EQ(0.f, mtx[1]);
-    EXPECT_EQ(0.f, mtx[2]);
-    EXPECT_EQ(0.f, mtx[3]);
-
-    EXPECT_EQ(0.f, mtx[4]);
-    EXPECT_EQ(-1.f, mtx[5]);
-    EXPECT_EQ(0.f, mtx[6]);
-    EXPECT_EQ(0.f, mtx[7]);
-
-    EXPECT_EQ(0.f, mtx[8]);
-    EXPECT_EQ(0.f, mtx[9]);
-    EXPECT_EQ(1.f, mtx[10]);
-    EXPECT_EQ(0.f, mtx[11]);
-
-    EXPECT_EQ(0.f, mtx[12]);
-    EXPECT_EQ(1.f, mtx[13]);
-    EXPECT_EQ(0.f, mtx[14]);
-    EXPECT_EQ(1.f, mtx[15]);
-}
-
-TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffersWithCrop) {
-    // Query to see if the image crop extension exists
-    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    const char* exts = eglQueryStringImplementationANDROID(dpy, EGL_EXTENSIONS);
-    size_t cropExtLen = strlen(CROP_EXT_STR);
-    size_t extsLen = strlen(exts);
-    bool equal = !strcmp(CROP_EXT_STR, exts);
-    bool atStart = !strncmp(CROP_EXT_STR " ", exts, cropExtLen+1);
-    bool atEnd = (cropExtLen+1) < extsLen &&
-            !strcmp(" " CROP_EXT_STR, exts + extsLen - (cropExtLen+1));
-    bool inMiddle = strstr(exts, " " CROP_EXT_STR " ");
-    bool hasEglAndroidImageCrop = equal || atStart || atEnd || inMiddle;
-
-    android_native_buffer_t* buf[3];
-    float mtx[16] = {};
-    android_native_rect_t crop;
-    crop.left = 0;
-    crop.top = 0;
-    crop.right = 5;
-    crop.bottom = 5;
-
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 8, 8));
-    ASSERT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
-    ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &crop));
-    ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
-    ASSERT_EQ(OK, mST->updateTexImage());
-    ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 6)); // frees buffers
-    mST->getTransformMatrix(mtx);
-
-    // If the egl image crop extension is not present, this accounts for the
-    // .5 texel shrink for each edge that's included in the transform matrix
-    // to avoid texturing outside the crop region. Otherwise the crop is not
-    // included in the transform matrix.
-    EXPECT_EQ(hasEglAndroidImageCrop ? 1 : 0.5, mtx[0]);
-    EXPECT_EQ(0.f, mtx[1]);
-    EXPECT_EQ(0.f, mtx[2]);
-    EXPECT_EQ(0.f, mtx[3]);
-
-    EXPECT_EQ(0.f, mtx[4]);
-    EXPECT_EQ(hasEglAndroidImageCrop ? -1 : -0.5, mtx[5]);
-    EXPECT_EQ(0.f, mtx[6]);
-    EXPECT_EQ(0.f, mtx[7]);
-
-    EXPECT_EQ(0.f, mtx[8]);
-    EXPECT_EQ(0.f, mtx[9]);
-    EXPECT_EQ(1.f, mtx[10]);
-    EXPECT_EQ(0.f, mtx[11]);
-
-    EXPECT_EQ(hasEglAndroidImageCrop ? 0 : 0.0625f, mtx[12]);
-    EXPECT_EQ(hasEglAndroidImageCrop ? 1 : 0.5625f, mtx[13]);
-    EXPECT_EQ(0.f, mtx[14]);
-    EXPECT_EQ(1.f, mtx[15]);
-}
-
-// This test verifies that the buffer format can be queried immediately after
-// it is set.
-TEST_F(SurfaceTextureClientTest, QueryFormatAfterSettingWorks) {
-    sp<ANativeWindow> anw(mSTC);
-    int fmts[] = {
-        // RGBA_8888 should not come first, as it's the default
-        HAL_PIXEL_FORMAT_RGBX_8888,
-        HAL_PIXEL_FORMAT_RGBA_8888,
-        HAL_PIXEL_FORMAT_RGB_888,
-        HAL_PIXEL_FORMAT_RGB_565,
-        HAL_PIXEL_FORMAT_BGRA_8888,
-        HAL_PIXEL_FORMAT_YV12,
-    };
-
-    const int numFmts = (sizeof(fmts) / sizeof(fmts[0]));
-    for (int i = 0; i < numFmts; i++) {
-      int fmt = -1;
-      ASSERT_EQ(OK, native_window_set_buffers_dimensions(anw.get(), 0, 0));
-      ASSERT_EQ(OK, native_window_set_buffers_format(anw.get(), fmts[i]));
-      ASSERT_EQ(OK, anw->query(anw.get(), NATIVE_WINDOW_FORMAT, &fmt));
-      EXPECT_EQ(fmts[i], fmt);
-    }
-}
-
-class MultiSurfaceTextureClientTest : public ::testing::Test {
-
-public:
-    MultiSurfaceTextureClientTest() :
-            mEglDisplay(EGL_NO_DISPLAY),
-            mEglContext(EGL_NO_CONTEXT) {
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            mEglSurfaces[i] = EGL_NO_CONTEXT;
-        }
-    }
-
-protected:
-
-    enum { NUM_SURFACE_TEXTURES = 32 };
-
-    virtual void SetUp() {
-        mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-
-        EGLint majorVersion, minorVersion;
-        EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        EGLConfig myConfig;
-        EGLint numConfigs = 0;
-        EGLint configAttribs[] = {
-            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-            EGL_NONE
-        };
-        EXPECT_TRUE(eglChooseConfig(mEglDisplay, configAttribs, &myConfig, 1,
-                &numConfigs));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        mEglContext = eglCreateContext(mEglDisplay, myConfig, EGL_NO_CONTEXT,
-                0);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mEglContext);
-
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            sp<IGraphicBufferProducer> producer;
-            sp<IGraphicBufferConsumer> consumer;
-            BufferQueue::createBufferQueue(&producer, &consumer);
-            sp<GLConsumer> st(new GLConsumer(consumer, i,
-                    GLConsumer::TEXTURE_EXTERNAL, true, false));
-            sp<Surface> stc(new Surface(producer));
-            mEglSurfaces[i] = eglCreateWindowSurface(mEglDisplay, myConfig,
-                    static_cast<ANativeWindow*>(stc.get()), NULL);
-            ASSERT_EQ(EGL_SUCCESS, eglGetError());
-            ASSERT_NE(EGL_NO_SURFACE, mEglSurfaces[i]);
-        }
-    }
-
-    virtual void TearDown() {
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                EGL_NO_CONTEXT);
-
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            if (mEglSurfaces[i] != EGL_NO_SURFACE) {
-                eglDestroySurface(mEglDisplay, mEglSurfaces[i]);
-            }
-        }
-
-        if (mEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mEglContext);
-        }
-
-        if (mEglDisplay != EGL_NO_DISPLAY) {
-            eglTerminate(mEglDisplay);
-        }
-    }
-
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurfaces[NUM_SURFACE_TEXTURES];
-    EGLContext mEglContext;
-};
-
-// XXX: This test is disabled because it causes a hang on some devices.  See bug
-// 5015672.
-TEST_F(MultiSurfaceTextureClientTest, DISABLED_MakeCurrentBetweenSurfacesWorks) {
-    for (int iter = 0; iter < 8; iter++) {
-        for (int i = 0; i < NUM_SURFACE_TEXTURES; i++) {
-            eglMakeCurrent(mEglDisplay, mEglSurfaces[i], mEglSurfaces[i],
-                    mEglContext);
-            glClear(GL_COLOR_BUFFER_BIT);
-            eglSwapBuffers(mEglDisplay, mEglSurfaces[i]);
-        }
-    }
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureFBO.h b/libs/gui/tests/SurfaceTextureFBO.h
deleted file mode 100644
index 7f1ae84c48..0000000000
--- a/libs/gui/tests/SurfaceTextureFBO.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_FBO_H
-#define ANDROID_SURFACE_TEXTURE_FBO_H
-
-#include "SurfaceTextureGL.h"
-
-#include <GLES2/gl2.h>
-
-namespace android {
-
-class SurfaceTextureFBOTest : public SurfaceTextureGLTest {
-protected:
-    virtual void SetUp() {
-        SurfaceTextureGLTest::SetUp();
-
-        glGenFramebuffers(1, &mFbo);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-        glGenTextures(1, &mFboTex);
-        glBindTexture(GL_TEXTURE_2D, mFboTex);
-        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, getSurfaceWidth(),
-                getSurfaceHeight(), 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
-        glBindTexture(GL_TEXTURE_2D, 0);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-        glBindFramebuffer(GL_FRAMEBUFFER, mFbo);
-        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                GL_TEXTURE_2D, mFboTex, 0);
-        glBindFramebuffer(GL_FRAMEBUFFER, 0);
-        ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    }
-
-    virtual void TearDown() {
-        SurfaceTextureGLTest::TearDown();
-
-        glDeleteTextures(1, &mFboTex);
-        glDeleteFramebuffers(1, &mFbo);
-    }
-
-    GLuint mFbo;
-    GLuint mFboTex;
-};
-
-void fillRGBA8BufferSolid(uint8_t* buf, int w, int h, int stride,
-        uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
-    const size_t PIXEL_SIZE = 4;
-    for (int y = 0; y < h; y++) {
-        for (int x = 0; x < w; x++) {
-            off_t offset = (y * stride + x) * PIXEL_SIZE;
-            buf[offset + 0] = r;
-            buf[offset + 1] = g;
-            buf[offset + 2] = b;
-            buf[offset + 3] = a;
-        }
-    }
-}
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureFBO_test.cpp b/libs/gui/tests/SurfaceTextureFBO_test.cpp
deleted file mode 100644
index 0134273a07..0000000000
--- a/libs/gui/tests/SurfaceTextureFBO_test.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureFBO_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureFBO.h"
-
-namespace android {
-
-// This test is intended to verify that proper synchronization is done when
-// rendering into an FBO.
-TEST_F(SurfaceTextureFBOTest, BlitFromCpuFilledBufferToFbo) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    android_native_buffer_t* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    // Fill the buffer with green
-    uint8_t* img = NULL;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    fillRGBA8BufferSolid(img, texWidth, texHeight, buf->getStride(), 0, 255,
-            0, 255);
-    buf->unlock();
-    ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
-            -1));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glBindFramebuffer(GL_FRAMEBUFFER, mFbo);
-    drawTexture();
-    glBindFramebuffer(GL_FRAMEBUFFER, 0);
-
-    for (int i = 0; i < 4; i++) {
-        SCOPED_TRACE(String8::format("frame %d", i).string());
-
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-                &anb));
-        ASSERT_TRUE(anb != NULL);
-
-        buf = GraphicBuffer::from(anb);
-
-        // Fill the buffer with red
-        ASSERT_EQ(NO_ERROR, buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN,
-                (void**)(&img)));
-        fillRGBA8BufferSolid(img, texWidth, texHeight, buf->getStride(), 255, 0,
-                0, 255);
-        ASSERT_EQ(NO_ERROR, buf->unlock());
-        ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(),
-                buf->getNativeBuffer(), -1));
-
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-        drawTexture();
-
-        EXPECT_TRUE(checkPixel( 24, 39, 255, 0, 0, 255));
-    }
-
-    glBindFramebuffer(GL_FRAMEBUFFER, mFbo);
-
-    EXPECT_TRUE(checkPixel( 24, 39, 0, 255, 0, 255));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureGL.h b/libs/gui/tests/SurfaceTextureGL.h
deleted file mode 100644
index 53eb68cad8..0000000000
--- a/libs/gui/tests/SurfaceTextureGL.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_GL_H
-#define ANDROID_SURFACE_TEXTURE_GL_H
-
-#include "GLTest.h"
-
-#include "FrameWaiter.h"
-#include "TextureRenderer.h"
-
-#include <gui/GLConsumer.h>
-#include <gui/Surface.h>
-
-namespace android {
-
-class FrameWaiter;
-class GLConsumer;
-class TextureRenderer;
-
-class SurfaceTextureGLTest : public GLTest {
-protected:
-    enum { TEX_ID = 123 };
-
-    void SetUp() {
-        GLTest::SetUp();
-        sp<IGraphicBufferProducer> producer;
-        BufferQueue::createBufferQueue(&producer, &mConsumer);
-        mST = new GLConsumer(mConsumer, TEX_ID, GLConsumer::TEXTURE_EXTERNAL,
-                true, false);
-        mSTC = new Surface(producer);
-        mANW = mSTC;
-        mTextureRenderer = new TextureRenderer(TEX_ID, mST);
-        ASSERT_NO_FATAL_FAILURE(mTextureRenderer->SetUp());
-        mFW = new FrameWaiter;
-        mST->setFrameAvailableListener(mFW);
-    }
-
-    void TearDown() {
-        mTextureRenderer.clear();
-        mANW.clear();
-        mSTC.clear();
-        mST.clear();
-        GLTest::TearDown();
-    }
-
-    void drawTexture() {
-        mTextureRenderer->drawTexture();
-    }
-
-    sp<IGraphicBufferConsumer> mConsumer;
-    sp<GLConsumer> mST;
-    sp<Surface> mSTC;
-    sp<ANativeWindow> mANW;
-    sp<TextureRenderer> mTextureRenderer;
-    sp<FrameWaiter> mFW;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureGLThreadToGL.h b/libs/gui/tests/SurfaceTextureGLThreadToGL.h
deleted file mode 100644
index 2ce20eb2b1..0000000000
--- a/libs/gui/tests/SurfaceTextureGLThreadToGL.h
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_GL_THREAD_TO_GL_H
-#define ANDROID_SURFACE_TEXTURE_GL_THREAD_TO_GL_H
-
-#include "SurfaceTextureGLToGL.h"
-
-namespace android {
-
-/*
- * This test fixture is for testing GL -> GL texture streaming from one thread
- * to another.  It contains functionality to create a producer thread that will
- * perform GL rendering to an ANativeWindow that feeds frames to a
- * GLConsumer.  Additionally it supports interlocking the producer and
- * consumer threads so that a specific sequence of calls can be
- * deterministically created by the test.
- *
- * The intended usage is as follows:
- *
- * TEST_F(...) {
- *     class PT : public ProducerThread {
- *         virtual void render() {
- *             ...
- *             swapBuffers();
- *         }
- *     };
- *
- *     runProducerThread(new PT());
- *
- *     // The order of these calls will vary from test to test and may include
- *     // multiple frames and additional operations (e.g. GL rendering from the
- *     // texture).
- *     fc->waitForFrame();
- *     mST->updateTexImage();
- *     fc->finishFrame();
- * }
- *
- */
-class SurfaceTextureGLThreadToGLTest : public SurfaceTextureGLToGLTest {
-protected:
-
-    // ProducerThread is an abstract base class to simplify the creation of
-    // OpenGL ES frame producer threads.
-    class ProducerThread : public Thread {
-    public:
-        virtual ~ProducerThread() {
-        }
-
-        void setEglObjects(EGLDisplay producerEglDisplay,
-                EGLSurface producerEglSurface,
-                EGLContext producerEglContext) {
-            mProducerEglDisplay = producerEglDisplay;
-            mProducerEglSurface = producerEglSurface;
-            mProducerEglContext = producerEglContext;
-        }
-
-        virtual bool threadLoop() {
-            eglMakeCurrent(mProducerEglDisplay, mProducerEglSurface,
-                    mProducerEglSurface, mProducerEglContext);
-            render();
-            eglMakeCurrent(mProducerEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                    EGL_NO_CONTEXT);
-            return false;
-        }
-
-    protected:
-        virtual void render() = 0;
-
-        void swapBuffers() {
-            eglSwapBuffers(mProducerEglDisplay, mProducerEglSurface);
-        }
-
-        EGLDisplay mProducerEglDisplay;
-        EGLSurface mProducerEglSurface;
-        EGLContext mProducerEglContext;
-    };
-
-    // FrameCondition is a utility class for interlocking between the producer
-    // and consumer threads.  The FrameCondition object should be created and
-    // destroyed in the consumer thread only.  The consumer thread should set
-    // the FrameCondition as the FrameAvailableListener of the GLConsumer,
-    // and should call both waitForFrame and finishFrame once for each expected
-    // frame.
-    //
-    // This interlocking relies on the fact that onFrameAvailable gets called
-    // synchronously from GLConsumer::queueBuffer.
-    class FrameCondition : public GLConsumer::FrameAvailableListener {
-    public:
-        FrameCondition():
-                mFrameAvailable(false),
-                mFrameFinished(false) {
-        }
-
-        // waitForFrame waits for the next frame to arrive.  This should be
-        // called from the consumer thread once for every frame expected by the
-        // test.
-        void waitForFrame() {
-            Mutex::Autolock lock(mMutex);
-            ALOGV("+waitForFrame");
-            while (!mFrameAvailable) {
-                mFrameAvailableCondition.wait(mMutex);
-            }
-            mFrameAvailable = false;
-            ALOGV("-waitForFrame");
-        }
-
-        // Allow the producer to return from its swapBuffers call and continue
-        // on to produce the next frame.  This should be called by the consumer
-        // thread once for every frame expected by the test.
-        void finishFrame() {
-            Mutex::Autolock lock(mMutex);
-            ALOGV("+finishFrame");
-            mFrameFinished = true;
-            mFrameFinishCondition.signal();
-            ALOGV("-finishFrame");
-        }
-
-        // This should be called by GLConsumer on the producer thread.
-        virtual void onFrameAvailable(const BufferItem& /* item */) {
-            Mutex::Autolock lock(mMutex);
-            ALOGV("+onFrameAvailable");
-            mFrameAvailable = true;
-            mFrameAvailableCondition.signal();
-            while (!mFrameFinished) {
-                mFrameFinishCondition.wait(mMutex);
-            }
-            mFrameFinished = false;
-            ALOGV("-onFrameAvailable");
-        }
-
-    protected:
-        bool mFrameAvailable;
-        bool mFrameFinished;
-
-        Mutex mMutex;
-        Condition mFrameAvailableCondition;
-        Condition mFrameFinishCondition;
-    };
-
-    virtual void SetUp() {
-        SurfaceTextureGLToGLTest::SetUp();
-        mFC = new FrameCondition();
-        mST->setFrameAvailableListener(mFC);
-    }
-
-    virtual void TearDown() {
-        if (mProducerThread != NULL) {
-            mProducerThread->requestExitAndWait();
-        }
-        mProducerThread.clear();
-        mFC.clear();
-        SurfaceTextureGLToGLTest::TearDown();
-    }
-
-    void runProducerThread(const sp<ProducerThread> producerThread) {
-        ASSERT_TRUE(mProducerThread == NULL);
-        mProducerThread = producerThread;
-        producerThread->setEglObjects(mEglDisplay, mProducerEglSurface,
-                mProducerEglContext);
-        producerThread->run("ProducerThread");
-    }
-
-    sp<ProducerThread> mProducerThread;
-    sp<FrameCondition> mFC;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp b/libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp
deleted file mode 100644
index c4d0aaa4bb..0000000000
--- a/libs/gui/tests/SurfaceTextureGLThreadToGL_test.cpp
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureGLThreadToGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureGLThreadToGL.h"
-
-namespace android {
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        UpdateTexImageBeforeFrameFinishedCompletes) {
-    class PT : public ProducerThread {
-        virtual void render() {
-            glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-            glClear(GL_COLOR_BUFFER_BIT);
-            swapBuffers();
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    mFC->waitForFrame();
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    mFC->finishFrame();
-
-    // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-}
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        UpdateTexImageAfterFrameFinishedCompletes) {
-    class PT : public ProducerThread {
-        virtual void render() {
-            glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-            glClear(GL_COLOR_BUFFER_BIT);
-            swapBuffers();
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    mFC->waitForFrame();
-    mFC->finishFrame();
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-}
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        RepeatedUpdateTexImageBeforeFrameFinishedCompletes) {
-    enum { NUM_ITERATIONS = 1024 };
-
-    class PT : public ProducerThread {
-        virtual void render() {
-            for (int i = 0; i < NUM_ITERATIONS; i++) {
-                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-                glClear(GL_COLOR_BUFFER_BIT);
-                ALOGV("+swapBuffers");
-                swapBuffers();
-                ALOGV("-swapBuffers");
-            }
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    for (int i = 0; i < NUM_ITERATIONS; i++) {
-        mFC->waitForFrame();
-        ALOGV("+updateTexImage");
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        ALOGV("-updateTexImage");
-        mFC->finishFrame();
-
-        // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-    }
-}
-
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        RepeatedUpdateTexImageAfterFrameFinishedCompletes) {
-    enum { NUM_ITERATIONS = 1024 };
-
-    class PT : public ProducerThread {
-        virtual void render() {
-            for (int i = 0; i < NUM_ITERATIONS; i++) {
-                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-                glClear(GL_COLOR_BUFFER_BIT);
-                ALOGV("+swapBuffers");
-                swapBuffers();
-                ALOGV("-swapBuffers");
-            }
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    for (int i = 0; i < NUM_ITERATIONS; i++) {
-        mFC->waitForFrame();
-        mFC->finishFrame();
-        ALOGV("+updateTexImage");
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        ALOGV("-updateTexImage");
-
-        // TODO: Add frame verification once RGB TEX_EXTERNAL_OES is supported!
-    }
-}
-
-// XXX: This test is disabled because it is currently hanging on some devices.
-TEST_F(SurfaceTextureGLThreadToGLTest,
-        DISABLED_RepeatedSwapBuffersWhileDequeueStalledCompletes) {
-    enum { NUM_ITERATIONS = 64 };
-
-    class PT : public ProducerThread {
-        virtual void render() {
-            for (int i = 0; i < NUM_ITERATIONS; i++) {
-                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
-                glClear(GL_COLOR_BUFFER_BIT);
-                ALOGV("+swapBuffers");
-                swapBuffers();
-                ALOGV("-swapBuffers");
-            }
-        }
-    };
-
-    SetUpWindowAndContext();
-
-    runProducerThread(new PT());
-
-    // Allow three frames to be rendered and queued before starting the
-    // rendering in this thread.  For the latter two frames we don't call
-    // updateTexImage so the next dequeue from the producer thread will block
-    // waiting for a frame to become available.
-    mFC->waitForFrame();
-    mFC->finishFrame();
-
-    // We must call updateTexImage to consume the first frame so that the
-    // SurfaceTexture is able to reduce the buffer count to 2.  This is because
-    // the GL driver may dequeue a buffer when the EGLSurface is created, and
-    // that happens before we call setDefaultMaxBufferCount.  It's possible that the
-    // driver does not dequeue a buffer at EGLSurface creation time, so we
-    // cannot rely on this to cause the second dequeueBuffer call to block.
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    mFC->waitForFrame();
-    mFC->finishFrame();
-    mFC->waitForFrame();
-    mFC->finishFrame();
-
-    // Sleep for 100ms to allow the producer thread's dequeueBuffer call to
-    // block waiting for a buffer to become available.
-    usleep(100000);
-
-    // Render and present a number of images.  This thread should not be blocked
-    // by the fact that the producer thread is blocking in dequeue.
-    for (int i = 0; i < NUM_ITERATIONS; i++) {
-        glClear(GL_COLOR_BUFFER_BIT);
-        eglSwapBuffers(mEglDisplay, mEglSurface);
-    }
-
-    // Consume the two pending buffers to unblock the producer thread.
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // Consume the remaining buffers from the producer thread.
-    for (int i = 0; i < NUM_ITERATIONS-3; i++) {
-        mFC->waitForFrame();
-        mFC->finishFrame();
-        ALOGV("+updateTexImage");
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        ALOGV("-updateTexImage");
-    }
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureGLToGL.h b/libs/gui/tests/SurfaceTextureGLToGL.h
deleted file mode 100644
index 5d43a48898..0000000000
--- a/libs/gui/tests/SurfaceTextureGLToGL.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_GL_TO_GL_H
-#define ANDROID_SURFACE_TEXTURE_GL_TO_GL_H
-
-#include "SurfaceTextureGL.h"
-
-namespace android {
-
-/*
- * This test fixture is for testing GL -> GL texture streaming.  It creates an
- * EGLSurface and an EGLContext for the image producer to use.
- */
-class SurfaceTextureGLToGLTest : public SurfaceTextureGLTest {
-protected:
-    SurfaceTextureGLToGLTest():
-            mProducerEglSurface(EGL_NO_SURFACE),
-            mProducerEglContext(EGL_NO_CONTEXT) {
-    }
-
-    virtual void SetUp() {
-        SurfaceTextureGLTest::SetUp();
-    }
-
-    void SetUpWindowAndContext() {
-        mProducerEglSurface = eglCreateWindowSurface(mEglDisplay, mGlConfig,
-                mANW.get(), NULL);
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_SURFACE, mProducerEglSurface);
-
-        mProducerEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-                EGL_NO_CONTEXT, getContextAttribs());
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mProducerEglContext);
-    }
-
-    virtual void TearDown() {
-        if (mProducerEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mProducerEglContext);
-        }
-        if (mProducerEglSurface != EGL_NO_SURFACE) {
-            eglDestroySurface(mEglDisplay, mProducerEglSurface);
-        }
-        SurfaceTextureGLTest::TearDown();
-    }
-
-    EGLSurface mProducerEglSurface;
-    EGLContext mProducerEglContext;
-};
-
-} // namespace android
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureGLToGL_test.cpp b/libs/gui/tests/SurfaceTextureGLToGL_test.cpp
deleted file mode 100644
index c28b4d141c..0000000000
--- a/libs/gui/tests/SurfaceTextureGLToGL_test.cpp
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureGLToGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureGLToGL.h"
-
-namespace android {
-
-TEST_F(SurfaceTextureGLToGLTest, TransformHintGetsRespected) {
-    const uint32_t texWidth = 32;
-    const uint32_t texHeight = 64;
-
-    mST->setDefaultBufferSize(texWidth, texHeight);
-    mST->setTransformHint(NATIVE_WINDOW_TRANSFORM_ROT_90);
-
-    // This test requires 3 buffers to avoid deadlock because we're
-    // both producer and consumer, and only using one thread. Set max dequeued
-    // to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Start a buffer with our chosen size and transform hint moving
-    // through the system.
-    glClear(GL_COLOR_BUFFER_BIT);  // give the driver something to do
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();  // consume it
-    // Swap again.
-    glClear(GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();
-
-    // The current buffer should either show the effects of the transform
-    // hint (in the form of an inverse transform), or show that the
-    // transform hint has been ignored.
-    sp<GraphicBuffer> buf = mST->getCurrentBuffer();
-    if (mST->getCurrentTransform() == NATIVE_WINDOW_TRANSFORM_ROT_270) {
-        ASSERT_EQ(texWidth, buf->getHeight());
-        ASSERT_EQ(texHeight, buf->getWidth());
-    } else {
-        ASSERT_EQ(texWidth, buf->getWidth());
-        ASSERT_EQ(texHeight, buf->getHeight());
-    }
-
-    // Reset the transform hint and confirm that it takes.
-    mST->setTransformHint(0);
-    glClear(GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();
-    glClear(GL_COLOR_BUFFER_BIT);
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-    mST->updateTexImage();
-
-    buf = mST->getCurrentBuffer();
-    ASSERT_EQ((uint32_t) 0, mST->getCurrentTransform());
-    ASSERT_EQ(texWidth, buf->getWidth());
-    ASSERT_EQ(texHeight, buf->getHeight());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromGLFilledRGBABufferPow2) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    mST->setDefaultBufferSize(texWidth, texHeight);
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(4, 4, 4, 4);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glScissor(24, 48, 4, 4);
-    glClearColor(0.0, 1.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glScissor(37, 17, 4, 4);
-    glClearColor(0.0, 0.0, 1.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 63, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 63, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel( 4,  7, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel(25, 51,   0, 255,   0, 255));
-    EXPECT_TRUE(checkPixel(40, 19,   0,   0, 255, 255));
-    EXPECT_TRUE(checkPixel(29, 51, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 5, 32, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(13,  8, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(46,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(30, 33, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 6, 52, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(55, 33, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(16, 29, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 1, 30, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(41, 37, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(46, 29, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(15, 25, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 3, 52, 153, 153, 153, 153));
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglDestroySurfaceUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffers[2];
-
-    // This test requires async mode to run on a single thread.
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    EXPECT_TRUE(eglSwapInterval(mEglDisplay, 0));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    for (int i = 0; i < 2; i++) {
-        // Produce a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-                mProducerEglSurface, mProducerEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        glClear(GL_COLOR_BUFFER_BIT);
-        eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-        // Consume a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mFW->waitForFrame();
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        buffers[i] = mST->getCurrentBuffer();
-    }
-
-    // Destroy the GL texture object to release its ref on buffers[2].
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // Destroy the EGLSurface
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-
-    // This test should have the only reference to buffer 0.
-    EXPECT_EQ(1, buffers[0]->getStrongCount());
-
-    // The GLConsumer should hold one reference to buffer 1 in its
-    // mCurrentTextureImage member and another reference in mEglSlots. The third
-    // reference is in this test.
-    EXPECT_EQ(3, buffers[1]->getStrongCount());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglDestroySurfaceAfterAbandonUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffers[3];
-
-    // This test requires async mode to run on a single thread.
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    EXPECT_TRUE(eglSwapInterval(mEglDisplay, 0));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    for (int i = 0; i < 3; i++) {
-        // Produce a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-                mProducerEglSurface, mProducerEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        glClear(GL_COLOR_BUFFER_BIT);
-        EXPECT_TRUE(eglSwapBuffers(mEglDisplay, mProducerEglSurface));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-        // Consume a frame
-        EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mFW->waitForFrame();
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        buffers[i] = mST->getCurrentBuffer();
-    }
-
-    // Abandon the GLConsumer, releasing the ref that the GLConsumer has
-    // on buffers[2].
-    mST->abandon();
-
-    // Destroy the GL texture object to release its ref on buffers[2].
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // Destroy the EGLSurface.
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-
-    EXPECT_EQ(1, buffers[1]->getStrongCount());
-
-    // Depending on how lazily the GL driver dequeues buffers, we may end up
-    // with either two or three total buffers.  If there are three, each entry
-    // of the buffers array will be unique and there should only be one
-    // reference (the one in this test). If there are two the first and last
-    // element in the array will be equal meaning that buffer representing both
-    // 0 and 2 will have two references (one for 0 and one for 2).
-    if (buffers[2] != buffers[0]) {
-        EXPECT_EQ(1, buffers[0]->getStrongCount());
-        EXPECT_EQ(1, buffers[2]->getStrongCount());
-    } else {
-        EXPECT_EQ(2, buffers[0]->getStrongCount());
-    }
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglMakeCurrentBeforeConsumerDeathUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffer;
-
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-
-    // Produce a frame
-    glClear(GL_COLOR_BUFFER_BIT);
-    EXPECT_TRUE(eglSwapBuffers(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Destroy the EGLSurface.
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-    mSTC.clear();
-    mANW.clear();
-    mTextureRenderer.clear();
-
-    // Consume a frame
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    buffer = mST->getCurrentBuffer();
-
-    // Destroy the GL texture object to release its ref
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // make un-current, all references to buffer should be gone
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE,
-            EGL_NO_SURFACE, EGL_NO_CONTEXT));
-
-    // Destroy consumer
-    mST.clear();
-
-    EXPECT_EQ(1, buffer->getStrongCount());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, EglMakeCurrentAfterConsumerDeathUnrefsBuffers) {
-    SetUpWindowAndContext();
-    sp<GraphicBuffer> buffer;
-
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-
-    // Produce a frame
-    glClear(GL_COLOR_BUFFER_BIT);
-    EXPECT_TRUE(eglSwapBuffers(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Destroy the EGLSurface.
-    EXPECT_TRUE(eglDestroySurface(mEglDisplay, mProducerEglSurface));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    mProducerEglSurface = EGL_NO_SURFACE;
-    mSTC.clear();
-    mANW.clear();
-    mTextureRenderer.clear();
-
-    // Consume a frame
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    buffer = mST->getCurrentBuffer();
-
-    // Destroy the GL texture object to release its ref
-    GLuint texID = TEX_ID;
-    glDeleteTextures(1, &texID);
-
-    // Destroy consumer
-    mST.clear();
-
-    // make un-current, all references to buffer should be gone
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE,
-            EGL_NO_SURFACE, EGL_NO_CONTEXT));
-
-    EXPECT_EQ(1, buffer->getStrongCount());
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromUserSizedGLFilledBuffer) {
-    enum { texWidth = 64 };
-    enum { texHeight = 64 };
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Set the user buffer size.
-    native_window_set_buffers_user_dimensions(mANW.get(), texWidth, texHeight);
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(4, 4, 1, 1);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 63, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 63, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel( 4,  4, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel( 5,  5, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 3,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(45, 52, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(12, 36, 153, 153, 153, 153));
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromPreRotatedUserSizedGLFilledBuffer) {
-    enum { texWidth = 64 };
-    enum { texHeight = 16 };
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Set the transform hint.
-    mST->setTransformHint(NATIVE_WINDOW_TRANSFORM_ROT_90);
-
-    // Set the user buffer size.
-    native_window_set_buffers_user_dimensions(mANW.get(), texWidth, texHeight);
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size and the
-    // new rotation hint.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(24, 4, 1, 1);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 15, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 15, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel(24,  4, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel(25,  5, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(23,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(45, 13, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(12,  8, 153, 153, 153, 153));
-}
-
-TEST_F(SurfaceTextureGLToGLTest, TexturingFromPreRotatedGLFilledBuffer) {
-    enum { texWidth = 64 };
-    enum { texHeight = 16 };
-
-    // This test requires 3 buffers to complete run on a single thread.
-    // Set max dequeued to 2, and max acquired already defaults to 1.
-    ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(2));
-
-    SetUpWindowAndContext();
-
-    // Set the transform hint.
-    mST->setTransformHint(NATIVE_WINDOW_TRANSFORM_ROT_90);
-
-    // Set the default buffer size.
-    mST->setDefaultBufferSize(texWidth, texHeight);
-
-    // Do the producer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mProducerEglSurface,
-            mProducerEglSurface, mProducerEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // This is needed to ensure we pick up a buffer of the correct size and the
-    // new rotation hint.
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    glClearColor(0.6, 0.6, 0.6, 0.6);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glEnable(GL_SCISSOR_TEST);
-    glScissor(24, 4, 1, 1);
-    glClearColor(1.0, 0.0, 0.0, 1.0);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    eglSwapBuffers(mEglDisplay, mProducerEglSurface);
-
-    // Do the consumer side of things
-    EXPECT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    glDisable(GL_SCISSOR_TEST);
-
-    // Skip the first frame, which was empty
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63,  0, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(63, 15, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel( 0, 15, 153, 153, 153, 153));
-
-    EXPECT_TRUE(checkPixel(24,  4, 255,   0,   0, 255));
-    EXPECT_TRUE(checkPixel(25,  5, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(23,  3, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(45, 13, 153, 153, 153, 153));
-    EXPECT_TRUE(checkPixel(12,  8, 153, 153, 153, 153));
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureGL_test.cpp b/libs/gui/tests/SurfaceTextureGL_test.cpp
deleted file mode 100644
index 56392867ea..0000000000
--- a/libs/gui/tests/SurfaceTextureGL_test.cpp
+++ /dev/null
@@ -1,737 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureGL.h"
-
-#include "DisconnectWaiter.h"
-#include "FillBuffer.h"
-
-namespace android {
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferNpot) {
-    const int texWidth = 64;
-    const int texHeight = 66;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ANativeWindowBuffer* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    // Fill the buffer with the a checkerboard pattern
-    uint8_t* img = NULL;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    fillYV12Buffer(img, texWidth, texHeight, buf->getStride());
-    buf->unlock();
-    ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
-            -1));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(63,  0,   0, 133,   0, 255, 3));
-    EXPECT_TRUE(checkPixel(63, 65,   0, 133,   0, 255, 3));
-    EXPECT_TRUE(checkPixel( 0, 65, 255, 127, 255, 255, 3));
-
-    EXPECT_TRUE(checkPixel(22, 44, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(45, 52, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(52, 51,  98, 255,  73, 255, 3));
-    EXPECT_TRUE(checkPixel( 7, 31, 155,   0, 118, 255, 3));
-    EXPECT_TRUE(checkPixel(31,  9, 107,  24,  87, 255, 3));
-    EXPECT_TRUE(checkPixel(29, 35, 255, 127, 255, 255, 3));
-    EXPECT_TRUE(checkPixel(36, 22, 155,  29,   0, 255, 3));
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferPow2) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ANativeWindowBuffer* anb;
-    ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    ASSERT_TRUE(anb != NULL);
-
-    sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-    // Fill the buffer with the a checkerboard pattern
-    uint8_t* img = NULL;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-    fillYV12Buffer(img, texWidth, texHeight, buf->getStride());
-    buf->unlock();
-    ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
-            -1));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0,   0, 133,   0, 255));
-    EXPECT_TRUE(checkPixel(63,  0, 255, 127, 255, 255));
-    EXPECT_TRUE(checkPixel(63, 63,   0, 133,   0, 255));
-    EXPECT_TRUE(checkPixel( 0, 63, 255, 127, 255, 255));
-
-    EXPECT_TRUE(checkPixel(22, 19, 100, 255,  74, 255, 3));
-    EXPECT_TRUE(checkPixel(45, 11, 100, 255,  74, 255, 3));
-    EXPECT_TRUE(checkPixel(52, 12, 155,   0, 181, 255, 3));
-    EXPECT_TRUE(checkPixel( 7, 32, 150, 237, 170, 255, 3));
-    EXPECT_TRUE(checkPixel(31, 54,   0,  71, 117, 255, 3));
-    EXPECT_TRUE(checkPixel(29, 28,   0, 133,   0, 255, 3));
-    EXPECT_TRUE(checkPixel(36, 41, 100, 232, 255, 255, 3));
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferWithCrop) {
-    const int texWidth = 64;
-    const int texHeight = 66;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    android_native_rect_t crops[] = {
-        {4, 6, 22, 36},
-        {0, 6, 22, 36},
-        {4, 0, 22, 36},
-        {4, 6, texWidth, 36},
-        {4, 6, 22, texHeight},
-    };
-
-    for (int i = 0; i < 5; i++) {
-        const android_native_rect_t& crop(crops[i]);
-        SCOPED_TRACE(String8::format("rect{ l: %d t: %d r: %d b: %d }",
-                crop.left, crop.top, crop.right, crop.bottom).string());
-
-        ASSERT_EQ(NO_ERROR, native_window_set_crop(mANW.get(), &crop));
-
-        ANativeWindowBuffer* anb;
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-                &anb));
-        ASSERT_TRUE(anb != NULL);
-
-        sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-        uint8_t* img = NULL;
-        buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-        fillYV12BufferRect(img, texWidth, texHeight, buf->getStride(), crop);
-        buf->unlock();
-        ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(),
-                buf->getNativeBuffer(), -1));
-
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-        glClearColor(0.2, 0.2, 0.2, 0.2);
-        glClear(GL_COLOR_BUFFER_BIT);
-
-        glViewport(0, 0, 64, 64);
-        drawTexture();
-
-        EXPECT_TRUE(checkPixel( 0,  0,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(63,  0,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(63, 63,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel( 0, 63,  82, 255,  35, 255));
-
-        EXPECT_TRUE(checkPixel(25, 14,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(35, 31,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(57,  6,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel( 5, 42,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(32, 33,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(16, 26,  82, 255,  35, 255));
-        EXPECT_TRUE(checkPixel(46, 51,  82, 255,  35, 255));
-    }
-}
-
-// This test is intended to catch synchronization bugs between the CPU-written
-// and GPU-read buffers.
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BuffersRepeatedly) {
-    enum { texWidth = 16 };
-    enum { texHeight = 16 };
-    enum { numFrames = 1024 };
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    struct TestPixel {
-        int x;
-        int y;
-    };
-    const TestPixel testPixels[] = {
-        {  4, 11 },
-        { 12, 14 },
-        {  7,  2 },
-    };
-    enum {numTestPixels = sizeof(testPixels) / sizeof(testPixels[0])};
-
-    class ProducerThread : public Thread {
-    public:
-        ProducerThread(const sp<ANativeWindow>& anw,
-                const TestPixel* testPixels):
-                mANW(anw),
-                mTestPixels(testPixels) {
-        }
-
-        virtual ~ProducerThread() {
-        }
-
-        virtual bool threadLoop() {
-            for (int i = 0; i < numFrames; i++) {
-                ANativeWindowBuffer* anb;
-                if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                        &anb) != NO_ERROR) {
-                    return false;
-                }
-                if (anb == NULL) {
-                    return false;
-                }
-
-                sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
-
-                const int yuvTexOffsetY = 0;
-                int stride = buf->getStride();
-                int yuvTexStrideY = stride;
-                int yuvTexOffsetV = yuvTexStrideY * texHeight;
-                int yuvTexStrideV = (yuvTexStrideY/2 + 0xf) & ~0xf;
-                int yuvTexOffsetU = yuvTexOffsetV + yuvTexStrideV * texHeight/2;
-                int yuvTexStrideU = yuvTexStrideV;
-
-                uint8_t* img = NULL;
-                buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-
-                // Gray out all the test pixels first, so we're more likely to
-                // see a failure if GL is still texturing from the buffer we
-                // just dequeued.
-                for (int j = 0; j < numTestPixels; j++) {
-                    int x = mTestPixels[j].x;
-                    int y = mTestPixels[j].y;
-                    uint8_t value = 128;
-                    img[y*stride + x] = value;
-                }
-
-                // Fill the buffer with gray.
-                for (int y = 0; y < texHeight; y++) {
-                    for (int x = 0; x < texWidth; x++) {
-                        img[yuvTexOffsetY + y*yuvTexStrideY + x] = 128;
-                        img[yuvTexOffsetU + (y/2)*yuvTexStrideU + x/2] = 128;
-                        img[yuvTexOffsetV + (y/2)*yuvTexStrideV + x/2] = 128;
-                    }
-                }
-
-                // Set the test pixels to either white or black.
-                for (int j = 0; j < numTestPixels; j++) {
-                    int x = mTestPixels[j].x;
-                    int y = mTestPixels[j].y;
-                    uint8_t value = 0;
-                    if (j == (i % numTestPixels)) {
-                        value = 255;
-                    }
-                    img[y*stride + x] = value;
-                }
-
-                buf->unlock();
-                if (mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(), -1)
-                        != NO_ERROR) {
-                    return false;
-                }
-            }
-            return false;
-        }
-
-        sp<ANativeWindow> mANW;
-        const TestPixel* mTestPixels;
-    };
-
-    sp<Thread> pt(new ProducerThread(mANW, testPixels));
-    pt->run("ProducerThread");
-
-    glViewport(0, 0, texWidth, texHeight);
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    // We wait for the first two frames up front so that the producer will be
-    // likely to dequeue the buffer that's currently being textured from.
-    mFW->waitForFrame();
-    mFW->waitForFrame();
-
-    for (int i = 0; i < numFrames; i++) {
-        SCOPED_TRACE(String8::format("frame %d", i).string());
-
-        // We must wait for each frame to come in because if we ever do an
-        // updateTexImage call that doesn't consume a newly available buffer
-        // then the producer and consumer will get out of sync, which will cause
-        // a deadlock.
-        if (i > 1) {
-            mFW->waitForFrame();
-        }
-        ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-        drawTexture();
-
-        for (int j = 0; j < numTestPixels; j++) {
-            int x = testPixels[j].x;
-            int y = testPixels[j].y;
-            if (j == (i % numTestPixels)) {
-                // We must y-invert the texture coords
-                EXPECT_TRUE(checkPixel(x, texHeight-y-1, 255, 255, 255, 255));
-            } else {
-                // We must y-invert the texture coords
-                EXPECT_TRUE(checkPixel(x, texHeight-y-1, 0, 0, 0, 255));
-            }
-        }
-    }
-
-    pt->requestExitAndWait();
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledRGBABufferNpot) {
-    const int texWidth = 64;
-    const int texHeight = 66;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(63,  0, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(63, 65, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel( 0, 65,  35,  35,  35,  35));
-
-    EXPECT_TRUE(checkPixel(15, 10,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(23, 65, 231,  35, 231,  35));
-    EXPECT_TRUE(checkPixel(19, 40,  35, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(38, 30, 231,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(42, 54,  35,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(37, 34,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(31,  8, 231,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(37, 47, 231,  35, 231, 231));
-    EXPECT_TRUE(checkPixel(25, 38,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(49,  6,  35, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(54, 50,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(27, 26, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(10,  6,  35,  35, 231, 231));
-    EXPECT_TRUE(checkPixel(29,  4,  35,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(55, 28,  35,  35, 231,  35));
-    EXPECT_TRUE(checkPixel(58, 55,  35,  35, 231, 231));
-}
-
-TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledRGBABufferPow2) {
-    const int texWidth = 64;
-    const int texHeight = 64;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    ASSERT_EQ(NO_ERROR, mST->updateTexImage());
-
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-
-    glViewport(0, 0, texWidth, texHeight);
-    drawTexture();
-
-    EXPECT_TRUE(checkPixel( 0,  0, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(63,  0,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel(63, 63, 231, 231, 231, 231));
-    EXPECT_TRUE(checkPixel( 0, 63,  35,  35,  35,  35));
-
-    EXPECT_TRUE(checkPixel(12, 46, 231, 231, 231,  35));
-    EXPECT_TRUE(checkPixel(16,  1, 231, 231,  35, 231));
-    EXPECT_TRUE(checkPixel(21, 12, 231,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(26, 51, 231,  35, 231,  35));
-    EXPECT_TRUE(checkPixel( 5, 32,  35, 231, 231,  35));
-    EXPECT_TRUE(checkPixel(13,  8,  35, 231, 231, 231));
-    EXPECT_TRUE(checkPixel(46,  3,  35,  35, 231,  35));
-    EXPECT_TRUE(checkPixel(30, 33,  35,  35,  35,  35));
-    EXPECT_TRUE(checkPixel( 6, 52, 231, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(55, 33,  35, 231,  35, 231));
-    EXPECT_TRUE(checkPixel(16, 29,  35,  35, 231, 231));
-    EXPECT_TRUE(checkPixel( 1, 30,  35,  35,  35, 231));
-    EXPECT_TRUE(checkPixel(41, 37,  35,  35, 231, 231));
-    EXPECT_TRUE(checkPixel(46, 29, 231, 231,  35,  35));
-    EXPECT_TRUE(checkPixel(15, 25,  35, 231,  35, 231));
-    EXPECT_TRUE(checkPixel( 3, 52,  35, 231,  35,  35));
-}
-
-// Tests if GLConsumer and BufferQueue are robust enough
-// to handle a special case where updateTexImage is called
-// in the middle of disconnect.  This ordering is enforced
-// by blocking in the disconnect callback.
-TEST_F(SurfaceTextureGLTest, DisconnectStressTest) {
-
-    class ProducerThread : public Thread {
-    public:
-        explicit ProducerThread(const sp<ANativeWindow>& anw):
-                mANW(anw) {
-        }
-
-        virtual ~ProducerThread() {
-        }
-
-        virtual bool threadLoop() {
-            ANativeWindowBuffer* anb;
-
-            if (native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU) !=
-                    NO_ERROR) {
-                return false;
-            }
-
-            for (int numFrames =0 ; numFrames < 2; numFrames ++) {
-
-                if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                        &anb) != NO_ERROR) {
-                    return false;
-                }
-                if (anb == NULL) {
-                    return false;
-                }
-                if (mANW->queueBuffer(mANW.get(), anb, -1)
-                        != NO_ERROR) {
-                    return false;
-                }
-            }
-
-            if (native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU)
-                    != NO_ERROR) {
-                return false;
-            }
-
-            return false;
-        }
-
-    private:
-        sp<ANativeWindow> mANW;
-    };
-
-    sp<DisconnectWaiter> dw(new DisconnectWaiter());
-    mConsumer->consumerConnect(dw, false);
-
-
-    sp<Thread> pt(new ProducerThread(mANW));
-    pt->run("ProducerThread");
-
-    // eat a frame so GLConsumer will own an at least one slot
-    dw->waitForFrame();
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    dw->waitForFrame();
-    // Could fail here as GLConsumer thinks it still owns the slot
-    // but bufferQueue has released all slots
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    dw->finishDisconnect();
-}
-
-
-// This test ensures that the GLConsumer clears the mCurrentTexture
-// when it is disconnected and reconnected.  Otherwise it will
-// attempt to release a buffer that it does not owned
-TEST_F(SurfaceTextureGLTest, DisconnectClearsCurrentTexture) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    ANativeWindowBuffer *anb;
-
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-
-    EXPECT_EQ(OK,mST->updateTexImage());
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    ASSERT_EQ(OK, native_window_api_disconnect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    EXPECT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-
-    // Will fail here if mCurrentTexture is not cleared properly
-    mFW->waitForFrame();
-    EXPECT_EQ(OK,mST->updateTexImage());
-
-    ASSERT_EQ(OK, native_window_api_disconnect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-}
-
-TEST_F(SurfaceTextureGLTest, ScaleToWindowMode) {
-    ASSERT_EQ(OK, native_window_set_scaling_mode(mANW.get(),
-        NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW));
-
-    // The producer image size
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 512, 512));
-
-    // The consumer image size (16 x 9) ratio
-    mST->setDefaultBufferSize(1280, 720);
-
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    ANativeWindowBuffer *anb;
-
-    android_native_rect_t odd = {23, 78, 123, 477};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &odd));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    Rect r = mST->getCurrentCrop();
-    assertRectEq(Rect(23, 78, 123, 477), r);
-
-    ASSERT_EQ(OK, native_window_api_disconnect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-}
-
-// This test ensures the scaling mode does the right thing
-// ie NATIVE_WINDOW_SCALING_MODE_CROP should crop
-// the image such that it has the same aspect ratio as the
-// default buffer size
-TEST_F(SurfaceTextureGLTest, CroppedScalingMode) {
-    ASSERT_EQ(OK, native_window_set_scaling_mode(mANW.get(),
-        NATIVE_WINDOW_SCALING_MODE_SCALE_CROP));
-
-    // The producer image size
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 512, 512));
-
-    // The consumer image size (16 x 9) ratio
-    mST->setDefaultBufferSize(1280, 720);
-
-    native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU);
-
-    ANativeWindowBuffer *anb;
-
-    // The crop is in the shape of (320, 180) === 16 x 9
-    android_native_rect_t standard = {10, 20, 330, 200};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &standard));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    Rect r = mST->getCurrentCrop();
-    // crop should be the same as crop (same aspect ratio)
-    assertRectEq(Rect(10, 20, 330, 200), r);
-
-    // make this wider then desired aspect 239 x 100 (2.39:1)
-    android_native_rect_t wide = {20, 30, 259, 130};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &wide));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    r = mST->getCurrentCrop();
-    // crop should be the same height, but have cropped left and right borders
-    // offset is 30.6 px L+, R-
-    assertRectEq(Rect(51, 30, 228, 130), r);
-
-    // This image is taller then desired aspect 400 x 300 (4:3)
-    android_native_rect_t narrow = {0, 0, 400, 300};
-    ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &narrow));
-    EXPECT_EQ (OK, native_window_dequeue_buffer_and_wait(mANW.get(), &anb));
-    EXPECT_EQ(OK, mANW->queueBuffer(mANW.get(), anb, -1));
-    mFW->waitForFrame();
-    EXPECT_EQ(OK, mST->updateTexImage());
-    r = mST->getCurrentCrop();
-    // crop should be the same width, but have cropped top and bottom borders
-    // offset is 37.5 px
-    assertRectEq(Rect(0, 37, 400, 262), r);
-
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-}
-
-TEST_F(SurfaceTextureGLTest, AbandonUnblocksDequeueBuffer) {
-    class ProducerThread : public Thread {
-    public:
-        explicit ProducerThread(const sp<ANativeWindow>& anw):
-                mANW(anw),
-                mDequeueError(NO_ERROR) {
-        }
-
-        virtual ~ProducerThread() {
-        }
-
-        virtual bool threadLoop() {
-            Mutex::Autolock lock(mMutex);
-            ANativeWindowBuffer* anb;
-
-            if (native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU) !=
-                    NO_ERROR) {
-                return false;
-            }
-
-            // Frame 1
-            if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                    &anb) != NO_ERROR) {
-                return false;
-            }
-            if (anb == NULL) {
-                return false;
-            }
-            if (mANW->queueBuffer(mANW.get(), anb, -1)
-                    != NO_ERROR) {
-                return false;
-            }
-
-            // Frame 2
-            if (native_window_dequeue_buffer_and_wait(mANW.get(),
-                    &anb) != NO_ERROR) {
-                return false;
-            }
-            if (anb == NULL) {
-                return false;
-            }
-            if (mANW->queueBuffer(mANW.get(), anb, -1)
-                    != NO_ERROR) {
-                return false;
-            }
-
-            // Frame 3 - error expected
-            mDequeueError = native_window_dequeue_buffer_and_wait(mANW.get(),
-                &anb);
-            return false;
-        }
-
-        status_t getDequeueError() {
-            Mutex::Autolock lock(mMutex);
-            return mDequeueError;
-        }
-
-    private:
-        sp<ANativeWindow> mANW;
-        status_t mDequeueError;
-        Mutex mMutex;
-    };
-
-    sp<Thread> pt(new ProducerThread(mANW));
-    pt->run("ProducerThread");
-
-    mFW->waitForFrame();
-    mFW->waitForFrame();
-
-    // Sleep for 100ms to allow the producer thread's dequeueBuffer call to
-    // block waiting for a buffer to become available.
-    usleep(100000);
-
-    mST->abandon();
-
-    pt->requestExitAndWait();
-    ASSERT_EQ(NO_INIT,
-            reinterpret_cast<ProducerThread*>(pt.get())->getDequeueError());
-}
-
-TEST_F(SurfaceTextureGLTest, InvalidWidthOrHeightFails) {
-    int texHeight = 16;
-    ANativeWindowBuffer* anb;
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(mANW.get(),
-            NATIVE_WINDOW_API_CPU));
-
-    GLint maxTextureSize;
-    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxTextureSize);
-
-    // make sure it works with small textures
-    mST->setDefaultBufferSize(16, texHeight);
-    EXPECT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    EXPECT_EQ(16, anb->width);
-    EXPECT_EQ(texHeight, anb->height);
-    EXPECT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), anb, -1));
-    EXPECT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // make sure it works with GL_MAX_TEXTURE_SIZE
-    mST->setDefaultBufferSize(maxTextureSize, texHeight);
-    EXPECT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    EXPECT_EQ(maxTextureSize, anb->width);
-    EXPECT_EQ(texHeight, anb->height);
-    EXPECT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), anb, -1));
-    EXPECT_EQ(NO_ERROR, mST->updateTexImage());
-
-    // make sure it fails with GL_MAX_TEXTURE_SIZE+1
-    mST->setDefaultBufferSize(maxTextureSize+1, texHeight);
-    EXPECT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(mANW.get(),
-            &anb));
-    EXPECT_EQ(maxTextureSize+1, anb->width);
-    EXPECT_EQ(texHeight, anb->height);
-    EXPECT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), anb, -1));
-    ASSERT_NE(NO_ERROR, mST->updateTexImage());
-}
-
-} // namespace android
diff --git a/libs/gui/tests/SurfaceTextureMultiContextGL.h b/libs/gui/tests/SurfaceTextureMultiContextGL.h
deleted file mode 100644
index 3cca035f27..0000000000
--- a/libs/gui/tests/SurfaceTextureMultiContextGL.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SURFACE_TEXTURE_MULTI_CONTEXT_GL_H
-#define ANDROID_SURFACE_TEXTURE_MULTI_CONTEXT_GL_H
-
-#include "SurfaceTextureGL.h"
-
-namespace android {
-
-class SurfaceTextureMultiContextGLTest : public SurfaceTextureGLTest {
-protected:
-    enum { SECOND_TEX_ID = 123 };
-    enum { THIRD_TEX_ID = 456 };
-
-    SurfaceTextureMultiContextGLTest():
-            mSecondEglContext(EGL_NO_CONTEXT),
-            mThirdEglContext(EGL_NO_CONTEXT) {
-    }
-
-    virtual void SetUp() {
-        SurfaceTextureGLTest::SetUp();
-
-        // Set up the secondary context and texture renderer.
-        mSecondEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-                EGL_NO_CONTEXT, getContextAttribs());
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mSecondEglContext);
-
-        ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mSecondEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mSecondTextureRenderer = new TextureRenderer(SECOND_TEX_ID, mST);
-        ASSERT_NO_FATAL_FAILURE(mSecondTextureRenderer->SetUp());
-
-        // Set up the tertiary context and texture renderer.
-        mThirdEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-                EGL_NO_CONTEXT, getContextAttribs());
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        ASSERT_NE(EGL_NO_CONTEXT, mThirdEglContext);
-
-        ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mThirdEglContext));
-        ASSERT_EQ(EGL_SUCCESS, eglGetError());
-        mThirdTextureRenderer = new TextureRenderer(THIRD_TEX_ID, mST);
-        ASSERT_NO_FATAL_FAILURE(mThirdTextureRenderer->SetUp());
-
-        // Switch back to the primary context to start the tests.
-        ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-                mEglContext));
-    }
-
-    virtual void TearDown() {
-        if (mThirdEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mThirdEglContext);
-        }
-        if (mSecondEglContext != EGL_NO_CONTEXT) {
-            eglDestroyContext(mEglDisplay, mSecondEglContext);
-        }
-        SurfaceTextureGLTest::TearDown();
-    }
-
-    EGLContext mSecondEglContext;
-    sp<TextureRenderer> mSecondTextureRenderer;
-
-    EGLContext mThirdEglContext;
-    sp<TextureRenderer> mThirdTextureRenderer;
-};
-
-}
-
-#endif
diff --git a/libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp b/libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp
deleted file mode 100644
index 5b02dcf539..0000000000
--- a/libs/gui/tests/SurfaceTextureMultiContextGL_test.cpp
+++ /dev/null
@@ -1,461 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "SurfaceTextureMultiContextGL_test"
-//#define LOG_NDEBUG 0
-
-#include "SurfaceTextureMultiContextGL.h"
-
-#include "FillBuffer.h"
-
-#include <GLES/glext.h>
-
-namespace android {
-
-TEST_F(SurfaceTextureMultiContextGLTest, UpdateFromMultipleContextsFails) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Attempt to latch the texture on the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_EQ(INVALID_OPERATION, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextSucceeds) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Check that the GL texture was deleted.
-    EXPECT_EQ(GL_FALSE, glIsTexture(TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        DetachFromContextSucceedsAfterProducerDisconnect) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Check that the GL texture was deleted.
-    EXPECT_EQ(GL_FALSE, glIsTexture(TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWhenAbandoned) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Attempt to detach from the primary context.
-    mST->abandon();
-    ASSERT_EQ(NO_INIT, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWhenDetached) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attempt to detach from the primary context again.
-    ASSERT_EQ(INVALID_OPERATION, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWithNoDisplay) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Make there be no current display.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-            EGL_NO_CONTEXT));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Attempt to detach from the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, DetachFromContextFailsWithNoContext) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Make current context be incorrect.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Attempt to detach from the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->detachFromContext());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, UpdateTexImageFailsWhenDetached) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attempt to latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(INVALID_OPERATION, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextSucceeds) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(SECOND_TEX_ID, texBinding);
-
-    // Try to use the texture from the secondary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mSecondTextureRenderer->drawTexture();
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextSucceedsAfterProducerDisconnect) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(SECOND_TEX_ID, texBinding);
-
-    // Try to use the texture from the secondary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mSecondTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextSucceedsBeforeUpdateTexImage) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    native_window_api_disconnect(mANW.get(), NATIVE_WINDOW_API_CPU);
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(SECOND_TEX_ID, texBinding);
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Try to use the texture from the secondary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mSecondTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextFailsWhenAbandoned) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attempt to attach to the secondary context.
-    mST->abandon();
-
-    // Attempt to attach to the primary context.
-    ASSERT_EQ(NO_INIT, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextFailsWhenAttached) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Attempt to attach to the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextFailsWhenAttachedBeforeUpdateTexImage) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Attempt to attach to the primary context.
-    ASSERT_EQ(INVALID_OPERATION, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextFailsWithNoDisplay) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Make there be no current display.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-            EGL_NO_CONTEXT));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Attempt to attach with no context current.
-    ASSERT_EQ(INVALID_OPERATION, mST->attachToContext(SECOND_TEX_ID));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest, AttachToContextSucceedsTwice) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Latch the texture contents on the primary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Detach from the secondary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the tertiary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mThirdEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(THIRD_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(THIRD_TEX_ID, texBinding);
-
-    // Try to use the texture from the tertiary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mThirdTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        AttachToContextSucceedsTwiceBeforeUpdateTexImage) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the secondary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Detach from the secondary context.
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Attach to the tertiary context.
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mThirdEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(THIRD_TEX_ID));
-
-    // Verify that the texture object was created and bound.
-    GLint texBinding = -1;
-    glGetIntegerv(GL_TEXTURE_BINDING_EXTERNAL_OES, &texBinding);
-    EXPECT_EQ(THIRD_TEX_ID, texBinding);
-
-    // Latch the texture contents on the tertiary context.
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // Try to use the texture from the tertiary context.
-    glClearColor(0.2, 0.2, 0.2, 0.2);
-    glClear(GL_COLOR_BUFFER_BIT);
-    glViewport(0, 0, 1, 1);
-    mThirdTextureRenderer->drawTexture();
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_TRUE(checkPixel( 0,  0,  35,  35,  35,  35));
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-        UpdateTexImageSucceedsForBufferConsumedBeforeDetach) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-
-    // produce two frames and consume them both on the primary context
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // produce one more frame
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context and attach to the secondary context
-    ASSERT_EQ(OK, mST->detachFromContext());
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-
-    // Consume final frame on secondary context
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-}
-
-TEST_F(SurfaceTextureMultiContextGLTest,
-       AttachAfterDisplayTerminatedSucceeds) {
-    ASSERT_EQ(OK, native_window_api_connect(mANW.get(), NATIVE_WINDOW_API_CPU));
-
-    // produce two frames and consume them both on the primary context
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-
-    // produce one more frame
-    ASSERT_NO_FATAL_FAILURE(produceOneRGBA8Frame(mANW));
-
-    // Detach from the primary context.
-    ASSERT_EQ(OK, mST->releaseTexImage());
-    ASSERT_EQ(OK, mST->detachFromContext());
-
-    // Terminate and then initialize the display. All contexts, surfaces
-    // and images are invalid at this point.
-    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    ASSERT_NE(EGL_NO_DISPLAY, mEglDisplay);
-    EGLint majorVersion = 0;
-    EGLint minorVersion = 0;
-    EXPECT_TRUE(eglTerminate(display));
-    EXPECT_TRUE(eglInitialize(mEglDisplay, &majorVersion, &minorVersion));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // The surface is invalid so create it again.
-    EGLint pbufferAttribs[] = {
-        EGL_WIDTH, 64,
-        EGL_HEIGHT, 64,
-        EGL_NONE };
-    mEglSurface = eglCreatePbufferSurface(mEglDisplay, mGlConfig,
-            pbufferAttribs);
-
-    // The second context is invalid so create it again.
-    mSecondEglContext = eglCreateContext(mEglDisplay, mGlConfig,
-            EGL_NO_CONTEXT, getContextAttribs());
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-    ASSERT_NE(EGL_NO_CONTEXT, mSecondEglContext);
-
-    ASSERT_TRUE(eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
-            mSecondEglContext));
-    ASSERT_EQ(EGL_SUCCESS, eglGetError());
-
-    // Now attach to and consume final frame on secondary context.
-    ASSERT_EQ(OK, mST->attachToContext(SECOND_TEX_ID));
-    mFW->waitForFrame();
-    ASSERT_EQ(OK, mST->updateTexImage());
-}
-
-
-} // namespace android
diff --git a/libs/gui/tests/Surface_test.cpp b/libs/gui/tests/Surface_test.cpp
deleted file mode 100644
index ca43c68f92..0000000000
--- a/libs/gui/tests/Surface_test.cpp
+++ /dev/null
@@ -1,1587 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "DummyConsumer.h"
-
-#include <gtest/gtest.h>
-
-#include <android/hardware/configstore/1.0/ISurfaceFlingerConfigs.h>
-#include <binder/ProcessState.h>
-#include <configstore/Utils.h>
-#include <cutils/properties.h>
-#include <gui/BufferItemConsumer.h>
-#include <gui/IDisplayEventConnection.h>
-#include <gui/IProducerListener.h>
-#include <gui/ISurfaceComposer.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-#include <private/gui/ComposerService.h>
-#include <ui/Rect.h>
-#include <utils/String8.h>
-
-#include <limits>
-#include <thread>
-
-namespace android {
-
-using namespace std::chrono_literals;
-// retrieve wide-color and hdr settings from configstore
-using namespace android::hardware::configstore;
-using namespace android::hardware::configstore::V1_0;
-
-static bool hasWideColorDisplay =
-        getBool<ISurfaceFlingerConfigs, &ISurfaceFlingerConfigs::hasWideColorDisplay>(false);
-
-class FakeSurfaceComposer;
-class FakeProducerFrameEventHistory;
-
-static constexpr uint64_t NO_FRAME_INDEX = std::numeric_limits<uint64_t>::max();
-
-class SurfaceTest : public ::testing::Test {
-protected:
-
-    SurfaceTest() {
-        ProcessState::self()->startThreadPool();
-    }
-
-    virtual void SetUp() {
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        // TODO(brianderson): The following sometimes fails and is a source of
-        //   test flakiness.
-        mSurfaceControl = mComposerClient->createSurface(
-                String8("Test Surface"), 32, 32, PIXEL_FORMAT_RGBA_8888, 0);
-
-        ASSERT_TRUE(mSurfaceControl != NULL);
-        ASSERT_TRUE(mSurfaceControl->isValid());
-
-        SurfaceComposerClient::openGlobalTransaction();
-        ASSERT_EQ(NO_ERROR, mSurfaceControl->setLayer(0x7fffffff));
-        ASSERT_EQ(NO_ERROR, mSurfaceControl->show());
-        SurfaceComposerClient::closeGlobalTransaction();
-
-        mSurface = mSurfaceControl->getSurface();
-        ASSERT_TRUE(mSurface != NULL);
-    }
-
-    virtual void TearDown() {
-        mComposerClient->dispose();
-    }
-
-    sp<Surface> mSurface;
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mSurfaceControl;
-};
-
-TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenVisible) {
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,
-            &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(1, result);
-}
-
-TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenPurgatorized) {
-    mSurfaceControl.clear();
-    // Wait for the async clean-up to complete.
-    std::this_thread::sleep_for(50ms);
-
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,
-            &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(1, result);
-}
-
-// This test probably doesn't belong here.
-TEST_F(SurfaceTest, ScreenshotsOfProtectedBuffersSucceed) {
-    sp<ANativeWindow> anw(mSurface);
-
-    // Verify the screenshot works with no protected buffers.
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-    sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-    sp<IBinder> display(sf->getBuiltInDisplay(
-            ISurfaceComposer::eDisplayIdMain));
-    ASSERT_EQ(NO_ERROR, sf->captureScreen(display, producer, Rect(),
-            64, 64, 0, 0x7fffffff, false));
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(anw.get(),
-            NATIVE_WINDOW_API_CPU));
-    // Set the PROTECTED usage bit and verify that the screenshot fails.  Note
-    // that we need to dequeue a buffer in order for it to actually get
-    // allocated in SurfaceFlinger.
-    ASSERT_EQ(NO_ERROR, native_window_set_usage(anw.get(),
-            GRALLOC_USAGE_PROTECTED));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffer_count(anw.get(), 3));
-    ANativeWindowBuffer* buf = 0;
-
-    status_t err = native_window_dequeue_buffer_and_wait(anw.get(), &buf);
-    if (err) {
-        // we could fail if GRALLOC_USAGE_PROTECTED is not supported.
-        // that's okay as long as this is the reason for the failure.
-        // try again without the GRALLOC_USAGE_PROTECTED bit.
-        ASSERT_EQ(NO_ERROR, native_window_set_usage(anw.get(), 0));
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(anw.get(),
-                &buf));
-        return;
-    }
-    ASSERT_EQ(NO_ERROR, anw->cancelBuffer(anw.get(), buf, -1));
-
-    for (int i = 0; i < 4; i++) {
-        // Loop to make sure SurfaceFlinger has retired a protected buffer.
-        ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(anw.get(),
-                &buf));
-        ASSERT_EQ(NO_ERROR, anw->queueBuffer(anw.get(), buf, -1));
-    }
-    ASSERT_EQ(NO_ERROR, sf->captureScreen(display, producer, Rect(),
-            64, 64, 0, 0x7fffffff, false));
-}
-
-TEST_F(SurfaceTest, ConcreteTypeIsSurface) {
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_CONCRETE_TYPE, &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(NATIVE_WINDOW_SURFACE, result);
-}
-
-TEST_F(SurfaceTest, LayerCountIsOne) {
-    sp<ANativeWindow> anw(mSurface);
-    int result = -123;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_LAYER_COUNT, &result);
-    EXPECT_EQ(NO_ERROR, err);
-    EXPECT_EQ(1, result);
-}
-
-TEST_F(SurfaceTest, QueryConsumerUsage) {
-    const int TEST_USAGE_FLAGS =
-            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_HW_RENDER;
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<BufferItemConsumer> c = new BufferItemConsumer(consumer,
-            TEST_USAGE_FLAGS);
-    sp<Surface> s = new Surface(producer);
-
-    sp<ANativeWindow> anw(s);
-
-    int flags = -1;
-    int err = anw->query(anw.get(), NATIVE_WINDOW_CONSUMER_USAGE_BITS, &flags);
-
-    ASSERT_EQ(NO_ERROR, err);
-    ASSERT_EQ(TEST_USAGE_FLAGS, flags);
-}
-
-TEST_F(SurfaceTest, QueryDefaultBuffersDataSpace) {
-    const android_dataspace TEST_DATASPACE = HAL_DATASPACE_SRGB;
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-
-    cpuConsumer->setDefaultBufferDataSpace(TEST_DATASPACE);
-
-    sp<Surface> s = new Surface(producer);
-
-    sp<ANativeWindow> anw(s);
-
-    android_dataspace dataSpace;
-
-    int err = anw->query(anw.get(), NATIVE_WINDOW_DEFAULT_DATASPACE,
-            reinterpret_cast<int*>(&dataSpace));
-
-    ASSERT_EQ(NO_ERROR, err);
-    ASSERT_EQ(TEST_DATASPACE, dataSpace);
-}
-
-TEST_F(SurfaceTest, SettingGenerationNumber) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-
-    // Allocate a buffer with a generation number of 0
-    ANativeWindowBuffer* buffer;
-    int fenceFd;
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(window.get(),
-            NATIVE_WINDOW_API_CPU));
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fenceFd));
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffer, fenceFd));
-
-    // Detach the buffer and check its generation number
-    sp<GraphicBuffer> graphicBuffer;
-    sp<Fence> fence;
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&graphicBuffer, &fence));
-    ASSERT_EQ(0U, graphicBuffer->getGenerationNumber());
-
-    ASSERT_EQ(NO_ERROR, surface->setGenerationNumber(1));
-    buffer = static_cast<ANativeWindowBuffer*>(graphicBuffer.get());
-
-    // This should change the generation number of the GraphicBuffer
-    ASSERT_EQ(NO_ERROR, surface->attachBuffer(buffer));
-
-    // Check that the new generation number sticks with the buffer
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffer, -1));
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fenceFd));
-    graphicBuffer = static_cast<GraphicBuffer*>(buffer);
-    ASSERT_EQ(1U, graphicBuffer->getGenerationNumber());
-}
-
-TEST_F(SurfaceTest, GetConsumerName) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    native_window_api_connect(window.get(), NATIVE_WINDOW_API_CPU);
-
-    EXPECT_STREQ("TestConsumer", surface->getConsumerName().string());
-}
-
-TEST_F(SurfaceTest, GetWideColorSupport) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    native_window_api_connect(window.get(), NATIVE_WINDOW_API_CPU);
-
-    bool supported;
-    surface->getWideColorSupport(&supported);
-
-    // NOTE: This test assumes that device that supports
-    // wide-color (as indicated by BoardConfig) must also
-    // have a wide-color primary display.
-    // That assumption allows this test to cover devices
-    // that advertised a wide-color color mode without
-    // actually supporting wide-color to pass this test
-    // as well as the case of a device that does support
-    // wide-color (via BoardConfig) and has a wide-color
-    // primary display.
-    // NOT covered at this time is a device that supports
-    // wide color in the BoardConfig but does not support
-    // a wide-color color mode on the primary display.
-    ASSERT_EQ(hasWideColorDisplay, supported);
-}
-
-TEST_F(SurfaceTest, DynamicSetBufferCount) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(window.get(),
-            NATIVE_WINDOW_API_CPU));
-    native_window_set_buffer_count(window.get(), 4);
-
-    int fence;
-    ANativeWindowBuffer* buffer;
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fence));
-    native_window_set_buffer_count(window.get(), 3);
-    ASSERT_EQ(NO_ERROR, window->queueBuffer(window.get(), buffer, fence));
-    native_window_set_buffer_count(window.get(), 2);
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fence));
-    ASSERT_EQ(NO_ERROR, window->queueBuffer(window.get(), buffer, fence));
-}
-
-TEST_F(SurfaceTest, GetAndFlushRemovedBuffers) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    sp<DummyProducerListener> listener = new DummyProducerListener();
-    ASSERT_EQ(OK, surface->connect(
-            NATIVE_WINDOW_API_CPU,
-            /*listener*/listener,
-            /*reportBufferRemoval*/true));
-    const int BUFFER_COUNT = 4;
-    ASSERT_EQ(NO_ERROR, native_window_set_buffer_count(window.get(), BUFFER_COUNT));
-
-    sp<GraphicBuffer> detachedBuffer;
-    sp<Fence> outFence;
-    int fences[BUFFER_COUNT];
-    ANativeWindowBuffer* buffers[BUFFER_COUNT];
-    // Allocate buffers because detachNextBuffer requires allocated buffers
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffers[i], &fences[i]));
-    }
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffers[i], fences[i]));
-    }
-
-    // Test detached buffer is correctly reported
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    std::vector<sp<GraphicBuffer>> removedBuffers;
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(1u, removedBuffers.size());
-    ASSERT_EQ(detachedBuffer->handle, removedBuffers.at(0)->handle);
-    // Test the list is flushed one getAndFlushRemovedBuffers returns
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(0u, removedBuffers.size());
-
-
-    // Test removed buffer list is cleanup after next dequeueBuffer call
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffers[0], &fences[0]));
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(0u, removedBuffers.size());
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffers[0], fences[0]));
-
-    // Test removed buffer list is cleanup after next detachNextBuffer call
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    ASSERT_EQ(1u, removedBuffers.size());
-    ASSERT_EQ(detachedBuffer->handle, removedBuffers.at(0)->handle);
-
-    // Re-allocate buffers since all buffers are detached up to now
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffers[i], &fences[i]));
-    }
-    for (int i = 0; i < BUFFER_COUNT; i++) {
-        ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffers[i], fences[i]));
-    }
-
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&detachedBuffer, &outFence));
-    ASSERT_EQ(NO_ERROR, surface->attachBuffer(detachedBuffer.get()));
-    ASSERT_EQ(OK, surface->getAndFlushRemovedBuffers(&removedBuffers));
-    // Depends on which slot GraphicBufferProducer impl pick, the attach call might
-    // get 0 or 1 buffer removed.
-    ASSERT_LE(removedBuffers.size(), 1u);
-}
-
-TEST_F(SurfaceTest, TestGetLastDequeueStartTime) {
-    sp<ANativeWindow> anw(mSurface);
-    ASSERT_EQ(NO_ERROR, native_window_api_connect(anw.get(), NATIVE_WINDOW_API_CPU));
-
-    ANativeWindowBuffer* buffer = nullptr;
-    int32_t fenceFd = -1;
-
-    nsecs_t before = systemTime(CLOCK_MONOTONIC);
-    anw->dequeueBuffer(anw.get(), &buffer, &fenceFd);
-    nsecs_t after = systemTime(CLOCK_MONOTONIC);
-
-    nsecs_t lastDequeueTime = mSurface->getLastDequeueStartTime();
-    ASSERT_LE(before, lastDequeueTime);
-    ASSERT_GE(after, lastDequeueTime);
-}
-
-class FakeConsumer : public BnConsumerListener {
-public:
-    void onFrameAvailable(const BufferItem& /*item*/) override {}
-    void onBuffersReleased() override {}
-    void onSidebandStreamChanged() override {}
-
-    void addAndGetFrameTimestamps(
-            const NewFrameEventsEntry* newTimestamps,
-            FrameEventHistoryDelta* outDelta) override {
-        if (newTimestamps) {
-            if (mGetFrameTimestampsEnabled) {
-                EXPECT_GT(mNewFrameEntryOverride.frameNumber, 0u) <<
-                        "Test should set mNewFrameEntryOverride before queuing "
-                        "a frame.";
-                EXPECT_EQ(newTimestamps->frameNumber,
-                        mNewFrameEntryOverride.frameNumber) <<
-                        "Test attempting to add NewFrameEntryOverride with "
-                        "incorrect frame number.";
-                mFrameEventHistory.addQueue(mNewFrameEntryOverride);
-                mNewFrameEntryOverride.frameNumber = 0;
-            }
-            mAddFrameTimestampsCount++;
-            mLastAddedFrameNumber = newTimestamps->frameNumber;
-        }
-        if (outDelta) {
-            mFrameEventHistory.getAndResetDelta(outDelta);
-            mGetFrameTimestampsCount++;
-        }
-        mAddAndGetFrameTimestampsCallCount++;
-    }
-
-    bool mGetFrameTimestampsEnabled = false;
-
-    ConsumerFrameEventHistory mFrameEventHistory;
-    int mAddAndGetFrameTimestampsCallCount = 0;
-    int mAddFrameTimestampsCount = 0;
-    int mGetFrameTimestampsCount = 0;
-    uint64_t mLastAddedFrameNumber = NO_FRAME_INDEX;
-
-    NewFrameEventsEntry mNewFrameEntryOverride = { 0, 0, 0, nullptr };
-};
-
-
-class FakeSurfaceComposer : public ISurfaceComposer{
-public:
-    ~FakeSurfaceComposer() override {}
-
-    void setSupportsPresent(bool supportsPresent) {
-        mSupportsPresent = supportsPresent;
-    }
-
-    sp<ISurfaceComposerClient> createConnection() override { return nullptr; }
-    sp<ISurfaceComposerClient> createScopedConnection(
-            const sp<IGraphicBufferProducer>& /* parent */) override {
-        return nullptr;
-    }
-    sp<IDisplayEventConnection> createDisplayEventConnection(ISurfaceComposer::VsyncSource)
-            override {
-        return nullptr;
-    }
-    sp<IBinder> createDisplay(const String8& /*displayName*/,
-            bool /*secure*/) override { return nullptr; }
-    void destroyDisplay(const sp<IBinder>& /*display */) override {}
-    sp<IBinder> getBuiltInDisplay(int32_t /*id*/) override { return nullptr; }
-    void setTransactionState(const Vector<ComposerState>& /*state*/,
-            const Vector<DisplayState>& /*displays*/, uint32_t /*flags*/)
-            override {}
-    void bootFinished() override {}
-    bool authenticateSurfaceTexture(
-            const sp<IGraphicBufferProducer>& /*surface*/) const override {
-        return false;
-    }
-
-    status_t getSupportedFrameTimestamps(std::vector<FrameEvent>* outSupported)
-            const override {
-        *outSupported = {
-                FrameEvent::REQUESTED_PRESENT,
-                FrameEvent::ACQUIRE,
-                FrameEvent::LATCH,
-                FrameEvent::FIRST_REFRESH_START,
-                FrameEvent::LAST_REFRESH_START,
-                FrameEvent::GPU_COMPOSITION_DONE,
-                FrameEvent::DEQUEUE_READY,
-                FrameEvent::RELEASE
-        };
-        if (mSupportsPresent) {
-            outSupported->push_back(
-                        FrameEvent::DISPLAY_PRESENT);
-        }
-        return NO_ERROR;
-    }
-
-    void setPowerMode(const sp<IBinder>& /*display*/, int /*mode*/) override {}
-    status_t getDisplayConfigs(const sp<IBinder>& /*display*/,
-            Vector<DisplayInfo>* /*configs*/) override { return NO_ERROR; }
-    status_t getDisplayStats(const sp<IBinder>& /*display*/,
-            DisplayStatInfo* /*stats*/) override { return NO_ERROR; }
-    int getActiveConfig(const sp<IBinder>& /*display*/) override { return 0; }
-    status_t setActiveConfig(const sp<IBinder>& /*display*/, int /*id*/)
-            override {
-        return NO_ERROR;
-    }
-    status_t getDisplayColorModes(const sp<IBinder>& /*display*/,
-            Vector<android_color_mode_t>* /*outColorModes*/) override {
-        return NO_ERROR;
-    }
-    android_color_mode_t getActiveColorMode(const sp<IBinder>& /*display*/)
-            override {
-        return HAL_COLOR_MODE_NATIVE;
-    }
-    status_t setActiveColorMode(const sp<IBinder>& /*display*/,
-            android_color_mode_t /*colorMode*/) override { return NO_ERROR; }
-    status_t captureScreen(const sp<IBinder>& /*display*/,
-            const sp<IGraphicBufferProducer>& /*producer*/,
-            Rect /*sourceCrop*/, uint32_t /*reqWidth*/, uint32_t /*reqHeight*/,
-            int32_t /*minLayerZ*/, int32_t /*maxLayerZ*/,
-            bool /*useIdentityTransform*/,
-            Rotation /*rotation*/) override { return NO_ERROR; }
-    status_t clearAnimationFrameStats() override { return NO_ERROR; }
-    status_t getAnimationFrameStats(FrameStats* /*outStats*/) const override {
-        return NO_ERROR;
-    }
-    status_t getHdrCapabilities(const sp<IBinder>& /*display*/,
-            HdrCapabilities* /*outCapabilities*/) const override {
-        return NO_ERROR;
-    }
-    status_t enableVSyncInjections(bool /*enable*/) override {
-        return NO_ERROR;
-    }
-    status_t injectVSync(nsecs_t /*when*/) override { return NO_ERROR; }
-    status_t getLayerDebugInfo(std::vector<LayerDebugInfo>* /*layers*/) const override {
-        return NO_ERROR;
-    }
-
-protected:
-    IBinder* onAsBinder() override { return nullptr; }
-
-private:
-    bool mSupportsPresent{true};
-};
-
-class FakeProducerFrameEventHistory : public ProducerFrameEventHistory {
-public:
-    FakeProducerFrameEventHistory(FenceToFenceTimeMap* fenceMap)
-        : mFenceMap(fenceMap) {}
-
-    ~FakeProducerFrameEventHistory() {}
-
-    void updateAcquireFence(uint64_t frameNumber,
-            std::shared_ptr<FenceTime>&& acquire) override {
-        // Verify the acquire fence being added isn't the one from the consumer.
-        EXPECT_NE(mConsumerAcquireFence, acquire);
-        // Override the fence, so we can verify this was called by the
-        // producer after the frame is queued.
-        ProducerFrameEventHistory::updateAcquireFence(frameNumber,
-                std::shared_ptr<FenceTime>(mAcquireFenceOverride));
-    }
-
-    void setAcquireFenceOverride(
-            const std::shared_ptr<FenceTime>& acquireFenceOverride,
-            const std::shared_ptr<FenceTime>& consumerAcquireFence) {
-        mAcquireFenceOverride = acquireFenceOverride;
-        mConsumerAcquireFence = consumerAcquireFence;
-    }
-
-protected:
-    std::shared_ptr<FenceTime> createFenceTime(const sp<Fence>& fence)
-            const override {
-        return mFenceMap->createFenceTimeForTest(fence);
-    }
-
-    FenceToFenceTimeMap* mFenceMap{nullptr};
-
-    std::shared_ptr<FenceTime> mAcquireFenceOverride{FenceTime::NO_FENCE};
-    std::shared_ptr<FenceTime> mConsumerAcquireFence{FenceTime::NO_FENCE};
-};
-
-
-class TestSurface : public Surface {
-public:
-    TestSurface(const sp<IGraphicBufferProducer>& bufferProducer,
-            FenceToFenceTimeMap* fenceMap)
-        : Surface(bufferProducer),
-          mFakeSurfaceComposer(new FakeSurfaceComposer) {
-        mFakeFrameEventHistory = new FakeProducerFrameEventHistory(fenceMap);
-        mFrameEventHistory.reset(mFakeFrameEventHistory);
-    }
-
-    ~TestSurface() override {}
-
-    sp<ISurfaceComposer> composerService() const override {
-        return mFakeSurfaceComposer;
-    }
-
-    nsecs_t now() const override {
-        return mNow;
-    }
-
-    void setNow(nsecs_t now) {
-        mNow = now;
-    }
-
-public:
-    sp<FakeSurfaceComposer> mFakeSurfaceComposer;
-    nsecs_t mNow = 0;
-
-    // mFrameEventHistory owns the instance of FakeProducerFrameEventHistory,
-    // but this raw pointer gives access to test functionality.
-    FakeProducerFrameEventHistory* mFakeFrameEventHistory;
-};
-
-
-class GetFrameTimestampsTest : public ::testing::Test {
-protected:
-    struct FenceAndFenceTime {
-        explicit FenceAndFenceTime(FenceToFenceTimeMap& fenceMap)
-           : mFence(new Fence),
-             mFenceTime(fenceMap.createFenceTimeForTest(mFence)) {}
-        sp<Fence> mFence { nullptr };
-        std::shared_ptr<FenceTime> mFenceTime { nullptr };
-    };
-
-    struct RefreshEvents {
-        RefreshEvents(FenceToFenceTimeMap& fenceMap, nsecs_t refreshStart)
-          : mFenceMap(fenceMap),
-            kCompositorTiming(
-                {refreshStart, refreshStart + 1, refreshStart + 2 }),
-            kStartTime(refreshStart + 3),
-            kGpuCompositionDoneTime(refreshStart + 4),
-            kPresentTime(refreshStart + 5) {}
-
-        void signalPostCompositeFences() {
-            mFenceMap.signalAllForTest(
-                        mGpuCompositionDone.mFence, kGpuCompositionDoneTime);
-            mFenceMap.signalAllForTest(mPresent.mFence, kPresentTime);
-        }
-
-        FenceToFenceTimeMap& mFenceMap;
-
-        FenceAndFenceTime mGpuCompositionDone { mFenceMap };
-        FenceAndFenceTime mPresent { mFenceMap };
-
-        const CompositorTiming kCompositorTiming;
-
-        const nsecs_t kStartTime;
-        const nsecs_t kGpuCompositionDoneTime;
-        const nsecs_t kPresentTime;
-    };
-
-    struct FrameEvents {
-        FrameEvents(FenceToFenceTimeMap& fenceMap, nsecs_t frameStartTime)
-            : mFenceMap(fenceMap),
-              kPostedTime(frameStartTime + 100),
-              kRequestedPresentTime(frameStartTime + 200),
-              kProducerAcquireTime(frameStartTime + 300),
-              kConsumerAcquireTime(frameStartTime + 301),
-              kLatchTime(frameStartTime + 500),
-              kDequeueReadyTime(frameStartTime + 600),
-              kReleaseTime(frameStartTime + 700),
-              mRefreshes {
-                    { mFenceMap, frameStartTime + 410 },
-                    { mFenceMap, frameStartTime + 420 },
-                    { mFenceMap, frameStartTime + 430 } } {}
-
-        void signalQueueFences() {
-            mFenceMap.signalAllForTest(
-                        mAcquireConsumer.mFence, kConsumerAcquireTime);
-            mFenceMap.signalAllForTest(
-                        mAcquireProducer.mFence, kProducerAcquireTime);
-        }
-
-        void signalRefreshFences() {
-            for (auto& re : mRefreshes) {
-                re.signalPostCompositeFences();
-            }
-        }
-
-        void signalReleaseFences() {
-            mFenceMap.signalAllForTest(mRelease.mFence, kReleaseTime);
-        }
-
-        FenceToFenceTimeMap& mFenceMap;
-
-        FenceAndFenceTime mAcquireConsumer { mFenceMap };
-        FenceAndFenceTime mAcquireProducer { mFenceMap };
-        FenceAndFenceTime mRelease { mFenceMap };
-
-        const nsecs_t kPostedTime;
-        const nsecs_t kRequestedPresentTime;
-        const nsecs_t kProducerAcquireTime;
-        const nsecs_t kConsumerAcquireTime;
-        const nsecs_t kLatchTime;
-        const nsecs_t kDequeueReadyTime;
-        const nsecs_t kReleaseTime;
-
-        RefreshEvents mRefreshes[3];
-    };
-
-    GetFrameTimestampsTest() {}
-
-    virtual void SetUp() {
-        BufferQueue::createBufferQueue(&mProducer, &mConsumer);
-        mFakeConsumer = new FakeConsumer;
-        mCfeh = &mFakeConsumer->mFrameEventHistory;
-        mConsumer->consumerConnect(mFakeConsumer, false);
-        mConsumer->setConsumerName(String8("TestConsumer"));
-        mSurface = new TestSurface(mProducer, &mFenceMap);
-        mWindow = mSurface;
-
-        ASSERT_EQ(NO_ERROR, native_window_api_connect(mWindow.get(),
-                NATIVE_WINDOW_API_CPU));
-        native_window_set_buffer_count(mWindow.get(), 4);
-    }
-
-    void disableFrameTimestamps() {
-        mFakeConsumer->mGetFrameTimestampsEnabled = false;
-        native_window_enable_frame_timestamps(mWindow.get(), 0);
-        mFrameTimestampsEnabled = false;
-    }
-
-    void enableFrameTimestamps() {
-        mFakeConsumer->mGetFrameTimestampsEnabled = true;
-        native_window_enable_frame_timestamps(mWindow.get(), 1);
-        mFrameTimestampsEnabled = true;
-    }
-
-    int getAllFrameTimestamps(uint64_t frameId) {
-        return native_window_get_frame_timestamps(mWindow.get(), frameId,
-                &outRequestedPresentTime, &outAcquireTime, &outLatchTime,
-                &outFirstRefreshStartTime, &outLastRefreshStartTime,
-                &outGpuCompositionDoneTime, &outDisplayPresentTime,
-                &outDequeueReadyTime, &outReleaseTime);
-    }
-
-    void resetTimestamps() {
-        outRequestedPresentTime = -1;
-        outAcquireTime = -1;
-        outLatchTime = -1;
-        outFirstRefreshStartTime = -1;
-        outLastRefreshStartTime = -1;
-        outGpuCompositionDoneTime = -1;
-        outDisplayPresentTime = -1;
-        outDequeueReadyTime = -1;
-        outReleaseTime = -1;
-    }
-
-    uint64_t getNextFrameId() {
-        uint64_t frameId = -1;
-        int status = native_window_get_next_frame_id(mWindow.get(), &frameId);
-        EXPECT_EQ(status, NO_ERROR);
-        return frameId;
-    }
-
-    void dequeueAndQueue(uint64_t frameIndex) {
-        int fence = -1;
-        ANativeWindowBuffer* buffer = nullptr;
-        ASSERT_EQ(NO_ERROR,
-                mWindow->dequeueBuffer(mWindow.get(), &buffer, &fence));
-
-        int oldAddFrameTimestampsCount =
-                mFakeConsumer->mAddFrameTimestampsCount;
-
-        FrameEvents* frame = &mFrames[frameIndex];
-        uint64_t frameNumber = frameIndex + 1;
-
-        NewFrameEventsEntry fe;
-        fe.frameNumber = frameNumber;
-        fe.postedTime = frame->kPostedTime;
-        fe.requestedPresentTime = frame->kRequestedPresentTime;
-        fe.acquireFence = frame->mAcquireConsumer.mFenceTime;
-        mFakeConsumer->mNewFrameEntryOverride = fe;
-
-        mSurface->mFakeFrameEventHistory->setAcquireFenceOverride(
-                    frame->mAcquireProducer.mFenceTime,
-                    frame->mAcquireConsumer.mFenceTime);
-
-        ASSERT_EQ(NO_ERROR, mWindow->queueBuffer(mWindow.get(), buffer, fence));
-
-        EXPECT_EQ(frameNumber, mFakeConsumer->mLastAddedFrameNumber);
-
-        EXPECT_EQ(
-                oldAddFrameTimestampsCount + (mFrameTimestampsEnabled ? 1 : 0),
-                mFakeConsumer->mAddFrameTimestampsCount);
-    }
-
-    void addFrameEvents(
-            bool gpuComposited, uint64_t iOldFrame, int64_t iNewFrame) {
-        FrameEvents* oldFrame =
-                (iOldFrame == NO_FRAME_INDEX) ? nullptr : &mFrames[iOldFrame];
-        FrameEvents* newFrame = &mFrames[iNewFrame];
-
-        uint64_t nOldFrame = iOldFrame + 1;
-        uint64_t nNewFrame = iNewFrame + 1;
-
-        // Latch, Composite, and Release the frames in a plausible order.
-        // Note: The timestamps won't necessarily match the order, but
-        // that's okay for the purposes of this test.
-        std::shared_ptr<FenceTime> gpuDoneFenceTime = FenceTime::NO_FENCE;
-
-        // Composite the previous frame one more time, which helps verify
-        // LastRefresh is updated properly.
-        if (oldFrame != nullptr) {
-            mCfeh->addPreComposition(nOldFrame,
-                                     oldFrame->mRefreshes[2].kStartTime);
-            gpuDoneFenceTime = gpuComposited ?
-                    oldFrame->mRefreshes[2].mGpuCompositionDone.mFenceTime :
-                    FenceTime::NO_FENCE;
-            mCfeh->addPostComposition(nOldFrame, gpuDoneFenceTime,
-                    oldFrame->mRefreshes[2].mPresent.mFenceTime,
-                    oldFrame->mRefreshes[2].kCompositorTiming);
-        }
-
-        // Latch the new frame.
-        mCfeh->addLatch(nNewFrame, newFrame->kLatchTime);
-
-        mCfeh->addPreComposition(nNewFrame, newFrame->mRefreshes[0].kStartTime);
-        gpuDoneFenceTime = gpuComposited ?
-                newFrame->mRefreshes[0].mGpuCompositionDone.mFenceTime :
-                FenceTime::NO_FENCE;
-        // HWC2 releases the previous buffer after a new latch just before
-        // calling postComposition.
-        if (oldFrame != nullptr) {
-            mCfeh->addRelease(nOldFrame, oldFrame->kDequeueReadyTime,
-                    std::shared_ptr<FenceTime>(oldFrame->mRelease.mFenceTime));
-        }
-        mCfeh->addPostComposition(nNewFrame, gpuDoneFenceTime,
-                newFrame->mRefreshes[0].mPresent.mFenceTime,
-                newFrame->mRefreshes[0].kCompositorTiming);
-
-        mCfeh->addPreComposition(nNewFrame, newFrame->mRefreshes[1].kStartTime);
-        gpuDoneFenceTime = gpuComposited ?
-                newFrame->mRefreshes[1].mGpuCompositionDone.mFenceTime :
-                FenceTime::NO_FENCE;
-        mCfeh->addPostComposition(nNewFrame, gpuDoneFenceTime,
-                newFrame->mRefreshes[1].mPresent.mFenceTime,
-                newFrame->mRefreshes[1].kCompositorTiming);
-    }
-
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-    sp<FakeConsumer> mFakeConsumer;
-    ConsumerFrameEventHistory* mCfeh;
-    sp<TestSurface> mSurface;
-    sp<ANativeWindow> mWindow;
-
-    FenceToFenceTimeMap mFenceMap;
-
-    bool mFrameTimestampsEnabled = false;
-
-    int64_t outRequestedPresentTime = -1;
-    int64_t outAcquireTime = -1;
-    int64_t outLatchTime = -1;
-    int64_t outFirstRefreshStartTime = -1;
-    int64_t outLastRefreshStartTime = -1;
-    int64_t outGpuCompositionDoneTime = -1;
-    int64_t outDisplayPresentTime = -1;
-    int64_t outDequeueReadyTime = -1;
-    int64_t outReleaseTime = -1;
-
-    FrameEvents mFrames[3] {
-        { mFenceMap, 1000 }, { mFenceMap, 2000 }, { mFenceMap, 3000 } };
-};
-
-
-// This test verifies that the frame timestamps are not retrieved when not
-// explicitly enabled via native_window_enable_frame_timestamps.
-// We want to check this to make sure there's no overhead for users
-// that don't need the timestamp information.
-TEST_F(GetFrameTimestampsTest, DefaultDisabled) {
-    int fence;
-    ANativeWindowBuffer* buffer;
-
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    const uint64_t fId = getNextFrameId();
-
-    // Verify the producer doesn't get frame timestamps piggybacked on dequeue.
-    ASSERT_EQ(NO_ERROR, mWindow->dequeueBuffer(mWindow.get(), &buffer, &fence));
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify the producer doesn't get frame timestamps piggybacked on queue.
-    // It is okay that frame timestamps are added in the consumer since it is
-    // still needed for SurfaceFlinger dumps.
-    ASSERT_EQ(NO_ERROR, mWindow->queueBuffer(mWindow.get(), buffer, fence));
-    EXPECT_EQ(1, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify attempts to get frame timestamps fail.
-    int result = getAllFrameTimestamps(fId);
-    EXPECT_EQ(INVALID_OPERATION, result);
-    EXPECT_EQ(0, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify compositor timing query fails.
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(INVALID_OPERATION, result);
-}
-
-// This test verifies that the frame timestamps are retrieved if explicitly
-// enabled via native_window_enable_frame_timestamps.
-TEST_F(GetFrameTimestampsTest, EnabledSimple) {
-    CompositorTiming initialCompositorTiming {
-        1000000000, // 1s deadline
-        16666667, // 16ms interval
-        50000000, // 50ms present latency
-    };
-    mCfeh->initializeCompositorTiming(initialCompositorTiming);
-
-    enableFrameTimestamps();
-
-    // Verify the compositor timing query gets the initial compositor values
-    // after timststamps are enabled; even before the first frame is queued
-    // or dequeued.
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-    mSurface->setNow(initialCompositorTiming.deadline - 1);
-    int result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    EXPECT_EQ(initialCompositorTiming.interval, compositeInterval);
-    EXPECT_EQ(initialCompositorTiming.presentLatency,
-              compositeToPresentLatency);
-
-    int fence;
-    ANativeWindowBuffer* buffer;
-
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(1, mFakeConsumer->mGetFrameTimestampsCount);
-
-    const uint64_t fId1 = getNextFrameId();
-
-    // Verify getFrameTimestamps is piggybacked on dequeue.
-    ASSERT_EQ(NO_ERROR, mWindow->dequeueBuffer(mWindow.get(), &buffer, &fence));
-    EXPECT_EQ(0, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(2, mFakeConsumer->mGetFrameTimestampsCount);
-
-    NewFrameEventsEntry f1;
-    f1.frameNumber = 1;
-    f1.postedTime = mFrames[0].kPostedTime;
-    f1.requestedPresentTime = mFrames[0].kRequestedPresentTime;
-    f1.acquireFence = mFrames[0].mAcquireConsumer.mFenceTime;
-    mSurface->mFakeFrameEventHistory->setAcquireFenceOverride(
-            mFrames[0].mAcquireProducer.mFenceTime,
-            mFrames[0].mAcquireConsumer.mFenceTime);
-    mFakeConsumer->mNewFrameEntryOverride = f1;
-    mFrames[0].signalQueueFences();
-
-    // Verify getFrameTimestamps is piggybacked on queue.
-    ASSERT_EQ(NO_ERROR, mWindow->queueBuffer(mWindow.get(), buffer, fence));
-    EXPECT_EQ(1, mFakeConsumer->mAddFrameTimestampsCount);
-    EXPECT_EQ(1u, mFakeConsumer->mLastAddedFrameNumber);
-    EXPECT_EQ(3, mFakeConsumer->mGetFrameTimestampsCount);
-
-    // Verify queries for timestamps that the producer doesn't know about
-    // triggers a call to see if the consumer has any new timestamps.
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(4, mFakeConsumer->mGetFrameTimestampsCount);
-}
-
-TEST_F(GetFrameTimestampsTest, QueryPresentSupported) {
-    bool displayPresentSupported = true;
-    mSurface->mFakeSurfaceComposer->setSupportsPresent(displayPresentSupported);
-
-    // Verify supported bits are forwarded.
-    int supportsPresent = -1;
-    mWindow.get()->query(mWindow.get(),
-            NATIVE_WINDOW_FRAME_TIMESTAMPS_SUPPORTS_PRESENT, &supportsPresent);
-    EXPECT_EQ(displayPresentSupported, supportsPresent);
-}
-
-TEST_F(GetFrameTimestampsTest, QueryPresentNotSupported) {
-    bool displayPresentSupported = false;
-    mSurface->mFakeSurfaceComposer->setSupportsPresent(displayPresentSupported);
-
-    // Verify supported bits are forwarded.
-    int supportsPresent = -1;
-    mWindow.get()->query(mWindow.get(),
-            NATIVE_WINDOW_FRAME_TIMESTAMPS_SUPPORTS_PRESENT, &supportsPresent);
-    EXPECT_EQ(displayPresentSupported, supportsPresent);
-}
-
-TEST_F(GetFrameTimestampsTest, SnapToNextTickBasic) {
-    nsecs_t phase = 4000;
-    nsecs_t interval = 1000;
-
-    // Timestamp in previous interval.
-    nsecs_t timestamp = 3500;
-    EXPECT_EQ(4000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp in next interval.
-    timestamp = 4500;
-    EXPECT_EQ(5000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp multiple intervals before.
-    timestamp = 2500;
-    EXPECT_EQ(3000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp multiple intervals after.
-    timestamp = 6500;
-    EXPECT_EQ(7000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp on previous interval.
-    timestamp = 3000;
-    EXPECT_EQ(3000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp on next interval.
-    timestamp = 5000;
-    EXPECT_EQ(5000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-
-    // Timestamp equal to phase.
-    timestamp = 4000;
-    EXPECT_EQ(4000, ProducerFrameEventHistory::snapToNextTick(
-            timestamp, phase, interval));
-}
-
-// int(big_timestamp / interval) < 0, which can cause a crash or invalid result
-// if the number of intervals elapsed is internally stored in an int.
-TEST_F(GetFrameTimestampsTest, SnapToNextTickOverflow) {
-      nsecs_t phase = 0;
-      nsecs_t interval = 4000;
-      nsecs_t big_timestamp = 8635916564000;
-      int32_t intervals = big_timestamp / interval;
-
-      EXPECT_LT(intervals, 0);
-      EXPECT_EQ(8635916564000, ProducerFrameEventHistory::snapToNextTick(
-            big_timestamp, phase, interval));
-      EXPECT_EQ(8635916564000, ProducerFrameEventHistory::snapToNextTick(
-            big_timestamp, big_timestamp, interval));
-}
-
-// This verifies the compositor timing is updated by refresh events
-// and piggy backed on a queue, dequeue, and enabling of timestamps..
-TEST_F(GetFrameTimestampsTest, CompositorTimingUpdatesBasic) {
-    CompositorTiming initialCompositorTiming {
-        1000000000, // 1s deadline
-        16666667, // 16ms interval
-        50000000, // 50ms present latency
-    };
-    mCfeh->initializeCompositorTiming(initialCompositorTiming);
-
-    enableFrameTimestamps();
-
-    // We get the initial values before any frames are submitted.
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-    mSurface->setNow(initialCompositorTiming.deadline - 1);
-    int result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    EXPECT_EQ(initialCompositorTiming.interval, compositeInterval);
-    EXPECT_EQ(initialCompositorTiming.presentLatency,
-              compositeToPresentLatency);
-
-    dequeueAndQueue(0);
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-
-    // Still get the initial values because the frame events for frame 0
-    // didn't get a chance to piggyback on a queue or dequeue yet.
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    EXPECT_EQ(initialCompositorTiming.interval, compositeInterval);
-    EXPECT_EQ(initialCompositorTiming.presentLatency,
-              compositeToPresentLatency);
-
-    dequeueAndQueue(1);
-    addFrameEvents(true, 0, 1);
-
-    // Now expect the composite values associated with frame 1.
-    mSurface->setNow(mFrames[0].mRefreshes[1].kCompositorTiming.deadline);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].mRefreshes[1].kCompositorTiming.deadline,
-            compositeDeadline);
-    EXPECT_EQ(mFrames[0].mRefreshes[1].kCompositorTiming.interval,
-            compositeInterval);
-    EXPECT_EQ(mFrames[0].mRefreshes[1].kCompositorTiming.presentLatency,
-            compositeToPresentLatency);
-
-    dequeueAndQueue(2);
-    addFrameEvents(true, 1, 2);
-
-    // Now expect the composite values associated with frame 2.
-    mSurface->setNow(mFrames[1].mRefreshes[1].kCompositorTiming.deadline);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kCompositorTiming.deadline,
-            compositeDeadline);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kCompositorTiming.interval,
-            compositeInterval);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kCompositorTiming.presentLatency,
-            compositeToPresentLatency);
-
-    // Re-enabling frame timestamps should get the latest values.
-    disableFrameTimestamps();
-    enableFrameTimestamps();
-
-    // Now expect the composite values associated with frame 3.
-    mSurface->setNow(mFrames[2].mRefreshes[1].kCompositorTiming.deadline);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[2].mRefreshes[1].kCompositorTiming.deadline,
-            compositeDeadline);
-    EXPECT_EQ(mFrames[2].mRefreshes[1].kCompositorTiming.interval,
-            compositeInterval);
-    EXPECT_EQ(mFrames[2].mRefreshes[1].kCompositorTiming.presentLatency,
-            compositeToPresentLatency);
-}
-
-// This verifies the compositor deadline properly snaps to the the next
-// deadline based on the current time.
-TEST_F(GetFrameTimestampsTest, CompositorTimingDeadlineSnaps) {
-    CompositorTiming initialCompositorTiming {
-        1000000000, // 1s deadline
-        16666667, // 16ms interval
-        50000000, // 50ms present latency
-    };
-    mCfeh->initializeCompositorTiming(initialCompositorTiming);
-
-    enableFrameTimestamps();
-
-    nsecs_t compositeDeadline = 0;
-    nsecs_t compositeInterval = 0;
-    nsecs_t compositeToPresentLatency = 0;
-
-    // A "now" just before the deadline snaps to the deadline.
-    mSurface->setNow(initialCompositorTiming.deadline - 1);
-    int result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(initialCompositorTiming.deadline, compositeDeadline);
-    nsecs_t expectedDeadline = initialCompositorTiming.deadline;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    dequeueAndQueue(0);
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-
-    // A "now" just after the deadline snaps properly.
-    mSurface->setNow(initialCompositorTiming.deadline + 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            initialCompositorTiming.deadline +initialCompositorTiming.interval;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    dequeueAndQueue(1);
-    addFrameEvents(true, 0, 1);
-
-    // A "now" just after the next interval snaps properly.
-    mSurface->setNow(
-            mFrames[0].mRefreshes[1].kCompositorTiming.deadline +
-            mFrames[0].mRefreshes[1].kCompositorTiming.interval + 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            mFrames[0].mRefreshes[1].kCompositorTiming.deadline +
-            mFrames[0].mRefreshes[1].kCompositorTiming.interval * 2;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    dequeueAndQueue(2);
-    addFrameEvents(true, 1, 2);
-
-    // A "now" over 1 interval before the deadline snaps properly.
-    mSurface->setNow(
-            mFrames[1].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[1].mRefreshes[1].kCompositorTiming.interval - 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            mFrames[1].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[1].mRefreshes[1].kCompositorTiming.interval;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-
-    // Re-enabling frame timestamps should get the latest values.
-    disableFrameTimestamps();
-    enableFrameTimestamps();
-
-    // A "now" over 2 intervals before the deadline snaps properly.
-    mSurface->setNow(
-            mFrames[2].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[2].mRefreshes[1].kCompositorTiming.interval * 2 - 1);
-    result = native_window_get_compositor_timing(mWindow.get(),
-        &compositeDeadline, &compositeInterval, &compositeToPresentLatency);
-    EXPECT_EQ(NO_ERROR, result);
-    expectedDeadline =
-            mFrames[2].mRefreshes[1].kCompositorTiming.deadline -
-            mFrames[2].mRefreshes[1].kCompositorTiming.interval * 2;
-    EXPECT_EQ(expectedDeadline, compositeDeadline);
-}
-
-// This verifies the timestamps recorded in the consumer's
-// FrameTimestampsHistory are properly retrieved by the producer for the
-// correct frames.
-TEST_F(GetFrameTimestampsTest, TimestampsAssociatedWithCorrectFrame) {
-    enableFrameTimestamps();
-
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-    mFrames[0].signalRefreshFences();
-    addFrameEvents(true, 0, 1);
-    mFrames[0].signalReleaseFences();
-    mFrames[1].signalRefreshFences();
-
-    // Verify timestamps are correct for frame 1.
-    resetTimestamps();
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kGpuCompositionDoneTime,
-            outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(mFrames[0].kReleaseTime, outReleaseTime);
-
-    // Verify timestamps are correct for frame 2.
-    resetTimestamps();
-    result = getAllFrameTimestamps(fId2);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[1].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[1].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kGpuCompositionDoneTime,
-            outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-}
-
-// This test verifies the acquire fence recorded by the consumer is not sent
-// back to the producer and the producer saves its own fence.
-TEST_F(GetFrameTimestampsTest, QueueTimestampsNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-
-    // Verify queue-related timestamps for f1 are available immediately in the
-    // producer without asking the consumer again, even before signaling the
-    // acquire fence.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = native_window_get_frame_timestamps(mWindow.get(), fId1,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outAcquireTime);
-
-    // Signal acquire fences. Verify a sync call still isn't necessary.
-    mFrames[0].signalQueueFences();
-
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = native_window_get_frame_timestamps(mWindow.get(), fId1,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-
-    // Dequeue and queue frame 2.
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-
-    // Verify queue-related timestamps for f2 are available immediately in the
-    // producer without asking the consumer again, even before signaling the
-    // acquire fence.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = native_window_get_frame_timestamps(mWindow.get(), fId2,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outAcquireTime);
-
-    // Signal acquire fences. Verify a sync call still isn't necessary.
-    mFrames[1].signalQueueFences();
-
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = native_window_get_frame_timestamps(mWindow.get(), fId2,
-            &outRequestedPresentTime, &outAcquireTime, nullptr, nullptr,
-            nullptr, nullptr, nullptr, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[1].kProducerAcquireTime, outAcquireTime);
-}
-
-TEST_F(GetFrameTimestampsTest, ZeroRequestedTimestampsNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-    mFrames[0].signalRefreshFences();
-    addFrameEvents(true, 0, 1);
-    mFrames[0].signalReleaseFences();
-    mFrames[1].signalRefreshFences();
-
-    // Verify a request for no timestamps doesn't result in a sync call.
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = native_window_get_frame_timestamps(mWindow.get(), fId2,
-            nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
-            nullptr, nullptr);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-}
-
-// This test verifies that fences can signal and update timestamps producer
-// side without an additional sync call to the consumer.
-TEST_F(GetFrameTimestampsTest, FencesInProducerNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(true, NO_FRAME_INDEX, 0);
-    addFrameEvents(true, 0, 1);
-
-    // Verify available timestamps are correct for frame 1, before any
-    // fence has been signaled.
-    // Note: A sync call is necessary here since the events triggered by
-    // addFrameEvents didn't get to piggyback on the earlier queues/dequeues.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount + 1, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    // Verify available timestamps are correct for frame 1 again, before any
-    // fence has been signaled.
-    // This time a sync call should not be necessary.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    // Signal the fences for frame 1.
-    mFrames[0].signalRefreshFences();
-    mFrames[0].signalReleaseFences();
-
-    // Verify all timestamps are available without a sync call.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kGpuCompositionDoneTime,
-            outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(mFrames[0].kReleaseTime, outReleaseTime);
-}
-
-// This test verifies that if the frame wasn't GPU composited but has a refresh
-// event a sync call isn't made to get the GPU composite done time since it will
-// never exist.
-TEST_F(GetFrameTimestampsTest, NoGpuNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(false, NO_FRAME_INDEX, 0);
-    addFrameEvents(false, 0, 1);
-
-    // Verify available timestamps are correct for frame 1, before any
-    // fence has been signaled.
-    // Note: A sync call is necessary here since the events triggered by
-    // addFrameEvents didn't get to piggyback on the earlier queues/dequeues.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount + 1, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    // Signal the fences for frame 1.
-    mFrames[0].signalRefreshFences();
-    mFrames[0].signalReleaseFences();
-
-    // Verify all timestamps, except GPU composition, are available without a
-    // sync call.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(mFrames[0].kReleaseTime, outReleaseTime);
-}
-
-// This test verifies that if the certain timestamps can't possibly exist for
-// the most recent frame, then a sync call is not done.
-TEST_F(GetFrameTimestampsTest, NoReleaseNoSync) {
-    enableFrameTimestamps();
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-    mFrames[0].signalQueueFences();
-
-    // Dequeue and queue frame 2.
-    const uint64_t fId2 = getNextFrameId();
-    dequeueAndQueue(1);
-    mFrames[1].signalQueueFences();
-
-    addFrameEvents(false, NO_FRAME_INDEX, 0);
-    addFrameEvents(false, 0, 1);
-
-    // Verify available timestamps are correct for frame 1, before any
-    // fence has been signaled.
-    // Note: A sync call is necessary here since the events triggered by
-    // addFrameEvents didn't get to piggyback on the earlier queues/dequeues.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = getAllFrameTimestamps(fId1);
-    EXPECT_EQ(oldCount + 1, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[0].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[0].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[0].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[0].mRefreshes[2].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDisplayPresentTime);
-    EXPECT_EQ(mFrames[0].kDequeueReadyTime, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-
-    mFrames[0].signalRefreshFences();
-    mFrames[0].signalReleaseFences();
-    mFrames[1].signalRefreshFences();
-
-    // Verify querying for all timestmaps of f2 does not do a sync call. Even
-    // though the lastRefresh, dequeueReady, and release times aren't
-    // available, a sync call should not occur because it's not possible for f2
-    // to encounter the final value for those events until another frame is
-    // queued.
-    resetTimestamps();
-    oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    result = getAllFrameTimestamps(fId2);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(NO_ERROR, result);
-    EXPECT_EQ(mFrames[1].kRequestedPresentTime, outRequestedPresentTime);
-    EXPECT_EQ(mFrames[1].kProducerAcquireTime, outAcquireTime);
-    EXPECT_EQ(mFrames[1].kLatchTime, outLatchTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kStartTime, outFirstRefreshStartTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[1].kStartTime, outLastRefreshStartTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_INVALID, outGpuCompositionDoneTime);
-    EXPECT_EQ(mFrames[1].mRefreshes[0].kPresentTime, outDisplayPresentTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outDequeueReadyTime);
-    EXPECT_EQ(NATIVE_WINDOW_TIMESTAMP_PENDING, outReleaseTime);
-}
-
-// This test verifies there are no sync calls for present times
-// when they aren't supported and that an error is returned.
-
-TEST_F(GetFrameTimestampsTest, PresentUnsupportedNoSync) {
-    enableFrameTimestamps();
-    mSurface->mFakeSurfaceComposer->setSupportsPresent(false);
-
-    // Dequeue and queue frame 1.
-    const uint64_t fId1 = getNextFrameId();
-    dequeueAndQueue(0);
-
-    // Verify a query for the Present times do not trigger a sync call if they
-    // are not supported.
-    resetTimestamps();
-    int oldCount = mFakeConsumer->mGetFrameTimestampsCount;
-    int result = native_window_get_frame_timestamps(mWindow.get(), fId1,
-            nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
-            &outDisplayPresentTime, nullptr, nullptr);
-    EXPECT_EQ(oldCount, mFakeConsumer->mGetFrameTimestampsCount);
-    EXPECT_EQ(BAD_VALUE, result);
-    EXPECT_EQ(-1, outDisplayPresentTime);
-}
-
-} // namespace android
diff --git a/libs/gui/tests/TextureRenderer.cpp b/libs/gui/tests/TextureRenderer.cpp
deleted file mode 100644
index e822e6eaf8..0000000000
--- a/libs/gui/tests/TextureRenderer.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "TextureRenderer.h"
-
-#include "GLTest.h"
-
-#include <gui/GLConsumer.h>
-
-#include <GLES2/gl2.h>
-#include <GLES2/gl2ext.h>
-
-#include <gtest/gtest.h>
-
-namespace android {
-
-TextureRenderer::TextureRenderer(GLuint texName,
-        const sp<GLConsumer>& st) : mTexName(texName), mST(st), mPgm(0),
-        mPositionHandle(-1), mTexSamplerHandle(-1), mTexMatrixHandle(-1) {
-}
-
-void TextureRenderer::SetUp() {
-    const char vsrc[] =
-        "attribute vec4 vPosition;\n"
-        "varying vec2 texCoords;\n"
-        "uniform mat4 texMatrix;\n"
-        "void main() {\n"
-        "  vec2 vTexCoords = 0.5 * (vPosition.xy + vec2(1.0, 1.0));\n"
-        "  texCoords = (texMatrix * vec4(vTexCoords, 0.0, 1.0)).xy;\n"
-        "  gl_Position = vPosition;\n"
-        "}\n";
-
-    const char fsrc[] =
-        "#extension GL_OES_EGL_image_external : require\n"
-        "precision mediump float;\n"
-        "uniform samplerExternalOES texSampler;\n"
-        "varying vec2 texCoords;\n"
-        "void main() {\n"
-        "  gl_FragColor = texture2D(texSampler, texCoords);\n"
-        "}\n";
-
-    {
-        SCOPED_TRACE("creating shader program");
-        ASSERT_NO_FATAL_FAILURE(GLTest::createProgram(vsrc, fsrc, &mPgm));
-    }
-
-    mPositionHandle = glGetAttribLocation(mPgm, "vPosition");
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_NE(-1, mPositionHandle);
-    mTexSamplerHandle = glGetUniformLocation(mPgm, "texSampler");
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_NE(-1, mTexSamplerHandle);
-    mTexMatrixHandle = glGetUniformLocation(mPgm, "texMatrix");
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    ASSERT_NE(-1, mTexMatrixHandle);
-}
-
-// drawTexture draws the GLConsumer over the entire GL viewport.
-void TextureRenderer::drawTexture() {
-    static const GLfloat triangleVertices[] = {
-        -1.0f, 1.0f,
-        -1.0f, -1.0f,
-        1.0f, -1.0f,
-        1.0f, 1.0f,
-    };
-
-    glVertexAttribPointer(mPositionHandle, 2, GL_FLOAT, GL_FALSE, 0,
-            triangleVertices);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glEnableVertexAttribArray(mPositionHandle);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-    glUseProgram(mPgm);
-    glUniform1i(mTexSamplerHandle, 0);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTexName);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-    // XXX: These calls are not needed for GL_TEXTURE_EXTERNAL_OES as
-    // they're setting the defautls for that target, but when hacking
-    // things to use GL_TEXTURE_2D they are needed to achieve the same
-    // behavior.
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER,
-            GL_LINEAR);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER,
-            GL_LINEAR);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S,
-            GL_CLAMP_TO_EDGE);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-    glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T,
-            GL_CLAMP_TO_EDGE);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-
-    GLfloat texMatrix[16];
-    mST->getTransformMatrix(texMatrix);
-    glUniformMatrix4fv(mTexMatrixHandle, 1, GL_FALSE, texMatrix);
-
-    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-    ASSERT_EQ(GLenum(GL_NO_ERROR), glGetError());
-}
-
-} // namespace android
diff --git a/libs/gui/tests/TextureRenderer.h b/libs/gui/tests/TextureRenderer.h
deleted file mode 100644
index 37b2b47b41..0000000000
--- a/libs/gui/tests/TextureRenderer.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_TEXTURE_RENDERER_H
-#define ANDROID_TEXTURE_RENDERER_H
-
-#include <GLES/gl.h>
-
-#include <utils/RefBase.h>
-
-namespace android {
-
-class GLConsumer;
-
-class TextureRenderer : public RefBase {
-public:
-    TextureRenderer(GLuint texName, const sp<GLConsumer>& st);
-
-    void SetUp();
-    void drawTexture();
-
-private:
-    GLuint mTexName;
-    sp<GLConsumer> mST;
-    GLuint mPgm;
-    GLint mPositionHandle;
-    GLint mTexSamplerHandle;
-    GLint mTexMatrixHandle;
-};
-
-} // namespace android
-
-#endif
diff --git a/services/surfaceflinger/Android.bp b/services/surfaceflinger/Android.bp
index 4775e4ef54..cc93105543 100644
--- a/services/surfaceflinger/Android.bp
+++ b/services/surfaceflinger/Android.bp
@@ -2,5 +2,3 @@ cc_library_static {
     name: "libsurfaceflingerincludes",
     export_include_dirs: ["."],
 }
-
-subdirs = ["tests/fakehwc"]
\ No newline at end of file
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index 4c9701588b..9e9b3b28f5 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -69,13 +69,13 @@ LOCAL_STATIC_LIBRARIES := \
     libvr_manager \
     libvrflinger
 
-#    android.hardware.graphics.composer@2.1 \
-
 LOCAL_SHARED_LIBRARIES := \
     android.frameworks.vr.composer@1.0 \
     android.hardware.graphics.allocator@2.0 \
+    android.hardware.graphics.composer@2.1 \
     android.hardware.configstore@1.0 \
     android.hardware.configstore-utils \
+    libbfqio \
     libcutils \
     liblog \
     libdl \
diff --git a/services/surfaceflinger/DispSync.cpp b/services/surfaceflinger/DispSync.cpp
index bef12ea50f..abf4aaee58 100644
--- a/services/surfaceflinger/DispSync.cpp
+++ b/services/surfaceflinger/DispSync.cpp
@@ -25,6 +25,7 @@
 #include <algorithm>
 
 #include <log/log.h>
+#include <bfqio/bfqio.h>
 #include <utils/String8.h>
 #include <utils/Thread.h>
 #include <utils/Trace.h>
@@ -386,13 +387,15 @@ void DispSync::init(bool hasSyncFramework, int64_t dispSyncPresentTimeOffset) {
     mIgnorePresentFences = !hasSyncFramework;
     mPresentTimeOffset = dispSyncPresentTimeOffset;
     mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
-
+#ifndef HARDWARE_SCHED_FIFO
     // set DispSync to SCHED_FIFO to minimize jitter
     struct sched_param param = {0};
     param.sched_priority = 2;
     if (sched_setscheduler(mThread->getTid(), SCHED_FIFO, &param) != 0) {
         ALOGE("Couldn't set SCHED_FIFO for DispSyncThread");
     }
+#endif
+    android_set_rt_ioprio(mThread->getTid(), 1);
 
     reset();
     beginResync();
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index a91d1df714..edec087645 100755
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -407,14 +407,6 @@ const Vector< sp<Layer> >& DisplayDevice::getVisibleLayersSortedByZ() const {
     return mVisibleLayersSortedByZ;
 }
 
-void DisplayDevice::setLayersNeedingFences(const Vector< sp<Layer> >& layers) {
-    mLayersNeedingFences = layers;
-}
-
-const Vector< sp<Layer> >& DisplayDevice::getLayersNeedingFences() const {
-    return mLayersNeedingFences;
-}
-
 Region DisplayDevice::getDirtyRegion(bool repaintEverything) const {
     Region dirty;
     if (repaintEverything) {
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index 82a72352a5..c054feb1d8 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -124,8 +124,6 @@ public:
 
     void                    setVisibleLayersSortedByZ(const Vector< sp<Layer> >& layers);
     const Vector< sp<Layer> >& getVisibleLayersSortedByZ() const;
-    void                    setLayersNeedingFences(const Vector< sp<Layer> >& layers);
-    const Vector< sp<Layer> >& getLayersNeedingFences() const;
     Region                  getDirtyRegion(bool repaintEverything) const;
 
     void                    setLayerStack(uint32_t stack);
@@ -243,8 +241,6 @@ private:
 
     // list of visible layers on that display
     Vector< sp<Layer> > mVisibleLayersSortedByZ;
-    // list of layers needing fences
-    Vector< sp<Layer> > mLayersNeedingFences;
 
     /*
      * Transaction state
diff --git a/services/surfaceflinger/EventThread.cpp b/services/surfaceflinger/EventThread.cpp
index f647742e2c..1d5149d08b 100644
--- a/services/surfaceflinger/EventThread.cpp
+++ b/services/surfaceflinger/EventThread.cpp
@@ -20,6 +20,7 @@
 #include <sys/types.h>
 
 #include <cutils/compiler.h>
+#include <bfqio/bfqio.h>
 
 #include <gui/IDisplayEventConnection.h>
 #include <gui/DisplayEventReceiver.h>
@@ -92,6 +93,7 @@ void EventThread::sendVsyncHintOnLocked() {
 
 void EventThread::onFirstRef() {
     run("EventThread", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);
+    android_set_rt_ioprio(getTid(), 1);
 }
 
 sp<EventThread::Connection> EventThread::createEventConnection() const {
@@ -248,7 +250,7 @@ Vector< sp<EventThread::Connection> > EventThread::waitForEvent(
 
         // find out connections waiting for events
         size_t count = mDisplayEventConnections.size();
-        for (size_t i=0 ; i<count ; ) {
+        for (size_t i=0 ; i<count ; i++) {
             sp<Connection> connection(mDisplayEventConnections[i].promote());
             if (connection != NULL) {
                 bool added = false;
@@ -279,12 +281,11 @@ Vector< sp<EventThread::Connection> > EventThread::waitForEvent(
                     // messages.
                     signalConnections.add(connection);
                 }
-                ++i;
             } else {
                 // we couldn't promote this reference, the connection has
                 // died, so clean-up!
                 mDisplayEventConnections.removeAt(i);
-                --count;
+                --i; --count;
             }
         }
 
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index e92565fd9c..038ece2e05 100755
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -40,7 +40,6 @@
 
 #include <gui/BufferItem.h>
 #include <gui/BufferQueue.h>
-#include <gui/LayerDebugInfo.h>
 #include <gui/Surface.h>
 
 #include "clz.h"
@@ -2421,51 +2420,69 @@ void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) const {
 // debugging
 // ----------------------------------------------------------------------------
 
-LayerDebugInfo Layer::getLayerDebugInfo() const {
-    LayerDebugInfo info;
-    const Layer::State& ds = getDrawingState();
-    info.mName = getName();
-    sp<Layer> parent = getParent();
-    info.mParentName = (parent == nullptr ? std::string("none") : parent->getName().string());
-    info.mType = String8(getTypeId());
-    info.mTransparentRegion = ds.activeTransparentRegion;
-    info.mVisibleRegion = visibleRegion;
-    info.mSurfaceDamageRegion = surfaceDamageRegion;
-    info.mLayerStack = getLayerStack();
-    info.mX = ds.active.transform.tx();
-    info.mY = ds.active.transform.ty();
-    info.mZ = ds.z;
-    info.mWidth = ds.active.w;
-    info.mHeight = ds.active.h;
-    info.mCrop = ds.crop;
-    info.mFinalCrop = ds.finalCrop;
-    info.mAlpha = ds.alpha;
-    info.mFlags = ds.flags;
-    info.mPixelFormat = getPixelFormat();
-    info.mDataSpace = getDataSpace();
-    info.mMatrix[0][0] = ds.active.transform[0][0];
-    info.mMatrix[0][1] = ds.active.transform[0][1];
-    info.mMatrix[1][0] = ds.active.transform[1][0];
-    info.mMatrix[1][1] = ds.active.transform[1][1];
-    {
-        sp<const GraphicBuffer> activeBuffer = getActiveBuffer();
-        if (activeBuffer != 0) {
-            info.mActiveBufferWidth = activeBuffer->getWidth();
-            info.mActiveBufferHeight = activeBuffer->getHeight();
-            info.mActiveBufferStride = activeBuffer->getStride();
-            info.mActiveBufferFormat = activeBuffer->format;
-        } else {
-            info.mActiveBufferWidth = 0;
-            info.mActiveBufferHeight = 0;
-            info.mActiveBufferStride = 0;
-            info.mActiveBufferFormat = 0;
-        }
+void Layer::dump(String8& result, Colorizer& colorizer) const
+{
+    const Layer::State& s(getDrawingState());
+
+    colorizer.colorize(result, Colorizer::GREEN);
+    result.appendFormat(
+            "+ %s %p (%s)\n",
+            getTypeId(), this, getName().string());
+    colorizer.reset(result);
+
+    s.activeTransparentRegion.dump(result, "transparentRegion");
+    visibleRegion.dump(result, "visibleRegion");
+    surfaceDamageRegion.dump(result, "surfaceDamageRegion");
+    sp<Client> client(mClientRef.promote());
+    PixelFormat pf = PIXEL_FORMAT_UNKNOWN;
+    const sp<GraphicBuffer>& buffer(getActiveBuffer());
+    if (buffer != NULL) {
+        pf = buffer->getPixelFormat();
+    }
+
+    result.appendFormat(            "      "
+            "layerStack=%4d, z=%9d, pos=(%g,%g), size=(%4d,%4d), "
+            "crop=(%4d,%4d,%4d,%4d), finalCrop=(%4d,%4d,%4d,%4d), "
+            "isOpaque=%1d, invalidate=%1d, "
+            "dataspace=%s, pixelformat=%s "
+#ifdef USE_HWC2
+            "alpha=%.3f, flags=0x%08x, tr=[%.2f, %.2f][%.2f, %.2f]\n"
+#else
+            "alpha=0x%02x, flags=0x%08x, tr=[%.2f, %.2f][%.2f, %.2f]\n"
+#endif
+            "      client=%p\n",
+            getLayerStack(), s.z,
+            s.active.transform.tx(), s.active.transform.ty(),
+            s.active.w, s.active.h,
+            s.crop.left, s.crop.top,
+            s.crop.right, s.crop.bottom,
+            s.finalCrop.left, s.finalCrop.top,
+            s.finalCrop.right, s.finalCrop.bottom,
+            isOpaque(s), contentDirty,
+            dataspaceDetails(getDataSpace()).c_str(), decodePixelFormat(pf).c_str(),
+            s.alpha, s.flags,
+            s.active.transform[0][0], s.active.transform[0][1],
+            s.active.transform[1][0], s.active.transform[1][1],
+            client.get());
+
+    sp<const GraphicBuffer> buf0(mActiveBuffer);
+    uint32_t w0=0, h0=0, s0=0, f0=0;
+    if (buf0 != 0) {
+        w0 = buf0->getWidth();
+        h0 = buf0->getHeight();
+        s0 = buf0->getStride();
+        f0 = buf0->format;
+    }
+    result.appendFormat(
+            "      "
+            "format=%2d, activeBuffer=[%4ux%4u:%4u,%3X],"
+            " queued-frames=%d, mRefreshPending=%d\n",
+            mFormat, w0, h0, s0,f0,
+            mQueuedFrames, mRefreshPending);
+
+    if (mSurfaceFlingerConsumer != 0) {
+        mSurfaceFlingerConsumer->dumpState(result, "            ");
     }
-    info.mNumQueuedFrames = getQueuedFrameCount();
-    info.mRefreshPending = isBufferLatched();
-    info.mIsOpaque = isOpaque(ds);
-    info.mContentDirty = contentDirty;
-    return info;
 }
 
 #ifdef USE_HWC2
diff --git a/services/surfaceflinger/Layer.h b/services/surfaceflinger/Layer.h
index f7b82e4fb7..c34d8a0930 100644
--- a/services/surfaceflinger/Layer.h
+++ b/services/surfaceflinger/Layer.h
@@ -60,7 +60,6 @@ class Colorizer;
 class DisplayDevice;
 class GraphicBuffer;
 class SurfaceFlinger;
-class LayerDebugInfo;
 
 // ---------------------------------------------------------------------------
 
@@ -448,8 +447,6 @@ public:
     bool hasQueuedFrame() const { return mQueuedFrames > 0 ||
             mSidebandStreamChanged || mAutoRefresh; }
 
-    int32_t getQueuedFrameCount() const { return mQueuedFrames; }
-
 #ifdef USE_HWC2
     // -----------------------------------------------------------------------
 
@@ -482,9 +479,9 @@ public:
     inline  const State&    getCurrentState() const { return mCurrentState; }
     inline  State&          getCurrentState()       { return mCurrentState; }
 
-    LayerDebugInfo getLayerDebugInfo() const;
 
     /* always call base class first */
+    void dump(String8& result, Colorizer& colorizer) const;
 #ifdef USE_HWC2
     static void miniDumpHeader(String8& result);
     void miniDump(String8& result, int32_t hwcId) const;
@@ -682,9 +679,6 @@ public:
     sp<IGraphicBufferProducer> getProducer() const;
     const String8& getName() const;
     void notifyAvailableFrames();
-
-    PixelFormat getPixelFormat() const { return mFormat; }
-
 private:
 
     // -----------------------------------------------------------------------
diff --git a/services/surfaceflinger/MessageQueue.cpp b/services/surfaceflinger/MessageQueue.cpp
index bca3430794..0b1199c2d0 100644
--- a/services/surfaceflinger/MessageQueue.cpp
+++ b/services/surfaceflinger/MessageQueue.cpp
@@ -91,6 +91,14 @@ void MessageQueue::init(const sp<SurfaceFlinger>& flinger)
 
 void MessageQueue::setEventThread(const sp<EventThread>& eventThread)
 {
+    if (mEventThread == eventThread) {
+        return;
+    }
+
+    if (mEventTube.getFd() >= 0) {
+        mLooper->removeFd(mEventTube.getFd());
+    }
+
     mEventThread = eventThread;
     mEvents = eventThread->createEventConnection();
     mEvents->stealReceiveChannel(&mEventTube);
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index 224f1fdbc9..a548ffe3b3 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -313,7 +313,6 @@ private:
             HdrCapabilities* outCapabilities) const;
     virtual status_t enableVSyncInjections(bool enable);
     virtual status_t injectVSync(nsecs_t when);
-    virtual status_t getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayers) const;
 
 
     /* ------------------------------------------------------------------------
@@ -367,6 +366,9 @@ private:
     // Called on the main thread in response to setActiveColorMode()
     void setActiveColorModeInternal(const sp<DisplayDevice>& hw, android_color_mode_t colorMode);
 
+    // Called on the main thread in response to enableVSyncInjections()
+    void enableVSyncInjectionsInternal(bool enable);
+
     // Returns whether the transaction actually modified any state
     bool handleMessageTransaction();
 
@@ -483,9 +485,9 @@ private:
     // called when starting, or restarting after system_server death
     void initializeDisplays();
 
-#ifndef USE_HWC2
+    // Create an IBinder for a builtin display and add it to current state
     void createBuiltinDisplayLocked(DisplayDevice::DisplayType type);
-#endif
+
 
     sp<const DisplayDevice> getDisplayDevice(const wp<IBinder>& dpy) const {
       Mutex::Autolock _l(mStateLock);
@@ -511,6 +513,8 @@ private:
         return getDisplayDeviceLocked(mBuiltinDisplays[DisplayDevice::DISPLAY_PRIMARY]);
     }
 
+    void createDefaultDisplayDevice();
+
     int32_t getDisplayType(const sp<IBinder>& display) {
         if (!display.get()) return NAME_NOT_FOUND;
         for (int i = 0; i < DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; ++i) {
@@ -574,8 +578,6 @@ private:
     /* ------------------------------------------------------------------------
      * Display management
      */
-    void processDisplayChangesLocked();
-    void processDisplayHotplugEventsLocked();
 
     /* ------------------------------------------------------------------------
      * VSync
@@ -627,8 +629,8 @@ private:
     void updateVrFlinger();
 #endif
 
-     // Panel hardware rotation
-     int32_t mHardwareRotation;
+    // Panel hardware rotation
+    int32_t mHardwareRotation;
 
     /* ------------------------------------------------------------------------
      * Attributes
@@ -673,10 +675,6 @@ private:
     // acquiring mStateLock.
     std::unique_ptr<HWComposer> mHwc;
 
-#ifdef USE_HWC2
-    const std::string mHwcServiceName; // "default" for real use, something else for testing.
-#endif
-
     // constant members (no synchronization needed for access)
     RenderEngine* mRenderEngine;
     nsecs_t mBootTime;
@@ -708,17 +706,6 @@ private:
     FenceTimeline mGlCompositionDoneTimeline;
     FenceTimeline mDisplayTimeline;
 
-#ifdef USE_HWC2
-    struct HotplugEvent {
-        hwc2_display_t display;
-        HWC2::Connection connection = HWC2::Connection::Invalid;
-        bool isPrimaryDisplay;
-    };
-    // protected by mStateLock
-    std::vector<HotplugEvent> mPendingHotplugEvents;
-#endif
-
-
     // this may only be written from the main thread with mStateLock held
     // it may be read from other threads with mStateLock held
     DefaultKeyedVector< wp<IBinder>, sp<DisplayDevice> > mDisplays;
@@ -833,6 +820,7 @@ private:
 #endif
 
     float mSaturation = 1.0f;
+    bool mForceNativeColorMode = false;
 };
 }; // namespace android
 
diff --git a/services/surfaceflinger/SurfaceFlinger_hwc1.cpp b/services/surfaceflinger/SurfaceFlinger_hwc1.cpp
index 2aaba00e16..647eb4bc58 100644
--- a/services/surfaceflinger/SurfaceFlinger_hwc1.cpp
+++ b/services/surfaceflinger/SurfaceFlinger_hwc1.cpp
@@ -28,6 +28,7 @@
 
 #include <EGL/egl.h>
 
+#include <bfqio/bfqio.h>
 #include <cutils/properties.h>
 #include <log/log.h>
 
@@ -41,7 +42,6 @@
 #include <gui/BufferQueue.h>
 #include <gui/GuiConfig.h>
 #include <gui/IDisplayEventConnection.h>
-#include <gui/LayerDebugInfo.h>
 #include <gui/Surface.h>
 
 #include <ui/GraphicBufferAllocator.h>
@@ -607,6 +607,7 @@ void SurfaceFlinger::init() {
 
     mEventControlThread = new EventControlThread(this);
     mEventControlThread->run("EventControl", PRIORITY_URGENT_DISPLAY);
+    android_set_rt_ioprio(mEventControlThread->getTid(), 1);
 
     // set a fake vsync period if there is no HWComposer
     if (mHwc->initCheck() != NO_ERROR) {
@@ -961,34 +962,6 @@ status_t SurfaceFlinger::injectVSync(nsecs_t when) {
     return NO_ERROR;
 }
 
-status_t SurfaceFlinger::getLayerDebugInfo(std::vector<LayerDebugInfo>* outLayers) const {
-    IPCThreadState* ipc = IPCThreadState::self();
-    const int pid = ipc->getCallingPid();
-    const int uid = ipc->getCallingUid();
-    if ((uid != AID_SHELL) &&
-            !PermissionCache::checkPermission(sDump, pid, uid)) {
-        ALOGE("Layer debug info permission denied for pid=%d, uid=%d", pid, uid);
-        return PERMISSION_DENIED;
-    }
-
-    // Try to acquire a lock for 1s, fail gracefully
-    status_t err = mStateLock.timedLock(s2ns(1));
-    bool locked = (err == NO_ERROR);
-    if (!locked) {
-        ALOGE("LayerDebugInfo: SurfaceFlinger unresponsive (%s [%d]) - exit", strerror(-err), err);
-        return TIMED_OUT;
-    }
-
-    outLayers->clear();
-    mCurrentState.traverseInZOrder([&](Layer* layer) {
-            outLayers->push_back(layer->getLayerDebugInfo());
-        });
-
-    mStateLock.unlock();
-
-    return NO_ERROR;
-}
-
 // ----------------------------------------------------------------------------
 
 sp<IDisplayEventConnection> SurfaceFlinger::createDisplayEventConnection(
@@ -3316,7 +3289,7 @@ void SurfaceFlinger::dumpAllLocked(const Vector<String16>& args, size_t& index,
     result.appendFormat("Visible layers (count = %zu)\n", mNumLayers);
     colorizer.reset(result);
     mCurrentState.traverseInZOrder([&](Layer* layer) {
-        result.append(to_string(layer->getLayerDebugInfo()).c_str());
+        layer->dump(result, colorizer);
     });
 
     /*
diff --git a/services/surfaceflinger/Transform.cpp b/services/surfaceflinger/Transform.cpp
index 073accaba9..6be9ae2c5f 100644
--- a/services/surfaceflinger/Transform.cpp
+++ b/services/surfaceflinger/Transform.cpp
@@ -224,27 +224,6 @@ Rect Transform::transform(const Rect& bounds, bool roundOutwards) const
     return r;
 }
 
-FloatRect Transform::transform(const FloatRect& bounds) const
-{
-    vec2 lt(bounds.left, bounds.top);
-    vec2 rt(bounds.right, bounds.top);
-    vec2 lb(bounds.left, bounds.bottom);
-    vec2 rb(bounds.right, bounds.bottom);
-
-    lt = transform(lt);
-    rt = transform(rt);
-    lb = transform(lb);
-    rb = transform(rb);
-
-    FloatRect r;
-    r.left = min(lt[0], rt[0], lb[0], rb[0]);
-    r.top = min(lt[1], rt[1], lb[1], rb[1]);
-    r.right = max(lt[0], rt[0], lb[0], rb[0]);
-    r.bottom = max(lt[1], rt[1], lb[1], rb[1]);
-
-    return r;
-}
-
 Region Transform::transform(const Region& reg) const
 {
     Region out;
diff --git a/services/surfaceflinger/Transform.h b/services/surfaceflinger/Transform.h
index 2b4788779c..6640a13839 100644
--- a/services/surfaceflinger/Transform.h
+++ b/services/surfaceflinger/Transform.h
@@ -80,7 +80,6 @@ public:
             Region  transform(const Region& reg) const;
             Rect    transform(const Rect& bounds,
                     bool roundOutwards = false) const;
-            FloatRect transform(const FloatRect& bounds) const;
             Transform operator * (const Transform& rhs) const;
             // assumes the last row is < 0 , 0 , 1 >
             vec2 transform(const vec2& v) const;
diff --git a/services/surfaceflinger/main_surfaceflinger.cpp b/services/surfaceflinger/main_surfaceflinger.cpp
index e50f3ce1f9..36f0b20173 100644
--- a/services/surfaceflinger/main_surfaceflinger.cpp
+++ b/services/surfaceflinger/main_surfaceflinger.cpp
@@ -111,11 +111,13 @@ int main(int, char**) {
     sp<GpuService> gpuservice = new GpuService();
     sm->addService(String16(GpuService::SERVICE_NAME), gpuservice, false);
 
+#ifndef HARDWARE_SCHED_FIFO
     struct sched_param param = {0};
     param.sched_priority = 2;
     if (sched_setscheduler(0, SCHED_FIFO, &param) != 0) {
         ALOGE("Couldn't set SCHED_FIFO");
     }
+#endif
 
     // run surface flinger in this thread
     flinger->run();
diff --git a/services/surfaceflinger/tests/Android.mk b/services/surfaceflinger/tests/Android.mk
deleted file mode 100644
index 43e22a0bd6..0000000000
--- a/services/surfaceflinger/tests/Android.mk
+++ /dev/null
@@ -1,44 +0,0 @@
-# Build the unit tests,
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-
-LOCAL_MODULE := SurfaceFlinger_test
-LOCAL_COMPATIBILITY_SUITE := device-tests
-LOCAL_MODULE_TAGS := tests
-
-LOCAL_SRC_FILES := \
-   Transaction_test.cpp \
-   Stress_test.cpp \
-   SurfaceInterceptor_test.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-    libEGL \
-    libGLESv2 \
-    libbinder \
-    libcutils \
-    libgui \
-    libprotobuf-cpp-full \
-    libui \
-    libutils \
-    libandroid \
-    liblog
-
-LOCAL_STATIC_LIBRARIES := libtrace_proto
-
-LOCAL_CFLAGS += -Wall -Werror -Wunused -Wunreachable-code
-
-LOCAL_TEST_DATA = SurfaceFlinger_test.filter
-
-# Build the binary to $(TARGET_OUT_DATA_NATIVE_TESTS)/$(LOCAL_MODULE)
-# to integrate with auto-test framework.
-include $(BUILD_NATIVE_TEST)
-
-# Include subdirectory makefiles
-# ============================================================
-
-# If we're building with ONE_SHOT_MAKEFILE (mm, mmm), then what the framework
-# team really wants is to build the stuff defined by this makefile.
-ifeq (,$(ONE_SHOT_MAKEFILE))
-include $(call first-makefiles-under,$(LOCAL_PATH))
-endif
diff --git a/services/surfaceflinger/tests/AndroidTest.xml b/services/surfaceflinger/tests/AndroidTest.xml
deleted file mode 100644
index 8315037b94..0000000000
--- a/services/surfaceflinger/tests/AndroidTest.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2017 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-<configuration description="Config for SurfaceFlinger_test">
-    <target_preparer class="com.android.tradefed.targetprep.PushFilePreparer">
-        <option name="cleanup" value="true" />
-        <option name="push" value="SurfaceFlinger_test->/data/local/tmp/SurfaceFlinger_test" />
-    </target_preparer>
-    <option name="test-suite-tag" value="apct" />
-    <test class="com.android.tradefed.testtype.GTest" >
-        <option name="native-test-device-path" value="/data/local/tmp" />
-        <option name="module-name" value="SurfaceFlinger_test" />
-    </test>
-</configuration>
diff --git a/services/surfaceflinger/tests/Stress_test.cpp b/services/surfaceflinger/tests/Stress_test.cpp
deleted file mode 100644
index 33dd2f55d3..0000000000
--- a/services/surfaceflinger/tests/Stress_test.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gtest/gtest.h>
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <utils/String8.h>
-
-#include <thread>
-#include <functional>
-
-
-namespace android {
-
-TEST(SurfaceFlingerStress, create_and_destroy) {
-    auto do_stress = []() {
-        sp<SurfaceComposerClient> client = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, client->initCheck());
-        for (int j = 0; j < 1000; j++) {
-            auto surf = client->createSurface(String8("t"), 100, 100,
-                    PIXEL_FORMAT_RGBA_8888, 0);
-            ASSERT_TRUE(surf != nullptr);
-            client->destroySurface(surf->getHandle());
-        }
-    };
-
-    std::vector<std::thread> threads;
-    for (int i = 0; i < 10; i++) {
-        threads.push_back(std::thread(do_stress));
-    }
-    for (auto& thread : threads) {
-        thread.join();
-    }
-}
-
-}
diff --git a/services/surfaceflinger/tests/SurfaceFlinger_test.filter b/services/surfaceflinger/tests/SurfaceFlinger_test.filter
deleted file mode 100644
index 6be708ad1c..0000000000
--- a/services/surfaceflinger/tests/SurfaceFlinger_test.filter
+++ /dev/null
@@ -1,5 +0,0 @@
-{
-        "presubmit": {
-            "filter": "LayerUpdateTest.*:ChildLayerTest.*:SurfaceFlingerStress.*:CropLatchingTest.*:GeometryLatchingTest.*"
-        }
-}
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/SurfaceInterceptor_test.cpp b/services/surfaceflinger/tests/SurfaceInterceptor_test.cpp
deleted file mode 100644
index 0cc763c740..0000000000
--- a/services/surfaceflinger/tests/SurfaceInterceptor_test.cpp
+++ /dev/null
@@ -1,864 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <frameworks/native/cmds/surfacereplayer/proto/src/trace.pb.h>
-#include <google/protobuf/io/zero_copy_stream_impl.h>
-
-#include <gtest/gtest.h>
-
-#include <android/native_window.h>
-
-#include <gui/ISurfaceComposer.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-#include <private/gui/ComposerService.h>
-#include <private/gui/LayerState.h>
-#include <ui/DisplayInfo.h>
-
-#include <fstream>
-#include <random>
-#include <thread>
-
-namespace android {
-
-constexpr int32_t SCALING_UPDATE = 1;
-constexpr uint32_t BUFFER_UPDATES = 18;
-constexpr uint32_t LAYER_UPDATE = INT_MAX - 2;
-constexpr uint32_t SIZE_UPDATE = 134;
-constexpr uint32_t STACK_UPDATE = 1;
-constexpr uint64_t DEFERRED_UPDATE = 13;
-constexpr float ALPHA_UPDATE = 0.29f;
-constexpr float POSITION_UPDATE = 121;
-const Rect CROP_UPDATE(16, 16, 32, 32);
-
-const String8 DISPLAY_NAME("SurfaceInterceptor Display Test");
-constexpr auto LAYER_NAME = "Layer Create and Delete Test";
-
-constexpr auto DEFAULT_FILENAME = "/data/SurfaceTrace.dat";
-
-// Fill an RGBA_8888 formatted surface with a single color.
-static void fillSurfaceRGBA8(const sp<SurfaceControl>& sc, uint8_t r, uint8_t g, uint8_t b) {
-    ANativeWindow_Buffer outBuffer;
-    sp<Surface> s = sc->getSurface();
-    ASSERT_TRUE(s != nullptr);
-    ASSERT_EQ(NO_ERROR, s->lock(&outBuffer, nullptr));
-    uint8_t* img = reinterpret_cast<uint8_t*>(outBuffer.bits);
-    for (int y = 0; y < outBuffer.height; y++) {
-        for (int x = 0; x < outBuffer.width; x++) {
-            uint8_t* pixel = img + (4 * (y*outBuffer.stride + x));
-            pixel[0] = r;
-            pixel[1] = g;
-            pixel[2] = b;
-            pixel[3] = 255;
-        }
-    }
-    ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-}
-
-static status_t readProtoFile(Trace* trace) {
-    status_t err = NO_ERROR;
-
-    int fd = open(DEFAULT_FILENAME, O_RDONLY);
-    {
-        google::protobuf::io::FileInputStream f(fd);
-        if (fd && !trace->ParseFromZeroCopyStream(&f)) {
-            err = PERMISSION_DENIED;
-        }
-    }
-    close(fd);
-
-    return err;
-}
-
-static void enableInterceptor() {
-    system("service call SurfaceFlinger 1020 i32 1 > /dev/null");
-}
-
-static void disableInterceptor() {
-    system("service call SurfaceFlinger 1020 i32 0 > /dev/null");
-}
-
-int32_t getSurfaceId(const std::string& surfaceName) {
-    enableInterceptor();
-    disableInterceptor();
-    Trace capturedTrace;
-    readProtoFile(&capturedTrace);
-    int32_t layerId = 0;
-    for (const auto& increment : *capturedTrace.mutable_increment()) {
-        if (increment.increment_case() == increment.kSurfaceCreation) {
-            if (increment.surface_creation().name() == surfaceName) {
-                layerId = increment.surface_creation().id();
-                break;
-            }
-        }
-    }
-    return layerId;
-}
-
-int32_t getDisplayId(const std::string& displayName) {
-    enableInterceptor();
-    disableInterceptor();
-    Trace capturedTrace;
-    readProtoFile(&capturedTrace);
-    int32_t displayId = 0;
-    for (const auto& increment : *capturedTrace.mutable_increment()) {
-        if (increment.increment_case() == increment.kDisplayCreation) {
-            if (increment.display_creation().name() == displayName) {
-                displayId = increment.display_creation().id();
-                break;
-            }
-        }
-    }
-    return displayId;
-}
-
-class SurfaceInterceptorTest : public ::testing::Test {
-protected:
-    virtual void SetUp() {
-        // Allow SurfaceInterceptor write to /data
-        system("setenforce 0");
-
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        sp<IBinder> display(SurfaceComposerClient::getBuiltInDisplay(
-                ISurfaceComposer::eDisplayIdMain));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-        ssize_t displayWidth = info.w;
-        ssize_t displayHeight = info.h;
-
-        // Background surface
-        mBGSurfaceControl = mComposerClient->createSurface(
-                String8("BG Interceptor Test Surface"), displayWidth, displayHeight,
-                PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mBGSurfaceControl != NULL);
-        ASSERT_TRUE(mBGSurfaceControl->isValid());
-        mBGLayerId = getSurfaceId("BG Interceptor Test Surface");
-
-        SurfaceComposerClient::openGlobalTransaction();
-        mComposerClient->setDisplayLayerStack(display, 0);
-        ASSERT_EQ(NO_ERROR, mBGSurfaceControl->setLayer(INT_MAX-3));
-        ASSERT_EQ(NO_ERROR, mBGSurfaceControl->show());
-        SurfaceComposerClient::closeGlobalTransaction(true);
-    }
-
-    virtual void TearDown() {
-        mComposerClient->dispose();
-        mBGSurfaceControl.clear();
-        mComposerClient.clear();
-    }
-
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mBGSurfaceControl;
-    int32_t mBGLayerId;
-    // Used to verify creation and destruction of surfaces and displays
-    int32_t mTargetId;
-
-public:
-    void captureTest(void (SurfaceInterceptorTest::* action)(void),
-            bool (SurfaceInterceptorTest::* verification)(Trace *));
-    void captureTest(void (SurfaceInterceptorTest::* action)(void),
-            SurfaceChange::SurfaceChangeCase changeCase);
-    void captureTest(void (SurfaceInterceptorTest::* action)(void),
-            Increment::IncrementCase incrementCase);
-    void runInTransaction(void (SurfaceInterceptorTest::* action)(void), bool intercepted = false);
-
-    // Verification of changes to a surface
-    bool positionUpdateFound(const SurfaceChange& change, bool foundPosition);
-    bool sizeUpdateFound(const SurfaceChange& change, bool foundSize);
-    bool alphaUpdateFound(const SurfaceChange& change, bool foundAlpha);
-    bool layerUpdateFound(const SurfaceChange& change, bool foundLayer);
-    bool cropUpdateFound(const SurfaceChange& change, bool foundCrop);
-    bool finalCropUpdateFound(const SurfaceChange& change, bool foundFinalCrop);
-    bool matrixUpdateFound(const SurfaceChange& change, bool foundMatrix);
-    bool scalingModeUpdateFound(const SurfaceChange& change, bool foundScalingMode);
-    bool transparentRegionHintUpdateFound(const SurfaceChange& change, bool foundTransparentRegion);
-    bool layerStackUpdateFound(const SurfaceChange& change, bool foundLayerStack);
-    bool hiddenFlagUpdateFound(const SurfaceChange& change, bool foundHiddenFlag);
-    bool opaqueFlagUpdateFound(const SurfaceChange& change, bool foundOpaqueFlag);
-    bool secureFlagUpdateFound(const SurfaceChange& change, bool foundSecureFlag);
-    bool deferredTransactionUpdateFound(const SurfaceChange& change, bool foundDeferred);
-    bool surfaceUpdateFound(Trace* trace, SurfaceChange::SurfaceChangeCase changeCase);
-    void assertAllUpdatesFound(Trace* trace);
-
-    // Verification of creation and deletion of a surface
-    bool surfaceCreationFound(const Increment& increment, bool foundSurface);
-    bool surfaceDeletionFound(const Increment& increment, bool foundSurface);
-    bool displayCreationFound(const Increment& increment, bool foundDisplay);
-    bool displayDeletionFound(const Increment& increment, bool foundDisplay);
-    bool singleIncrementFound(Trace* trace, Increment::IncrementCase incrementCase);
-
-    // Verification of buffer updates
-    bool bufferUpdatesFound(Trace* trace);
-
-    // Perform each of the possible changes to a surface
-    void positionUpdate();
-    void sizeUpdate();
-    void alphaUpdate();
-    void layerUpdate();
-    void cropUpdate();
-    void finalCropUpdate();
-    void matrixUpdate();
-    void overrideScalingModeUpdate();
-    void transparentRegionHintUpdate();
-    void layerStackUpdate();
-    void hiddenFlagUpdate();
-    void opaqueFlagUpdate();
-    void secureFlagUpdate();
-    void deferredTransactionUpdate();
-    void runAllUpdates();
-    void surfaceCreation();
-    void nBufferUpdates();
-    void displayCreation();
-    void displayDeletion();
-};
-
-void SurfaceInterceptorTest::captureTest(void (SurfaceInterceptorTest::* action)(void),
-        bool (SurfaceInterceptorTest::* verification)(Trace *))
-{
-    runInTransaction(action, true);
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE((this->*verification)(&capturedTrace));
-}
-
-void SurfaceInterceptorTest::captureTest(void (SurfaceInterceptorTest::* action)(void),
-        Increment::IncrementCase incrementCase)
-{
-    runInTransaction(action, true);
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE(singleIncrementFound(&capturedTrace, incrementCase));
-}
-
-void SurfaceInterceptorTest::captureTest(void (SurfaceInterceptorTest::* action)(void),
-        SurfaceChange::SurfaceChangeCase changeCase)
-{
-    runInTransaction(action, true);
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE(surfaceUpdateFound(&capturedTrace, changeCase));
-}
-
-void SurfaceInterceptorTest::runInTransaction(void (SurfaceInterceptorTest::* action)(void),
-        bool intercepted)
-{
-    if (intercepted) {
-        enableInterceptor();
-    }
-    SurfaceComposerClient::openGlobalTransaction();
-    (this->*action)();
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    if (intercepted) {
-        disableInterceptor();
-    }
-}
-
-void SurfaceInterceptorTest::positionUpdate() {
-    mBGSurfaceControl->setPosition(POSITION_UPDATE, POSITION_UPDATE);
-}
-
-void SurfaceInterceptorTest::sizeUpdate() {
-    mBGSurfaceControl->setSize(SIZE_UPDATE, SIZE_UPDATE);
-}
-
-void SurfaceInterceptorTest::alphaUpdate() {
-    mBGSurfaceControl->setAlpha(ALPHA_UPDATE);
-}
-
-void SurfaceInterceptorTest::layerUpdate() {
-    mBGSurfaceControl->setLayer(LAYER_UPDATE);
-}
-
-void SurfaceInterceptorTest::cropUpdate() {
-    mBGSurfaceControl->setCrop(CROP_UPDATE);
-}
-
-void SurfaceInterceptorTest::finalCropUpdate() {
-    mBGSurfaceControl->setFinalCrop(CROP_UPDATE);
-}
-
-void SurfaceInterceptorTest::matrixUpdate() {
-    mBGSurfaceControl->setMatrix(M_SQRT1_2, M_SQRT1_2, -M_SQRT1_2, M_SQRT1_2);
-}
-
-void SurfaceInterceptorTest::overrideScalingModeUpdate() {
-    mBGSurfaceControl->setOverrideScalingMode(SCALING_UPDATE);
-}
-
-void SurfaceInterceptorTest::transparentRegionHintUpdate() {
-    Region region(CROP_UPDATE);
-    mBGSurfaceControl->setTransparentRegionHint(region);
-}
-
-void SurfaceInterceptorTest::layerStackUpdate() {
-    mBGSurfaceControl->setLayerStack(STACK_UPDATE);
-}
-
-void SurfaceInterceptorTest::hiddenFlagUpdate() {
-    mBGSurfaceControl->setFlags(layer_state_t::eLayerHidden, layer_state_t::eLayerHidden);
-}
-
-void SurfaceInterceptorTest::opaqueFlagUpdate() {
-    mBGSurfaceControl->setFlags(layer_state_t::eLayerOpaque, layer_state_t::eLayerOpaque);
-}
-
-void SurfaceInterceptorTest::secureFlagUpdate() {
-    mBGSurfaceControl->setFlags(layer_state_t::eLayerSecure, layer_state_t::eLayerSecure);
-}
-
-void SurfaceInterceptorTest::deferredTransactionUpdate() {
-    mBGSurfaceControl->deferTransactionUntil(mBGSurfaceControl->getHandle(), DEFERRED_UPDATE);
-}
-
-void SurfaceInterceptorTest::displayCreation() {
-    sp<IBinder> testDisplay = SurfaceComposerClient::createDisplay(DISPLAY_NAME, true);
-    SurfaceComposerClient::destroyDisplay(testDisplay);
-}
-
-void SurfaceInterceptorTest::displayDeletion() {
-    sp<IBinder> testDisplay = SurfaceComposerClient::createDisplay(DISPLAY_NAME, false);
-    mTargetId = getDisplayId(DISPLAY_NAME.string());
-    SurfaceComposerClient::destroyDisplay(testDisplay);
-}
-
-void SurfaceInterceptorTest::runAllUpdates() {
-    runInTransaction(&SurfaceInterceptorTest::positionUpdate);
-    runInTransaction(&SurfaceInterceptorTest::sizeUpdate);
-    runInTransaction(&SurfaceInterceptorTest::alphaUpdate);
-    runInTransaction(&SurfaceInterceptorTest::layerUpdate);
-    runInTransaction(&SurfaceInterceptorTest::cropUpdate);
-    runInTransaction(&SurfaceInterceptorTest::finalCropUpdate);
-    runInTransaction(&SurfaceInterceptorTest::matrixUpdate);
-    runInTransaction(&SurfaceInterceptorTest::overrideScalingModeUpdate);
-    runInTransaction(&SurfaceInterceptorTest::transparentRegionHintUpdate);
-    runInTransaction(&SurfaceInterceptorTest::layerStackUpdate);
-    runInTransaction(&SurfaceInterceptorTest::hiddenFlagUpdate);
-    runInTransaction(&SurfaceInterceptorTest::opaqueFlagUpdate);
-    runInTransaction(&SurfaceInterceptorTest::secureFlagUpdate);
-    runInTransaction(&SurfaceInterceptorTest::deferredTransactionUpdate);
-}
-
-void SurfaceInterceptorTest::surfaceCreation() {
-    mComposerClient->createSurface(String8(LAYER_NAME), SIZE_UPDATE, SIZE_UPDATE,
-            PIXEL_FORMAT_RGBA_8888, 0);
-}
-
-void SurfaceInterceptorTest::nBufferUpdates() {
-    std::random_device rd;
-    std::mt19937_64 gen(rd());
-    // This makes testing fun
-    std::uniform_int_distribution<uint8_t> dis;
-    for (uint32_t i = 0; i < BUFFER_UPDATES; ++i) {
-        fillSurfaceRGBA8(mBGSurfaceControl, dis(gen), dis(gen), dis(gen));
-    }
-}
-
-bool SurfaceInterceptorTest::positionUpdateFound(const SurfaceChange& change, bool foundPosition) {
-    // There should only be one position transaction with x and y = POSITION_UPDATE
-    bool hasX(change.position().x() == POSITION_UPDATE);
-    bool hasY(change.position().y() == POSITION_UPDATE);
-    if (hasX && hasY && !foundPosition) {
-        foundPosition = true;
-    }
-    // Failed because the position update was found a second time
-    else if (hasX && hasY && foundPosition) {
-        [] () { FAIL(); }();
-    }
-    return foundPosition;
-}
-
-bool SurfaceInterceptorTest::sizeUpdateFound(const SurfaceChange& change, bool foundSize) {
-    bool hasWidth(change.size().h() == SIZE_UPDATE);
-    bool hasHeight(change.size().w() == SIZE_UPDATE);
-    if (hasWidth && hasHeight && !foundSize) {
-        foundSize = true;
-    }
-    else if (hasWidth && hasHeight && foundSize) {
-        [] () { FAIL(); }();
-    }
-    return foundSize;
-}
-
-bool SurfaceInterceptorTest::alphaUpdateFound(const SurfaceChange& change, bool foundAlpha) {
-    bool hasAlpha(change.alpha().alpha() == ALPHA_UPDATE);
-    if (hasAlpha && !foundAlpha) {
-        foundAlpha = true;
-    }
-    else if (hasAlpha && foundAlpha) {
-        [] () { FAIL(); }();
-    }
-    return foundAlpha;
-}
-
-bool SurfaceInterceptorTest::layerUpdateFound(const SurfaceChange& change, bool foundLayer) {
-    bool hasLayer(change.layer().layer() == LAYER_UPDATE);
-    if (hasLayer && !foundLayer) {
-        foundLayer = true;
-    }
-    else if (hasLayer && foundLayer) {
-        [] () { FAIL(); }();
-    }
-    return foundLayer;
-}
-
-bool SurfaceInterceptorTest::cropUpdateFound(const SurfaceChange& change, bool foundCrop) {
-    bool hasLeft(change.crop().rectangle().left() == CROP_UPDATE.left);
-    bool hasTop(change.crop().rectangle().top() == CROP_UPDATE.top);
-    bool hasRight(change.crop().rectangle().right() == CROP_UPDATE.right);
-    bool hasBottom(change.crop().rectangle().bottom() == CROP_UPDATE.bottom);
-    if (hasLeft && hasRight && hasTop && hasBottom && !foundCrop) {
-        foundCrop = true;
-    }
-    else if (hasLeft && hasRight && hasTop && hasBottom && foundCrop) {
-        [] () { FAIL(); }();
-    }
-    return foundCrop;
-}
-
-bool SurfaceInterceptorTest::finalCropUpdateFound(const SurfaceChange& change,
-        bool foundFinalCrop)
-{
-    bool hasLeft(change.final_crop().rectangle().left() == CROP_UPDATE.left);
-    bool hasTop(change.final_crop().rectangle().top() == CROP_UPDATE.top);
-    bool hasRight(change.final_crop().rectangle().right() == CROP_UPDATE.right);
-    bool hasBottom(change.final_crop().rectangle().bottom() == CROP_UPDATE.bottom);
-    if (hasLeft && hasRight && hasTop && hasBottom && !foundFinalCrop) {
-        foundFinalCrop = true;
-    }
-    else if (hasLeft && hasRight && hasTop && hasBottom && foundFinalCrop) {
-        [] () { FAIL(); }();
-    }
-    return foundFinalCrop;
-}
-
-bool SurfaceInterceptorTest::matrixUpdateFound(const SurfaceChange& change, bool foundMatrix) {
-    bool hasSx((float)change.matrix().dsdx() == (float)M_SQRT1_2);
-    bool hasTx((float)change.matrix().dtdx() == (float)M_SQRT1_2);
-    bool hasSy((float)change.matrix().dsdy() == (float)-M_SQRT1_2);
-    bool hasTy((float)change.matrix().dtdy() == (float)M_SQRT1_2);
-    if (hasSx && hasTx && hasSy && hasTy && !foundMatrix) {
-        foundMatrix = true;
-    }
-    else if (hasSx && hasTx && hasSy && hasTy && foundMatrix) {
-        [] () { FAIL(); }();
-    }
-    return foundMatrix;
-}
-
-bool SurfaceInterceptorTest::scalingModeUpdateFound(const SurfaceChange& change,
-        bool foundScalingMode)
-{
-    bool hasScalingUpdate(change.override_scaling_mode().override_scaling_mode() == SCALING_UPDATE);
-    if (hasScalingUpdate && !foundScalingMode) {
-        foundScalingMode = true;
-    }
-    else if (hasScalingUpdate && foundScalingMode) {
-        [] () { FAIL(); }();
-    }
-    return foundScalingMode;
-}
-
-bool SurfaceInterceptorTest::transparentRegionHintUpdateFound(const SurfaceChange& change,
-        bool foundTransparentRegion)
-{
-    auto traceRegion = change.transparent_region_hint().region(0);
-    bool hasLeft(traceRegion.left() == CROP_UPDATE.left);
-    bool hasTop(traceRegion.top() == CROP_UPDATE.top);
-    bool hasRight(traceRegion.right() == CROP_UPDATE.right);
-    bool hasBottom(traceRegion.bottom() == CROP_UPDATE.bottom);
-    if (hasLeft && hasRight && hasTop && hasBottom && !foundTransparentRegion) {
-        foundTransparentRegion = true;
-    }
-    else if (hasLeft && hasRight && hasTop && hasBottom && foundTransparentRegion) {
-        [] () { FAIL(); }();
-    }
-    return foundTransparentRegion;
-}
-
-bool SurfaceInterceptorTest::layerStackUpdateFound(const SurfaceChange& change,
-        bool foundLayerStack)
-{
-    bool hasLayerStackUpdate(change.layer_stack().layer_stack() == STACK_UPDATE);
-    if (hasLayerStackUpdate && !foundLayerStack) {
-        foundLayerStack = true;
-    }
-    else if (hasLayerStackUpdate && foundLayerStack) {
-        [] () { FAIL(); }();
-    }
-    return foundLayerStack;
-}
-
-bool SurfaceInterceptorTest::hiddenFlagUpdateFound(const SurfaceChange& change,
-        bool foundHiddenFlag)
-{
-    bool hasHiddenFlag(change.hidden_flag().hidden_flag());
-    if (hasHiddenFlag && !foundHiddenFlag) {
-        foundHiddenFlag = true;
-    }
-    else if (hasHiddenFlag && foundHiddenFlag) {
-        [] () { FAIL(); }();
-    }
-    return foundHiddenFlag;
-}
-
-bool SurfaceInterceptorTest::opaqueFlagUpdateFound(const SurfaceChange& change,
-        bool foundOpaqueFlag)
-{
-    bool hasOpaqueFlag(change.opaque_flag().opaque_flag());
-    if (hasOpaqueFlag && !foundOpaqueFlag) {
-        foundOpaqueFlag = true;
-    }
-    else if (hasOpaqueFlag && foundOpaqueFlag) {
-        [] () { FAIL(); }();
-    }
-    return foundOpaqueFlag;
-}
-
-bool SurfaceInterceptorTest::secureFlagUpdateFound(const SurfaceChange& change,
-        bool foundSecureFlag)
-{
-    bool hasSecureFlag(change.secure_flag().secure_flag());
-    if (hasSecureFlag && !foundSecureFlag) {
-        foundSecureFlag = true;
-    }
-    else if (hasSecureFlag && foundSecureFlag) {
-        [] () { FAIL(); }();
-    }
-    return foundSecureFlag;
-}
-
-bool SurfaceInterceptorTest::deferredTransactionUpdateFound(const SurfaceChange& change,
-        bool foundDeferred)
-{
-    bool hasId(change.deferred_transaction().layer_id() == mBGLayerId);
-    bool hasFrameNumber(change.deferred_transaction().frame_number() == DEFERRED_UPDATE);
-    if (hasId && hasFrameNumber && !foundDeferred) {
-        foundDeferred = true;
-    }
-    else if (hasId && hasFrameNumber && foundDeferred) {
-        [] () { FAIL(); }();
-    }
-    return foundDeferred;
-}
-
-bool SurfaceInterceptorTest::surfaceUpdateFound(Trace* trace,
-        SurfaceChange::SurfaceChangeCase changeCase)
-{
-    bool foundUpdate = false;
-    for (const auto& increment : *trace->mutable_increment()) {
-        if (increment.increment_case() == increment.kTransaction) {
-            for (const auto& change : increment.transaction().surface_change()) {
-                if (change.id() == mBGLayerId && change.SurfaceChange_case() == changeCase) {
-                    switch (changeCase) {
-                        case SurfaceChange::SurfaceChangeCase::kPosition:
-                            // foundUpdate is sent for the tests to fail on duplicated increments
-                            foundUpdate = positionUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kSize:
-                            foundUpdate = sizeUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kAlpha:
-                            foundUpdate = alphaUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kLayer:
-                            foundUpdate = layerUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kCrop:
-                            foundUpdate = cropUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kFinalCrop:
-                            foundUpdate = finalCropUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kMatrix:
-                            foundUpdate = matrixUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kOverrideScalingMode:
-                            foundUpdate = scalingModeUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kTransparentRegionHint:
-                            foundUpdate = transparentRegionHintUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kLayerStack:
-                            foundUpdate = layerStackUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kHiddenFlag:
-                            foundUpdate = hiddenFlagUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kOpaqueFlag:
-                            foundUpdate = opaqueFlagUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kSecureFlag:
-                            foundUpdate = secureFlagUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::kDeferredTransaction:
-                            foundUpdate = deferredTransactionUpdateFound(change, foundUpdate);
-                            break;
-                        case SurfaceChange::SurfaceChangeCase::SURFACECHANGE_NOT_SET:
-                            break;
-                    }
-                }
-            }
-        }
-    }
-    return foundUpdate;
-}
-
-void SurfaceInterceptorTest::assertAllUpdatesFound(Trace* trace) {
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kPosition));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kSize));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kAlpha));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kLayer));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kCrop));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kFinalCrop));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kMatrix));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kOverrideScalingMode));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kTransparentRegionHint));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kLayerStack));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kHiddenFlag));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kOpaqueFlag));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kSecureFlag));
-    ASSERT_TRUE(surfaceUpdateFound(trace, SurfaceChange::SurfaceChangeCase::kDeferredTransaction));
-}
-
-bool SurfaceInterceptorTest::surfaceCreationFound(const Increment& increment, bool foundSurface) {
-    bool isMatch(increment.surface_creation().name() == LAYER_NAME &&
-            increment.surface_creation().w() == SIZE_UPDATE &&
-            increment.surface_creation().h() == SIZE_UPDATE);
-    if (isMatch && !foundSurface) {
-        foundSurface = true;
-    }
-    else if (isMatch && foundSurface) {
-        [] () { FAIL(); }();
-    }
-    return foundSurface;
-}
-
-bool SurfaceInterceptorTest::surfaceDeletionFound(const Increment& increment, bool foundSurface) {
-    bool isMatch(increment.surface_deletion().id() == mTargetId);
-    if (isMatch && !foundSurface) {
-        foundSurface = true;
-    }
-    else if (isMatch && foundSurface) {
-        [] () { FAIL(); }();
-    }
-    return foundSurface;
-}
-
-bool SurfaceInterceptorTest::displayCreationFound(const Increment& increment, bool foundDisplay) {
-    bool isMatch(increment.display_creation().name() == DISPLAY_NAME.string() &&
-            increment.display_creation().is_secure());
-    if (isMatch && !foundDisplay) {
-        foundDisplay = true;
-    }
-    else if (isMatch && foundDisplay) {
-        [] () { FAIL(); }();
-    }
-    return foundDisplay;
-}
-
-bool SurfaceInterceptorTest::displayDeletionFound(const Increment& increment, bool foundDisplay) {
-    bool isMatch(increment.display_deletion().id() == mTargetId);
-    if (isMatch && !foundDisplay) {
-        foundDisplay = true;
-    }
-    else if (isMatch && foundDisplay) {
-        [] () { FAIL(); }();
-    }
-    return foundDisplay;
-}
-
-bool SurfaceInterceptorTest::singleIncrementFound(Trace* trace,
-        Increment::IncrementCase incrementCase)
-{
-    bool foundIncrement = false;
-    for (const auto& increment : *trace->mutable_increment()) {
-        if (increment.increment_case() == incrementCase) {
-            switch (incrementCase) {
-                case Increment::IncrementCase::kSurfaceCreation:
-                    foundIncrement = surfaceCreationFound(increment, foundIncrement);
-                    break;
-                case Increment::IncrementCase::kSurfaceDeletion:
-                    foundIncrement = surfaceDeletionFound(increment, foundIncrement);
-                    break;
-                case Increment::IncrementCase::kDisplayCreation:
-                    foundIncrement = displayCreationFound(increment, foundIncrement);
-                    break;
-                case Increment::IncrementCase::kDisplayDeletion:
-                    foundIncrement = displayDeletionFound(increment, foundIncrement);
-                    break;
-                default:
-                    /* code */
-                    break;
-            }
-        }
-    }
-    return foundIncrement;
-}
-
-bool SurfaceInterceptorTest::bufferUpdatesFound(Trace* trace) {
-    uint32_t updates = 0;
-    for (const auto& inc : *trace->mutable_increment()) {
-        if (inc.increment_case() == inc.kBufferUpdate && inc.buffer_update().id() == mBGLayerId) {
-            updates++;
-        }
-    }
-    return updates == BUFFER_UPDATES;
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptPositionUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::positionUpdate,
-            SurfaceChange::SurfaceChangeCase::kPosition);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSizeUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::sizeUpdate, SurfaceChange::SurfaceChangeCase::kSize);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptAlphaUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::alphaUpdate, SurfaceChange::SurfaceChangeCase::kAlpha);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptLayerUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::layerUpdate, SurfaceChange::SurfaceChangeCase::kLayer);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptCropUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::cropUpdate, SurfaceChange::SurfaceChangeCase::kCrop);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptFinalCropUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::finalCropUpdate,
-            SurfaceChange::SurfaceChangeCase::kFinalCrop);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptMatrixUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::matrixUpdate, SurfaceChange::SurfaceChangeCase::kMatrix);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptOverrideScalingModeUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::overrideScalingModeUpdate,
-            SurfaceChange::SurfaceChangeCase::kOverrideScalingMode);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptTransparentRegionHintUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::transparentRegionHintUpdate,
-            SurfaceChange::SurfaceChangeCase::kTransparentRegionHint);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptLayerStackUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::layerStackUpdate,
-            SurfaceChange::SurfaceChangeCase::kLayerStack);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptHiddenFlagUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::hiddenFlagUpdate,
-            SurfaceChange::SurfaceChangeCase::kHiddenFlag);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptOpaqueFlagUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::opaqueFlagUpdate,
-            SurfaceChange::SurfaceChangeCase::kOpaqueFlag);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSecureFlagUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::secureFlagUpdate,
-            SurfaceChange::SurfaceChangeCase::kSecureFlag);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptDeferredTransactionUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::deferredTransactionUpdate,
-            SurfaceChange::SurfaceChangeCase::kDeferredTransaction);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptAllUpdatesWorks) {
-    enableInterceptor();
-    runAllUpdates();
-    disableInterceptor();
-
-    // Find all of the updates in the single trace
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    assertAllUpdatesFound(&capturedTrace);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSurfaceCreationWorks) {
-    captureTest(&SurfaceInterceptorTest::surfaceCreation,
-            Increment::IncrementCase::kSurfaceCreation);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSurfaceDeletionWorks) {
-    sp<SurfaceControl> layerToDelete = mComposerClient->createSurface(String8(LAYER_NAME),
-            SIZE_UPDATE, SIZE_UPDATE, PIXEL_FORMAT_RGBA_8888, 0);
-    this->mTargetId = getSurfaceId(LAYER_NAME);
-    enableInterceptor();
-    mComposerClient->destroySurface(layerToDelete->getHandle());
-    disableInterceptor();
-
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    ASSERT_TRUE(singleIncrementFound(&capturedTrace, Increment::IncrementCase::kSurfaceDeletion));
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptDisplayCreationWorks) {
-    captureTest(&SurfaceInterceptorTest::displayCreation,
-            Increment::IncrementCase::kDisplayCreation);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptDisplayDeletionWorks) {
-    captureTest(&SurfaceInterceptorTest::displayDeletion,
-            Increment::IncrementCase::kDisplayDeletion);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptBufferUpdateWorks) {
-    captureTest(&SurfaceInterceptorTest::nBufferUpdates,
-            &SurfaceInterceptorTest::bufferUpdatesFound);
-}
-
-// If the interceptor is enabled while buffer updates are being pushed, the interceptor should
-// first create a snapshot of the existing displays and surfaces and then start capturing
-// the buffer updates
-TEST_F(SurfaceInterceptorTest, InterceptWhileBufferUpdatesWorks) {
-    std::thread bufferUpdates(&SurfaceInterceptorTest::nBufferUpdates, this);
-    enableInterceptor();
-    disableInterceptor();
-    bufferUpdates.join();
-
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-    const auto& firstIncrement = capturedTrace.mutable_increment(0);
-    ASSERT_EQ(firstIncrement->increment_case(), Increment::IncrementCase::kDisplayCreation);
-}
-
-TEST_F(SurfaceInterceptorTest, InterceptSimultaneousUpdatesWorks) {
-    enableInterceptor();
-    std::thread bufferUpdates(&SurfaceInterceptorTest::nBufferUpdates, this);
-    std::thread surfaceUpdates(&SurfaceInterceptorTest::runAllUpdates, this);
-    runInTransaction(&SurfaceInterceptorTest::surfaceCreation);
-    bufferUpdates.join();
-    surfaceUpdates.join();
-    disableInterceptor();
-
-    Trace capturedTrace;
-    ASSERT_EQ(NO_ERROR, readProtoFile(&capturedTrace));
-
-    assertAllUpdatesFound(&capturedTrace);
-    ASSERT_TRUE(bufferUpdatesFound(&capturedTrace));
-    ASSERT_TRUE(singleIncrementFound(&capturedTrace, Increment::IncrementCase::kSurfaceCreation));
-}
-
-}
diff --git a/services/surfaceflinger/tests/Transaction_test.cpp b/services/surfaceflinger/tests/Transaction_test.cpp
deleted file mode 100644
index 4ce14f8d3a..0000000000
--- a/services/surfaceflinger/tests/Transaction_test.cpp
+++ /dev/null
@@ -1,1126 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gtest/gtest.h>
-
-#include <android/native_window.h>
-
-#include <gui/ISurfaceComposer.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-#include <private/gui/ComposerService.h>
-#include <private/gui/LayerState.h>
-
-#include <utils/String8.h>
-#include <ui/DisplayInfo.h>
-
-#include <math.h>
-
-namespace android {
-
-// Fill an RGBA_8888 formatted surface with a single color.
-static void fillSurfaceRGBA8(const sp<SurfaceControl>& sc,
-        uint8_t r, uint8_t g, uint8_t b, bool unlock=true) {
-    ANativeWindow_Buffer outBuffer;
-    sp<Surface> s = sc->getSurface();
-    ASSERT_TRUE(s != NULL);
-    ASSERT_EQ(NO_ERROR, s->lock(&outBuffer, NULL));
-    uint8_t* img = reinterpret_cast<uint8_t*>(outBuffer.bits);
-    for (int y = 0; y < outBuffer.height; y++) {
-        for (int x = 0; x < outBuffer.width; x++) {
-            uint8_t* pixel = img + (4 * (y*outBuffer.stride + x));
-            pixel[0] = r;
-            pixel[1] = g;
-            pixel[2] = b;
-            pixel[3] = 255;
-        }
-    }
-    if (unlock) {
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-    }
-}
-
-// A ScreenCapture is a screenshot from SurfaceFlinger that can be used to check
-// individual pixel values for testing purposes.
-class ScreenCapture : public RefBase {
-public:
-    static void captureScreen(sp<ScreenCapture>* sc) {
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-        sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-        sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-        sp<IBinder> display(sf->getBuiltInDisplay(
-                ISurfaceComposer::eDisplayIdMain));
-        SurfaceComposerClient::openGlobalTransaction();
-        SurfaceComposerClient::closeGlobalTransaction(true);
-        ASSERT_EQ(NO_ERROR, sf->captureScreen(display, producer, Rect(), 0, 0,
-                0, INT_MAX, false));
-        *sc = new ScreenCapture(cpuConsumer);
-    }
-
-    void checkPixel(uint32_t x, uint32_t y, uint8_t r, uint8_t g, uint8_t b) {
-        ASSERT_EQ(HAL_PIXEL_FORMAT_RGBA_8888, mBuf.format);
-        const uint8_t* img = static_cast<const uint8_t*>(mBuf.data);
-        const uint8_t* pixel = img + (4 * (y * mBuf.stride + x));
-        if (r != pixel[0] || g != pixel[1] || b != pixel[2]) {
-            String8 err(String8::format("pixel @ (%3d, %3d): "
-                    "expected [%3d, %3d, %3d], got [%3d, %3d, %3d]",
-                    x, y, r, g, b, pixel[0], pixel[1], pixel[2]));
-            EXPECT_EQ(String8(), err) << err.string();
-        }
-    }
-
-    void expectFGColor(uint32_t x, uint32_t y) {
-        checkPixel(x, y, 195, 63, 63);
-    }
-
-    void expectBGColor(uint32_t x, uint32_t y) {
-        checkPixel(x, y, 63, 63, 195);
-    }
-
-    void expectChildColor(uint32_t x, uint32_t y) {
-        checkPixel(x, y, 200, 200, 200);
-    }
-
-private:
-    ScreenCapture(const sp<CpuConsumer>& cc) :
-        mCC(cc) {
-        EXPECT_EQ(NO_ERROR, mCC->lockNextBuffer(&mBuf));
-    }
-
-    ~ScreenCapture() {
-        mCC->unlockBuffer(mBuf);
-    }
-
-    sp<CpuConsumer> mCC;
-    CpuConsumer::LockedBuffer mBuf;
-};
-
-class LayerUpdateTest : public ::testing::Test {
-protected:
-    virtual void SetUp() {
-        mComposerClient = new SurfaceComposerClient;
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        sp<IBinder> display(SurfaceComposerClient::getBuiltInDisplay(
-                ISurfaceComposer::eDisplayIdMain));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-
-        ssize_t displayWidth = info.w;
-        ssize_t displayHeight = info.h;
-
-        // Background surface
-        mBGSurfaceControl = mComposerClient->createSurface(
-                String8("BG Test Surface"), displayWidth, displayHeight,
-                PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mBGSurfaceControl != NULL);
-        ASSERT_TRUE(mBGSurfaceControl->isValid());
-        fillSurfaceRGBA8(mBGSurfaceControl, 63, 63, 195);
-
-        // Foreground surface
-        mFGSurfaceControl = mComposerClient->createSurface(
-                String8("FG Test Surface"), 64, 64, PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mFGSurfaceControl != NULL);
-        ASSERT_TRUE(mFGSurfaceControl->isValid());
-
-        fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63);
-
-        // Synchronization surface
-        mSyncSurfaceControl = mComposerClient->createSurface(
-                String8("Sync Test Surface"), 1, 1, PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(mSyncSurfaceControl != NULL);
-        ASSERT_TRUE(mSyncSurfaceControl->isValid());
-
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-
-        SurfaceComposerClient::openGlobalTransaction();
-
-        mComposerClient->setDisplayLayerStack(display, 0);
-
-        ASSERT_EQ(NO_ERROR, mBGSurfaceControl->setLayer(INT32_MAX-2));
-        ASSERT_EQ(NO_ERROR, mBGSurfaceControl->show());
-
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setLayer(INT32_MAX-1));
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(64, 64));
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->show());
-
-        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl->setLayer(INT32_MAX-1));
-        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl->setPosition(displayWidth-2,
-                displayHeight-2));
-        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl->show());
-
-        SurfaceComposerClient::closeGlobalTransaction(true);
-    }
-
-    virtual void TearDown() {
-        mComposerClient->dispose();
-        mBGSurfaceControl = 0;
-        mFGSurfaceControl = 0;
-        mSyncSurfaceControl = 0;
-        mComposerClient = 0;
-    }
-
-    void waitForPostedBuffers() {
-        // Since the sync surface is in synchronous mode (i.e. double buffered)
-        // posting three buffers to it should ensure that at least two
-        // SurfaceFlinger::handlePageFlip calls have been made, which should
-        // guaranteed that a buffer posted to another Surface has been retired.
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-        fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-    }
-
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mBGSurfaceControl;
-    sp<SurfaceControl> mFGSurfaceControl;
-
-    // This surface is used to ensure that the buffers posted to
-    // mFGSurfaceControl have been picked up by SurfaceFlinger.
-    sp<SurfaceControl> mSyncSurfaceControl;
-};
-
-TEST_F(LayerUpdateTest, LayerMoveWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before move");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(0, 12);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(128, 128));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should reflect the new position, but not the new color.
-        SCOPED_TRACE("after move, before redraw");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->expectFGColor(145, 145);
-    }
-
-    fillSurfaceRGBA8(mFGSurfaceControl, 63, 195, 63);
-    waitForPostedBuffers();
-    {
-        // This should reflect the new position and the new color.
-        SCOPED_TRACE("after redraw");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->checkPixel(145, 145, 63, 195, 63);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerResizeWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before resize");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(0, 12);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    ALOGD("resizing");
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setSize(128, 128));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    ALOGD("resized");
-    {
-        // This should not reflect the new size or color because SurfaceFlinger
-        // has not yet received a buffer of the correct size.
-        SCOPED_TRACE("after resize, before redraw");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(0, 12);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    ALOGD("drawing");
-    fillSurfaceRGBA8(mFGSurfaceControl, 63, 195, 63);
-    waitForPostedBuffers();
-    ALOGD("drawn");
-    {
-        // This should reflect the new size and the new color.
-        SCOPED_TRACE("after redraw");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->checkPixel(75, 75, 63, 195, 63);
-        sc->checkPixel(145, 145, 63, 195, 63);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerCropWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before crop");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    Rect cropRect(16, 16, 32, 32);
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setCrop(cropRect));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should crop the foreground surface.
-        SCOPED_TRACE("after crop");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->expectFGColor(95, 80);
-        sc->expectFGColor(80, 95);
-        sc->expectBGColor(96, 96);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerFinalCropWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before crop");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-    SurfaceComposerClient::openGlobalTransaction();
-    Rect cropRect(16, 16, 32, 32);
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setFinalCrop(cropRect));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should crop the foreground surface.
-        SCOPED_TRACE("after crop");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->expectBGColor(95, 80);
-        sc->expectBGColor(80, 95);
-        sc->expectBGColor(96, 96);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerSetLayerWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before setLayer");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setLayer(INT_MAX - 3));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should hide the foreground surface beneath the background.
-        SCOPED_TRACE("after setLayer");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerShowHideWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before hide");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->hide());
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should hide the foreground surface.
-        SCOPED_TRACE("after hide, before show");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->show());
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should show the foreground surface.
-        SCOPED_TRACE("after show");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerSetAlphaWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before setAlpha");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(0.75f));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should set foreground to be 75% opaque.
-        SCOPED_TRACE("after setAlpha");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->checkPixel(75, 75, 162, 63, 96);
-        sc->expectBGColor(145, 145);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerSetLayerStackWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before setLayerStack");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setLayerStack(1));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should hide the foreground surface since it goes to a different
-        // layer stack.
-        SCOPED_TRACE("after setLayerStack");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerSetFlagsWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before setFlags");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setFlags(
-            layer_state_t::eLayerHidden, layer_state_t::eLayerHidden));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        // This should hide the foreground surface
-        SCOPED_TRACE("after setFlags");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectBGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerSetMatrixWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before setMatrix");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(91, 96);
-        sc->expectFGColor(96, 101);
-        sc->expectBGColor(145, 145);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setMatrix(M_SQRT1_2, M_SQRT1_2,
-            -M_SQRT1_2, M_SQRT1_2));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    {
-        SCOPED_TRACE("after setMatrix");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(91, 96);
-        sc->expectBGColor(96, 91);
-        sc->expectBGColor(145, 145);
-    }
-}
-
-class GeometryLatchingTest : public LayerUpdateTest {
-protected:
-    void EXPECT_INITIAL_STATE(const char * trace) {
-        SCOPED_TRACE(trace);
-        ScreenCapture::captureScreen(&sc);
-        // We find the leading edge of the FG surface.
-        sc->expectFGColor(127, 127);
-        sc->expectBGColor(128, 128);
-    }
-
-    void lockAndFillFGBuffer() {
-        fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63, false);
-    }
-
-    void unlockFGBuffer() {
-        sp<Surface> s = mFGSurfaceControl->getSurface();
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-        waitForPostedBuffers();
-    }
-
-    void completeFGResize() {
-        fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63);
-        waitForPostedBuffers();
-    }
-    void restoreInitialState() {
-        SurfaceComposerClient::openGlobalTransaction();
-        mFGSurfaceControl->setSize(64, 64);
-        mFGSurfaceControl->setPosition(64, 64);
-        mFGSurfaceControl->setCrop(Rect(0, 0, 64, 64));
-        mFGSurfaceControl->setFinalCrop(Rect(0, 0, -1, -1));
-        SurfaceComposerClient::closeGlobalTransaction(true);
-
-        EXPECT_INITIAL_STATE("After restoring initial state");
-    }
-    sp<ScreenCapture> sc;
-};
-
-TEST_F(GeometryLatchingTest, SurfacePositionLatching) {
-    EXPECT_INITIAL_STATE("before anything");
-
-    // By default position can be updated even while
-    // a resize is pending.
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(32, 32);
-    mFGSurfaceControl->setPosition(100, 100);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        SCOPED_TRACE("After moving surface");
-        ScreenCapture::captureScreen(&sc);
-        // If we moved, the FG Surface should cover up what was previously BG
-        // however if we didn't move the FG wouldn't be large enough now.
-        sc->expectFGColor(163, 163);
-    }
-
-    restoreInitialState();
-
-    // Now we repeat with setGeometryAppliesWithResize
-    // and verify the position DOESN'T latch.
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setGeometryAppliesWithResize();
-    mFGSurfaceControl->setSize(32, 32);
-    mFGSurfaceControl->setPosition(100, 100);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        SCOPED_TRACE("While resize is pending");
-        ScreenCapture::captureScreen(&sc);
-        // This time we shouldn't have moved, so the BG color
-        // should still be visible.
-        sc->expectBGColor(128, 128);
-    }
-
-    completeFGResize();
-
-    {
-        SCOPED_TRACE("After the resize");
-        ScreenCapture::captureScreen(&sc);
-        // But after the resize completes, we should move
-        // and the FG should be visible here.
-        sc->expectFGColor(128, 128);
-    }
-}
-
-class CropLatchingTest : public GeometryLatchingTest {
-protected:
-    void EXPECT_CROPPED_STATE(const char* trace) {
-        SCOPED_TRACE(trace);
-        ScreenCapture::captureScreen(&sc);
-        // The edge should be moved back one pixel by our crop.
-        sc->expectFGColor(126, 126);
-        sc->expectBGColor(127, 127);
-        sc->expectBGColor(128, 128);
-    }
-
-    void EXPECT_RESIZE_STATE(const char* trace) {
-        SCOPED_TRACE(trace);
-        ScreenCapture::captureScreen(&sc);
-        // The FG is now resized too 128,128 at 64,64
-        sc->expectFGColor(64, 64);
-        sc->expectFGColor(191, 191);
-        sc->expectBGColor(192, 192);
-    }
-};
-
-TEST_F(CropLatchingTest, CropLatching) {
-    EXPECT_INITIAL_STATE("before anything");
-    // Normally the crop applies immediately even while a resize is pending.
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(128, 128);
-    mFGSurfaceControl->setCrop(Rect(0, 0, 63, 63));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_CROPPED_STATE("after setting crop (without geometryAppliesWithResize)");
-
-    restoreInitialState();
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(128, 128);
-    mFGSurfaceControl->setGeometryAppliesWithResize();
-    mFGSurfaceControl->setCrop(Rect(0, 0, 63, 63));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_INITIAL_STATE("after setting crop (with geometryAppliesWithResize)");
-
-    completeFGResize();
-
-    EXPECT_CROPPED_STATE("after the resize finishes");
-}
-
-TEST_F(CropLatchingTest, FinalCropLatching) {
-    EXPECT_INITIAL_STATE("before anything");
-    // Normally the crop applies immediately even while a resize is pending.
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(128, 128);
-    mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_CROPPED_STATE("after setting crop (without geometryAppliesWithResize)");
-
-    restoreInitialState();
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(128, 128);
-    mFGSurfaceControl->setGeometryAppliesWithResize();
-    mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_INITIAL_STATE("after setting crop (with geometryAppliesWithResize)");
-
-    completeFGResize();
-
-    EXPECT_CROPPED_STATE("after the resize finishes");
-}
-
-// In this test we ensure that setGeometryAppliesWithResize actually demands
-// a buffer of the new size, and not just any size.
-TEST_F(CropLatchingTest, FinalCropLatchingBufferOldSize) {
-    EXPECT_INITIAL_STATE("before anything");
-    // Normally the crop applies immediately even while a resize is pending.
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(128, 128);
-    mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_CROPPED_STATE("after setting crop (without geometryAppliesWithResize)");
-
-    restoreInitialState();
-
-    // In order to prepare to submit a buffer at the wrong size, we acquire it prior to
-    // initiating the resize.
-    lockAndFillFGBuffer();
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(128, 128);
-    mFGSurfaceControl->setGeometryAppliesWithResize();
-    mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_INITIAL_STATE("after setting crop (with geometryAppliesWithResize)");
-
-    // We now submit our old buffer, at the old size, and ensure it doesn't
-    // trigger geometry latching.
-    unlockFGBuffer();
-
-    EXPECT_INITIAL_STATE("after unlocking FG buffer (with geometryAppliesWithResize)");
-
-    completeFGResize();
-
-    EXPECT_CROPPED_STATE("after the resize finishes");
-}
-
-TEST_F(CropLatchingTest, FinalCropLatchingRegressionForb37531386) {
-    EXPECT_INITIAL_STATE("before anything");
-    // In this scenario, we attempt to set the final crop a second time while the resize
-    // is still pending, and ensure we are successful. Success meaning the second crop
-    // is the one which eventually latches and not the first.
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setSize(128, 128);
-    mFGSurfaceControl->setGeometryAppliesWithResize();
-    mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_INITIAL_STATE("after setting crops with geometryAppliesWithResize");
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setFinalCrop(Rect(0, 0, -1, -1));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    EXPECT_INITIAL_STATE("after setting another crop");
-
-    completeFGResize();
-
-    EXPECT_RESIZE_STATE("after the resize finishes");
-}
-
-TEST_F(LayerUpdateTest, DeferredTransactionTest) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before anything");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->expectFGColor(96, 96);
-        sc->expectBGColor(160, 160);
-    }
-
-    // set up two deferred transactions on different frames
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(0.75));
-    mFGSurfaceControl->deferTransactionUntil(mSyncSurfaceControl->getHandle(),
-            mSyncSurfaceControl->getSurface()->getNextFrameNumber());
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(128,128));
-    mFGSurfaceControl->deferTransactionUntil(mSyncSurfaceControl->getHandle(),
-            mSyncSurfaceControl->getSurface()->getNextFrameNumber() + 1);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        SCOPED_TRACE("before any trigger");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->expectFGColor(96, 96);
-        sc->expectBGColor(160, 160);
-    }
-
-    // should trigger the first deferred transaction, but not the second one
-    fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-    {
-        SCOPED_TRACE("after first trigger");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->checkPixel(96, 96, 162, 63, 96);
-        sc->expectBGColor(160, 160);
-    }
-
-    // should show up immediately since it's not deferred
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(1.0));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    // trigger the second deferred transaction
-    fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31);
-    {
-        SCOPED_TRACE("after second trigger");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(32, 32);
-        sc->expectBGColor(96, 96);
-        sc->expectFGColor(160, 160);
-    }
-}
-
-TEST_F(LayerUpdateTest, LayerSetRelativeLayerWorks) {
-    sp<ScreenCapture> sc;
-    {
-        SCOPED_TRACE("before adding relative surface");
-        ScreenCapture::captureScreen(&sc);
-        sc->expectBGColor(24, 24);
-        sc->expectFGColor(75, 75);
-        sc->expectBGColor(145, 145);
-    }
-
-    auto relativeSurfaceControl = mComposerClient->createSurface(
-            String8("Test Surface"), 64, 64, PIXEL_FORMAT_RGBA_8888, 0);
-    fillSurfaceRGBA8(relativeSurfaceControl, 255, 177, 177);
-    waitForPostedBuffers();
-
-    // Now we stack the surface above the foreground surface and make sure it is visible.
-    SurfaceComposerClient::openGlobalTransaction();
-    relativeSurfaceControl->setPosition(64, 64);
-    relativeSurfaceControl->show();
-    relativeSurfaceControl->setRelativeLayer(mFGSurfaceControl->getHandle(), 1);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-
-    {
-        SCOPED_TRACE("after adding relative surface");
-        ScreenCapture::captureScreen(&sc);
-        // our relative surface should be visible now.
-        sc->checkPixel(75, 75, 255, 177, 177);
-    }
-
-    // A call to setLayer will override a call to setRelativeLayer
-    SurfaceComposerClient::openGlobalTransaction();
-    relativeSurfaceControl->setLayer(0);
-    SurfaceComposerClient::closeGlobalTransaction();
-
-    {
-        SCOPED_TRACE("after set layer");
-        ScreenCapture::captureScreen(&sc);
-        // now the FG surface should be visible again.
-        sc->expectFGColor(75, 75);
-    }
-}
-
-class ChildLayerTest : public LayerUpdateTest {
-protected:
-    void SetUp() override {
-        LayerUpdateTest::SetUp();
-        mChild = mComposerClient->createSurface(
-                String8("Child surface"),
-                10, 10, PIXEL_FORMAT_RGBA_8888,
-                0, mFGSurfaceControl.get());
-        fillSurfaceRGBA8(mChild, 200, 200, 200);
-
-        {
-            SCOPED_TRACE("before anything");
-            ScreenCapture::captureScreen(&mCapture);
-            mCapture->expectChildColor(64, 64);
-        }
-    }
-    void TearDown() override {
-        LayerUpdateTest::TearDown();
-        mChild = 0;
-    }
-
-    sp<SurfaceControl> mChild;
-    sp<ScreenCapture> mCapture;
-};
-
-TEST_F(ChildLayerTest, ChildLayerPositioning) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(10, 10);
-    mFGSurfaceControl->setPosition(64, 64);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(0, 0));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground should now be at 0, 0
-        mCapture->expectFGColor(0, 0);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(10, 10);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(20, 20);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerCropping) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(0, 0);
-    mFGSurfaceControl->setPosition(0, 0);
-    mFGSurfaceControl->setCrop(Rect(0, 0, 5, 5));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectChildColor(4, 4);
-        mCapture->expectBGColor(5, 5);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerFinalCropping) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(0, 0);
-    mFGSurfaceControl->setPosition(0, 0);
-    mFGSurfaceControl->setFinalCrop(Rect(0, 0, 5, 5));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectChildColor(4, 4);
-        mCapture->expectBGColor(5, 5);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerConstraints) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mFGSurfaceControl->setPosition(0, 0);
-    mChild->setPosition(63, 63);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(0, 0);
-        // Last pixel in foreground should now be the child.
-        mCapture->expectChildColor(63, 63);
-        // But the child should be constrained and the next pixel
-        // must be the background
-        mCapture->expectBGColor(64, 64);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerScaling) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setPosition(0, 0);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    // Find the boundary between the parent and child
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(9, 9);
-        mCapture->expectFGColor(10, 10);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setMatrix(2.0, 0, 0, 2.0);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    // The boundary should be twice as far from the origin now.
-    // The pixels from the last test should all be child now
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(9, 9);
-        mCapture->expectChildColor(10, 10);
-        mCapture->expectChildColor(19, 19);
-        mCapture->expectFGColor(20, 20);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildLayerAlpha) {
-    fillSurfaceRGBA8(mBGSurfaceControl, 0, 0, 254);
-    fillSurfaceRGBA8(mFGSurfaceControl, 254, 0, 0);
-    fillSurfaceRGBA8(mChild, 0, 254, 0);
-    waitForPostedBuffers();
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(0, 0);
-    mFGSurfaceControl->setPosition(0, 0);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Unblended child color
-        mCapture->checkPixel(0, 0, 0, 254, 0);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mChild->setAlpha(0.5));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Child and BG blended.
-        mCapture->checkPixel(0, 0, 127, 127, 0);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(0.5));
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Child and BG blended.
-        mCapture->checkPixel(0, 0, 95, 64, 95);
-    }
-}
-
-TEST_F(ChildLayerTest, ReparentChildren) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(10, 10);
-    mFGSurfaceControl->setPosition(64, 64);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-    mFGSurfaceControl->reparentChildren(mBGSurfaceControl->getHandle());
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(64, 64);
-        // In reparenting we should have exposed the entire foreground surface.
-        mCapture->expectFGColor(74, 74);
-        // And the child layer should now begin at 10, 10 (since the BG
-        // layer is at (0, 0)).
-        mCapture->expectBGColor(9, 9);
-        mCapture->expectChildColor(10, 10);
-    }
-}
-
-TEST_F(ChildLayerTest, DetachChildren) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(10, 10);
-    mFGSurfaceControl->setPosition(64, 64);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // Top left of foreground must now be visible
-        mCapture->expectFGColor(64, 64);
-        // But 10 pixels in we should see the child surface
-        mCapture->expectChildColor(74, 74);
-        // And 10 more pixels we should be back to the foreground surface
-        mCapture->expectFGColor(84, 84);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->detachChildren();
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->hide();
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    // Nothing should have changed.
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectFGColor(64, 64);
-        mCapture->expectChildColor(74, 74);
-        mCapture->expectFGColor(84, 84);
-    }
-}
-
-TEST_F(ChildLayerTest, ChildrenInheritNonTransformScalingFromParent) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(0, 0);
-    mFGSurfaceControl->setPosition(0, 0);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // We've positioned the child in the top left.
-        mCapture->expectChildColor(0, 0);
-        // But it's only 10x10.
-        mCapture->expectFGColor(10, 10);
-    }
-
-    SurfaceComposerClient::openGlobalTransaction();
-    mFGSurfaceControl->setOverrideScalingMode(NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
-    // We cause scaling by 2.
-    mFGSurfaceControl->setSize(128, 128);
-    SurfaceComposerClient::closeGlobalTransaction();
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // We've positioned the child in the top left.
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectChildColor(10, 10);
-        mCapture->expectChildColor(19, 19);
-        // And now it should be scaled all the way to 20x20
-        mCapture->expectFGColor(20, 20);
-    }
-}
-
-// Regression test for b/37673612
-TEST_F(ChildLayerTest, ChildrenWithParentBufferTransform) {
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->show();
-    mChild->setPosition(0, 0);
-    mFGSurfaceControl->setPosition(0, 0);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    {
-        ScreenCapture::captureScreen(&mCapture);
-        // We've positioned the child in the top left.
-        mCapture->expectChildColor(0, 0);
-        // But it's only 10x10.
-        mCapture->expectFGColor(10, 10);
-    }
-
-
-    // We set things up as in b/37673612 so that there is a mismatch between the buffer size and
-    // the WM specified state size.
-    mFGSurfaceControl->setSize(128, 64);
-    sp<Surface> s = mFGSurfaceControl->getSurface();
-    auto anw = static_cast<ANativeWindow*>(s.get());
-    native_window_set_buffers_transform(anw, NATIVE_WINDOW_TRANSFORM_ROT_90);
-    native_window_set_buffers_dimensions(anw, 64, 128);
-    fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63);
-    waitForPostedBuffers();
-
-    {
-        // The child should still be in the same place and not have any strange scaling as in
-        // b/37673612.
-        ScreenCapture::captureScreen(&mCapture);
-        mCapture->expectChildColor(0, 0);
-        mCapture->expectFGColor(10, 10);
-    }
-}
-
-TEST_F(ChildLayerTest, Bug36858924) {
-    // Destroy the child layer
-    mChild.clear();
-
-    // Now recreate it as hidden
-    mChild = mComposerClient->createSurface(String8("Child surface"), 10, 10,
-                                            PIXEL_FORMAT_RGBA_8888, ISurfaceComposerClient::eHidden,
-                                            mFGSurfaceControl.get());
-
-    // Show the child layer in a deferred transaction
-    SurfaceComposerClient::openGlobalTransaction();
-    mChild->deferTransactionUntil(mFGSurfaceControl->getHandle(),
-                                  mFGSurfaceControl->getSurface()->getNextFrameNumber());
-    mChild->show();
-    SurfaceComposerClient::closeGlobalTransaction(true);
-
-    // Render the foreground surface a few times
-    //
-    // Prior to the bugfix for b/36858924, this would usually hang while trying to fill the third
-    // frame because SurfaceFlinger would never process the deferred transaction and would therefore
-    // never acquire/release the first buffer
-    ALOGI("Filling 1");
-    fillSurfaceRGBA8(mFGSurfaceControl, 0, 255, 0);
-    ALOGI("Filling 2");
-    fillSurfaceRGBA8(mFGSurfaceControl, 0, 0, 255);
-    ALOGI("Filling 3");
-    fillSurfaceRGBA8(mFGSurfaceControl, 255, 0, 0);
-    ALOGI("Filling 4");
-    fillSurfaceRGBA8(mFGSurfaceControl, 0, 255, 0);
-}
-
-}
diff --git a/services/surfaceflinger/tests/fakehwc/Android.bp b/services/surfaceflinger/tests/fakehwc/Android.bp
deleted file mode 100644
index f4a9b99298..0000000000
--- a/services/surfaceflinger/tests/fakehwc/Android.bp
+++ /dev/null
@@ -1,34 +0,0 @@
-cc_test {
-    name: "sffakehwc_test",
-    srcs: [
-         "FakeComposerClient.cpp",
-         "FakeComposerService.cpp",
-         "FakeComposerUtils.cpp",
-         "SFFakeHwc_test.cpp"
-    ],
-    shared_libs: [
-        "libcutils",
-        "libutils",
-        "libbinder",
-        "libui",
-        "libgui",
-        "liblog",
-        "libnativewindow",
-        "android.hardware.graphics.composer@2.1",
-        "android.hardware.graphics.mapper@2.0",
-        "libhwbinder",
-        "libhardware",
-        "libhidlbase",
-        "libsync",
-        "libfmq",
-        "libbase",
-        "libhidltransport"
-    ],
-    static_libs: [
-        "libhwcomposer-client",
-        "libsurfaceflingerincludes",
-        "libtrace_proto",
-        "libgmock"
-    ],
-    test_suites: ["device-tests"]
-}
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp b/services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp
deleted file mode 100644
index 07b8cc0b0d..0000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.cpp
+++ /dev/null
@@ -1,617 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//#define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeComposer"
-
-#include "FakeComposerClient.h"
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <log/log.h>
-
-#include <gtest/gtest.h>
-
-#include <inttypes.h>
-#include <time.h>
-#include <algorithm>
-#include <condition_variable>
-#include <iostream>
-#include <mutex>
-#include <set>
-#include <thread>
-
-constexpr Config NULL_DISPLAY_CONFIG = static_cast<Config>(0);
-constexpr Display DEFAULT_DISPLAY = static_cast<Display>(1);
-
-using namespace sftest;
-
-using android::Condition;
-using android::Mutex;
-
-using Clock = std::chrono::steady_clock;
-using TimePoint = std::chrono::time_point<Clock>;
-
-namespace {
-
-// Internal state of a layer in the HWC API.
-class LayerImpl {
-public:
-    LayerImpl() = default;
-
-    bool mValid = true;
-    RenderState mRenderState;
-    uint32_t mZ = 0;
-};
-
-// Struct for storing per frame rectangle state. Contains the render
-// state shared to the test case. Basically a snapshot and a subset of
-// LayerImpl sufficient to re-create the pixels of a layer for the
-// frame.
-struct FrameRect {
-public:
-    FrameRect(Layer layer_, const RenderState& state, uint32_t z_)
-          : layer(layer_), renderState(state), z(z_) {}
-
-    const Layer layer;
-    const RenderState renderState;
-    const uint32_t z;
-};
-
-// Collection of FrameRects forming one rendered frame. Could store
-// related fences and other data in the future.
-class Frame {
-public:
-    Frame() = default;
-    std::vector<std::unique_ptr<FrameRect>> rectangles;
-};
-
-class DelayedEventGenerator {
-public:
-    DelayedEventGenerator(std::function<void()> onTimerExpired)
-          : mOnTimerExpired(onTimerExpired), mThread([this]() { loop(); }) {}
-
-    ~DelayedEventGenerator() {
-        ALOGI("DelayedEventGenerator exiting.");
-        {
-            std::unique_lock<std::mutex> lock(mMutex);
-            mRunning = false;
-            mWakeups.clear();
-            mCondition.notify_one();
-        }
-        mThread.join();
-        ALOGI("DelayedEventGenerator exited.");
-    }
-
-    void wakeAfter(std::chrono::nanoseconds waitTime) {
-        std::unique_lock<std::mutex> lock(mMutex);
-        mWakeups.insert(Clock::now() + waitTime);
-        mCondition.notify_one();
-    }
-
-private:
-    void loop() {
-        while (true) {
-            // Lock scope
-            {
-                std::unique_lock<std::mutex> lock(mMutex);
-                mCondition.wait(lock, [this]() { return !mRunning || !mWakeups.empty(); });
-                if (!mRunning && mWakeups.empty()) {
-                    // This thread should only exit once the destructor has been called and all
-                    // wakeups have been processed
-                    return;
-                }
-
-                // At this point, mWakeups will not be empty
-
-                TimePoint target = *(mWakeups.begin());
-                auto status = mCondition.wait_until(lock, target);
-                while (status == std::cv_status::no_timeout) {
-                    // This was either a spurious wakeup or another wakeup was added, so grab the
-                    // oldest point and wait again
-                    target = *(mWakeups.begin());
-                    status = mCondition.wait_until(lock, target);
-                }
-
-                // status must have been timeout, so we can finally clear this point
-                mWakeups.erase(target);
-            }
-            // Callback *without* locks!
-            mOnTimerExpired();
-        }
-    }
-
-    std::function<void()> mOnTimerExpired;
-    std::thread mThread;
-    std::mutex mMutex;
-    std::condition_variable mCondition;
-    bool mRunning = true;
-    std::set<TimePoint> mWakeups;
-};
-
-} // namespace
-
-FakeComposerClient::FakeComposerClient()
-      : mCallbacksOn(false),
-        mClient(nullptr),
-        mCurrentConfig(NULL_DISPLAY_CONFIG),
-        mVsyncEnabled(false),
-        mLayers(),
-        mDelayedEventGenerator(
-                std::make_unique<DelayedEventGenerator>([this]() { this->requestVSync(); })),
-        mSurfaceComposer(nullptr) {}
-
-FakeComposerClient::~FakeComposerClient() {}
-
-bool FakeComposerClient::hasCapability(hwc2_capability_t /*capability*/) {
-    return false;
-}
-
-void FakeComposerClient::removeClient() {
-    ALOGV("removeClient");
-    // TODO: Ahooga! Only thing current lifetime management choices in
-    // APIs make possible. Sad.
-    delete this;
-}
-
-void FakeComposerClient::enableCallback(bool enable) {
-    ALOGV("enableCallback");
-    mCallbacksOn = enable;
-    if (mCallbacksOn) {
-        mClient->onHotplug(DEFAULT_DISPLAY, IComposerCallback::Connection::CONNECTED);
-    }
-}
-
-void FakeComposerClient::hotplugDisplay(Display display, IComposerCallback::Connection state) {
-    if (mCallbacksOn) {
-        mClient->onHotplug(display, state);
-    }
-}
-
-uint32_t FakeComposerClient::getMaxVirtualDisplayCount() {
-    ALOGV("getMaxVirtualDisplayCount");
-    return 1;
-}
-
-Error FakeComposerClient::createVirtualDisplay(uint32_t /*width*/, uint32_t /*height*/,
-                                               PixelFormat* /*format*/, Display* /*outDisplay*/) {
-    ALOGV("createVirtualDisplay");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::destroyVirtualDisplay(Display /*display*/) {
-    ALOGV("destroyVirtualDisplay");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::createLayer(Display /*display*/, Layer* outLayer) {
-    ALOGV("createLayer");
-    *outLayer = mLayers.size();
-    auto newLayer = std::make_unique<LayerImpl>();
-    mLayers.push_back(std::move(newLayer));
-    return Error::NONE;
-}
-
-Error FakeComposerClient::destroyLayer(Display /*display*/, Layer layer) {
-    ALOGV("destroyLayer");
-    mLayers[layer]->mValid = false;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getActiveConfig(Display /*display*/, Config* outConfig) {
-    ALOGV("getActiveConfig");
-
-    // TODO Assert outConfig != nullptr
-
-    // TODO This is my reading of the
-    // IComposerClient::getActiveConfig, but returning BAD_CONFIG
-    // seems to not fit SurfaceFlinger plans. See version 2 below.
-    // if (mCurrentConfig == NULL_DISPLAY_CONFIG) {
-    //     return Error::BAD_CONFIG;
-    // }
-    //*outConfig = mCurrentConfig;
-    *outConfig = 1; // Very special config for you my friend
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getClientTargetSupport(Display /*display*/, uint32_t /*width*/,
-                                                 uint32_t /*height*/, PixelFormat /*format*/,
-                                                 Dataspace /*dataspace*/) {
-    ALOGV("getClientTargetSupport");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getColorModes(Display /*display*/, hidl_vec<ColorMode>* /*outModes*/) {
-    ALOGV("getColorModes");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayAttribute(Display display, Config config,
-                                              IComposerClient::Attribute attribute,
-                                              int32_t* outValue) {
-    ALOGV("getDisplayAttribute (%d, %d, %d, %p)", static_cast<int>(display),
-          static_cast<int>(config), static_cast<int>(attribute), outValue);
-
-    // TODO: SOOO much fun to be had with these alone
-    switch (attribute) {
-        case IComposerClient::Attribute::WIDTH:
-            *outValue = 1920;
-            break;
-        case IComposerClient::Attribute::HEIGHT:
-            *outValue = 1080;
-            break;
-        case IComposerClient::Attribute::VSYNC_PERIOD:
-            *outValue = 1666666666;
-            break; // TOOD: Tests break down if lowered to 16ms?
-        case IComposerClient::Attribute::DPI_X:
-            *outValue = 240;
-            break;
-        case IComposerClient::Attribute::DPI_Y:
-            *outValue = 240;
-            break;
-        default:
-            LOG_ALWAYS_FATAL("Say what!?! New attribute");
-    }
-
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayConfigs(Display /*display*/, hidl_vec<Config>* outConfigs) {
-    ALOGV("getDisplayConfigs");
-    // TODO assert display == 1, outConfigs != nullptr
-
-    outConfigs->resize(1);
-    (*outConfigs)[0] = 1;
-
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayName(Display /*display*/, hidl_string* /*outName*/) {
-    ALOGV("getDisplayName");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDisplayType(Display /*display*/,
-                                         IComposerClient::DisplayType* outType) {
-    ALOGV("getDisplayType");
-    // TODO: This setting nothing on the output had no effect on initial trials. Is first display
-    // assumed to be physical?
-    *outType = static_cast<IComposerClient::DisplayType>(HWC2_DISPLAY_TYPE_PHYSICAL);
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getDozeSupport(Display /*display*/, bool* /*outSupport*/) {
-    ALOGV("getDozeSupport");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::getHdrCapabilities(Display /*display*/, hidl_vec<Hdr>* /*outTypes*/,
-                                             float* /*outMaxLuminance*/,
-                                             float* /*outMaxAverageLuminance*/,
-                                             float* /*outMinLuminance*/) {
-    ALOGV("getHdrCapabilities");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setActiveConfig(Display /*display*/, Config config) {
-    ALOGV("setActiveConfig");
-    mCurrentConfig = config;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setColorMode(Display /*display*/, ColorMode /*mode*/) {
-    ALOGV("setColorMode");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setPowerMode(Display /*display*/, IComposerClient::PowerMode /*mode*/) {
-    ALOGV("setPowerMode");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setVsyncEnabled(Display /*display*/, IComposerClient::Vsync enabled) {
-    mVsyncEnabled = (enabled == IComposerClient::Vsync::ENABLE);
-    ALOGV("setVsyncEnabled(%s)", mVsyncEnabled ? "ENABLE" : "DISABLE");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setColorTransform(Display /*display*/, const float* /*matrix*/,
-                                            int32_t /*hint*/) {
-    ALOGV("setColorTransform");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setClientTarget(Display /*display*/, buffer_handle_t /*target*/,
-                                          int32_t /*acquireFence*/, int32_t /*dataspace*/,
-                                          const std::vector<hwc_rect_t>& /*damage*/) {
-    ALOGV("setClientTarget");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setOutputBuffer(Display /*display*/, buffer_handle_t /*buffer*/,
-                                          int32_t /*releaseFence*/) {
-    ALOGV("setOutputBuffer");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::validateDisplay(
-        Display /*display*/, std::vector<Layer>* /*outChangedLayers*/,
-        std::vector<IComposerClient::Composition>* /*outCompositionTypes*/,
-        uint32_t* /*outDisplayRequestMask*/, std::vector<Layer>* /*outRequestedLayers*/,
-        std::vector<uint32_t>* /*outRequestMasks*/) {
-    ALOGV("validateDisplay");
-    // TODO: Assume touching nothing means All Korrekt!
-    return Error::NONE;
-}
-
-Error FakeComposerClient::acceptDisplayChanges(Display /*display*/) {
-    ALOGV("acceptDisplayChanges");
-    // Didn't ask for changes because software is omnipotent.
-    return Error::NONE;
-}
-
-bool layerZOrdering(const std::unique_ptr<FrameRect>& a, const std::unique_ptr<FrameRect>& b) {
-    return a->z <= b->z;
-}
-
-Error FakeComposerClient::presentDisplay(Display /*display*/, int32_t* /*outPresentFence*/,
-                                         std::vector<Layer>* /*outLayers*/,
-                                         std::vector<int32_t>* /*outReleaseFences*/) {
-    ALOGV("presentDisplay");
-    // TODO Leaving layers and their fences out for now. Doing so
-    // means that we've already processed everything. Important to
-    // test that the fences are respected, though. (How?)
-
-    std::unique_ptr<Frame> newFrame(new Frame);
-    for (uint64_t layer = 0; layer < mLayers.size(); layer++) {
-        const LayerImpl& layerImpl = *mLayers[layer];
-
-        if (!layerImpl.mValid) continue;
-
-        auto rect = std::make_unique<FrameRect>(layer, layerImpl.mRenderState, layerImpl.mZ);
-        newFrame->rectangles.push_back(std::move(rect));
-    }
-    std::sort(newFrame->rectangles.begin(), newFrame->rectangles.end(), layerZOrdering);
-    {
-        Mutex::Autolock _l(mStateMutex);
-        mFrames.push_back(std::move(newFrame));
-        mFramesAvailable.broadcast();
-    }
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerCursorPosition(Display /*display*/, Layer /*layer*/,
-                                                 int32_t /*x*/, int32_t /*y*/) {
-    ALOGV("setLayerCursorPosition");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerBuffer(Display /*display*/, Layer layer, buffer_handle_t buffer,
-                                         int32_t acquireFence) {
-    ALOGV("setLayerBuffer");
-    LayerImpl& l = getLayerImpl(layer);
-    if (buffer != l.mRenderState.mBuffer) {
-        l.mRenderState.mSwapCount++; // TODO: Is setting to same value a swap or not?
-    }
-    l.mRenderState.mBuffer = buffer;
-    l.mRenderState.mAcquireFence = acquireFence;
-
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerSurfaceDamage(Display /*display*/, Layer /*layer*/,
-                                                const std::vector<hwc_rect_t>& /*damage*/) {
-    ALOGV("setLayerSurfaceDamage");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerBlendMode(Display /*display*/, Layer layer, int32_t mode) {
-    ALOGV("setLayerBlendMode");
-    getLayerImpl(layer).mRenderState.mBlendMode = static_cast<hwc2_blend_mode_t>(mode);
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerColor(Display /*display*/, Layer layer,
-                                        IComposerClient::Color color) {
-    ALOGV("setLayerColor");
-    getLayerImpl(layer).mRenderState.mLayerColor.r = color.r;
-    getLayerImpl(layer).mRenderState.mLayerColor.g = color.g;
-    getLayerImpl(layer).mRenderState.mLayerColor.b = color.b;
-    getLayerImpl(layer).mRenderState.mLayerColor.a = color.a;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerCompositionType(Display /*display*/, Layer /*layer*/,
-                                                  int32_t /*type*/) {
-    ALOGV("setLayerCompositionType");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerDataspace(Display /*display*/, Layer /*layer*/,
-                                            int32_t /*dataspace*/) {
-    ALOGV("setLayerDataspace");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerDisplayFrame(Display /*display*/, Layer layer,
-                                               const hwc_rect_t& frame) {
-    ALOGV("setLayerDisplayFrame (%d, %d, %d, %d)", frame.left, frame.top, frame.right,
-          frame.bottom);
-    getLayerImpl(layer).mRenderState.mDisplayFrame = frame;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerPlaneAlpha(Display /*display*/, Layer layer, float alpha) {
-    ALOGV("setLayerPlaneAlpha");
-    getLayerImpl(layer).mRenderState.mPlaneAlpha = alpha;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerSidebandStream(Display /*display*/, Layer /*layer*/,
-                                                 buffer_handle_t /*stream*/) {
-    ALOGV("setLayerSidebandStream");
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerSourceCrop(Display /*display*/, Layer layer,
-                                             const hwc_frect_t& crop) {
-    ALOGV("setLayerSourceCrop");
-    getLayerImpl(layer).mRenderState.mSourceCrop = crop;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerTransform(Display /*display*/, Layer layer, int32_t transform) {
-    ALOGV("setLayerTransform");
-    getLayerImpl(layer).mRenderState.mTransform = static_cast<hwc_transform_t>(transform);
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerVisibleRegion(Display /*display*/, Layer layer,
-                                                const std::vector<hwc_rect_t>& visible) {
-    ALOGV("setLayerVisibleRegion");
-    getLayerImpl(layer).mRenderState.mVisibleRegion = visible;
-    return Error::NONE;
-}
-
-Error FakeComposerClient::setLayerZOrder(Display /*display*/, Layer layer, uint32_t z) {
-    ALOGV("setLayerZOrder");
-    getLayerImpl(layer).mZ = z;
-    return Error::NONE;
-}
-
-//////////////////////////////////////////////////////////////////
-
-void FakeComposerClient::setClient(ComposerClient* client) {
-    mClient = client;
-}
-
-void FakeComposerClient::requestVSync(uint64_t vsyncTime) {
-    if (mCallbacksOn) {
-        uint64_t timestamp = vsyncTime;
-        ALOGV("Vsync");
-        if (timestamp == 0) {
-            struct timespec ts;
-            clock_gettime(CLOCK_MONOTONIC, &ts);
-            timestamp = ts.tv_sec * 1000 * 1000 * 1000 + ts.tv_nsec;
-        }
-        if (mSurfaceComposer != nullptr) {
-            mSurfaceComposer->injectVSync(timestamp);
-        } else {
-            mClient->onVsync(DEFAULT_DISPLAY, timestamp);
-        }
-    }
-}
-
-void FakeComposerClient::runVSyncAfter(std::chrono::nanoseconds wait) {
-    mDelayedEventGenerator->wakeAfter(wait);
-}
-
-LayerImpl& FakeComposerClient::getLayerImpl(Layer handle) {
-    // TODO Change these to an internal state check that can be
-    // invoked from the gtest? GTest macros do not seem all that safe
-    // when used outside the test class
-    EXPECT_GE(handle, static_cast<Layer>(0));
-    EXPECT_LT(handle, mLayers.size());
-    return *(mLayers[handle]);
-}
-
-int FakeComposerClient::getFrameCount() const {
-    return mFrames.size();
-}
-
-static std::vector<RenderState> extractRenderState(
-        const std::vector<std::unique_ptr<FrameRect>>& internalRects) {
-    std::vector<RenderState> result;
-    result.reserve(internalRects.size());
-    for (const std::unique_ptr<FrameRect>& rect : internalRects) {
-        result.push_back(rect->renderState);
-    }
-    return result;
-}
-
-std::vector<RenderState> FakeComposerClient::getFrameRects(int frame) const {
-    Mutex::Autolock _l(mStateMutex);
-    return extractRenderState(mFrames[frame]->rectangles);
-}
-
-std::vector<RenderState> FakeComposerClient::getLatestFrame() const {
-    Mutex::Autolock _l(mStateMutex);
-    return extractRenderState(mFrames[mFrames.size() - 1]->rectangles);
-}
-
-void FakeComposerClient::runVSyncAndWait(std::chrono::nanoseconds maxWait) {
-    int currentFrame = 0;
-    {
-        Mutex::Autolock _l(mStateMutex); // I hope this is ok...
-        currentFrame = static_cast<int>(mFrames.size());
-        requestVSync();
-    }
-    waitUntilFrame(currentFrame + 1, maxWait);
-}
-
-void FakeComposerClient::waitUntilFrame(int targetFrame, std::chrono::nanoseconds maxWait) const {
-    Mutex::Autolock _l(mStateMutex);
-    while (mFrames.size() < static_cast<size_t>(targetFrame)) {
-        android::status_t result = mFramesAvailable.waitRelative(mStateMutex, maxWait.count());
-        if (result == android::TIMED_OUT) {
-            ALOGE("Waiting for frame %d (at frame %zu now) timed out after %lld ns", targetFrame,
-                  mFrames.size(), maxWait.count());
-            return;
-        }
-    }
-}
-
-void FakeComposerClient::clearFrames() {
-    Mutex::Autolock _l(mStateMutex);
-    mFrames.clear();
-    for (const std::unique_ptr<LayerImpl>& layer : mLayers) {
-        if (layer->mValid) {
-            layer->mRenderState.mSwapCount = 0;
-        }
-    }
-}
-
-void FakeComposerClient::onSurfaceFlingerStart() {
-    mSurfaceComposer = nullptr;
-    do {
-        mSurfaceComposer = new android::SurfaceComposerClient;
-        android::status_t initResult = mSurfaceComposer->initCheck();
-        if (initResult != android::NO_ERROR) {
-            ALOGD("Init result: %d", initResult);
-            mSurfaceComposer = nullptr;
-            std::this_thread::sleep_for(10ms);
-        }
-    } while (mSurfaceComposer == nullptr);
-    ALOGD("SurfaceComposerClient created");
-    mSurfaceComposer->enableVSyncInjections(true);
-}
-
-void FakeComposerClient::onSurfaceFlingerStop() {
-    mSurfaceComposer->dispose();
-    mSurfaceComposer.clear();
-}
-
-// Includes destroyed layers, stored in order of creation.
-int FakeComposerClient::getLayerCount() const {
-    return mLayers.size();
-}
-
-Layer FakeComposerClient::getLayer(size_t index) const {
-    // NOTE: If/when passing calls through to actual implementation,
-    // this might get more involving.
-    return static_cast<Layer>(index);
-}
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.h b/services/surfaceflinger/tests/fakehwc/FakeComposerClient.h
deleted file mode 100644
index dd384c0829..0000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerClient.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include "ComposerClient.h"
-#include "RenderState.h"
-
-#include <utils/Condition.h>
-
-#include <chrono>
-
-using namespace android::hardware::graphics::composer::V2_1;
-using namespace android::hardware::graphics::composer::V2_1::implementation;
-using namespace android::hardware;
-using namespace std::chrono_literals;
-
-namespace {
-class LayerImpl;
-class Frame;
-class DelayedEventGenerator;
-} // namespace
-
-namespace android {
-class SurfaceComposerClient;
-} // namespace android
-
-namespace sftest {
-
-class FakeComposerClient : public ComposerBase {
-public:
-    FakeComposerClient();
-    virtual ~FakeComposerClient();
-
-    bool hasCapability(hwc2_capability_t capability) override;
-
-    void removeClient() override;
-    void enableCallback(bool enable) override;
-    uint32_t getMaxVirtualDisplayCount() override;
-    Error createVirtualDisplay(uint32_t width, uint32_t height, PixelFormat* format,
-                               Display* outDisplay) override;
-    Error destroyVirtualDisplay(Display display) override;
-    Error createLayer(Display display, Layer* outLayer) override;
-    Error destroyLayer(Display display, Layer layer) override;
-
-    Error getActiveConfig(Display display, Config* outConfig) override;
-    Error getClientTargetSupport(Display display, uint32_t width, uint32_t height,
-                                 PixelFormat format, Dataspace dataspace) override;
-    Error getColorModes(Display display, hidl_vec<ColorMode>* outModes) override;
-    Error getDisplayAttribute(Display display, Config config, IComposerClient::Attribute attribute,
-                              int32_t* outValue) override;
-    Error getDisplayConfigs(Display display, hidl_vec<Config>* outConfigs) override;
-    Error getDisplayName(Display display, hidl_string* outName) override;
-    Error getDisplayType(Display display, IComposerClient::DisplayType* outType) override;
-    Error getDozeSupport(Display display, bool* outSupport) override;
-    Error getHdrCapabilities(Display display, hidl_vec<Hdr>* outTypes, float* outMaxLuminance,
-                             float* outMaxAverageLuminance, float* outMinLuminance) override;
-
-    Error setActiveConfig(Display display, Config config) override;
-    Error setColorMode(Display display, ColorMode mode) override;
-    Error setPowerMode(Display display, IComposerClient::PowerMode mode) override;
-    Error setVsyncEnabled(Display display, IComposerClient::Vsync enabled) override;
-
-    Error setColorTransform(Display display, const float* matrix, int32_t hint) override;
-    Error setClientTarget(Display display, buffer_handle_t target, int32_t acquireFence,
-                          int32_t dataspace, const std::vector<hwc_rect_t>& damage) override;
-    Error setOutputBuffer(Display display, buffer_handle_t buffer, int32_t releaseFence) override;
-    Error validateDisplay(Display display, std::vector<Layer>* outChangedLayers,
-                          std::vector<IComposerClient::Composition>* outCompositionTypes,
-                          uint32_t* outDisplayRequestMask, std::vector<Layer>* outRequestedLayers,
-                          std::vector<uint32_t>* outRequestMasks) override;
-    Error acceptDisplayChanges(Display display) override;
-    Error presentDisplay(Display display, int32_t* outPresentFence, std::vector<Layer>* outLayers,
-                         std::vector<int32_t>* outReleaseFences) override;
-
-    Error setLayerCursorPosition(Display display, Layer layer, int32_t x, int32_t y) override;
-    Error setLayerBuffer(Display display, Layer layer, buffer_handle_t buffer,
-                         int32_t acquireFence) override;
-    Error setLayerSurfaceDamage(Display display, Layer layer,
-                                const std::vector<hwc_rect_t>& damage) override;
-    Error setLayerBlendMode(Display display, Layer layer, int32_t mode) override;
-    Error setLayerColor(Display display, Layer layer, IComposerClient::Color color) override;
-    Error setLayerCompositionType(Display display, Layer layer, int32_t type) override;
-    Error setLayerDataspace(Display display, Layer layer, int32_t dataspace) override;
-    Error setLayerDisplayFrame(Display display, Layer layer, const hwc_rect_t& frame) override;
-    Error setLayerPlaneAlpha(Display display, Layer layer, float alpha) override;
-    Error setLayerSidebandStream(Display display, Layer layer, buffer_handle_t stream) override;
-    Error setLayerSourceCrop(Display display, Layer layer, const hwc_frect_t& crop) override;
-    Error setLayerTransform(Display display, Layer layer, int32_t transform) override;
-    Error setLayerVisibleRegion(Display display, Layer layer,
-                                const std::vector<hwc_rect_t>& visible) override;
-    Error setLayerZOrder(Display display, Layer layer, uint32_t z) override;
-
-    void setClient(ComposerClient* client);
-
-    void requestVSync(uint64_t vsyncTime = 0);
-    // We don't want tests hanging, so always use a timeout. Remember
-    // to always check the number of frames with test ASSERT_!
-    // Wait until next frame is rendered after requesting vsync.
-    void runVSyncAndWait(std::chrono::nanoseconds maxWait = 100ms);
-    void runVSyncAfter(std::chrono::nanoseconds wait);
-
-    int getFrameCount() const;
-    // We don't want tests hanging, so always use a timeout. Remember
-    // to always check the number of frames with test ASSERT_!
-    void waitUntilFrame(int targetFrame, std::chrono::nanoseconds maxWait = 100ms) const;
-    std::vector<RenderState> getFrameRects(int frame) const;
-    std::vector<RenderState> getLatestFrame() const;
-    void clearFrames();
-
-    void onSurfaceFlingerStart();
-    void onSurfaceFlingerStop();
-
-    int getLayerCount() const;
-    Layer getLayer(size_t index) const;
-
-    void hotplugDisplay(Display display, IComposerCallback::Connection state);
-
-private:
-    LayerImpl& getLayerImpl(Layer handle);
-
-    bool mCallbacksOn;
-    ComposerClient* mClient;
-    Config mCurrentConfig;
-    bool mVsyncEnabled;
-    std::vector<std::unique_ptr<LayerImpl>> mLayers;
-    std::vector<std::unique_ptr<Frame>> mFrames;
-    // Using a pointer to hide the implementation into the CPP file.
-    std::unique_ptr<DelayedEventGenerator> mDelayedEventGenerator;
-    android::sp<android::SurfaceComposerClient> mSurfaceComposer; // For VSync injections
-    mutable android::Mutex mStateMutex;
-    mutable android::Condition mFramesAvailable;
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp b/services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp
deleted file mode 100644
index c411604587..0000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerService.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeHwcService"
-#include <log/log.h>
-
-#include "FakeComposerService.h"
-
-using namespace android::hardware;
-
-namespace sftest {
-
-FakeComposerService::FakeComposerService(android::sp<ComposerClient>& client) : mClient(client) {}
-
-FakeComposerService::~FakeComposerService() {
-    ALOGI("Maybe killing client %p", mClient.get());
-    // Rely on sp to kill the client.
-}
-
-Return<void> FakeComposerService::getCapabilities(getCapabilities_cb hidl_cb) {
-    ALOGI("FakeComposerService::getCapabilities");
-    hidl_cb(hidl_vec<Capability>());
-    return Void();
-}
-
-Return<void> FakeComposerService::dumpDebugInfo(dumpDebugInfo_cb hidl_cb) {
-    ALOGI("FakeComposerService::dumpDebugInfo");
-    hidl_cb(hidl_string());
-    return Void();
-}
-
-Return<void> FakeComposerService::createClient(createClient_cb hidl_cb) {
-    ALOGI("FakeComposerService::createClient %p", mClient.get());
-    mClient->initialize();
-    hidl_cb(Error::NONE, mClient);
-    return Void();
-}
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerService.h b/services/surfaceflinger/tests/fakehwc/FakeComposerService.h
deleted file mode 100644
index 520408496f..0000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerService.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include "ComposerClient.h"
-
-using namespace android::hardware::graphics::composer::V2_1;
-using namespace android::hardware::graphics::composer::V2_1::implementation;
-using android::hardware::Return;
-
-namespace sftest {
-
-class FakeComposerService : public IComposer {
-public:
-    FakeComposerService(android::sp<ComposerClient>& client);
-    virtual ~FakeComposerService();
-
-    Return<void> getCapabilities(getCapabilities_cb hidl_cb) override;
-    Return<void> dumpDebugInfo(dumpDebugInfo_cb hidl_cb) override;
-    Return<void> createClient(createClient_cb hidl_cb) override;
-
-private:
-    android::sp<ComposerClient> mClient;
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp b/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp
deleted file mode 100644
index 51956ec970..0000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.cpp
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeHwcUtil"
-#include <log/log.h>
-
-#include "FakeComposerUtils.h"
-#include "RenderState.h"
-
-#include "SurfaceFlinger.h" // Get the name of the service...
-
-#include <binder/IServiceManager.h>
-
-#include <cutils/properties.h>
-
-#include <iomanip>
-#include <thread>
-
-using android::String16;
-using android::sp;
-using namespace std::chrono_literals;
-using namespace sftest;
-using std::setw;
-
-namespace sftest {
-
-// clang-format off
-inline void printSourceRectAligned(::std::ostream& os, const hwc_frect_t& sourceRect, int align) {
-    os << std::fixed << std::setprecision(1) << "("
-       << setw(align) << sourceRect.left << setw(0) << ","
-       << setw(align) << sourceRect.top << setw(0) << ","
-       << setw(align) << sourceRect.right << setw(0) << ","
-       << setw(align) << sourceRect.bottom << setw(0) << ")";
-}
-
-inline void printDisplayRectAligned(::std::ostream& os, const hwc_rect_t& displayRect, int align) {
-    os << "("
-       << setw(align) << displayRect.left << setw(0) << ","
-       << setw(align) << displayRect.top << setw(0) << ","
-       << setw(align) << displayRect.right << setw(0) << ","
-       << setw(align) << displayRect.bottom << setw(0) << ")";
-}
-// clang-format on
-
-inline ::std::ostream& operator<<(::std::ostream& os, const sftest::RenderState& state) {
-    printSourceRectAligned(os, state.mSourceCrop, 7);
-    os << "->";
-    printDisplayRectAligned(os, state.mDisplayFrame, 5);
-    return os << " Swaps:" << state.mSwapCount << " Alpha:" << std::setprecision(3)
-              << state.mPlaneAlpha << " Xform:" << state.mTransform;
-}
-
-// Helper for verifying the parts of the RenderState
-template <typename T>
-bool valuesMatch(::testing::AssertionResult& message, const T& ref, const T& val,
-                 const char* name) {
-    if (ref != val) {
-        message = message << "Expected " << name << ":" << ref << ", got:" << val << ".";
-        return false;
-    }
-    return true;
-}
-
-::testing::AssertionResult rectsAreSame(const RenderState& ref, const RenderState& val) {
-    // TODO: Message could start as success and be assigned as failure.
-    // Only problem is that utility assumes it to be failure and just adds stuff. Would
-    // need still special case the initial failure in the utility?
-    // TODO: ... or would it be possible to break this back to gtest primitives?
-    ::testing::AssertionResult message = ::testing::AssertionFailure();
-    bool passes = true;
-
-    // The work here is mostly about providing good log strings for differences
-    passes &= valuesMatch(message, ref.mDisplayFrame, val.mDisplayFrame, "display frame");
-    passes &= valuesMatch(message, ref.mPlaneAlpha, val.mPlaneAlpha, "alpha");
-    passes &= valuesMatch(message, ref.mSwapCount, val.mSwapCount, "swap count");
-    passes &= valuesMatch(message, ref.mSourceCrop, val.mSourceCrop, "source crop");
-    // ... add more
-    if (passes) {
-        return ::testing::AssertionSuccess();
-    }
-    return message;
-}
-
-::testing::AssertionResult framesAreSame(const std::vector<RenderState>& ref,
-                                         const std::vector<RenderState>& val) {
-    ::testing::AssertionResult message = ::testing::AssertionFailure();
-    bool passed = true;
-    if (ref.size() != val.size()) {
-        message << "Expected " << ref.size() << " rects, got " << val.size() << ".";
-        passed = false;
-    }
-    for (size_t rectIndex = 0; rectIndex < std::min(ref.size(), val.size()); rectIndex++) {
-        ::testing::AssertionResult rectResult = rectsAreSame(ref[rectIndex], val[rectIndex]);
-        if (rectResult == false) {
-            message << "First different rect at " << rectIndex << ": " << rectResult.message();
-            passed = false;
-            break;
-        }
-    }
-
-    if (passed) {
-        return ::testing::AssertionSuccess();
-    } else {
-        message << "\nReference:";
-        for (auto state = ref.begin(); state != ref.end(); ++state) {
-            message << "\n" << *state;
-        }
-        message << "\nActual:";
-        for (auto state = val.begin(); state != val.end(); ++state) {
-            message << "\n" << *state;
-        }
-    }
-    return message;
-}
-
-void startSurfaceFlinger() {
-    ALOGI("Start SurfaceFlinger");
-    system("start surfaceflinger");
-
-    sp<android::IServiceManager> sm(android::defaultServiceManager());
-    sp<android::IBinder> sf;
-    while (sf == nullptr) {
-        std::this_thread::sleep_for(10ms);
-        sf = sm->checkService(String16(android::SurfaceFlinger::getServiceName()));
-    }
-    ALOGV("SurfaceFlinger running");
-}
-
-void stopSurfaceFlinger() {
-    ALOGI("Stop SurfaceFlinger");
-    system("stop surfaceflinger");
-    sp<android::IServiceManager> sm(android::defaultServiceManager());
-    sp<android::IBinder> sf;
-    while (sf != nullptr) {
-        std::this_thread::sleep_for(10ms);
-        sf = sm->checkService(String16(android::SurfaceFlinger::getServiceName()));
-    }
-    ALOGV("SurfaceFlinger stopped");
-}
-
-////////////////////////////////////////////////
-
-void FakeHwcEnvironment::SetUp() {
-    ALOGI("Test env setup");
-    system("setenforce 0");
-    system("stop");
-    property_set("debug.sf.nobootanimation", "1");
-    {
-        char value[PROPERTY_VALUE_MAX];
-        property_get("debug.sf.nobootanimation", value, "0");
-        LOG_FATAL_IF(atoi(value) != 1, "boot skip not set");
-    }
-    // TODO: Try registering the mock as the default service instead.
-    property_set("debug.sf.hwc_service_name", "mock");
-    // This allows the SurfaceFlinger to load a HIDL service not listed in manifest files.
-    property_set("debug.sf.treble_testing_override", "true");
-}
-
-void FakeHwcEnvironment::TearDown() {
-    ALOGI("Test env tear down");
-    system("stop");
-    // Wait for mock call signaling teardown?
-    property_set("debug.sf.nobootanimation", "0");
-    property_set("debug.sf.hwc_service_name", "default");
-    ALOGI("Test env tear down - done");
-}
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h b/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h
deleted file mode 100644
index 74dc0e51bb..0000000000
--- a/services/surfaceflinger/tests/fakehwc/FakeComposerUtils.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include "FakeComposerClient.h"
-
-#include <gui/SurfaceComposerClient.h>
-
-#include <hardware/hwcomposer_defs.h>
-
-#include <log/log.h>
-
-#include <gtest/gtest.h>
-
-// clang-format off
-// Note: This needs to reside in the global namespace for the GTest to use it
-inline ::std::ostream& operator<<(::std::ostream& os, const hwc_rect_t& rect) {
-    return os << "(" << rect.left << ","
-              << rect.top << ","
-              << rect.right << ","
-              << rect.bottom << ")";
-}
-
-inline ::std::ostream& operator<<(::std::ostream& os, const hwc_frect_t& rect) {
-    return os << "(" << rect.left << ","
-              << rect.top << ","
-              << rect.right << ","
-              << rect.bottom << ")";
-}
-// clang-format on
-
-namespace sftest {
-
-class RenderState;
-
-// clang-format off
-inline bool operator==(const hwc_rect_t& a, const hwc_rect_t& b) {
-    return a.top == b.top &&
-            a.left == b.left &&
-            a.bottom == b.bottom &&
-            a.right == b.right;
-}
-
-inline bool operator==(const hwc_frect_t& a, const hwc_frect_t& b) {
-    return a.top == b.top &&
-            a.left == b.left &&
-            a.bottom == b.bottom &&
-            a.right == b.right;
-}
-// clang-format on
-
-inline bool operator!=(const hwc_rect_t& a, const hwc_rect_t& b) {
-    return !(a == b);
-}
-
-inline bool operator!=(const hwc_frect_t& a, const hwc_frect_t& b) {
-    return !(a == b);
-}
-
-::testing::AssertionResult rectsAreSame(const RenderState& ref, const RenderState& val);
-::testing::AssertionResult framesAreSame(const std::vector<RenderState>& ref,
-                                         const std::vector<RenderState>& val);
-
-void startSurfaceFlinger();
-void stopSurfaceFlinger();
-
-class FakeHwcEnvironment : public ::testing::Environment {
-public:
-    virtual ~FakeHwcEnvironment() {}
-    void SetUp() override;
-    void TearDown() override;
-};
-
-/*
- * All surface state changes are supposed to happen inside a global
- * transaction. GlobalTransactionScope object at the beginning of
- * scope automates the process. The resulting scope gives a visual cue
- * on the span of the transaction as well.
- *
- * Closing the transaction is synchronous, i.e., it waits for
- * SurfaceFlinger to composite one frame. Now, the FakeComposerClient
- * is built to explicitly request vsyncs one at the time. A delayed
- * request must be made before closing the transaction or the test
- * thread stalls until SurfaceFlinger does an emergency vsync by
- * itself. GlobalTransactionScope encapsulates this vsync magic.
- */
-class GlobalTransactionScope {
-public:
-    GlobalTransactionScope(FakeComposerClient& composer) : mComposer(composer) {
-        android::SurfaceComposerClient::openGlobalTransaction();
-    }
-    ~GlobalTransactionScope() {
-        int frameCount = mComposer.getFrameCount();
-        mComposer.runVSyncAfter(1ms);
-        android::SurfaceComposerClient::closeGlobalTransaction(true);
-        // Make sure that exactly one frame has been rendered.
-        mComposer.waitUntilFrame(frameCount + 1);
-        LOG_ALWAYS_FATAL_IF(frameCount + 1 != mComposer.getFrameCount(),
-                            "Unexpected frame advance. Delta: %d",
-                            mComposer.getFrameCount() - frameCount);
-    }
-    FakeComposerClient& mComposer;
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/RenderState.h b/services/surfaceflinger/tests/fakehwc/RenderState.h
deleted file mode 100644
index 0059289d4f..0000000000
--- a/services/surfaceflinger/tests/fakehwc/RenderState.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <hardware/hwcomposer2.h>
-
-#include <vector>
-
-namespace sftest {
-// Description of a rendered rectangle.  Should only contain
-// instructions necessary to rasterize the rectangle. The full scene
-// is given as a sorted list of rectangles, bottom layer at index 0.
-class RenderState {
-public:
-    RenderState() = default;
-    // Default copy-ctor
-
-    hwc_rect_t mDisplayFrame = {0, 0, 0, 0};
-    hwc_frect_t mSourceCrop = {0.f, 0.f, 0.f, 0.f};
-    std::vector<hwc_rect_t> mVisibleRegion;
-    hwc2_blend_mode_t mBlendMode = HWC2_BLEND_MODE_NONE;
-    buffer_handle_t mBuffer = 0;
-    uint32_t mSwapCount = 0;   // How many set buffer calls to the layer.
-    int32_t mAcquireFence = 0; // Probably should not be here.
-    float mPlaneAlpha = 0.f;
-    hwc_color_t mLayerColor = {0, 0, 0, 0};
-    hwc_transform_t mTransform = static_cast<hwc_transform_t>(0);
-};
-
-} // namespace sftest
diff --git a/services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp b/services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp
deleted file mode 100644
index 68fefea135..0000000000
--- a/services/surfaceflinger/tests/fakehwc/SFFakeHwc_test.cpp
+++ /dev/null
@@ -1,1306 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// #define LOG_NDEBUG 0
-#undef LOG_TAG
-#define LOG_TAG "FakeHwcTest"
-
-#include "FakeComposerClient.h"
-#include "FakeComposerService.h"
-#include "FakeComposerUtils.h"
-
-#include <gui/ISurfaceComposer.h>
-#include <gui/LayerDebugInfo.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-
-#include <private/gui/ComposerService.h>
-#include <private/gui/LayerState.h>
-
-#include <ui/DisplayInfo.h>
-
-#include <android/native_window.h>
-
-#include <android/hidl/manager/1.0/IServiceManager.h>
-
-#include <hwbinder/ProcessState.h>
-
-#include <binder/ProcessState.h>
-
-#include <log/log.h>
-
-#include <gmock/gmock.h>
-#include <gtest/gtest.h>
-
-#include <limits>
-
-using namespace std::chrono_literals;
-
-using namespace android;
-using namespace android::hardware;
-
-using namespace sftest;
-
-namespace {
-
-// Mock test helpers
-using ::testing::Invoke;
-using ::testing::Return;
-using ::testing::SetArgPointee;
-using ::testing::_;
-
-///////////////////////////////////////////////
-
-struct TestColor {
-public:
-    uint8_t r;
-    uint8_t g;
-    uint8_t b;
-    uint8_t a;
-};
-
-constexpr static TestColor RED = {195, 63, 63, 255};
-constexpr static TestColor LIGHT_RED = {255, 177, 177, 255};
-constexpr static TestColor GREEN = {63, 195, 63, 255};
-constexpr static TestColor BLUE = {63, 63, 195, 255};
-constexpr static TestColor DARK_GRAY = {63, 63, 63, 255};
-constexpr static TestColor LIGHT_GRAY = {200, 200, 200, 255};
-
-// Fill an RGBA_8888 formatted surface with a single color.
-static void fillSurfaceRGBA8(const sp<SurfaceControl>& sc, const TestColor& color,
-                             bool unlock = true) {
-    ANativeWindow_Buffer outBuffer;
-    sp<Surface> s = sc->getSurface();
-    ASSERT_TRUE(s != nullptr);
-    ASSERT_EQ(NO_ERROR, s->lock(&outBuffer, nullptr));
-    uint8_t* img = reinterpret_cast<uint8_t*>(outBuffer.bits);
-    for (int y = 0; y < outBuffer.height; y++) {
-        for (int x = 0; x < outBuffer.width; x++) {
-            uint8_t* pixel = img + (4 * (y * outBuffer.stride + x));
-            pixel[0] = color.r;
-            pixel[1] = color.g;
-            pixel[2] = color.b;
-            pixel[3] = color.a;
-        }
-    }
-    if (unlock) {
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-    }
-}
-
-inline RenderState makeSimpleRect(int left, int top, int right, int bottom) {
-    RenderState res;
-    res.mDisplayFrame = hwc_rect_t{left, top, right, bottom};
-    res.mPlaneAlpha = 1.0f;
-    res.mSwapCount = 0;
-    res.mSourceCrop = hwc_frect_t{0.f, 0.f, static_cast<float>(right - left),
-                                  static_cast<float>(bottom - top)};
-    return res;
-}
-
-inline RenderState makeSimpleRect(unsigned int left, unsigned int top, unsigned int right,
-                                  unsigned int bottom) {
-    EXPECT_LE(left, static_cast<unsigned int>(INT_MAX));
-    EXPECT_LE(top, static_cast<unsigned int>(INT_MAX));
-    EXPECT_LE(right, static_cast<unsigned int>(INT_MAX));
-    EXPECT_LE(bottom, static_cast<unsigned int>(INT_MAX));
-    return makeSimpleRect(static_cast<int>(left), static_cast<int>(top), static_cast<int>(right),
-                          static_cast<int>(bottom));
-}
-
-////////////////////////////////////////////////
-
-class DisplayTest : public ::testing::Test {
-public:
-    class MockComposerClient : public FakeComposerClient {
-    public:
-        MOCK_METHOD2(getDisplayType, Error(Display display, ComposerClient::DisplayType* outType));
-        MOCK_METHOD4(getDisplayAttribute,
-                     Error(Display display, Config config, IComposerClient::Attribute attribute,
-                           int32_t* outValue));
-
-        // Re-routing to basic fake implementation
-        Error getDisplayAttributeFake(Display display, Config config,
-                                      IComposerClient::Attribute attribute, int32_t* outValue) {
-            return FakeComposerClient::getDisplayAttribute(display, config, attribute, outValue);
-        }
-    };
-
-protected:
-    void SetUp() override;
-    void TearDown() override;
-
-    sp<IComposer> mFakeService;
-    sp<SurfaceComposerClient> mComposerClient;
-
-    MockComposerClient* mMockComposer;
-};
-
-void DisplayTest::SetUp() {
-    // TODO: The mMockComposer should be a unique_ptr, but it needs to
-    // outlive the test class.  Currently ComposerClient only dies
-    // when the service is replaced. The Mock deletes itself when
-    // removeClient is called on it, which is ugly.  This can be
-    // changed if HIDL ServiceManager allows removing services or
-    // ComposerClient starts taking the ownership of the contained
-    // implementation class. Moving the fake class to the HWC2
-    // interface instead of the current Composer interface might also
-    // change the situation.
-    mMockComposer = new MockComposerClient;
-    sp<ComposerClient> client = new ComposerClient(*mMockComposer);
-    mMockComposer->setClient(client.get());
-    mFakeService = new FakeComposerService(client);
-    (void)mFakeService->registerAsService("mock");
-
-    android::hardware::ProcessState::self()->startThreadPool();
-    android::ProcessState::self()->startThreadPool();
-
-    EXPECT_CALL(*mMockComposer, getDisplayType(1, _))
-            .WillOnce(DoAll(SetArgPointee<1>(IComposerClient::DisplayType::PHYSICAL),
-                            Return(Error::NONE)));
-    // Seems to be doubled right now, once for display ID 1 and once for 0. This sounds fishy
-    // but encoding that here exactly.
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(1, 1, _, _))
-            .Times(5)
-            .WillRepeatedly(Invoke(mMockComposer, &MockComposerClient::getDisplayAttributeFake));
-    // TODO: Find out what code is generating the ID 0.
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(0, 1, _, _))
-            .Times(5)
-            .WillRepeatedly(Invoke(mMockComposer, &MockComposerClient::getDisplayAttributeFake));
-
-    startSurfaceFlinger();
-
-    // Fake composer wants to enable VSync injection
-    mMockComposer->onSurfaceFlingerStart();
-
-    mComposerClient = new SurfaceComposerClient;
-    ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-}
-
-void DisplayTest::TearDown() {
-    mComposerClient->dispose();
-    mComposerClient = nullptr;
-
-    // Fake composer needs to release SurfaceComposerClient before the stop.
-    mMockComposer->onSurfaceFlingerStop();
-    stopSurfaceFlinger();
-
-    mFakeService = nullptr;
-    // TODO: Currently deleted in FakeComposerClient::removeClient(). Devise better lifetime
-    // management.
-    mMockComposer = nullptr;
-}
-
-TEST_F(DisplayTest, Hotplug) {
-    ALOGD("DisplayTest::Hotplug");
-
-    EXPECT_CALL(*mMockComposer, getDisplayType(2, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<1>(IComposerClient::DisplayType::PHYSICAL),
-                                  Return(Error::NONE)));
-    // The attribute queries will get done twice. This is for defaults
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(2, 1, _, _))
-            .Times(2 * 3)
-            .WillRepeatedly(Invoke(mMockComposer, &MockComposerClient::getDisplayAttributeFake));
-    // ... and then special handling for dimensions. Specifying this
-    // rules later means that gmock will try them first, i.e.,
-    // ordering of width/height vs. the default implementation for
-    // other queries is significant.
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(2, 1, IComposerClient::Attribute::WIDTH, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<3>(400), Return(Error::NONE)));
-
-    EXPECT_CALL(*mMockComposer, getDisplayAttribute(2, 1, IComposerClient::Attribute::HEIGHT, _))
-            .Times(2)
-            .WillRepeatedly(DoAll(SetArgPointee<3>(200), Return(Error::NONE)));
-
-    // TODO: Width and height queries are not actually called. Display
-    // info returns dimensions 0x0 in display info. Why?
-
-    mMockComposer->hotplugDisplay(static_cast<Display>(2),
-                                  IComposerCallback::Connection::CONNECTED);
-
-    {
-        sp<android::IBinder> display(
-                SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdHdmi));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-        ASSERT_EQ(400u, info.w);
-        ASSERT_EQ(200u, info.h);
-
-        auto surfaceControl =
-                mComposerClient->createSurface(String8("Display Test Surface Foo"), info.w, info.h,
-                                               PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(surfaceControl != nullptr);
-        ASSERT_TRUE(surfaceControl->isValid());
-        fillSurfaceRGBA8(surfaceControl, BLUE);
-
-        {
-            GlobalTransactionScope gts(*mMockComposer);
-            mComposerClient->setDisplayLayerStack(display, 0);
-
-            ASSERT_EQ(NO_ERROR, surfaceControl->setLayer(INT32_MAX - 2));
-            ASSERT_EQ(NO_ERROR, surfaceControl->show());
-        }
-    }
-
-    mMockComposer->hotplugDisplay(static_cast<Display>(2),
-                                  IComposerCallback::Connection::DISCONNECTED);
-
-    mMockComposer->clearFrames();
-
-    mMockComposer->hotplugDisplay(static_cast<Display>(2),
-                                  IComposerCallback::Connection::CONNECTED);
-
-    {
-        sp<android::IBinder> display(
-                SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdHdmi));
-        DisplayInfo info;
-        SurfaceComposerClient::getDisplayInfo(display, &info);
-        ASSERT_EQ(400u, info.w);
-        ASSERT_EQ(200u, info.h);
-
-        auto surfaceControl =
-                mComposerClient->createSurface(String8("Display Test Surface Bar"), info.w, info.h,
-                                               PIXEL_FORMAT_RGBA_8888, 0);
-        ASSERT_TRUE(surfaceControl != nullptr);
-        ASSERT_TRUE(surfaceControl->isValid());
-        fillSurfaceRGBA8(surfaceControl, BLUE);
-
-        {
-            GlobalTransactionScope gts(*mMockComposer);
-            mComposerClient->setDisplayLayerStack(display, 0);
-
-            ASSERT_EQ(NO_ERROR, surfaceControl->setLayer(INT32_MAX - 2));
-            ASSERT_EQ(NO_ERROR, surfaceControl->show());
-        }
-    }
-    mMockComposer->hotplugDisplay(static_cast<Display>(2),
-                                  IComposerCallback::Connection::DISCONNECTED);
-}
-
-////////////////////////////////////////////////
-
-class TransactionTest : public ::testing::Test {
-protected:
-    // Layer array indexing constants.
-    constexpr static int BG_LAYER = 0;
-    constexpr static int FG_LAYER = 1;
-
-    static void SetUpTestCase();
-    static void TearDownTestCase();
-
-    void SetUp() override;
-    void TearDown() override;
-
-    sp<SurfaceComposerClient> mComposerClient;
-    sp<SurfaceControl> mBGSurfaceControl;
-    sp<SurfaceControl> mFGSurfaceControl;
-    std::vector<RenderState> mBaseFrame;
-    uint32_t mDisplayWidth;
-    uint32_t mDisplayHeight;
-
-    static FakeComposerClient* sFakeComposer;
-};
-
-FakeComposerClient* TransactionTest::sFakeComposer;
-
-void TransactionTest::SetUpTestCase() {
-    // TODO: See TODO comment at DisplayTest::SetUp for background on
-    // the lifetime of the FakeComposerClient.
-    sFakeComposer = new FakeComposerClient;
-    sp<ComposerClient> client = new ComposerClient(*sFakeComposer);
-    sFakeComposer->setClient(client.get());
-    sp<IComposer> fakeService = new FakeComposerService(client);
-    (void)fakeService->registerAsService("mock");
-
-    android::hardware::ProcessState::self()->startThreadPool();
-    android::ProcessState::self()->startThreadPool();
-
-    startSurfaceFlinger();
-
-    // Fake composer wants to enable VSync injection
-    sFakeComposer->onSurfaceFlingerStart();
-}
-
-void TransactionTest::TearDownTestCase() {
-    // Fake composer needs to release SurfaceComposerClient before the stop.
-    sFakeComposer->onSurfaceFlingerStop();
-    stopSurfaceFlinger();
-    // TODO: This is deleted when the ComposerClient calls
-    // removeClient. Devise better lifetime control.
-    sFakeComposer = nullptr;
-}
-
-void TransactionTest::SetUp() {
-    ALOGI("TransactionTest::SetUp");
-    mComposerClient = new SurfaceComposerClient;
-    ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-    ALOGI("TransactionTest::SetUp - display");
-    sp<android::IBinder> display(
-            SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
-    DisplayInfo info;
-    SurfaceComposerClient::getDisplayInfo(display, &info);
-
-    mDisplayWidth = info.w;
-    mDisplayHeight = info.h;
-
-    // Background surface
-    mBGSurfaceControl = mComposerClient->createSurface(String8("BG Test Surface"), mDisplayWidth,
-                                                       mDisplayHeight, PIXEL_FORMAT_RGBA_8888, 0);
-    ASSERT_TRUE(mBGSurfaceControl != nullptr);
-    ASSERT_TRUE(mBGSurfaceControl->isValid());
-    fillSurfaceRGBA8(mBGSurfaceControl, BLUE);
-
-    // Foreground surface
-    mFGSurfaceControl = mComposerClient->createSurface(String8("FG Test Surface"), 64, 64,
-                                                       PIXEL_FORMAT_RGBA_8888, 0);
-    ASSERT_TRUE(mFGSurfaceControl != nullptr);
-    ASSERT_TRUE(mFGSurfaceControl->isValid());
-
-    fillSurfaceRGBA8(mFGSurfaceControl, RED);
-
-    SurfaceComposerClient::openGlobalTransaction();
-
-    mComposerClient->setDisplayLayerStack(display, 0);
-
-    ASSERT_EQ(NO_ERROR, mBGSurfaceControl->setLayer(INT32_MAX - 2));
-    ASSERT_EQ(NO_ERROR, mBGSurfaceControl->show());
-
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setLayer(INT32_MAX - 1));
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(64, 64));
-    ASSERT_EQ(NO_ERROR, mFGSurfaceControl->show());
-
-    // Synchronous transaction will stop this thread, so we set up a
-    // delayed, off-thread vsync request before closing the
-    // transaction. In the test code this is usually done with
-    // GlobalTransactionScope. Leaving here in the 'vanilla' form for
-    // reference.
-    ASSERT_EQ(0, sFakeComposer->getFrameCount());
-    sFakeComposer->runVSyncAfter(1ms);
-    SurfaceComposerClient::closeGlobalTransaction(true);
-    sFakeComposer->waitUntilFrame(1);
-
-    // Reference data. This is what the HWC should see.
-    static_assert(BG_LAYER == 0 && FG_LAYER == 1, "Unexpected enum values for array indexing");
-    mBaseFrame.push_back(makeSimpleRect(0u, 0u, mDisplayWidth, mDisplayHeight));
-    mBaseFrame[BG_LAYER].mSwapCount = 1;
-    mBaseFrame.push_back(makeSimpleRect(64, 64, 64 + 64, 64 + 64));
-    mBaseFrame[FG_LAYER].mSwapCount = 1;
-
-    auto frame = sFakeComposer->getFrameRects(0);
-    ASSERT_TRUE(framesAreSame(mBaseFrame, frame));
-}
-
-void TransactionTest::TearDown() {
-    ALOGD("TransactionTest::TearDown");
-
-    mComposerClient->dispose();
-    mBGSurfaceControl = 0;
-    mFGSurfaceControl = 0;
-    mComposerClient = 0;
-
-    sFakeComposer->runVSyncAndWait();
-    mBaseFrame.clear();
-    sFakeComposer->clearFrames();
-    ASSERT_EQ(0, sFakeComposer->getFrameCount());
-
-    sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-    std::vector<LayerDebugInfo> layers;
-    status_t result = sf->getLayerDebugInfo(&layers);
-    if (result != NO_ERROR) {
-        ALOGE("Failed to get layers %s %d", strerror(-result), result);
-    } else {
-        // If this fails, the test being torn down leaked layers.
-        EXPECT_EQ(0u, layers.size());
-        if (layers.size() > 0) {
-            for (auto layer = layers.begin(); layer != layers.end(); ++layer) {
-                std::cout << to_string(*layer).c_str();
-            }
-            // To ensure the next test has clean slate, will run the class
-            // tear down and setup here.
-            TearDownTestCase();
-            SetUpTestCase();
-        }
-    }
-    ALOGD("TransactionTest::TearDown - complete");
-}
-
-TEST_F(TransactionTest, LayerMove) {
-    ALOGD("TransactionTest::LayerMove");
-
-    // The scope opens and closes a global transaction and, at the
-    // same time, makes sure the SurfaceFlinger progresses one frame
-    // after the transaction closes. The results of the transaction
-    // should be available in the latest frame stored by the fake
-    // composer.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(128, 128));
-        // NOTE: No changes yet, so vsync will do nothing, HWC does not get any calls.
-        // (How to verify that? Throw in vsync and wait a 2x frame time? Separate test?)
-        //
-        // sFakeComposer->runVSyncAndWait();
-    }
-
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-
-    ASSERT_EQ(3, sFakeComposer->getFrameCount()); // Make sure the waits didn't time out and there's
-                                                  // no extra frames.
-
-    // NOTE: Frame 0 is produced in the SetUp.
-    auto frame1Ref = mBaseFrame;
-    frame1Ref[FG_LAYER].mDisplayFrame =
-            hwc_rect_t{128, 128, 128 + 64, 128 + 64}; // Top-most layer moves.
-    EXPECT_TRUE(framesAreSame(frame1Ref, sFakeComposer->getFrameRects(1)));
-
-    auto frame2Ref = frame1Ref;
-    frame2Ref[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(frame2Ref, sFakeComposer->getFrameRects(2)));
-}
-
-TEST_F(TransactionTest, LayerResize) {
-    ALOGD("TransactionTest::LayerResize");
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setSize(128, 128));
-    }
-
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-
-    ASSERT_EQ(3, sFakeComposer->getFrameCount()); // Make sure the waits didn't time out and there's
-                                                  // no extra frames.
-
-    auto frame1Ref = mBaseFrame;
-    // NOTE: The resize should not be visible for frame 1 as there's no buffer with new size posted.
-    EXPECT_TRUE(framesAreSame(frame1Ref, sFakeComposer->getFrameRects(1)));
-
-    auto frame2Ref = frame1Ref;
-    frame2Ref[FG_LAYER].mSwapCount++;
-    frame2Ref[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 128, 64 + 128};
-    frame2Ref[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 128.f, 128.f};
-    EXPECT_TRUE(framesAreSame(frame2Ref, sFakeComposer->getFrameRects(2)));
-}
-
-TEST_F(TransactionTest, LayerCrop) {
-    // TODO: Add scaling to confirm that crop happens in buffer space?
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        Rect cropRect(16, 16, 32, 32);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setCrop(cropRect));
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{16.f, 16.f, 32.f, 32.f};
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64 + 16, 64 + 16, 64 + 32, 64 + 32};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerFinalCrop) {
-    // TODO: Add scaling to confirm that crop happens in display space?
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        Rect cropRect(32, 32, 32 + 64, 32 + 64);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setFinalCrop(cropRect));
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // In display space we are cropping with [32, 32, 96, 96] against display rect
-    // [64, 64, 128, 128]. Should yield display rect [64, 64, 96, 96]
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 32.f, 32.f};
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 32, 64 + 32};
-
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerFinalCropEmpty) {
-    // TODO: Add scaling to confirm that crop happens in display space?
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        Rect cropRect(16, 16, 32, 32);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setFinalCrop(cropRect));
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // In display space we are cropping with [16, 16, 32, 32] against display rect
-    // [64, 64, 128, 128]. The intersection is empty and only the background layer is composited.
-    std::vector<RenderState> referenceFrame(1);
-    referenceFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetLayer) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setLayer(INT_MAX - 3));
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // The layers will switch order, but both are rendered because the background layer is
-    // transparent (RGBA8888).
-    std::vector<RenderState> referenceFrame(2);
-    referenceFrame[0] = mBaseFrame[FG_LAYER];
-    referenceFrame[1] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetLayerOpaque) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setLayer(INT_MAX - 3));
-        ASSERT_EQ(NO_ERROR,
-                  mBGSurfaceControl->setFlags(layer_state_t::eLayerOpaque,
-                                              layer_state_t::eLayerOpaque));
-    }
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-
-    // The former foreground layer is now covered with opaque layer - it should have disappeared
-    std::vector<RenderState> referenceFrame(1);
-    referenceFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, SetLayerStack) {
-    ALOGD("TransactionTest::SetLayerStack");
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setLayerStack(1));
-    }
-
-    // Foreground layer should have disappeared.
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    std::vector<RenderState> refFrame(1);
-    refFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(refFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerShowHide) {
-    ALOGD("TransactionTest::LayerShowHide");
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->hide());
-    }
-
-    // Foreground layer should have disappeared.
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    std::vector<RenderState> refFrame(1);
-    refFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(refFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->show());
-    }
-
-    // Foreground layer should be back
-    ASSERT_EQ(3, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetAlpha) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(0.75f));
-    }
-
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mPlaneAlpha = 0.75f;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetFlags) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR,
-                  mFGSurfaceControl->setFlags(layer_state_t::eLayerHidden,
-                                              layer_state_t::eLayerHidden));
-    }
-
-    // Foreground layer should have disappeared.
-    ASSERT_EQ(2, sFakeComposer->getFrameCount());
-    std::vector<RenderState> refFrame(1);
-    refFrame[BG_LAYER] = mBaseFrame[BG_LAYER];
-    EXPECT_TRUE(framesAreSame(refFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, LayerSetMatrix) {
-    struct matrixTestData {
-        float matrix[4];
-        hwc_transform_t expectedTransform;
-        hwc_rect_t expectedDisplayFrame;
-    };
-
-    // The matrix operates on the display frame and is applied before
-    // the position is added. So, the foreground layer rect is (0, 0,
-    // 64, 64) is first transformed, potentially yielding negative
-    // coordinates and then the position (64, 64) is added yielding
-    // the final on-screen rectangles given.
-
-    const matrixTestData MATRIX_TESTS[7] = // clang-format off
-            {{{-1.f, 0.f, 0.f, 1.f},    HWC_TRANSFORM_FLIP_H,           {0, 64, 64, 128}},
-             {{1.f, 0.f, 0.f, -1.f},    HWC_TRANSFORM_FLIP_V,           {64, 0, 128, 64}},
-             {{0.f, 1.f, -1.f, 0.f},    HWC_TRANSFORM_ROT_90,           {0, 64, 64, 128}},
-             {{-1.f, 0.f, 0.f, -1.f},   HWC_TRANSFORM_ROT_180,          {0, 0, 64, 64}},
-             {{0.f, -1.f, 1.f, 0.f},    HWC_TRANSFORM_ROT_270,          {64, 0, 128, 64}},
-             {{0.f, 1.f, 1.f, 0.f},     HWC_TRANSFORM_FLIP_H_ROT_90,    {64, 64, 128, 128}},
-             {{0.f, 1.f, 1.f, 0.f},     HWC_TRANSFORM_FLIP_V_ROT_90,    {64, 64, 128, 128}}};
-    // clang-format on
-    constexpr int TEST_COUNT = sizeof(MATRIX_TESTS)/sizeof(matrixTestData);
-
-    for (int i = 0; i < TEST_COUNT; i++) {
-        // TODO: How to leverage the HWC2 stringifiers?
-        const matrixTestData& xform = MATRIX_TESTS[i];
-        SCOPED_TRACE(i);
-        {
-            GlobalTransactionScope gts(*sFakeComposer);
-            ASSERT_EQ(NO_ERROR,
-                      mFGSurfaceControl->setMatrix(xform.matrix[0], xform.matrix[1],
-                                                   xform.matrix[2], xform.matrix[3]));
-        }
-
-        auto referenceFrame = mBaseFrame;
-        referenceFrame[FG_LAYER].mTransform = xform.expectedTransform;
-        referenceFrame[FG_LAYER].mDisplayFrame = xform.expectedDisplayFrame;
-
-        EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-    }
-}
-
-#if 0
-TEST_F(TransactionTest, LayerSetMatrix2) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        // TODO: PLEASE SPEC THE FUNCTION!
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setMatrix(0.11f, 0.123f,
-                                                         -2.33f, 0.22f));
-    }
-    auto referenceFrame = mBaseFrame;
-    // TODO: Is this correct for sure?
-    //referenceFrame[FG_LAYER].mTransform = HWC_TRANSFORM_FLIP_V & HWC_TRANSFORM_ROT_90;
-
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-#endif
-
-TEST_F(TransactionTest, DeferredTransaction) {
-    // Synchronization surface
-    constexpr static int SYNC_LAYER = 2;
-    auto syncSurfaceControl = mComposerClient->createSurface(String8("Sync Test Surface"), 1, 1,
-                                                             PIXEL_FORMAT_RGBA_8888, 0);
-    ASSERT_TRUE(syncSurfaceControl != nullptr);
-    ASSERT_TRUE(syncSurfaceControl->isValid());
-
-    fillSurfaceRGBA8(syncSurfaceControl, DARK_GRAY);
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, syncSurfaceControl->setLayer(INT32_MAX - 1));
-        ASSERT_EQ(NO_ERROR, syncSurfaceControl->setPosition(mDisplayWidth - 2, mDisplayHeight - 2));
-        ASSERT_EQ(NO_ERROR, syncSurfaceControl->show());
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame.push_back(makeSimpleRect(mDisplayWidth - 2, mDisplayHeight - 2,
-                                            mDisplayWidth - 1, mDisplayHeight - 1));
-    referenceFrame[SYNC_LAYER].mSwapCount = 1;
-    EXPECT_EQ(2, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // set up two deferred transactions on different frames - these should not yield composited
-    // frames
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(0.75));
-        mFGSurfaceControl
-                ->deferTransactionUntil(syncSurfaceControl->getHandle(),
-                                        syncSurfaceControl->getSurface()->getNextFrameNumber());
-    }
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(128, 128));
-        mFGSurfaceControl
-                ->deferTransactionUntil(syncSurfaceControl->getHandle(),
-                                        syncSurfaceControl->getSurface()->getNextFrameNumber() + 1);
-    }
-    EXPECT_EQ(4, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // should trigger the first deferred transaction, but not the second one
-    fillSurfaceRGBA8(syncSurfaceControl, DARK_GRAY);
-    sFakeComposer->runVSyncAndWait();
-    EXPECT_EQ(5, sFakeComposer->getFrameCount());
-
-    referenceFrame[FG_LAYER].mPlaneAlpha = 0.75f;
-    referenceFrame[SYNC_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // should show up immediately since it's not deferred
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(1.0));
-    }
-    referenceFrame[FG_LAYER].mPlaneAlpha = 1.f;
-    EXPECT_EQ(6, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // trigger the second deferred transaction
-    fillSurfaceRGBA8(syncSurfaceControl, DARK_GRAY);
-    sFakeComposer->runVSyncAndWait();
-    // TODO: Compute from layer size?
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{128, 128, 128 + 64, 128 + 64};
-    referenceFrame[SYNC_LAYER].mSwapCount++;
-    EXPECT_EQ(7, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(TransactionTest, SetRelativeLayer) {
-    constexpr int RELATIVE_LAYER = 2;
-    auto relativeSurfaceControl = mComposerClient->createSurface(String8("Test Surface"), 64, 64,
-                                                                 PIXEL_FORMAT_RGBA_8888, 0);
-    fillSurfaceRGBA8(relativeSurfaceControl, LIGHT_RED);
-
-    // Now we stack the surface above the foreground surface and make sure it is visible.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        relativeSurfaceControl->setPosition(64, 64);
-        relativeSurfaceControl->show();
-        relativeSurfaceControl->setRelativeLayer(mFGSurfaceControl->getHandle(), 1);
-    }
-    auto referenceFrame = mBaseFrame;
-    // NOTE: All three layers will be visible as the surfaces are
-    // transparent because of the RGBA format.
-    referenceFrame.push_back(makeSimpleRect(64, 64, 64 + 64, 64 + 64));
-    referenceFrame[RELATIVE_LAYER].mSwapCount = 1;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    // A call to setLayer will override a call to setRelativeLayer
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        relativeSurfaceControl->setLayer(0);
-    }
-
-    // Previous top layer will now appear at the bottom.
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2.insert(referenceFrame2.begin(), referenceFrame[RELATIVE_LAYER]);
-    EXPECT_EQ(3, sFakeComposer->getFrameCount());
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-class ChildLayerTest : public TransactionTest {
-protected:
-    constexpr static int CHILD_LAYER = 2;
-
-    void SetUp() override {
-        TransactionTest::SetUp();
-        mChild = mComposerClient->createSurface(String8("Child surface"), 10, 10,
-                                                PIXEL_FORMAT_RGBA_8888, 0, mFGSurfaceControl.get());
-        fillSurfaceRGBA8(mChild, LIGHT_GRAY);
-
-        sFakeComposer->runVSyncAndWait();
-        mBaseFrame.push_back(makeSimpleRect(64, 64, 64 + 10, 64 + 10));
-        mBaseFrame[CHILD_LAYER].mSwapCount = 1;
-        ASSERT_EQ(2, sFakeComposer->getFrameCount());
-        ASSERT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-    }
-    void TearDown() override {
-        mChild = 0;
-        TransactionTest::TearDown();
-    }
-
-    sp<SurfaceControl> mChild;
-};
-
-TEST_F(ChildLayerTest, Positioning) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(10, 10);
-        // Move to the same position as in the original setup.
-        mFGSurfaceControl->setPosition(64, 64);
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{64 + 10, 64 + 10, 64 + 10 + 10, 64 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setPosition(0, 0));
-    }
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 64, 0 + 64};
-    referenceFrame2[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{0 + 10, 0 + 10, 0 + 10 + 10, 0 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Cropping) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(0, 0);
-        mFGSurfaceControl->setPosition(0, 0);
-        mFGSurfaceControl->setCrop(Rect(0, 0, 5, 5));
-    }
-    // NOTE: The foreground surface would be occluded by the child
-    // now, but is included in the stack because the child is
-    // transparent.
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, FinalCropping) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(0, 0);
-        mFGSurfaceControl->setPosition(0, 0);
-        mFGSurfaceControl->setFinalCrop(Rect(0, 0, 5, 5));
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 0 + 5, 0 + 5};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 5.f, 5.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Constraints) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mFGSurfaceControl->setPosition(0, 0);
-        mChild->setPosition(63, 63);
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 64, 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{63, 63, 64, 64};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 1.f, 1.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Scaling) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setPosition(0, 0);
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 64, 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 10, 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setMatrix(2.0, 0, 0, 2.0);
-    }
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 128, 128};
-    referenceFrame2[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 20, 20};
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, LayerAlpha) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(0, 0);
-        mFGSurfaceControl->setPosition(0, 0);
-        ASSERT_EQ(NO_ERROR, mChild->setAlpha(0.5));
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 64, 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 10, 10};
-    referenceFrame[CHILD_LAYER].mPlaneAlpha = 0.5f;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        ASSERT_EQ(NO_ERROR, mFGSurfaceControl->setAlpha(0.5));
-    }
-
-    auto referenceFrame2 = referenceFrame;
-    referenceFrame2[FG_LAYER].mPlaneAlpha = 0.5f;
-    referenceFrame2[CHILD_LAYER].mPlaneAlpha = 0.25f;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, ReparentChildren) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(10, 10);
-        mFGSurfaceControl->setPosition(64, 64);
-    }
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{64 + 10, 64 + 10, 64 + 10 + 10, 64 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->reparentChildren(mBGSurfaceControl->getHandle());
-    }
-
-    auto referenceFrame2 = referenceFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame2[CHILD_LAYER].mDisplayFrame = hwc_rect_t{10, 10, 10 + 10, 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, DetachChildren) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(10, 10);
-        mFGSurfaceControl->setPosition(64, 64);
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 64, 64 + 64};
-    referenceFrame[CHILD_LAYER].mDisplayFrame =
-            hwc_rect_t{64 + 10, 64 + 10, 64 + 10 + 10, 64 + 10 + 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->detachChildren();
-    }
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->hide();
-    }
-
-    // Nothing should have changed. The child control becomes a no-op
-    // zombie on detach. See comments for detachChildren in the
-    // SurfaceControl.h file.
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, InheritNonTransformScalingFromParent) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(0, 0);
-        mFGSurfaceControl->setPosition(0, 0);
-    }
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setOverrideScalingMode(NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
-        // We cause scaling by 2.
-        mFGSurfaceControl->setSize(128, 128);
-    }
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 128, 128};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 64.f, 64.f};
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 20, 20};
-    referenceFrame[CHILD_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 10.f, 10.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-// Regression test for b/37673612
-TEST_F(ChildLayerTest, ChildrenWithParentBufferTransform) {
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->show();
-        mChild->setPosition(0, 0);
-        mFGSurfaceControl->setPosition(0, 0);
-    }
-
-    // We set things up as in b/37673612 so that there is a mismatch between the buffer size and
-    // the WM specified state size.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 64);
-    }
-
-    sp<Surface> s = mFGSurfaceControl->getSurface();
-    auto anw = static_cast<ANativeWindow*>(s.get());
-    native_window_set_buffers_transform(anw, NATIVE_WINDOW_TRANSFORM_ROT_90);
-    native_window_set_buffers_dimensions(anw, 64, 128);
-    fillSurfaceRGBA8(mFGSurfaceControl, RED);
-    sFakeComposer->runVSyncAndWait();
-
-    // The child should still be in the same place and not have any strange scaling as in
-    // b/37673612.
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 128, 64};
-    referenceFrame[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 64.f, 128.f};
-    referenceFrame[FG_LAYER].mSwapCount++;
-    referenceFrame[CHILD_LAYER].mDisplayFrame = hwc_rect_t{0, 0, 10, 10};
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(ChildLayerTest, Bug36858924) {
-    // Destroy the child layer
-    mChild.clear();
-
-    // Now recreate it as hidden
-    mChild = mComposerClient->createSurface(String8("Child surface"), 10, 10,
-                                            PIXEL_FORMAT_RGBA_8888, ISurfaceComposerClient::eHidden,
-                                            mFGSurfaceControl.get());
-
-    // Show the child layer in a deferred transaction
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mChild->deferTransactionUntil(mFGSurfaceControl->getHandle(),
-                                      mFGSurfaceControl->getSurface()->getNextFrameNumber());
-        mChild->show();
-    }
-
-    // Render the foreground surface a few times
-    //
-    // Prior to the bugfix for b/36858924, this would usually hang while trying to fill the third
-    // frame because SurfaceFlinger would never process the deferred transaction and would therefore
-    // never acquire/release the first buffer
-    ALOGI("Filling 1");
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-    ALOGI("Filling 2");
-    fillSurfaceRGBA8(mFGSurfaceControl, BLUE);
-    sFakeComposer->runVSyncAndWait();
-    ALOGI("Filling 3");
-    fillSurfaceRGBA8(mFGSurfaceControl, RED);
-    sFakeComposer->runVSyncAndWait();
-    ALOGI("Filling 4");
-    fillSurfaceRGBA8(mFGSurfaceControl, GREEN);
-    sFakeComposer->runVSyncAndWait();
-}
-
-class LatchingTest : public TransactionTest {
-protected:
-    void lockAndFillFGBuffer() { fillSurfaceRGBA8(mFGSurfaceControl, RED, false); }
-
-    void unlockFGBuffer() {
-        sp<Surface> s = mFGSurfaceControl->getSurface();
-        ASSERT_EQ(NO_ERROR, s->unlockAndPost());
-        sFakeComposer->runVSyncAndWait();
-    }
-
-    void completeFGResize() {
-        fillSurfaceRGBA8(mFGSurfaceControl, RED);
-        sFakeComposer->runVSyncAndWait();
-    }
-    void restoreInitialState() {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(64, 64);
-        mFGSurfaceControl->setPosition(64, 64);
-        mFGSurfaceControl->setCrop(Rect(0, 0, 64, 64));
-        mFGSurfaceControl->setFinalCrop(Rect(0, 0, -1, -1));
-    }
-};
-
-TEST_F(LatchingTest, SurfacePositionLatching) {
-    // By default position can be updated even while
-    // a resize is pending.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(32, 32);
-        mFGSurfaceControl->setPosition(100, 100);
-    }
-
-    // The size should not have updated as we have not provided a new buffer.
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{100, 100, 100 + 64, 100 + 64};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    // Now we repeat with setGeometryAppliesWithResize
-    // and verify the position DOESN'T latch.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setGeometryAppliesWithResize();
-        mFGSurfaceControl->setSize(32, 32);
-        mFGSurfaceControl->setPosition(100, 100);
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{100, 100, 100 + 32, 100 + 32};
-    referenceFrame2[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 32.f, 32.f};
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(LatchingTest, CropLatching) {
-    // Normally the crop applies immediately even while a resize is pending.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 128);
-        mFGSurfaceControl->setCrop(Rect(0, 0, 63, 63));
-    }
-
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 63, 64 + 63};
-    referenceFrame1[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 63.f, 63.f};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 128);
-        mFGSurfaceControl->setGeometryAppliesWithResize();
-        mFGSurfaceControl->setCrop(Rect(0, 0, 63, 63));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 64 + 63, 64 + 63};
-    referenceFrame2[FG_LAYER].mSourceCrop = hwc_frect_t{0.f, 0.f, 63.f, 63.f};
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(LatchingTest, FinalCropLatching) {
-    // Normally the crop applies immediately even while a resize is pending.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 128);
-        mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    }
-
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame1[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 128);
-        mFGSurfaceControl->setGeometryAppliesWithResize();
-        mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame2[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-}
-
-// In this test we ensure that setGeometryAppliesWithResize actually demands
-// a buffer of the new size, and not just any size.
-TEST_F(LatchingTest, FinalCropLatchingBufferOldSize) {
-    // Normally the crop applies immediately even while a resize is pending.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 128);
-        mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    }
-
-    auto referenceFrame1 = mBaseFrame;
-    referenceFrame1[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame1[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    EXPECT_TRUE(framesAreSame(referenceFrame1, sFakeComposer->getLatestFrame()));
-
-    restoreInitialState();
-
-    // In order to prepare to submit a buffer at the wrong size, we acquire it prior to
-    // initiating the resize.
-    lockAndFillFGBuffer();
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 128);
-        mFGSurfaceControl->setGeometryAppliesWithResize();
-        mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    // We now submit our old buffer, at the old size, and ensure it doesn't
-    // trigger geometry latching.
-    unlockFGBuffer();
-
-    auto referenceFrame2 = mBaseFrame;
-    referenceFrame2[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame2, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-    auto referenceFrame3 = referenceFrame2;
-    referenceFrame3[FG_LAYER].mDisplayFrame = hwc_rect_t{64, 64, 127, 127};
-    referenceFrame3[FG_LAYER].mSourceCrop =
-            hwc_frect_t{0.f, 0.f, static_cast<float>(127 - 64), static_cast<float>(127 - 64)};
-    referenceFrame3[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame3, sFakeComposer->getLatestFrame()));
-}
-
-TEST_F(LatchingTest, FinalCropLatchingRegressionForb37531386) {
-    // In this scenario, we attempt to set the final crop a second time while the resize
-    // is still pending, and ensure we are successful. Success meaning the second crop
-    // is the one which eventually latches and not the first.
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setSize(128, 128);
-        mFGSurfaceControl->setGeometryAppliesWithResize();
-        mFGSurfaceControl->setFinalCrop(Rect(64, 64, 127, 127));
-    }
-
-    {
-        GlobalTransactionScope gts(*sFakeComposer);
-        mFGSurfaceControl->setFinalCrop(Rect(0, 0, -1, -1));
-    }
-    EXPECT_TRUE(framesAreSame(mBaseFrame, sFakeComposer->getLatestFrame()));
-
-    completeFGResize();
-
-    auto referenceFrame = mBaseFrame;
-    referenceFrame[FG_LAYER].mSwapCount++;
-    EXPECT_TRUE(framesAreSame(referenceFrame, sFakeComposer->getLatestFrame()));
-}
-
-} // namespace
-
-int main(int argc, char** argv) {
-    ::testing::InitGoogleTest(&argc, argv);
-
-    sftest::FakeHwcEnvironment* fakeEnvironment = new sftest::FakeHwcEnvironment;
-    ::testing::AddGlobalTestEnvironment(fakeEnvironment);
-    ::testing::InitGoogleMock(&argc, argv);
-    return RUN_ALL_TESTS();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Android.mk b/services/surfaceflinger/tests/hwc2/Android.mk
deleted file mode 100644
index 203ced5c3a..0000000000
--- a/services/surfaceflinger/tests/hwc2/Android.mk
+++ /dev/null
@@ -1,54 +0,0 @@
-#
-# Copyright (C) 2016 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := test-hwc2
-LOCAL_MODULE_TAGS := tests
-LOCAL_CFLAGS += \
-    -fstack-protector-all \
-    -g \
-    -Wall -Wextra \
-    -Werror \
-    -fno-builtin \
-    -DEGL_EGLEXT_PROTOTYPES \
-    -DGL_GLEXT_PROTOTYPES
-LOCAL_SHARED_LIBRARIES := \
-    libcutils \
-    libutils \
-    libhardware \
-    libEGL \
-    libGLESv2 \
-    libui \
-    libgui \
-    liblog \
-    libsync
-LOCAL_STATIC_LIBRARIES := \
-    libbase \
-    libadf \
-    libadfhwc \
-    libmath
-LOCAL_SRC_FILES := \
-    Hwc2Test.cpp \
-    Hwc2TestProperties.cpp \
-    Hwc2TestLayer.cpp \
-    Hwc2TestLayers.cpp \
-    Hwc2TestBuffer.cpp \
-    Hwc2TestClientTarget.cpp \
-    Hwc2TestVirtualDisplay.cpp
-
-include $(BUILD_NATIVE_TEST)
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2Test.cpp b/services/surfaceflinger/tests/hwc2/Hwc2Test.cpp
deleted file mode 100644
index 4055527b13..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2Test.cpp
+++ /dev/null
@@ -1,4559 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <array>
-#include <unordered_set>
-#include <unordered_map>
-#include <gtest/gtest.h>
-#include <dlfcn.h>
-#include <android-base/unique_fd.h>
-#include <hardware/hardware.h>
-#include <sync/sync.h>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestLayer.h"
-#include "Hwc2TestLayers.h"
-#include "Hwc2TestClientTarget.h"
-#include "Hwc2TestVirtualDisplay.h"
-
-void hwc2TestHotplugCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int32_t connected);
-void hwc2TestVsyncCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int64_t timestamp);
-
-class Hwc2Test : public testing::Test {
-public:
-
-    virtual void SetUp()
-    {
-        hw_module_t const* hwc2Module;
-
-        int err = hw_get_module(HWC_HARDWARE_MODULE_ID, &hwc2Module);
-        ASSERT_GE(err, 0) << "failed to get hwc hardware module: "
-                << strerror(-err);
-
-        /* The following method will fail if you have not run
-         * "adb shell stop" */
-        err = hwc2_open(hwc2Module, &mHwc2Device);
-        ASSERT_GE(err, 0) << "failed to open hwc hardware module: "
-                << strerror(-err);
-
-        populateDisplays();
-    }
-
-    virtual void TearDown()
-    {
-
-        for (auto itr = mLayers.begin(); itr != mLayers.end();) {
-            hwc2_display_t display = itr->first;
-            hwc2_layer_t layer = itr->second;
-            itr++;
-            /* Destroys and removes the layer from mLayers */
-            destroyLayer(display, layer);
-        }
-
-        for (auto itr = mActiveDisplays.begin(); itr != mActiveDisplays.end();) {
-            hwc2_display_t display = *itr;
-            itr++;
-            /* Sets power mode to off and removes the display from
-             * mActiveDisplays */
-            setPowerMode(display, HWC2_POWER_MODE_OFF);
-        }
-
-        for (auto itr = mVirtualDisplays.begin(); itr != mVirtualDisplays.end();) {
-            hwc2_display_t display = *itr;
-            itr++;
-            /* Destroys virtual displays */
-            destroyVirtualDisplay(display);
-        }
-
-        if (mHwc2Device)
-            hwc2_close(mHwc2Device);
-    }
-
-    void registerCallback(hwc2_callback_descriptor_t descriptor,
-            hwc2_callback_data_t callbackData, hwc2_function_pointer_t pointer,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_REGISTER_CALLBACK>(
-                getFunction(HWC2_FUNCTION_REGISTER_CALLBACK));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, descriptor,
-                callbackData, pointer));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to register callback";
-        }
-    }
-
-    void getDisplayType(hwc2_display_t display, hwc2_display_type_t* outType,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_TYPE>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_TYPE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    reinterpret_cast<int32_t*>(outType)));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display type";
-        }
-    }
-
-    /* If the populateDisplays function is still receiving displays and the
-     * display is connected, the display handle is stored in mDisplays. */
-    void hotplugCallback(hwc2_display_t display, int32_t connected)
-    {
-        std::lock_guard<std::mutex> lock(mHotplugMutex);
-
-        if (mHotplugStatus != Hwc2TestHotplugStatus::Receiving)
-            return;
-
-        if (connected == HWC2_CONNECTION_CONNECTED)
-            mDisplays.insert(display);
-
-        mHotplugCv.notify_all();
-    }
-
-    void createLayer(hwc2_display_t display, hwc2_layer_t* outLayer,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_CREATE_LAYER>(
-                getFunction(HWC2_FUNCTION_CREATE_LAYER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outLayer));
-
-        if (err == HWC2_ERROR_NONE)
-            mLayers.insert(std::make_pair(display, *outLayer));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to create layer";
-        }
-    }
-
-    void destroyLayer(hwc2_display_t display, hwc2_layer_t layer,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_DESTROY_LAYER>(
-                getFunction(HWC2_FUNCTION_DESTROY_LAYER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer));
-
-        if (err == HWC2_ERROR_NONE)
-            mLayers.erase(std::make_pair(display, layer));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to destroy layer "
-                    << layer;
-        }
-    }
-
-    void getDisplayAttribute(hwc2_display_t display, hwc2_config_t config,
-            hwc2_attribute_t attribute, int32_t* outValue,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_ATTRIBUTE>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_ATTRIBUTE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, config,
-                attribute, outValue));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display attribute "
-                    << getAttributeName(attribute) << " for config " << config;
-        }
-    }
-
-    void getDisplayConfigs(hwc2_display_t display,
-            std::vector<hwc2_config_t>* outConfigs,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_CONFIGS>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_CONFIGS));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numConfigs = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numConfigs, nullptr));
-
-        if (err == HWC2_ERROR_NONE) {
-            outConfigs->resize(numConfigs);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numConfigs, outConfigs->data()));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get configs for"
-                    " display " << display;
-        }
-    }
-
-    void getActiveConfig(hwc2_display_t display, hwc2_config_t* outConfig,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_ACTIVE_CONFIG>(
-                getFunction(HWC2_FUNCTION_GET_ACTIVE_CONFIG));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outConfig));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get active config on"
-                    " display " << display;
-        }
-    }
-
-    void setActiveConfig(hwc2_display_t display, hwc2_config_t config,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_ACTIVE_CONFIG>(
-                getFunction(HWC2_FUNCTION_SET_ACTIVE_CONFIG));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, config));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set active config "
-                    << config;
-        }
-    }
-
-    void getDozeSupport(hwc2_display_t display, int32_t* outSupport,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DOZE_SUPPORT>(
-                getFunction(HWC2_FUNCTION_GET_DOZE_SUPPORT));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outSupport));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get doze support on"
-                    " display " << display;
-        }
-    }
-
-    void setPowerMode(hwc2_display_t display, hwc2_power_mode_t mode,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_POWER_MODE>(
-                getFunction(HWC2_FUNCTION_SET_POWER_MODE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                mode));
-        if (outErr) {
-            *outErr = err;
-            if (err != HWC2_ERROR_NONE)
-                return;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set power mode "
-                    << getPowerModeName(mode) << " on display " << display;
-        }
-
-        if (mode == HWC2_POWER_MODE_OFF) {
-            mActiveDisplays.erase(display);
-        } else {
-            mActiveDisplays.insert(display);
-        }
-    }
-
-    void setVsyncEnabled(hwc2_display_t display, hwc2_vsync_t enabled,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_VSYNC_ENABLED>(
-                getFunction(HWC2_FUNCTION_SET_VSYNC_ENABLED));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                enabled));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set vsync enabled "
-                    << getVsyncName(enabled);
-        }
-    }
-
-    void vsyncCallback(hwc2_display_t display, int64_t timestamp)
-    {
-        std::lock_guard<std::mutex> lock(mVsyncMutex);
-        mVsyncDisplay = display;
-        mVsyncTimestamp = timestamp;
-        mVsyncCv.notify_all();
-    }
-
-    void getDisplayName(hwc2_display_t display, std::string* outName,
-                hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_NAME>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_NAME));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t size = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, &size,
-                nullptr));
-
-        if (err == HWC2_ERROR_NONE) {
-            std::vector<char> name(size);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, &size,
-                    name.data()));
-
-            outName->assign(name.data());
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display name for "
-                    << display;
-        }
-    }
-
-    void setLayerCompositionType(hwc2_display_t display, hwc2_layer_t layer,
-            hwc2_composition_t composition, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_COMPOSITION_TYPE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_COMPOSITION_TYPE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                composition));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer composition"
-                    " type " << getCompositionName(composition);
-        }
-    }
-
-    void setCursorPosition(hwc2_display_t display, hwc2_layer_t layer,
-            int32_t x, int32_t y, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_CURSOR_POSITION>(
-                getFunction(HWC2_FUNCTION_SET_CURSOR_POSITION));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer, x,
-                y));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_TRUE((err == HWC2_ERROR_NONE) ||
-                (err == HWC2_ERROR_BAD_LAYER)) <<
-                "failed to set cursor position";
-        }
-    }
-
-    void setLayerBlendMode(hwc2_display_t display, hwc2_layer_t layer,
-            hwc2_blend_mode_t mode, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_BLEND_MODE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_BLEND_MODE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                mode));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer blend mode "
-                    << getBlendModeName(mode);
-        }
-    }
-
-    void setLayerBuffer(hwc2_display_t display, hwc2_layer_t layer,
-            buffer_handle_t buffer, int32_t acquireFence,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_BUFFER>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_BUFFER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                buffer, acquireFence));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer buffer";
-        }
-    }
-
-    void setLayerColor(hwc2_display_t display, hwc2_layer_t layer,
-            hwc_color_t color, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_COLOR>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_COLOR));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                color));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer color";
-        }
-    }
-
-    void setLayerDataspace(hwc2_display_t display, hwc2_layer_t layer,
-            android_dataspace_t dataspace, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_DATASPACE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_DATASPACE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                layer, dataspace));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer dataspace";
-        }
-    }
-
-    void setLayerDisplayFrame(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_rect_t& displayFrame, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_DISPLAY_FRAME>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_DISPLAY_FRAME));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                displayFrame));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer display"
-                    " frame";
-        }
-    }
-
-    void setLayerPlaneAlpha(hwc2_display_t display, hwc2_layer_t layer,
-            float alpha, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_PLANE_ALPHA>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_PLANE_ALPHA));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                alpha));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer plane alpha "
-                    << alpha;
-        }
-    }
-
-    void setLayerSourceCrop(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_frect_t& sourceCrop, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_SOURCE_CROP>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_SOURCE_CROP));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                sourceCrop));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer source crop";
-        }
-    }
-
-    void setLayerSurfaceDamage(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_region_t& surfaceDamage, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_SURFACE_DAMAGE>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_SURFACE_DAMAGE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                surfaceDamage));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer surface"
-                    " damage";
-        }
-    }
-
-    void setLayerTransform(hwc2_display_t display, hwc2_layer_t layer,
-            hwc_transform_t transform, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_TRANSFORM>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_TRANSFORM));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                transform));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer transform "
-                    << getTransformName(transform);
-        }
-    }
-
-    void setLayerVisibleRegion(hwc2_display_t display, hwc2_layer_t layer,
-            const hwc_region_t& visibleRegion, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_VISIBLE_REGION>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_VISIBLE_REGION));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                visibleRegion));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer visible"
-                    " region";
-        }
-    }
-
-    void setLayerZOrder(hwc2_display_t display, hwc2_layer_t layer,
-            uint32_t zOrder, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_LAYER_Z_ORDER>(
-                getFunction(HWC2_FUNCTION_SET_LAYER_Z_ORDER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, layer,
-                zOrder));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set layer z order "
-                    << zOrder;
-        }
-    }
-
-    void validateDisplay(hwc2_display_t display, uint32_t* outNumTypes,
-            uint32_t* outNumRequests, hwc2_error_t* outErr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_VALIDATE_DISPLAY>(
-                getFunction(HWC2_FUNCTION_VALIDATE_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        *outErr = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outNumTypes, outNumRequests));
-    }
-
-    void validateDisplay(hwc2_display_t display, uint32_t* outNumTypes,
-            uint32_t* outNumRequests, bool* outHasChanges)
-    {
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        EXPECT_NO_FATAL_FAILURE(validateDisplay(display, outNumTypes,
-                outNumRequests, &err));
-
-        if (err != HWC2_ERROR_HAS_CHANGES) {
-            *outHasChanges = false;
-            EXPECT_EQ(err, HWC2_ERROR_NONE) << "failed to validate display";
-        } else {
-            *outHasChanges = true;
-        }
-    }
-
-    void getDisplayRequests(hwc2_display_t display,
-            hwc2_display_request_t* outDisplayRequests,
-            std::vector<hwc2_layer_t>* outLayers,
-            std::vector<hwc2_layer_request_t>* outLayerRequests,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_DISPLAY_REQUESTS>(
-                getFunction(HWC2_FUNCTION_GET_DISPLAY_REQUESTS));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numElements = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                reinterpret_cast<int32_t*>(outDisplayRequests), &numElements,
-                nullptr, nullptr));
-
-        if (err == HWC2_ERROR_NONE && numElements > 0) {
-            outLayers->resize(numElements);
-            outLayerRequests->resize(numElements);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    reinterpret_cast<int32_t*>(outDisplayRequests), &numElements,
-                    reinterpret_cast<uint64_t*>(outLayers->data()),
-                    reinterpret_cast<int32_t*>(outLayerRequests->data())));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get display requests";
-        }
-    }
-
-    void handleRequests(hwc2_display_t display,
-            const std::vector<hwc2_layer_t>& layers, uint32_t numRequests,
-            std::set<hwc2_layer_t>* outClearLayers = nullptr,
-            bool* outFlipClientTarget = nullptr)
-    {
-        hwc2_display_request_t displayRequest =
-                static_cast<hwc2_display_request_t>(0);
-        std::vector<hwc2_layer_t> requestedLayers;
-        std::vector<hwc2_layer_request_t> requests;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayRequests(display, &displayRequest,
-                &requestedLayers, &requests));
-
-        EXPECT_EQ(numRequests, requests.size()) << "validate returned "
-                << numRequests << " requests and get display requests returned "
-                << requests.size() << " requests";
-
-        for (size_t i = 0; i < requests.size(); i++) {
-            hwc2_layer_t requestedLayer = requestedLayers.at(i);
-            hwc2_layer_request_t request = requests.at(i);
-
-            EXPECT_EQ(std::count(layers.begin(), layers.end(), requestedLayer),
-                    1) << "get display requests returned an unknown layer";
-            EXPECT_NE(request, 0) << "returned empty request for layer "
-                    << requestedLayer;
-
-            if (outClearLayers && request
-                    == HWC2_LAYER_REQUEST_CLEAR_CLIENT_TARGET)
-                outClearLayers->insert(requestedLayer);
-        }
-
-        if (outFlipClientTarget)
-            *outFlipClientTarget = displayRequest
-                    & HWC2_DISPLAY_REQUEST_FLIP_CLIENT_TARGET;
-    }
-
-    void getChangedCompositionTypes(hwc2_display_t display,
-            std::vector<hwc2_layer_t>* outLayers,
-            std::vector<hwc2_composition_t>* outTypes,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_CHANGED_COMPOSITION_TYPES>(
-                getFunction(HWC2_FUNCTION_GET_CHANGED_COMPOSITION_TYPES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numElements = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numElements, nullptr, nullptr));
-
-        if (err == HWC2_ERROR_NONE && numElements > 0) {
-            outLayers->resize(numElements);
-            outTypes->resize(numElements);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numElements, reinterpret_cast<uint64_t*>(outLayers->data()),
-                    reinterpret_cast<int32_t*>(outTypes->data())));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get changed"
-                    " composition types";
-        }
-    }
-
-    void handleCompositionChanges(hwc2_display_t display,
-            const Hwc2TestLayers& testLayers,
-            const std::vector<hwc2_layer_t>& layers, uint32_t numTypes,
-            std::set<hwc2_layer_t>* outClientLayers = nullptr)
-    {
-        std::vector<hwc2_layer_t> changedLayers;
-        std::vector<hwc2_composition_t> types;
-
-        ASSERT_NO_FATAL_FAILURE(getChangedCompositionTypes(display,
-                &changedLayers, &types));
-
-        EXPECT_EQ(numTypes, types.size()) << "validate returned "
-                << numTypes << " types and get changed composition types"
-                " returned " << types.size() << " types";
-
-        for (size_t i = 0; i < types.size(); i++) {
-
-            auto layer = std::find(layers.begin(), layers.end(),
-                    changedLayers.at(i));
-
-            EXPECT_TRUE(layer != layers.end() || !testLayers.contains(*layer))
-                    << "get changed composition types returned an unknown layer";
-
-            hwc2_composition_t requestedType = testLayers.getComposition(*layer);
-            hwc2_composition_t returnedType = types.at(i);
-
-            EXPECT_NE(returnedType, HWC2_COMPOSITION_INVALID) << "get changed"
-                    " composition types returned invalid composition";
-
-            switch (requestedType) {
-            case HWC2_COMPOSITION_CLIENT:
-                EXPECT_TRUE(false) << getCompositionName(returnedType)
-                        << " cannot be changed";
-                break;
-            case HWC2_COMPOSITION_DEVICE:
-            case HWC2_COMPOSITION_SOLID_COLOR:
-                EXPECT_EQ(returnedType, HWC2_COMPOSITION_CLIENT)
-                        << "composition of type "
-                        << getCompositionName(requestedType)
-                        << " can only be changed to "
-                        << getCompositionName(HWC2_COMPOSITION_CLIENT);
-                break;
-            case HWC2_COMPOSITION_CURSOR:
-            case HWC2_COMPOSITION_SIDEBAND:
-                EXPECT_TRUE(returnedType == HWC2_COMPOSITION_CLIENT
-                        || returnedType == HWC2_COMPOSITION_DEVICE)
-                        << "composition of type "
-                        << getCompositionName(requestedType)
-                        << " can only be changed to "
-                        << getCompositionName(HWC2_COMPOSITION_CLIENT) << " or "
-                        << getCompositionName(HWC2_COMPOSITION_DEVICE);
-                break;
-            default:
-                EXPECT_TRUE(false) << "unknown type "
-                        << getCompositionName(requestedType);
-                break;
-            }
-
-            if (outClientLayers)
-                if (returnedType == HWC2_COMPOSITION_CLIENT)
-                    outClientLayers->insert(*layer);
-        }
-
-        if (outClientLayers) {
-            for (auto layer : layers) {
-                if (testLayers.getComposition(layer) == HWC2_COMPOSITION_CLIENT)
-                    outClientLayers->insert(layer);
-            }
-        }
-    }
-
-    void acceptDisplayChanges(hwc2_display_t display,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_ACCEPT_DISPLAY_CHANGES>(
-                getFunction(HWC2_FUNCTION_ACCEPT_DISPLAY_CHANGES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to accept display changes";
-        }
-    }
-
-    void getClientTargetSupport(hwc2_display_t display, int32_t width,
-            int32_t height, android_pixel_format_t format,
-            android_dataspace_t dataspace, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_CLIENT_TARGET_SUPPORT>(
-                getFunction(HWC2_FUNCTION_GET_CLIENT_TARGET_SUPPORT));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, width,
-                height, format, dataspace));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get client target"
-                    " support";
-        }
-    }
-
-    void setClientTarget(hwc2_display_t display, buffer_handle_t handle,
-            int32_t acquireFence, android_dataspace_t dataspace,
-            hwc_region_t damage, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_CLIENT_TARGET>(
-                getFunction(HWC2_FUNCTION_SET_CLIENT_TARGET));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, handle,
-                acquireFence, dataspace, damage));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set client target";
-        }
-    }
-
-    void presentDisplay(hwc2_display_t display, int32_t* outPresentFence,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_PRESENT_DISPLAY>(
-                getFunction(HWC2_FUNCTION_PRESENT_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                outPresentFence));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to present display";
-        }
-    }
-
-    void getReleaseFences(hwc2_display_t display,
-            std::vector<hwc2_layer_t>* outLayers,
-            std::vector<int32_t>* outFences, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_RELEASE_FENCES>(
-                getFunction(HWC2_FUNCTION_GET_RELEASE_FENCES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numElements = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numElements, nullptr, nullptr));
-
-        if (err == HWC2_ERROR_NONE) {
-            outLayers->resize(numElements);
-            outFences->resize(numElements);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numElements, outLayers->data(), outFences->data()));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get release fences";
-        }
-    }
-
-    void getColorModes(hwc2_display_t display,
-            std::vector<android_color_mode_t>* outColorModes,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_COLOR_MODES>(
-                getFunction(HWC2_FUNCTION_GET_COLOR_MODES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numColorModes = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numColorModes, nullptr));
-        if (err == HWC2_ERROR_NONE) {
-            outColorModes->resize(numColorModes);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                    &numColorModes,
-                    reinterpret_cast<int32_t*>(outColorModes->data())));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get color modes for"
-                    " display " << display;
-        }
-    }
-
-    void setColorMode(hwc2_display_t display, android_color_mode_t colorMode,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_COLOR_MODE>(
-                getFunction(HWC2_FUNCTION_SET_COLOR_MODE));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                static_cast<int32_t>(colorMode)));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set color mode "
-                    << colorMode;
-        }
-    }
-
-    void getHdrCapabilities(hwc2_display_t display,
-            std::vector<android_hdr_t>* outTypes, float* outMaxLuminance,
-            float* outMaxAverageLuminance, float* outMinLuminance,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_HDR_CAPABILITIES>(
-                getFunction(HWC2_FUNCTION_GET_HDR_CAPABILITIES));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t numTypes = 0;
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                &numTypes, nullptr, outMaxLuminance, outMaxAverageLuminance,
-                outMinLuminance));
-
-        if (err == HWC2_ERROR_NONE) {
-            outTypes->resize(numTypes);
-
-            err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, &numTypes,
-                    reinterpret_cast<int32_t*>(outTypes->data()), outMaxLuminance,
-                    outMaxAverageLuminance, outMinLuminance));
-        }
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to get hdr capabilities"
-                    " for display " << display;
-        }
-    }
-
-    void setColorTransform(hwc2_display_t display,
-            const std::array<float, 16>& matrix, android_color_transform_t hint,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_COLOR_TRANSFORM>(
-                getFunction(HWC2_FUNCTION_SET_COLOR_TRANSFORM));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display,
-                matrix.data(), hint));
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set color transform "
-                    << hint;
-        }
-    }
-
-    void createVirtualDisplay(uint32_t width, uint32_t height,
-            android_pixel_format_t* outFormat, hwc2_display_t* outDisplay,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_CREATE_VIRTUAL_DISPLAY>(
-                getFunction(HWC2_FUNCTION_CREATE_VIRTUAL_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, width, height,
-                reinterpret_cast<int32_t*>(outFormat), outDisplay));
-
-        if (err == HWC2_ERROR_NONE)
-            mVirtualDisplays.insert(*outDisplay);
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to create virtual display";
-        }
-    }
-
-    void destroyVirtualDisplay(hwc2_display_t display,
-            hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_DESTROY_VIRTUAL_DISPLAY>(
-                getFunction(HWC2_FUNCTION_DESTROY_VIRTUAL_DISPLAY));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display));
-
-        if (err == HWC2_ERROR_NONE)
-            mVirtualDisplays.erase(display);
-
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to destroy virtual display";
-        }
-    }
-
-    void getMaxVirtualDisplayCount(uint32_t* outMaxCnt)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_GET_MAX_VIRTUAL_DISPLAY_COUNT>(
-                getFunction(HWC2_FUNCTION_GET_MAX_VIRTUAL_DISPLAY_COUNT));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        *outMaxCnt = pfn(mHwc2Device);
-    }
-
-    void setOutputBuffer(hwc2_display_t display, buffer_handle_t buffer,
-            int32_t releaseFence, hwc2_error_t* outErr = nullptr)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_SET_OUTPUT_BUFFER>(
-                getFunction(HWC2_FUNCTION_SET_OUTPUT_BUFFER));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        auto err = static_cast<hwc2_error_t>(pfn(mHwc2Device, display, buffer,
-                releaseFence));
-        if (outErr) {
-            *outErr = err;
-        } else {
-            ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to set output buffer";
-        }
-    }
-
-    void dump(std::string* outBuffer)
-    {
-        auto pfn = reinterpret_cast<HWC2_PFN_DUMP>(
-                getFunction(HWC2_FUNCTION_DUMP));
-        ASSERT_TRUE(pfn) << "failed to get function";
-
-        uint32_t size = 0;
-
-        pfn(mHwc2Device, &size, nullptr);
-
-        std::vector<char> buffer(size);
-
-        pfn(mHwc2Device, &size, buffer.data());
-
-        outBuffer->assign(buffer.data());
-    }
-
-    void getBadDisplay(hwc2_display_t* outDisplay)
-    {
-        for (hwc2_display_t display = 0; display < UINT64_MAX; display++) {
-            if (mDisplays.count(display) == 0) {
-                *outDisplay = display;
-                return;
-            }
-        }
-        ASSERT_TRUE(false) << "Unable to find bad display. UINT64_MAX displays"
-                " are registered. This should never happen.";
-    }
-
-    void waitForVsync(hwc2_display_t* outDisplay = nullptr,
-            int64_t* outTimestamp = nullptr)
-    {
-        std::unique_lock<std::mutex> lock(mVsyncMutex);
-        ASSERT_EQ(mVsyncCv.wait_for(lock, std::chrono::seconds(3)),
-                std::cv_status::no_timeout) << "timed out attempting to get"
-                " vsync callback";
-        if (outDisplay)
-            *outDisplay = mVsyncDisplay;
-        if (outTimestamp)
-            *outTimestamp = mVsyncTimestamp;
-    }
-
-    void enableVsync(hwc2_display_t display)
-    {
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, this,
-                reinterpret_cast<hwc2_function_pointer_t>(
-                hwc2TestVsyncCallback)));
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-    }
-
-    void disableVsync(hwc2_display_t display)
-    {
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-    }
-
-protected:
-    hwc2_function_pointer_t getFunction(hwc2_function_descriptor_t descriptor)
-    {
-        return mHwc2Device->getFunction(mHwc2Device, descriptor);
-    }
-
-    void getCapabilities(std::vector<hwc2_capability_t>* outCapabilities)
-    {
-        uint32_t num = 0;
-
-        mHwc2Device->getCapabilities(mHwc2Device, &num, nullptr);
-
-        outCapabilities->resize(num);
-
-        mHwc2Device->getCapabilities(mHwc2Device, &num,
-                reinterpret_cast<int32_t*>(outCapabilities->data()));
-    }
-
-    /* Registers a hotplug callback and waits for hotplug callbacks. This
-     * function will have no effect if called more than once. */
-    void populateDisplays()
-    {
-        /* Sets the hotplug status to receiving */
-        {
-            std::lock_guard<std::mutex> lock(mHotplugMutex);
-
-            if (mHotplugStatus != Hwc2TestHotplugStatus::Init)
-                return;
-            mHotplugStatus = Hwc2TestHotplugStatus::Receiving;
-        }
-
-        /* Registers the callback. This function call cannot be locked because
-         * a callback could happen on the same thread */
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_HOTPLUG, this,
-                reinterpret_cast<hwc2_function_pointer_t>(
-                hwc2TestHotplugCallback)));
-
-        /* Waits for hotplug events. If a hotplug event has not come within 1
-         * second, stop waiting. */
-        std::unique_lock<std::mutex> lock(mHotplugMutex);
-
-        while (mHotplugCv.wait_for(lock, std::chrono::seconds(1)) !=
-                std::cv_status::timeout) { }
-
-        /* Sets the hotplug status to done. Future calls will have no effect */
-        mHotplugStatus = Hwc2TestHotplugStatus::Done;
-    }
-
-    /* NOTE: will create min(newlayerCnt, max supported layers) layers */
-    void createLayers(hwc2_display_t display,
-            std::vector<hwc2_layer_t>* outLayers, size_t newLayerCnt)
-    {
-        std::vector<hwc2_layer_t> newLayers;
-        hwc2_layer_t layer;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        for (size_t i = 0; i < newLayerCnt; i++) {
-
-            EXPECT_NO_FATAL_FAILURE(createLayer(display, &layer, &err));
-            if (err == HWC2_ERROR_NO_RESOURCES)
-                break;
-            if (err != HWC2_ERROR_NONE) {
-                newLayers.clear();
-                ASSERT_EQ(err, HWC2_ERROR_NONE) << "failed to create layer";
-            }
-            newLayers.push_back(layer);
-        }
-
-        *outLayers = std::move(newLayers);
-    }
-
-    void destroyLayers(hwc2_display_t display,
-            std::vector<hwc2_layer_t>&& layers)
-    {
-        for (hwc2_layer_t layer : layers) {
-            EXPECT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-        }
-    }
-
-    void getInvalidConfig(hwc2_display_t display, hwc2_config_t* outConfig)
-    {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        hwc2_config_t CONFIG_MAX = UINT32_MAX;
-
-        ASSERT_LE(configs.size() - 1, CONFIG_MAX) << "every config value"
-                " (2^32 values) has been taken which shouldn't happen";
-
-        hwc2_config_t config;
-        for (config = 0; config < CONFIG_MAX; config++) {
-            if (std::count(configs.begin(), configs.end(), config) == 0)
-                break;
-        }
-
-        *outConfig = config;
-    }
-
-    /* Calls a set property function from Hwc2Test to set a property value from
-     * Hwc2TestLayer to hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertyFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayer* testLayer, hwc2_error_t* outErr);
-
-    /* Calls a set property function from Hwc2Test to set property values from
-     * Hwc2TestLayers to hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertiesFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayers* testLayers);
-
-    /* Calls a set property function from Hwc2Test to set a bad property value
-     * on hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertyBadLayerFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayer* testLayer, hwc2_error_t* outErr);
-
-    /* Calls a set property function from Hwc2Test to set a bad property value
-     * on hwc2_layer_t on hwc2_display_t */
-    using TestLayerPropertyBadParameterFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, hwc2_layer_t layer, hwc2_error_t* outErr);
-
-    /* Is called after a display is powered on and all layer properties have
-     * been set. It should be used to test functions such as validate, accepting
-     * changes, present, etc. */
-    using TestDisplayLayersFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestLayers* testLayers);
-
-    /* It is called on an non validated display */
-    using TestDisplayNonValidatedLayersFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, std::vector<hwc2_layer_t>* layers);
-
-    /* Tests client target support on a particular display and config */
-    using TestClientTargetSupportFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display,
-            const Hwc2TestClientTargetSupport& testClientTargetSupport);
-
-    /* Tests a particular active display config */
-    using TestActiveDisplayConfigFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display);
-
-    /* Tests a newly created virtual display */
-    using TestCreateVirtualDisplayFunction = void (*)(Hwc2Test* test,
-            hwc2_display_t display, Hwc2TestVirtualDisplay* testVirtualDisplay);
-
-    /* Advances a property of Hwc2TestLayer */
-    using AdvanceProperty = bool (*)(Hwc2TestLayer* testLayer);
-
-    /* Advances properties of Hwc2TestLayers */
-    using AdvanceProperties = bool (*)(Hwc2TestLayers* testLayer);
-
-    /* Advances properties of Hwc2TestClientTargetSupport */
-    using AdvanceClientTargetSupport = bool (*)(
-            Hwc2TestClientTargetSupport* testClientTargetSupport);
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates a layer, sets the property and then
-     * destroys the layer */
-    void setLayerProperty(Hwc2TestCoverage coverage,
-            TestLayerPropertyFunction function, AdvanceProperty advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer;
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestLayer testLayer(coverage, displayArea);
-
-                do {
-                    ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                    ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                            &testLayer, nullptr));
-
-                    ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-                } while (advance(&testLayer));
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates a layer, cycles through each property
-     * value and updates the layer property value and then destroys the layer */
-    void setLayerPropertyUpdate(Hwc2TestCoverage coverage,
-            TestLayerPropertyFunction function, AdvanceProperty advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer;
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestLayer testLayer(coverage, displayArea);
-
-                ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                do {
-                    ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                            &testLayer, nullptr));
-                } while (advance(&testLayer));
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates multiple layers, calls the
-     * TestLayerPropertiesFunction to set property values and then
-     * destroys the layers */
-    void setLayerProperties(Hwc2TestCoverage coverage, size_t layerCnt,
-            TestLayerPropertiesFunction function, AdvanceProperties advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                std::vector<hwc2_layer_t> layers;
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-
-                ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-                Hwc2TestLayers testLayers(layers, coverage, displayArea);
-
-                do {
-                    for (auto layer : layers) {
-                        EXPECT_NO_FATAL_FAILURE(function(this, display, layer,
-                                &testLayers));
-                    }
-                } while (advance(&testLayers));
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config.
-     * 1) It attempts to set a valid property value to bad layer handle.
-     * 2) It creates a layer x and attempts to set a valid property value to
-     *    layer x + 1
-     * 3) It destroys the layer x and attempts to set a valid property value to
-     *    the destroyed layer x.
-     */
-    void setLayerPropertyBadLayer(Hwc2TestCoverage coverage,
-            TestLayerPropertyBadLayerFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer = 0;
-                Area displayArea;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestLayer testLayer(coverage, displayArea);
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                        &testLayer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-                ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer + 1,
-                        &testLayer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer,
-                        &testLayer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-            }
-        }
-    }
-
-    /* For each active display it cycles through each display config and tests
-     * each property value. It creates a layer, sets a bad property value and
-     * then destroys the layer */
-    void setLayerPropertyBadParameter(TestLayerPropertyBadParameterFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                hwc2_layer_t layer;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-
-                ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-                ASSERT_NO_FATAL_FAILURE(function(this, display, layer, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong"
-                        " error code";
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-            }
-        }
-    }
-
-    /* For each active display it powers on the display, cycles through each
-     * config and creates a set of layers with a certain amount of coverage.
-     * For each active display, for each config and for each set of layers,
-     * it calls the TestDisplayLayersFunction */
-    void displayLayers(Hwc2TestCoverage coverage, size_t layerCnt,
-            TestDisplayLayersFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                Area displayArea;
-                std::vector<hwc2_layer_t> layers;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display, &displayArea));
-
-                ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-                Hwc2TestLayers testLayers(layers, coverage, displayArea);
-
-                do {
-                    bool skip;
-
-                    ASSERT_NO_FATAL_FAILURE(setLayerProperties(display, layers,
-                            &testLayers, &skip));
-                    if (!skip)
-                        EXPECT_NO_FATAL_FAILURE(function(this, display, layers,
-                                &testLayers));
-
-                } while (testLayers.advance());
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayers(display,
-                        std::move(layers)));
-            }
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        }
-    }
-
-    /* For each active display, it calls the
-     * TestDisplayNonValidatedLayersFunction on a variety on non-validated
-     * layer combinations */
-    void displayNonValidatedLayers(size_t layerCnt,
-            TestDisplayNonValidatedLayersFunction function)
-    {
-        for (auto display : mDisplays) {
-            uint32_t numTypes, numRequests;
-            std::vector<hwc2_layer_t> layers;
-            bool hasChanges;
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            for (auto layer : layers) {
-                ASSERT_NO_FATAL_FAILURE(setLayerCompositionType(display, layer,
-                        HWC2_COMPOSITION_CLIENT));
-            }
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes,
-                    &numRequests, &hasChanges));
-
-            for (auto layer : layers) {
-                ASSERT_NO_FATAL_FAILURE(setLayerCompositionType(display, layer,
-                        HWC2_COMPOSITION_DEVICE));
-            }
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display, &layers));
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        }
-    }
-
-    /* Test client target support on each config on each active display */
-    void setClientTargetSupport(Hwc2TestCoverage coverage,
-            TestClientTargetSupportFunction function,
-            AdvanceClientTargetSupport advance)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                Area displayArea;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-                Hwc2TestClientTargetSupport testClientTargetSupport(coverage,
-                        displayArea);
-
-                do {
-                    EXPECT_NO_FATAL_FAILURE(function(this, display,
-                            testClientTargetSupport));
-
-                } while (advance(&testClientTargetSupport));
-            }
-        }
-    }
-
-    /* Cycles through each config on each active display and calls
-     * a TestActiveDisplayConfigFunction */
-    void setActiveDisplayConfig(TestActiveDisplayConfigFunction function)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-
-                EXPECT_NO_FATAL_FAILURE(function(this, display));
-            }
-        }
-    }
-
-    /* Creates a virtual display for testing */
-    void createVirtualDisplay(Hwc2TestCoverage coverage,
-            TestCreateVirtualDisplayFunction function)
-    {
-        Hwc2TestVirtualDisplay testVirtualDisplay(coverage);
-
-        do {
-            hwc2_display_t display;
-            hwc2_error_t err = HWC2_ERROR_NONE;
-
-            const UnsignedArea& dimension =
-                    testVirtualDisplay.getDisplayDimension();
-            android_pixel_format_t desiredFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-
-            ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(dimension.width,
-                    dimension.height, &desiredFormat, &display, &err));
-
-            EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_NO_RESOURCES
-                    || err == HWC2_ERROR_UNSUPPORTED)
-                    << "returned wrong error code";
-            EXPECT_GE(desiredFormat, 0) << "invalid format";
-
-            if (err != HWC2_ERROR_NONE)
-                continue;
-
-            EXPECT_NO_FATAL_FAILURE(function(this, display,
-                    &testVirtualDisplay));
-
-            ASSERT_NO_FATAL_FAILURE(destroyVirtualDisplay(display));
-
-        } while (testVirtualDisplay.advance());
-    }
-
-
-    void getActiveConfigAttribute(hwc2_display_t display,
-            hwc2_attribute_t attribute, int32_t* outValue)
-    {
-        hwc2_config_t config;
-        ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &config));
-        ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                attribute, outValue));
-        ASSERT_GE(*outValue, 0) << "failed to get valid "
-                << getAttributeName(attribute);
-    }
-
-    void getActiveDisplayArea(hwc2_display_t display, Area* displayArea)
-    {
-        ASSERT_NO_FATAL_FAILURE(getActiveConfigAttribute(display,
-                HWC2_ATTRIBUTE_WIDTH, &displayArea->width));
-        ASSERT_NO_FATAL_FAILURE(getActiveConfigAttribute(display,
-                HWC2_ATTRIBUTE_HEIGHT, &displayArea->height));
-    }
-
-    void closeFences(hwc2_display_t display, int32_t presentFence)
-    {
-        std::vector<hwc2_layer_t> layers;
-        std::vector<int32_t> fences;
-        const int msWait = 3000;
-
-        if (presentFence >= 0) {
-            ASSERT_GE(sync_wait(presentFence, msWait), 0);
-            close(presentFence);
-        }
-
-        ASSERT_NO_FATAL_FAILURE(getReleaseFences(display, &layers, &fences));
-        EXPECT_EQ(layers.size(), fences.size());
-
-        for (int32_t fence : fences) {
-            if (fence >= 0) {
-                EXPECT_GE(sync_wait(fence, msWait), 0);
-                close(fence);
-            }
-        }
-    }
-
-    void setLayerProperties(hwc2_display_t display, hwc2_layer_t layer,
-            Hwc2TestLayers* testLayers, bool* outSkip)
-    {
-        hwc2_composition_t composition;
-        buffer_handle_t handle = nullptr;
-        int32_t acquireFence;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-        *outSkip = true;
-
-        if (!testLayers->contains(layer))
-            return;
-
-        composition = testLayers->getComposition(layer);
-
-        /* If the device cannot support a buffer format, then do not continue */
-        if ((composition == HWC2_COMPOSITION_DEVICE
-                || composition == HWC2_COMPOSITION_CURSOR)
-                && testLayers->getBuffer(layer, &handle, &acquireFence) < 0)
-            return;
-
-        EXPECT_NO_FATAL_FAILURE(setLayerCompositionType(display, layer,
-                composition, &err));
-        if (err == HWC2_ERROR_UNSUPPORTED)
-            EXPECT_TRUE(composition != HWC2_COMPOSITION_CLIENT
-                    && composition != HWC2_COMPOSITION_DEVICE);
-
-        const hwc_rect_t cursor = testLayers->getCursorPosition(layer);
-
-        EXPECT_NO_FATAL_FAILURE(setLayerBuffer(display, layer, handle,
-                acquireFence));
-        EXPECT_NO_FATAL_FAILURE(setLayerBlendMode(display, layer,
-                testLayers->getBlendMode(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerColor(display, layer,
-                testLayers->getColor(layer)));
-        if (composition == HWC2_COMPOSITION_CURSOR)
-            EXPECT_NO_FATAL_FAILURE(setCursorPosition(display, layer,
-            cursor.left, cursor.top));
-        EXPECT_NO_FATAL_FAILURE(setLayerDataspace(display, layer,
-                testLayers->getDataspace(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerDisplayFrame(display, layer,
-                testLayers->getDisplayFrame(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerPlaneAlpha(display, layer,
-                testLayers->getPlaneAlpha(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerSourceCrop(display, layer,
-                testLayers->getSourceCrop(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerSurfaceDamage(display, layer,
-                testLayers->getSurfaceDamage(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerTransform(display, layer,
-                testLayers->getTransform(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerVisibleRegion(display, layer,
-                testLayers->getVisibleRegion(layer)));
-        EXPECT_NO_FATAL_FAILURE(setLayerZOrder(display, layer,
-                testLayers->getZOrder(layer)));
-
-        *outSkip = false;
-    }
-
-    void setLayerProperties(hwc2_display_t display,
-            const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestLayers* testLayers, bool* outSkip)
-    {
-        for (auto layer : layers) {
-            EXPECT_NO_FATAL_FAILURE(setLayerProperties(display, layer,
-                    testLayers, outSkip));
-            if (*outSkip)
-                return;
-        }
-    }
-
-    void setClientTarget(hwc2_display_t display,
-            Hwc2TestClientTarget* testClientTarget,
-            const Hwc2TestLayers& testLayers,
-            const std::set<hwc2_layer_t>& clientLayers,
-            const std::set<hwc2_layer_t>& clearLayers, bool flipClientTarget,
-            const Area& displayArea)
-    {
-        android_dataspace_t dataspace = HAL_DATASPACE_UNKNOWN;
-        hwc_region_t damage = { };
-        buffer_handle_t handle;
-        int32_t acquireFence;
-
-        ASSERT_EQ(testClientTarget->getBuffer(testLayers, clientLayers,
-                clearLayers, flipClientTarget, displayArea, &handle,
-                &acquireFence), 0);
-        EXPECT_NO_FATAL_FAILURE(setClientTarget(display, handle, acquireFence,
-                dataspace, damage));
-    }
-
-    void presentDisplays(size_t layerCnt, Hwc2TestCoverage coverage,
-            const std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>&
-            coverageExceptions, bool optimize)
-    {
-        for (auto display : mDisplays) {
-            std::vector<hwc2_config_t> configs;
-
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-            ASSERT_NO_FATAL_FAILURE(enableVsync(display));
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-            for (auto config : configs) {
-                Area displayArea;
-                std::vector<hwc2_layer_t> layers;
-
-                ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-                ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display,
-                        &displayArea));
-
-                ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-                Hwc2TestLayers testLayers(layers, coverage, displayArea,
-                        coverageExceptions);
-
-                if (optimize && !testLayers.optimizeLayouts())
-                    continue;
-
-                std::set<hwc2_layer_t> clientLayers;
-                std::set<hwc2_layer_t> clearLayers;
-                Hwc2TestClientTarget testClientTarget;
-
-                do {
-                    uint32_t numTypes, numRequests;
-                    bool hasChanges, skip;
-                    bool flipClientTarget;
-                    int32_t presentFence;
-
-                    ASSERT_NO_FATAL_FAILURE(setLayerProperties(display, layers,
-                            &testLayers, &skip));
-                    if (skip)
-                        continue;
-
-                    ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes,
-                            &numRequests, &hasChanges));
-                    if (hasChanges)
-                        EXPECT_LE(numTypes, static_cast<uint32_t>(layers.size()))
-                                << "wrong number of requests";
-
-                    ASSERT_NO_FATAL_FAILURE(handleCompositionChanges(display,
-                            testLayers, layers, numTypes, &clientLayers));
-                    ASSERT_NO_FATAL_FAILURE(handleRequests(display, layers,
-                            numRequests, &clearLayers, &flipClientTarget));
-                    ASSERT_NO_FATAL_FAILURE(setClientTarget(display,
-                            &testClientTarget, testLayers, clientLayers,
-                            clearLayers, flipClientTarget, displayArea));
-                    ASSERT_NO_FATAL_FAILURE(acceptDisplayChanges(display));
-
-                    ASSERT_NO_FATAL_FAILURE(waitForVsync());
-
-                    EXPECT_NO_FATAL_FAILURE(presentDisplay(display,
-                            &presentFence));
-
-                    ASSERT_NO_FATAL_FAILURE(closeFences(display, presentFence));
-
-                } while (testLayers.advance());
-
-                ASSERT_NO_FATAL_FAILURE(destroyLayers(display,
-                        std::move(layers)));
-            }
-
-            ASSERT_NO_FATAL_FAILURE(disableVsync(display));
-            ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        }
-    }
-
-    hwc2_device_t* mHwc2Device = nullptr;
-
-    enum class Hwc2TestHotplugStatus {
-        Init = 1,
-        Receiving,
-        Done,
-    };
-
-    std::mutex mHotplugMutex;
-    std::condition_variable mHotplugCv;
-    Hwc2TestHotplugStatus mHotplugStatus = Hwc2TestHotplugStatus::Init;
-    std::unordered_set<hwc2_display_t> mDisplays;
-
-    /* Store all created layers that have not been destroyed. If an ASSERT_*
-     * fails, then destroy the layers on exit */
-    std::set<std::pair<hwc2_display_t, hwc2_layer_t>> mLayers;
-
-    /* Store the power mode state. If it is not HWC2_POWER_MODE_OFF when
-     * tearing down the test cases, change it to HWC2_POWER_MODE_OFF */
-    std::set<hwc2_display_t> mActiveDisplays;
-
-    /* Store all created virtual displays that have not been destroyed. If an
-     * ASSERT_* fails, then destroy the virtual displays on exit */
-    std::set<hwc2_display_t> mVirtualDisplays;
-
-    std::mutex mVsyncMutex;
-    std::condition_variable mVsyncCv;
-    hwc2_display_t mVsyncDisplay;
-    int64_t mVsyncTimestamp = -1;
-};
-
-void hwc2TestHotplugCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int32_t connection)
-{
-    if (callbackData)
-        static_cast<Hwc2Test*>(callbackData)->hotplugCallback(display,
-                connection);
-}
-
-void hwc2TestVsyncCallback(hwc2_callback_data_t callbackData,
-        hwc2_display_t display, int64_t timestamp)
-{
-    if (callbackData)
-        static_cast<Hwc2Test*>(callbackData)->vsyncCallback(display,
-                timestamp);
-}
-
-void setBlendMode(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerBlendMode(display, layer,
-            testLayer->getBlendMode(), outErr));
-}
-
-void setBuffer(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    buffer_handle_t handle;
-    android::base::unique_fd acquireFence;
-    hwc2_composition_t composition = testLayer->getComposition();
-
-    if (composition == HWC2_COMPOSITION_CLIENT
-            || composition == HWC2_COMPOSITION_SOLID_COLOR
-            || composition == HWC2_COMPOSITION_SIDEBAND)
-        return;
-
-    if (testLayer->getBuffer(&handle, &acquireFence) < 0)
-        return;
-
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display, layer,
-            composition));
-    EXPECT_NO_FATAL_FAILURE(test->setLayerBuffer(display, layer,
-            handle, acquireFence, outErr));
-}
-
-void setColor(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display,
-            layer, HWC2_COMPOSITION_SOLID_COLOR));
-    ASSERT_NO_FATAL_FAILURE(test->setLayerPlaneAlpha(display,
-            layer, testLayer->getPlaneAlpha()));
-    ASSERT_NO_FATAL_FAILURE(test->setLayerBlendMode(display,
-            layer, testLayer->getBlendMode()));
-    EXPECT_NO_FATAL_FAILURE(test->setLayerColor(display, layer,
-            testLayer->getColor(), outErr));
-}
-
-void setComposition(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    hwc2_composition_t composition = testLayer->getComposition();
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display, layer,
-            composition, &err));
-    if (outErr) {
-        *outErr = err;
-        return;
-    }
-
-    if (composition != HWC2_COMPOSITION_SIDEBAND) {
-        EXPECT_EQ(err, HWC2_ERROR_NONE) << "returned wrong error code";
-    } else {
-        EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_UNSUPPORTED)
-                 << "returned wrong error code";
-    }
-}
-
-void setCursorPosition(Hwc2Test* test, hwc2_display_t display,
-        hwc2_layer_t layer, Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display,
-            layer, HWC2_COMPOSITION_CURSOR));
-
-    const hwc_rect_t cursorPosition = testLayer->getCursorPosition();
-    EXPECT_NO_FATAL_FAILURE(test->setCursorPosition(display, layer,
-            cursorPosition.left, cursorPosition.top, outErr));
-}
-
-void setDataspace(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerDataspace(display, layer,
-            testLayer->getDataspace(), outErr));
-}
-
-void setDisplayFrame(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerDisplayFrame(display, layer,
-            testLayer->getDisplayFrame(), outErr));
-}
-
-void setPlaneAlpha(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t *outErr)
-{
-    ASSERT_NO_FATAL_FAILURE(test->setLayerBlendMode(display, layer,
-            testLayer->getBlendMode()));
-    EXPECT_NO_FATAL_FAILURE(test->setLayerPlaneAlpha(display, layer,
-            testLayer->getPlaneAlpha(), outErr));
-}
-
-void setSourceCrop(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerSourceCrop(display, layer,
-            testLayer->getSourceCrop(), outErr));
-}
-
-void setSurfaceDamage(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerSurfaceDamage(display, layer,
-            testLayer->getSurfaceDamage(), outErr));
-}
-
-void setTransform(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerTransform(display, layer,
-            testLayer->getTransform(), outErr));
-}
-
-void setVisibleRegion(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerVisibleRegion(display, layer,
-            testLayer->getVisibleRegion(), outErr));
-}
-
-void setZOrder(Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-        Hwc2TestLayer* testLayer, hwc2_error_t* outErr)
-{
-    EXPECT_NO_FATAL_FAILURE(test->setLayerZOrder(display, layer,
-            testLayer->getZOrder(), outErr));
-}
-
-bool advanceBlendMode(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceBlendMode();
-}
-
-bool advanceBuffer(Hwc2TestLayer* testLayer)
-{
-    if (testLayer->advanceComposition())
-        return true;
-    return testLayer->advanceBufferArea();
-}
-
-bool advanceColor(Hwc2TestLayer* testLayer)
-{
-    /* Color depends on blend mode so advance blend mode last so color is not
-     * force to update as often */
-    if (testLayer->advancePlaneAlpha())
-        return true;
-    if (testLayer->advanceColor())
-        return true;
-    return testLayer->advanceBlendMode();
-}
-
-bool advanceComposition(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceComposition();
-}
-
-bool advanceCursorPosition(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceCursorPosition();
-}
-
-bool advanceDataspace(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceDataspace();
-}
-
-bool advanceDisplayFrame(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceDisplayFrame();
-}
-
-bool advancePlaneAlpha(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advancePlaneAlpha();
-}
-
-bool advanceSourceCrop(Hwc2TestLayer* testLayer)
-{
-    if (testLayer->advanceSourceCrop())
-        return true;
-    return testLayer->advanceBufferArea();
-}
-
-bool advanceSurfaceDamage(Hwc2TestLayer* testLayer)
-{
-    if (testLayer->advanceSurfaceDamage())
-        return true;
-    return testLayer->advanceBufferArea();
-}
-
-bool advanceTransform(Hwc2TestLayer* testLayer)
-{
-    return testLayer->advanceTransform();
-}
-
-bool advanceVisibleRegions(Hwc2TestLayers* testLayers)
-{
-    return testLayers->advanceVisibleRegions();
-}
-
-bool advanceClientTargetSupport(
-        Hwc2TestClientTargetSupport* testClientTargetSupport)
-{
-    return testClientTargetSupport->advance();
-}
-
-static const std::array<hwc2_function_descriptor_t, 42> requiredFunctions = {{
-    HWC2_FUNCTION_ACCEPT_DISPLAY_CHANGES,
-    HWC2_FUNCTION_CREATE_LAYER,
-    HWC2_FUNCTION_CREATE_VIRTUAL_DISPLAY,
-    HWC2_FUNCTION_DESTROY_LAYER,
-    HWC2_FUNCTION_DESTROY_VIRTUAL_DISPLAY,
-    HWC2_FUNCTION_DUMP,
-    HWC2_FUNCTION_GET_ACTIVE_CONFIG,
-    HWC2_FUNCTION_GET_CHANGED_COMPOSITION_TYPES,
-    HWC2_FUNCTION_GET_CLIENT_TARGET_SUPPORT,
-    HWC2_FUNCTION_GET_COLOR_MODES,
-    HWC2_FUNCTION_GET_DISPLAY_ATTRIBUTE,
-    HWC2_FUNCTION_GET_DISPLAY_CONFIGS,
-    HWC2_FUNCTION_GET_DISPLAY_NAME,
-    HWC2_FUNCTION_GET_DISPLAY_REQUESTS,
-    HWC2_FUNCTION_GET_DISPLAY_TYPE,
-    HWC2_FUNCTION_GET_DOZE_SUPPORT,
-    HWC2_FUNCTION_GET_HDR_CAPABILITIES,
-    HWC2_FUNCTION_GET_MAX_VIRTUAL_DISPLAY_COUNT,
-    HWC2_FUNCTION_GET_RELEASE_FENCES,
-    HWC2_FUNCTION_PRESENT_DISPLAY,
-    HWC2_FUNCTION_REGISTER_CALLBACK,
-    HWC2_FUNCTION_SET_ACTIVE_CONFIG,
-    HWC2_FUNCTION_SET_CLIENT_TARGET,
-    HWC2_FUNCTION_SET_COLOR_MODE,
-    HWC2_FUNCTION_SET_COLOR_TRANSFORM,
-    HWC2_FUNCTION_SET_CURSOR_POSITION,
-    HWC2_FUNCTION_SET_LAYER_BLEND_MODE,
-    HWC2_FUNCTION_SET_LAYER_BUFFER,
-    HWC2_FUNCTION_SET_LAYER_COLOR,
-    HWC2_FUNCTION_SET_LAYER_COMPOSITION_TYPE,
-    HWC2_FUNCTION_SET_LAYER_DATASPACE,
-    HWC2_FUNCTION_SET_LAYER_DISPLAY_FRAME,
-    HWC2_FUNCTION_SET_LAYER_PLANE_ALPHA,
-    HWC2_FUNCTION_SET_LAYER_SOURCE_CROP,
-    HWC2_FUNCTION_SET_LAYER_SURFACE_DAMAGE,
-    HWC2_FUNCTION_SET_LAYER_TRANSFORM,
-    HWC2_FUNCTION_SET_LAYER_VISIBLE_REGION,
-    HWC2_FUNCTION_SET_LAYER_Z_ORDER,
-    HWC2_FUNCTION_SET_OUTPUT_BUFFER,
-    HWC2_FUNCTION_SET_POWER_MODE,
-    HWC2_FUNCTION_SET_VSYNC_ENABLED,
-    HWC2_FUNCTION_VALIDATE_DISPLAY,
-}};
-
-/* TESTCASE: Tests that the HWC2 supports all required functions. */
-TEST_F(Hwc2Test, GET_FUNCTION)
-{
-    for (hwc2_function_descriptor_t descriptor : requiredFunctions) {
-        hwc2_function_pointer_t pfn = getFunction(descriptor);
-        EXPECT_TRUE(pfn) << "failed to get function "
-                << getFunctionDescriptorName(descriptor);
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 fails to retrieve and invalid function. */
-TEST_F(Hwc2Test, GET_FUNCTION_invalid_function)
-{
-    hwc2_function_pointer_t pfn = getFunction(HWC2_FUNCTION_INVALID);
-    EXPECT_FALSE(pfn) << "failed to get invalid function";
-}
-
-/* TESTCASE: Tests that the HWC2 does not return an invalid capability. */
-TEST_F(Hwc2Test, GET_CAPABILITIES)
-{
-    std::vector<hwc2_capability_t> capabilities;
-
-    getCapabilities(&capabilities);
-
-    EXPECT_EQ(std::count(capabilities.begin(), capabilities.end(),
-            HWC2_CAPABILITY_INVALID), 0);
-}
-
-static const std::array<hwc2_callback_descriptor_t, 3> callbackDescriptors = {{
-    HWC2_CALLBACK_HOTPLUG,
-    HWC2_CALLBACK_REFRESH,
-    HWC2_CALLBACK_VSYNC,
-}};
-
-/* TESTCASE: Tests that the HWC2 can successfully register all required
- * callback functions. */
-TEST_F(Hwc2Test, REGISTER_CALLBACK)
-{
-    hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-            const_cast<char*>("data"));
-
-    for (auto descriptor : callbackDescriptors) {
-        ASSERT_NO_FATAL_FAILURE(registerCallback(descriptor, data,
-                []() { return; }));
-    }
-}
-
-/* TESTCASE: Test that the HWC2 fails to register invalid callbacks. */
-TEST_F(Hwc2Test, REGISTER_CALLBACK_bad_parameter)
-{
-    hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-            const_cast<char*>("data"));
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_INVALID, data,
-            []() { return; }, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can register a callback with null data. */
-TEST_F(Hwc2Test, REGISTER_CALLBACK_null_data)
-{
-    hwc2_callback_data_t data = nullptr;
-
-    for (auto descriptor : callbackDescriptors) {
-        ASSERT_NO_FATAL_FAILURE(registerCallback(descriptor, data,
-                []() { return; }));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns the correct display type for each
- * physical display. */
-TEST_F(Hwc2Test, GET_DISPLAY_TYPE)
-{
-    for (auto display : mDisplays) {
-        hwc2_display_type_t type;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayType(display, &type));
-        EXPECT_EQ(type, HWC2_DISPLAY_TYPE_PHYSICAL) << "failed to return"
-                " correct display type";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns an error when the display type of a bad
- * display is requested. */
-TEST_F(Hwc2Test, GET_DISPLAY_TYPE_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_display_type_t type;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDisplayType(display, &type, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can create and destroy layers. */
-TEST_F(Hwc2Test, CREATE_DESTROY_LAYER)
-{
-    for (auto display : mDisplays) {
-        hwc2_layer_t layer;
-
-        ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot create a layer for a bad display */
-TEST_F(Hwc2Test, CREATE_LAYER_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_layer_t layer;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 will either support a large number of resources
- * or will return no resources. */
-TEST_F(Hwc2Test, CREATE_LAYER_no_resources)
-{
-    const size_t layerCnt = 1000;
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_layer_t> layers;
-
-        ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destroy a layer for a bad display */
-TEST_F(Hwc2Test, DESTROY_LAYER_bad_display)
-{
-    hwc2_display_t badDisplay;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&badDisplay));
-
-    for (auto display : mDisplays) {
-        hwc2_layer_t layer = 0;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(badDisplay, layer, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(badDisplay, layer, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destory a bad layer */
-TEST_F(Hwc2Test, DESTROY_LAYER_bad_layer)
-{
-    for (auto display : mDisplays) {
-        hwc2_layer_t layer;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, UINT64_MAX / 2, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, 0, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, UINT64_MAX - 1, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, 1, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, UINT64_MAX, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer + 1, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-
-        ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_LAYER) << "returned wrong error code";
-    }
-}
-
-static const std::array<hwc2_attribute_t, 2> requiredAttributes = {{
-    HWC2_ATTRIBUTE_WIDTH,
-    HWC2_ATTRIBUTE_HEIGHT,
-}};
-
-static const std::array<hwc2_attribute_t, 3> optionalAttributes = {{
-    HWC2_ATTRIBUTE_VSYNC_PERIOD,
-    HWC2_ATTRIBUTE_DPI_X,
-    HWC2_ATTRIBUTE_DPI_Y,
-}};
-
-/* TESTCASE: Tests that the HWC2 can return display attributes for a valid
- * config. */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            int32_t value;
-
-            for (auto attribute : requiredAttributes) {
-                ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                        attribute, &value));
-                EXPECT_GE(value, 0) << "missing required attribute "
-                        << getAttributeName(attribute) << " for config "
-                        << config;
-            }
-            for (auto attribute : optionalAttributes) {
-                ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                        attribute, &value));
-            }
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will return a value of -1 for an invalid
- * attribute */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE_invalid_attribute)
-{
-    const hwc2_attribute_t attribute = HWC2_ATTRIBUTE_INVALID;
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            int32_t value;
-            hwc2_error_t err = HWC2_ERROR_NONE;
-
-            ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                    attribute, &value, &err));
-            EXPECT_EQ(value, -1) << "failed to return -1 for an invalid"
-                    " attribute for config " << config;
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will fail to get attributes for a bad display */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE_bad_display)
-{
-    hwc2_display_t display;
-    const hwc2_config_t config = 0;
-    int32_t value;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    for (auto attribute : requiredAttributes) {
-        ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config, attribute,
-                &value, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-    }
-
-    for (auto attribute : optionalAttributes) {
-        ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config, attribute,
-                &value, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will fail to get attributes for a bad config */
-TEST_F(Hwc2Test, GET_DISPLAY_ATTRIBUTE_bad_config)
-{
-    for (auto display : mDisplays) {
-        hwc2_config_t config;
-        int32_t value;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getInvalidConfig(display, &config));
-
-        for (auto attribute : requiredAttributes) {
-            ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                    attribute, &value, &err));
-            EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-        }
-
-        for (auto attribute : optionalAttributes) {
-            ASSERT_NO_FATAL_FAILURE(getDisplayAttribute(display, config,
-                    attribute, &value, &err));
-            EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will get display configs for active displays */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will not get display configs for bad displays */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_config_t> configs;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs, &err));
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-    EXPECT_TRUE(configs.empty()) << "returned configs for bad display";
-}
-
-/* TESTCASE: Tests that the HWC2 will return the same config list multiple
- * times in a row. */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS_same)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs1, configs2;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs1));
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs2));
-
-        EXPECT_TRUE(std::is_permutation(configs1.begin(), configs1.end(),
-                configs2.begin())) << "returned two different config sets";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 does not return duplicate display configs */
-TEST_F(Hwc2Test, GET_DISPLAY_CONFIGS_duplicate)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        std::unordered_set<hwc2_config_t> configsSet(configs.begin(),
-                configs.end());
-        EXPECT_EQ(configs.size(), configsSet.size()) << "returned duplicate"
-                " configs";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns the active config for a display */
-TEST_F(Hwc2Test, GET_ACTIVE_CONFIG)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            hwc2_config_t activeConfig;
-
-            ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-            ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &activeConfig));
-
-            EXPECT_EQ(activeConfig, config) << "failed to get active config";
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 does not return an active config for a bad
- * display. */
-TEST_F(Hwc2Test, GET_ACTIVE_CONFIG_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_config_t activeConfig;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &activeConfig, &err));
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 either begins with a valid active config
- * or returns an error when getActiveConfig is called. */
-TEST_F(Hwc2Test, GET_ACTIVE_CONFIG_bad_config)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-        hwc2_config_t activeConfig;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        if (configs.empty())
-            return;
-
-        ASSERT_NO_FATAL_FAILURE(getActiveConfig(display, &activeConfig, &err));
-        if (err == HWC2_ERROR_NONE) {
-            EXPECT_NE(std::count(configs.begin(), configs.end(),
-                    activeConfig), 0) << "active config is not found in "
-                    " configs for display";
-        } else {
-            EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set every display config as an active
- * config */
-TEST_F(Hwc2Test, SET_ACTIVE_CONFIG)
-{
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            EXPECT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an active config for a bad display */
-TEST_F(Hwc2Test, SET_ACTIVE_CONFIG_bad_display)
-{
-    hwc2_display_t display;
-    const hwc2_config_t config = 0;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid active config */
-TEST_F(Hwc2Test, SET_ACTIVE_CONFIG_bad_config)
-{
-    for (auto display : mDisplays) {
-        hwc2_config_t config;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getInvalidConfig(display, &config));
-
-        ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_CONFIG) << "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns a valid value for getDozeSupport. */
-TEST_F(Hwc2Test, GET_DOZE_SUPPORT)
-{
-    for (auto display : mDisplays) {
-        int32_t support = -1;
-
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support));
-
-        EXPECT_TRUE(support == 0 || support == 1) << "invalid doze support value";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get doze support for a bad display. */
-TEST_F(Hwc2Test, GET_DOZE_SUPPORT_bad_display)
-{
-    hwc2_display_t display;
-    int32_t support = -1;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support, &err));
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can set all supported power modes */
-TEST_F(Hwc2Test, SET_POWER_MODE)
-{
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-
-        int32_t support = -1;
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support));
-        if (support != 1)
-            return;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a power mode for a bad display. */
-TEST_F(Hwc2Test, SET_POWER_MODE_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    int32_t support = -1;
-    ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support, &err));
-    if (support != 1)
-        return;
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE_SUSPEND,
-            &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid power mode value. */
-TEST_F(Hwc2Test, SET_POWER_MODE_bad_parameter)
-{
-    for (auto display : mDisplays) {
-        hwc2_power_mode_t mode = static_cast<hwc2_power_mode_t>(
-                HWC2_POWER_MODE_DOZE_SUSPEND + 1);
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, mode, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code "
-                << mode;
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 will return unsupported if it does not support
- * an optional power mode. */
-TEST_F(Hwc2Test, SET_POWER_MODE_unsupported)
-{
-    for (auto display : mDisplays) {
-        int32_t support = -1;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support, &err));
-        if (support == 1)
-            return;
-
-        ASSERT_EQ(support, 0) << "invalid doze support value";
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE,
-                &err));
-        EXPECT_EQ(err, HWC2_ERROR_UNSUPPORTED) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND, &err));
-        EXPECT_EQ(err, HWC2_ERROR_UNSUPPORTED) <<  "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set the same power mode multiple times. */
-TEST_F(Hwc2Test, SET_POWER_MODE_stress)
-{
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-
-        int32_t support = -1;
-        ASSERT_NO_FATAL_FAILURE(getDozeSupport(display, &support));
-        if (support != 1)
-            return;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_DOZE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND));
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display,
-                HWC2_POWER_MODE_DOZE_SUSPEND));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can enable and disable vsync on active
- * displays */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED)
-{
-    for (auto display : mDisplays) {
-        hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-                const_cast<char*>("data"));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-                []() { return; }));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 issues a valid vsync callback. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_callback)
-{
-    for (auto display : mDisplays) {
-        hwc2_display_t receivedDisplay;
-        int64_t receivedTimestamp;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(enableVsync(display));
-
-        ASSERT_NO_FATAL_FAILURE(waitForVsync(&receivedDisplay,
-                &receivedTimestamp));
-
-        EXPECT_EQ(receivedDisplay, display) << "failed to get correct display";
-        EXPECT_GE(receivedTimestamp, 0) << "failed to get valid timestamp";
-
-        ASSERT_NO_FATAL_FAILURE(disableVsync(display));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot enable a vsync for a bad display */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-            const_cast<char*>("data"));
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-            []() { return; }));
-
-    ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-
-    ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot enable an invalid vsync value */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_bad_parameter)
-{
-    for (auto display : mDisplays) {
-        hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-                const_cast<char*>("data"));
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-                []() { return; }));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_INVALID,
-                &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code";
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can enable and disable a vsync value multiple
- * times. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_stress)
-{
-    for (auto display : mDisplays) {
-        hwc2_callback_data_t data = reinterpret_cast<hwc2_callback_data_t>(
-                const_cast<char*>("data"));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(registerCallback(HWC2_CALLBACK_VSYNC, data,
-                []() { return; }));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set a vsync enable value when the display
- * is off and no callback is registered. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_no_callback_no_power)
-{
-    const uint secs = 1;
-
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        sleep(secs);
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set a vsync enable value when no callback
- * is registered. */
-TEST_F(Hwc2Test, SET_VSYNC_ENABLED_no_callback)
-{
-    const uint secs = 1;
-
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_ENABLE));
-
-        sleep(secs);
-
-        ASSERT_NO_FATAL_FAILURE(setVsyncEnabled(display, HWC2_VSYNC_DISABLE));
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 returns a display name for each display */
-TEST_F(Hwc2Test, GET_DISPLAY_NAME)
-{
-    for (auto display : mDisplays) {
-        std::string name;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayName(display, &name));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 does not return a display name for a bad
- * display */
-TEST_F(Hwc2Test, GET_DISPLAY_NAME_bad_display)
-{
-    hwc2_display_t display;
-    std::string name;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getDisplayName(display, &name, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can set basic composition types. */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setComposition, advanceComposition));
-}
-
-/* TESTCASE: Tests that the HWC2 can update a basic composition type on a
- * layer. */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setComposition, advanceComposition));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a composition type for a bad layer */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setComposition));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a bad composition type */
-TEST_F(Hwc2Test, SET_LAYER_COMPOSITION_TYPE_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadParameter(
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    hwc2_error_t* outErr) {
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerCompositionType(display,
-                        layer, HWC2_COMPOSITION_INVALID, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the cursor position of a layer. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            ::setCursorPosition, advanceCursorPosition));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the cursor position of a layer. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            ::setCursorPosition, advanceCursorPosition));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the cursor position of a layer when the
- * composition type has not been set to HWC2_COMPOSITION_CURSOR. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_composition_type_unset)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-                const hwc_rect_t cursorPosition = testLayer->getCursorPosition();
-                EXPECT_NO_FATAL_FAILURE(test->setCursorPosition(display, layer,
-                        cursorPosition.left, cursorPosition.top, outErr));
-            },
-
-            advanceCursorPosition));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the cursor position of a bad
- * display. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_layer_t layer = 0;
-    int32_t x = 0, y = 0;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setCursorPosition(display, layer, x, y, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the cursor position of a bad layer. */
-TEST_F(Hwc2Test, SET_CURSOR_POSITION_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                const hwc_rect_t cursorPosition = testLayer->getCursorPosition();
-                EXPECT_NO_FATAL_FAILURE(test->setCursorPosition(display,
-                        badLayer, cursorPosition.left, cursorPosition.top,
-                        outErr));
-            }
-   ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set a blend mode value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setBlendMode, advanceBlendMode));
-}
-
-/* TESTCASE: Tests that the HWC2 can update a blend mode value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setBlendMode, advanceBlendMode));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a blend mode for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setBlendMode));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid blend mode. */
-TEST_F(Hwc2Test, SET_LAYER_BLEND_MODE_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadParameter(
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    hwc2_error_t* outErr) {
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerBlendMode(display,
-                        layer, HWC2_BLEND_MODE_INVALID, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the buffer of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setBuffer, advanceBuffer));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the buffer of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setBuffer, advanceBuffer));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the buffer of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                buffer_handle_t handle = nullptr;
-                android::base::unique_fd acquireFence;
-
-                /* If there is not available buffer for the given buffer
-                 * properties, it should not fail this test case */
-                if (testLayer->getBuffer(&handle, &acquireFence) == 0) {
-                    *outErr = HWC2_ERROR_BAD_LAYER;
-                    return;
-                }
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerBuffer(display, badLayer,
-                        handle, acquireFence, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set an invalid buffer for a layer. */
-TEST_F(Hwc2Test, SET_LAYER_BUFFER_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadParameter(
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    hwc2_error_t* outErr) {
-
-                buffer_handle_t handle = nullptr;
-                int32_t acquireFence = -1;
-
-                ASSERT_NO_FATAL_FAILURE(test->setLayerBuffer(display, layer,
-                        handle, acquireFence, outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the color of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setColor, advanceColor));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the color of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setColor, advanceColor));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the color of a layer when the
- * composition type has not been set to HWC2_COMPOSITION_SOLID_COLOR. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR_composition_type_unset)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Basic,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerColor(display, layer,
-                        testLayer->getColor(), outErr));
-            },
-
-            advanceColor));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the color of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_COLOR_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t* outErr) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerColor(display, badLayer,
-                        testLayer->getColor(), outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the dataspace of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DATASPACE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setDataspace, advanceDataspace));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the dataspace of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DATASPACE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setDataspace, advanceDataspace));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a dataspace for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_DATASPACE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setDataspace));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the display frame of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DISPLAY_FRAME)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setDisplayFrame, advanceDisplayFrame));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the display frame of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_DISPLAY_FRAME_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setDisplayFrame, advanceDisplayFrame));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the display frame of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_DISPLAY_FRAME_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setDisplayFrame));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the plane alpha of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_PLANE_ALPHA)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setPlaneAlpha, advancePlaneAlpha));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the plane alpha of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_PLANE_ALPHA_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setPlaneAlpha, advancePlaneAlpha));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a plane alpha for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_PLANE_ALPHA_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t badLayer,
-                    Hwc2TestLayer* testLayer, hwc2_error_t *outErr) {
-
-                    EXPECT_NO_FATAL_FAILURE(test->setLayerPlaneAlpha(display,
-                            badLayer, testLayer->getPlaneAlpha(), outErr));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the source crop of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SOURCE_CROP)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setSourceCrop, advanceSourceCrop));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the source crop of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SOURCE_CROP_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setSourceCrop, advanceSourceCrop));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the source crop of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_SOURCE_CROP_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setSourceCrop));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the surface damage of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SURFACE_DAMAGE)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setSurfaceDamage, advanceSurfaceDamage));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the surface damage of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_SURFACE_DAMAGE_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setSurfaceDamage, advanceSurfaceDamage));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the surface damage of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_SURFACE_DAMAGE_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setSurfaceDamage));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the transform value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_TRANSFORM)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperty(Hwc2TestCoverage::Complete,
-            setTransform, advanceTransform));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the transform value of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_TRANSFORM_update)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyUpdate(Hwc2TestCoverage::Complete,
-            setTransform, advanceTransform));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the transform for a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_TRANSFORM_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setTransform));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the visible region of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_VISIBLE_REGION)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperties(Hwc2TestCoverage::Basic, 5,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayers* testLayers) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerVisibleRegion(display,
-                        layer, testLayers->getVisibleRegion(layer)));
-            },
-
-            advanceVisibleRegions));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the visible region of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_VISIBLE_REGION_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setVisibleRegion));
-}
-
-/* TESTCASE: Tests that the HWC2 can set the z order of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_Z_ORDER)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerProperties(Hwc2TestCoverage::Complete, 10,
-            [] (Hwc2Test* test, hwc2_display_t display, hwc2_layer_t layer,
-                    Hwc2TestLayers* testLayers) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setLayerZOrder(display, layer,
-                        testLayers->getZOrder(layer)));
-            },
-
-            /* TestLayer z orders are set during the construction of TestLayers
-             * and cannot be updated. There is no need (or ability) to cycle
-             * through additional z order configurations. */
-            [] (Hwc2TestLayers* /*testLayers*/) {
-                return false;
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can update the z order of a layer. */
-TEST_F(Hwc2Test, SET_LAYER_Z_ORDER_update)
-{
-    const std::vector<uint32_t> zOrders = { static_cast<uint32_t>(0),
-            static_cast<uint32_t>(1), static_cast<uint32_t>(UINT32_MAX / 4),
-            static_cast<uint32_t>(UINT32_MAX / 2),
-            static_cast<uint32_t>(UINT32_MAX) };
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            hwc2_layer_t layer;
-
-            ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-
-            ASSERT_NO_FATAL_FAILURE(createLayer(display, &layer));
-
-            for (uint32_t zOrder : zOrders) {
-                EXPECT_NO_FATAL_FAILURE(setLayerZOrder(display, layer, zOrder));
-            }
-
-            ASSERT_NO_FATAL_FAILURE(destroyLayer(display, layer));
-        }
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the z order of a bad layer. */
-TEST_F(Hwc2Test, SET_LAYER_Z_ORDER_bad_layer)
-{
-    ASSERT_NO_FATAL_FAILURE(setLayerPropertyBadLayer(Hwc2TestCoverage::Default,
-            setZOrder));
-}
-
-/* TESTCASE: Tests that the HWC2 can display a layer with basic property
- * coverage */
-TEST_F(Hwc2Test, VALIDATE_DISPLAY_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                EXPECT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, static_cast<uint32_t>(layers.size()))
-                            << "wrong number of requests";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can display 5 layers with default coverage. */
-TEST_F(Hwc2Test, VALIDATE_DISPLAY_default_5)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Default, 5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                EXPECT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, static_cast<uint32_t>(layers.size()))
-                            << "wrong number of requests";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot validate a bad display */
-TEST_F(Hwc2Test, VALIDATE_DISPLAY_bad_display)
-{
-    hwc2_display_t display;
-    uint32_t numTypes, numRequests;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes, &numRequests,
-            &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can get display requests after validating a
- * basic layer. */
-TEST_F(Hwc2Test, GET_DISPLAY_REQUESTS_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                ASSERT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                EXPECT_NO_FATAL_FAILURE(test->handleRequests(display, layers,
-                        numRequests));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get display requests from a bad display */
-TEST_F(Hwc2Test, GET_DISPLAY_REQUESTS_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_display_request_t displayRequests;
-    std::vector<hwc2_layer_t> layers;
-    std::vector<hwc2_layer_request_t> layerRequests;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    EXPECT_NO_FATAL_FAILURE(getDisplayRequests(display, &displayRequests,
-            &layers, &layerRequests, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get display requests from an non
- * validated display. */
-TEST_F(Hwc2Test, GET_DISPLAY_REQUESTS_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayNonValidatedLayers(5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    std::vector<hwc2_layer_t>* layers) {
-
-                hwc2_display_request_t displayRequests;
-                std::vector<hwc2_layer_request_t> layerRequests;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getDisplayRequests(display,
-                        &displayRequests, layers, &layerRequests, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can get changed composition types after
- * validating a basic layer. */
-TEST_F(Hwc2Test, GET_CHANGED_COMPOSITION_TYPES_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* testLayers) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                ASSERT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                EXPECT_NO_FATAL_FAILURE(test->handleCompositionChanges(display,
-                        *testLayers, layers, numTypes));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get changed composition types from a bad
- * display */
-TEST_F(Hwc2Test, GET_CHANGED_COMPOSITION_TYPES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_layer_t> layers;
-    std::vector<hwc2_composition_t> types;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    EXPECT_NO_FATAL_FAILURE(getChangedCompositionTypes(display, &layers,
-            &types, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get changed composition types from an non
- * validated display. */
-TEST_F(Hwc2Test, GET_CHANGED_COMPOSITION_TYPES_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayNonValidatedLayers(5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    std::vector<hwc2_layer_t>* layers) {
-
-                std::vector<hwc2_composition_t> types;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getChangedCompositionTypes(
-                        display, layers, &types, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can accept display changes after validating a
- * basic layer. */
-TEST_F(Hwc2Test, ACCEPT_DISPLAY_CHANGES_basic)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Basic, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& layers,
-                    Hwc2TestLayers* testLayers) {
-
-                uint32_t numTypes, numRequests;
-                bool hasChanges = false;
-
-                ASSERT_NO_FATAL_FAILURE(test->validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                ASSERT_NO_FATAL_FAILURE(test->handleCompositionChanges(display,
-                        *testLayers, layers, numTypes));
-
-                EXPECT_NO_FATAL_FAILURE(test->acceptDisplayChanges(display));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot accept display changes from a bad
- * display */
-TEST_F(Hwc2Test, ACCEPT_DISPLAY_CHANGES_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    EXPECT_NO_FATAL_FAILURE(acceptDisplayChanges(display, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot accept display changes from an non
- * validated display. */
-TEST_F(Hwc2Test, ACCEPT_DISPLAY_CHANGES_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayNonValidatedLayers(5,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    std::vector<hwc2_layer_t>* /*layers*/) {
-
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->acceptDisplayChanges(display, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 supports client target with required values */
-TEST_F(Hwc2Test, GET_CLIENT_TARGET_SUPPORT)
-{
-    ASSERT_NO_FATAL_FAILURE(setClientTargetSupport(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const Hwc2TestClientTargetSupport& testClientTargetSupport) {
-
-                const Area bufferArea = testClientTargetSupport.getBufferArea();
-                const android_pixel_format_t format = HAL_PIXEL_FORMAT_RGBA_8888;
-
-                ASSERT_NO_FATAL_FAILURE(test->getClientTargetSupport(display,
-                        bufferArea.width, bufferArea.height, format,
-                        testClientTargetSupport.getDataspace()));
-            },
-
-            advanceClientTargetSupport));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get client target support for a bad
- * display. */
-TEST_F(Hwc2Test, GET_CLIENT_TARGET_SUPPORT_bad_display)
-{
-    ASSERT_NO_FATAL_FAILURE(setClientTargetSupport(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t /*display*/,
-                    const Hwc2TestClientTargetSupport& testClientTargetSupport) {
-
-                const Area bufferArea = testClientTargetSupport.getBufferArea();
-                const android_pixel_format_t format = HAL_PIXEL_FORMAT_RGBA_8888;
-                hwc2_display_t badDisplay;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getBadDisplay(&badDisplay));
-
-                ASSERT_NO_FATAL_FAILURE(test->getClientTargetSupport(badDisplay,
-                        bufferArea.width, bufferArea.height, format,
-                        testClientTargetSupport.getDataspace(), &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-            },
-
-            advanceClientTargetSupport));
-}
-
-/* TESTCASE: Tests that the HWC2 either supports or returns error unsupported
- * for a variety of client target values. */
-TEST_F(Hwc2Test, GET_CLIENT_TARGET_SUPPORT_unsupported)
-{
-    ASSERT_NO_FATAL_FAILURE(setClientTargetSupport(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const Hwc2TestClientTargetSupport& testClientTargetSupport) {
-
-                const Area bufferArea = testClientTargetSupport.getBufferArea();
-                const android_pixel_format_t format = HAL_PIXEL_FORMAT_RGBA_8888;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getClientTargetSupport(display,
-                        bufferArea.width, bufferArea.height, format,
-                        testClientTargetSupport.getDataspace(), &err));
-                EXPECT_TRUE(err == HWC2_ERROR_NONE
-                        || err == HWC2_ERROR_UNSUPPORTED)
-                        << "returned wrong error code";
-            },
-
-            advanceClientTargetSupport));
-}
-
-/* TESTCASE: Tests that the HWC2 can set a client target buffer for a basic
- * layer. */
-TEST_F(Hwc2Test, SET_CLIENT_TARGET_basic)
-{
-    const android_dataspace_t dataspace = HAL_DATASPACE_UNKNOWN;
-    const hwc_region_t damage = { };
-    const size_t layerCnt = 1;
-
-    for (auto display : mDisplays) {
-        std::vector<hwc2_config_t> configs;
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_ON));
-
-        ASSERT_NO_FATAL_FAILURE(getDisplayConfigs(display, &configs));
-
-        for (auto config : configs) {
-            Area displayArea;
-            std::vector<hwc2_layer_t> layers;
-
-            ASSERT_NO_FATAL_FAILURE(setActiveConfig(display, config));
-            ASSERT_NO_FATAL_FAILURE(getActiveDisplayArea(display, &displayArea));
-
-            ASSERT_NO_FATAL_FAILURE(createLayers(display, &layers, layerCnt));
-            Hwc2TestLayers testLayers(layers, Hwc2TestCoverage::Basic,
-                    displayArea);
-
-            if (!testLayers.optimizeLayouts())
-                continue;
-
-            Hwc2TestClientTarget testClientTarget;
-
-            do {
-                std::set<hwc2_layer_t> clientLayers;
-                std::set<hwc2_layer_t> clearLayers;
-                uint32_t numTypes, numRequests;
-                bool hasChanges, skip;
-                bool flipClientTarget;
-                buffer_handle_t handle;
-                int32_t acquireFence;
-
-                ASSERT_NO_FATAL_FAILURE(setLayerProperties(display, layers,
-                        &testLayers, &skip));
-                if (skip)
-                    continue;
-
-                ASSERT_NO_FATAL_FAILURE(validateDisplay(display, &numTypes,
-                        &numRequests, &hasChanges));
-                if (hasChanges)
-                    EXPECT_LE(numTypes, layers.size())
-                            << "wrong number of requests";
-
-                ASSERT_NO_FATAL_FAILURE(handleCompositionChanges(display,
-                        testLayers, layers, numTypes, &clientLayers));
-                ASSERT_NO_FATAL_FAILURE(handleRequests(display, layers,
-                        numRequests, &clearLayers, &flipClientTarget));
-                ASSERT_EQ(testClientTarget.getBuffer(testLayers, clientLayers,
-                        clearLayers, flipClientTarget, displayArea, &handle,
-                        &acquireFence), 0);
-                EXPECT_NO_FATAL_FAILURE(setClientTarget(display, handle,
-                        acquireFence, dataspace, damage));
-
-                if (acquireFence >= 0)
-                    close(acquireFence);
-
-            } while (testLayers.advance());
-
-            ASSERT_NO_FATAL_FAILURE(destroyLayers(display, std::move(layers)));
-        }
-
-        ASSERT_NO_FATAL_FAILURE(setPowerMode(display, HWC2_POWER_MODE_OFF));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a client target for a bad display. */
-TEST_F(Hwc2Test, SET_CLIENT_TARGET_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_layer_t> layers;
-    const Area displayArea = {0, 0};
-    Hwc2TestLayers testLayers(layers, Hwc2TestCoverage::Default, displayArea);
-    std::set<hwc2_layer_t> clientLayers;
-    std::set<hwc2_layer_t> flipClientTargetLayers;
-    bool flipClientTarget = true;
-    const android_dataspace_t dataspace = HAL_DATASPACE_UNKNOWN;
-    const hwc_region_t damage = { };
-    buffer_handle_t handle;
-    int32_t acquireFence;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    Hwc2TestClientTarget testClientTarget;
-
-    ASSERT_EQ(testClientTarget.getBuffer(testLayers, clientLayers,
-            flipClientTargetLayers, flipClientTarget, displayArea, &handle,
-            &acquireFence), 0);
-
-    EXPECT_NO_FATAL_FAILURE(setClientTarget(display, handle, acquireFence,
-            dataspace, damage, &err));
-
-    if (acquireFence >= 0)
-        close(acquireFence);
-
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 default layer. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 3 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_3)
-{
-    const size_t layerCnt = 3;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 4 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_4)
-{
-    const size_t layerCnt = 4;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 5 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_5)
-{
-    const size_t layerCnt = 5;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 6 default layers. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_default_6)
-{
-    const size_t layerCnt = 6;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * blend mode. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_blend_mode_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::Transform, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Basic}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * blend mode. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_blend_mode_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Basic}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * buffer. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_buffer_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BufferArea, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * color. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_color_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::Color, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * color. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_color_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::Color, Hwc2TestCoverage::Basic}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * composition. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_composition_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * cursor. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_cursor_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::CursorPosition, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * cursor. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_cursor_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Composition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::CursorPosition, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Basic}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * dataspace. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_dataspace_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Dataspace, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 3 layers with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_3)
-{
-    const size_t layerCnt = 3;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 4 layers with complete coverage of
- * display frame. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_display_frame_4)
-{
-    const size_t layerCnt = 4;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * plane alpha. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_plane_alpha_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Complete}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * plane alpha. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_plane_alpha_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::BlendMode, Hwc2TestCoverage::Basic},
-            {Hwc2TestPropertyName::PlaneAlpha, Hwc2TestCoverage::Complete}};
-    bool optimize = false;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * source crop. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_source_crop_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::SourceCrop, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * source crop. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_source_crop_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::SourceCrop, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * surface damage. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_surface_damage_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::SurfaceDamage, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * transform. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_transform_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Transform, Hwc2TestCoverage::Complete}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 2 layers with complete coverage of
- * transform. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_transform_2)
-{
-    const size_t layerCnt = 2;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Default;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions =
-            {{Hwc2TestPropertyName::Transform, Hwc2TestCoverage::Complete},
-            {Hwc2TestPropertyName::DisplayFrame, Hwc2TestCoverage::Basic}};
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 can present 1 layer with complete coverage of
- * basic. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_basic_1)
-{
-    const size_t layerCnt = 1;
-    Hwc2TestCoverage coverage = Hwc2TestCoverage::Basic;
-    std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage> exceptions;
-    bool optimize = true;
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplays(layerCnt, coverage, exceptions,
-            optimize));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot present a bad display.  */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_bad_display)
-{
-    hwc2_display_t display;
-    int32_t presentFence;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(presentDisplay(display, &presentFence, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot present an unvalidated display. */
-TEST_F(Hwc2Test, PRESENT_DISPLAY_not_validated)
-{
-    ASSERT_NO_FATAL_FAILURE(displayLayers(Hwc2TestCoverage::Default, 1,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    const std::vector<hwc2_layer_t>& /*layers*/,
-                    Hwc2TestLayers* /*testLayers*/) {
-
-                int32_t presentFence;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setPowerMode(display,
-                        HWC2_POWER_MODE_ON));
-                ASSERT_NO_FATAL_FAILURE(test->enableVsync(display));
-
-                ASSERT_NO_FATAL_FAILURE(test->waitForVsync());
-
-                ASSERT_NO_FATAL_FAILURE(test->presentDisplay(display,
-                        &presentFence, &err));
-                EXPECT_EQ(err, HWC2_ERROR_NOT_VALIDATED)
-                        << "returned wrong error code";
-
-                ASSERT_NO_FATAL_FAILURE(test->disableVsync(display));
-                ASSERT_NO_FATAL_FAILURE(test->setPowerMode(display,
-                        HWC2_POWER_MODE_OFF));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get release fences from a bad display. */
-TEST_F(Hwc2Test, GET_RELEASE_FENCES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<hwc2_layer_t> layers;
-    std::vector<int32_t> fences;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getReleaseFences(display, &layers, &fences, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-static const std::array<android_color_mode, 9> androidColorModes = {{
-    HAL_COLOR_MODE_NATIVE,
-    HAL_COLOR_MODE_STANDARD_BT601_625,
-    HAL_COLOR_MODE_STANDARD_BT601_625_UNADJUSTED,
-    HAL_COLOR_MODE_STANDARD_BT601_525,
-    HAL_COLOR_MODE_STANDARD_BT601_525_UNADJUSTED,
-    HAL_COLOR_MODE_STANDARD_BT709,
-    HAL_COLOR_MODE_DCI_P3,
-    HAL_COLOR_MODE_SRGB,
-    HAL_COLOR_MODE_ADOBE_RGB,
-}};
-
-/* TESTCASE: Tests that the HWC2 can get the color modes for a display. The
- * display must support HAL_COLOR_MODE_NATIVE */
-TEST_F(Hwc2Test, GET_COLOR_MODES)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                std::vector<android_color_mode_t> colorModes;
-
-                ASSERT_NO_FATAL_FAILURE(test->getColorModes(display,
-                        &colorModes));
-
-                EXPECT_NE(std::count(colorModes.begin(), colorModes.end(),
-                        HAL_COLOR_MODE_NATIVE), 0) << "all displays"
-                        " must support HAL_COLOR_MODE_NATIVE";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get color modes from a bad display. */
-TEST_F(Hwc2Test, GET_COLOR_MODES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<android_color_mode_t> colorModes;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getColorModes(display, &colorModes, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 can set the required color mode on a display. */
-TEST_F(Hwc2Test, SET_COLOR_MODES)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const android_color_mode_t colorMode = HAL_COLOR_MODE_NATIVE;
-
-                EXPECT_NO_FATAL_FAILURE(test->setColorMode(display, colorMode));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set a color mode on a bad display. */
-TEST_F(Hwc2Test, SET_COLOR_MODES_bad_display)
-{
-    hwc2_display_t display;
-    const android_color_mode_t colorMode = HAL_COLOR_MODE_NATIVE;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setColorMode(display, colorMode, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid color mode. */
-TEST_F(Hwc2Test, SET_COLOR_MODES_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const android_color_mode_t colorMode =
-                        static_cast<android_color_mode_t>(-1);
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setColorMode(display, colorMode,
-                        &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 either supports or returns error unsupported
- * for all valid color modes. */
-TEST_F(Hwc2Test, SET_COLOR_MODES_unsupported)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                for (auto colorMode : androidColorModes) {
-                    hwc2_error_t err = HWC2_ERROR_NONE;
-
-                    ASSERT_NO_FATAL_FAILURE(test->setColorMode(display,
-                            colorMode, &err));
-
-                    EXPECT_TRUE(err == HWC2_ERROR_NONE
-                            || err == HWC2_ERROR_UNSUPPORTED)
-                            << "returned wrong error code";
-                }
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 gets the HDR capabilities for a display and
- * test if they are valid. */
-TEST_F(Hwc2Test, GET_HDR_CAPABILITIES)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                std::vector<android_hdr_t> hdrCapabilities;
-                float maxLuminance, maxAverageLuminance, minLuminance;
-
-                EXPECT_NO_FATAL_FAILURE(test->getHdrCapabilities(display,
-                        &hdrCapabilities, &maxLuminance, &maxAverageLuminance,
-                        &minLuminance));
-
-                if (hdrCapabilities.empty())
-                    return;
-
-                EXPECT_GE(maxLuminance, maxAverageLuminance);
-                EXPECT_GE(maxAverageLuminance, minLuminance);
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot get hdr capabilities from a bad display */
-TEST_F(Hwc2Test, GET_HDR_CAPABILITIES_bad_display)
-{
-    hwc2_display_t display;
-    std::vector<android_hdr_t> hdrCapabilities;
-    float maxLuminance, maxAverageLuminance, minLuminance;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(getHdrCapabilities(display, &hdrCapabilities,
-            &maxLuminance, &maxAverageLuminance, &minLuminance, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-static const std::array<float, 16> identityMatrix = {{
-    1.0,  0.0,  0.0,  0.0,
-    0.0,  1.0,  0.0,  0.0,
-    0.0,  0.0,  1.0,  0.0,
-    0.0,  0.0,  0.0,  1.0,
-}};
-
-/* Values for the color transform matrices were precomputed using the source code
- * in surfaceflinger/Effects/Daltonizer.cpp. */
-
-static const std::array<const std::array<float, 16>, 5> exampleMatrices = {{
-    identityMatrix,
-    /* Converts RGB color to the XYZ space */
-    {{ 0.4124, 0.2126, 0.0193, 0,
-       0.3576, 0.7152, 0.1192, 0,
-       0.1805, 0.0722, 0.9505, 0,
-       0     , 0     , 0     , 1 }},
-    /* Protanomaly */
-    {{ 0.068493,  0.931506,  0,  0,
-       0.068493,  0.931507,  0,  0,
-       0.013626, -0.013626,  1,  0,
-       0,         0,         0,  1 }},
-    /* Deuteranomaly */
-    {{ 0.288299, 0.711701,  0,  0,
-       0.052709, 0.947291,  0,  0,
-      -0.257912, 0.257912,  1,  0,
-       0,        0,         0,  1 }},
-    /* Tritanomaly */
-    {{ 1, -0.805712, 0.805712,  0,
-       0,  0.378838, 0.621162,  0,
-       0,  0.104823, 0.895177,  0,
-       0,  0,        0,         1 }},
-}};
-
-/* TESTCASE: Tests that the HWC2 can set the identity color transform */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                EXPECT_NO_FATAL_FAILURE(test->setColorTransform(display,
-                        identityMatrix, HAL_COLOR_TRANSFORM_IDENTITY));
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set the color transform for a bad
- * display. */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(setColorTransform(display, identityMatrix,
-            HAL_COLOR_TRANSFORM_IDENTITY, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid color transform. */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const android_color_transform_t hint =
-                        static_cast<android_color_transform_t>(-1);
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setColorTransform(display,
-                        identityMatrix, hint, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER)
-                        << "returned wrong error code";
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 can set an arbitrary color matrix. */
-TEST_F(Hwc2Test, SET_COLOR_TRANSFORM_arbitrary_matrix)
-{
-    ASSERT_NO_FATAL_FAILURE(setActiveDisplayConfig(
-            [] (Hwc2Test* test, hwc2_display_t display) {
-
-                const android_color_transform_t hint =
-                        HAL_COLOR_TRANSFORM_ARBITRARY_MATRIX;
-
-                for (const std::array<float, 16>& matrix : exampleMatrices) {
-                    EXPECT_NO_FATAL_FAILURE(test->setColorTransform(display,
-                            matrix, hint));
-                }
-            }
-    ));
-}
-
-/* TESTCASE: Tests that the HWC2 create an destory virtual displays. */
-TEST_F(Hwc2Test, CREATE_DESTROY_VIRTUAL_DISPLAY)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* /*test*/, hwc2_display_t /*display*/,
-                    Hwc2TestVirtualDisplay* /*testVirtualDisplay*/) { }));
-}
-
-/* TESTCASE: Tests that the HWC2 can create and destroy multiple virtual
- * displays. */
-TEST_F(Hwc2Test, CREATE_DESTROY_VIRTUAL_DISPLAY_multiple)
-{
-    Hwc2TestVirtualDisplay testVirtualDisplay(Hwc2TestCoverage::Complete);
-    std::vector<hwc2_display_t> displays;
-
-    do {
-        const UnsignedArea& dimension =
-                testVirtualDisplay.getDisplayDimension();
-        android_pixel_format_t desiredFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-        hwc2_display_t display;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(dimension.width,
-                dimension.height, &desiredFormat, &display, &err));
-
-        EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_NO_RESOURCES
-                || err == HWC2_ERROR_UNSUPPORTED) << "returned wrong error code";
-        EXPECT_GE(desiredFormat, 0) << "invalid format";
-
-        if (err == HWC2_ERROR_NONE)
-            displays.push_back(display);
-
-    } while (testVirtualDisplay.advance());
-
-    for (hwc2_display_t display : displays) {
-        EXPECT_NO_FATAL_FAILURE(destroyVirtualDisplay(display));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destroy a bad virtual displays.  */
-TEST_F(Hwc2Test, DESTROY_VIRTUAL_DISPLAY_bad_display)
-{
-    hwc2_display_t display;
-    hwc2_error_t err = HWC2_ERROR_NONE;
-
-    ASSERT_NO_FATAL_FAILURE(getBadDisplay(&display));
-
-    ASSERT_NO_FATAL_FAILURE(destroyVirtualDisplay(display, &err));
-    EXPECT_EQ(err, HWC2_ERROR_BAD_DISPLAY) << "returned wrong error code";
-}
-
-/* TESTCASE: Tests that the HWC2 cannot destroy a physical display. */
-TEST_F(Hwc2Test, DESTROY_VIRTUAL_DISPLAY_bad_parameter)
-{
-    hwc2_error_t err = HWC2_ERROR_NONE;
-    for (auto display : mDisplays) {
-        ASSERT_NO_FATAL_FAILURE(destroyVirtualDisplay(display, &err));
-        EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER) << "returned wrong error code";
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can get the max virtual display count. */
-TEST_F(Hwc2Test, GET_MAX_VIRTUAL_DISPLAY_COUNT)
-{
-    uint32_t maxCnt;
-
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt));
-}
-
-/* TESTCASE: Tests that the HWC2 returns the same max virtual display count for
- * each call. */
-TEST_F(Hwc2Test, GET_MAX_VIRTUAL_DISPLAY_COUNT_duplicate)
-{
-    uint32_t maxCnt1, maxCnt2;
-
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt1));
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt2));
-
-    EXPECT_EQ(maxCnt1, maxCnt2) << "returned two different max virtual display"
-            " counts";
-}
-
-/* TESTCASE: Tests that the HWC2 can create the max number of virtual displays
- * that it reports. */
-TEST_F(Hwc2Test, GET_MAX_VIRTUAL_DISPLAY_COUNT_create_max)
-{
-    std::vector<hwc2_display_t> displays;
-    uint32_t maxCnt;
-
-    ASSERT_NO_FATAL_FAILURE(getMaxVirtualDisplayCount(&maxCnt));
-
-    while (displays.size() < maxCnt) {
-        uint32_t width = 1920, height = 1080;
-        android_pixel_format_t desiredFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-        hwc2_display_t display;
-        hwc2_error_t err = HWC2_ERROR_NONE;
-
-        ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(width, height,
-                    &desiredFormat, &display, &err));
-
-        EXPECT_TRUE(err == HWC2_ERROR_NONE || err == HWC2_ERROR_UNSUPPORTED)
-                << "returned wrong error code";
-        if (err != HWC2_ERROR_NONE)
-            break;
-
-        displays.push_back(display);
-    }
-
-    for (hwc2_display_t display : displays) {
-        EXPECT_NO_FATAL_FAILURE(destroyVirtualDisplay(display));
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can set an output buffer for a virtual
- * display. */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Complete,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    Hwc2TestVirtualDisplay* testVirtualDisplay) {
-
-                buffer_handle_t handle;
-                android::base::unique_fd acquireFence;
-
-                if (testVirtualDisplay->getBuffer(&handle, &acquireFence) >= 0)
-                    EXPECT_NO_FATAL_FAILURE(test->setOutputBuffer(display,
-                            handle, acquireFence));
-            }));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an output buffer for a bad display */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER_bad_display)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t /*display*/,
-                    Hwc2TestVirtualDisplay* testVirtualDisplay) {
-
-                hwc2_display_t badDisplay;
-                buffer_handle_t handle;
-                android::base::unique_fd acquireFence;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->getBadDisplay(&badDisplay));
-
-                if (testVirtualDisplay->getBuffer(&handle, &acquireFence) < 0)
-                    return;
-
-                ASSERT_NO_FATAL_FAILURE(test->setOutputBuffer(badDisplay,
-                        handle, acquireFence, &err));
-                EXPECT_TRUE(err == HWC2_ERROR_BAD_DISPLAY)
-                        << "returned wrong error code";
-            }));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an invalid output buffer. */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER_bad_parameter)
-{
-    ASSERT_NO_FATAL_FAILURE(createVirtualDisplay(Hwc2TestCoverage::Default,
-            [] (Hwc2Test* test, hwc2_display_t display,
-                    Hwc2TestVirtualDisplay* /*testVirtualDisplay*/) {
-
-                const buffer_handle_t handle = nullptr;
-                uint32_t releaseFence = -1;
-                hwc2_error_t err = HWC2_ERROR_NONE;
-
-                ASSERT_NO_FATAL_FAILURE(test->setOutputBuffer(display, handle,
-                        releaseFence, &err));
-                EXPECT_EQ(err, HWC2_ERROR_BAD_PARAMETER)
-                        << "returned wrong error code";
-            }));
-}
-
-/* TESTCASE: Tests that the HWC2 cannot set an output buffer for non virtual
- * display */
-TEST_F(Hwc2Test, SET_OUTPUT_BUFFER_unsupported)
-{
-    for (auto display : mDisplays) {
-        Hwc2TestVirtualDisplay testVirtualDisplay(Hwc2TestCoverage::Complete);
-
-        do {
-            buffer_handle_t handle;
-            android::base::unique_fd acquireFence;
-            hwc2_error_t err = HWC2_ERROR_NONE;
-
-            if (testVirtualDisplay.getBuffer(&handle, &acquireFence) < 0)
-                continue;
-
-            ASSERT_NO_FATAL_FAILURE(setOutputBuffer(display, handle,
-                    acquireFence, &err));
-            EXPECT_EQ(err, HWC2_ERROR_UNSUPPORTED) << "returned wrong error code";
-
-        } while (testVirtualDisplay.advance());
-    }
-}
-
-/* TESTCASE: Tests that the HWC2 can dump debug information. */
-TEST_F(Hwc2Test, DUMP)
-{
-    std::string buffer;
-
-    ASSERT_NO_FATAL_FAILURE(dump(&buffer));
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp
deleted file mode 100644
index 1d3a1d38ac..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.cpp
+++ /dev/null
@@ -1,695 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <mutex>
-#include <array>
-#include <sstream>
-#include <algorithm>
-
-#include <gui/Surface.h>
-#include <gui/BufferItemConsumer.h>
-
-#include <ui/GraphicBuffer.h>
-#include <math/vec4.h>
-
-#include <GLES3/gl3.h>
-
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestLayers.h"
-
-using namespace android;
-
-/* Returns a fence from egl */
-typedef void (*FenceCallback)(int32_t fence, void* callbackArgs);
-
-/* Returns fence to fence generator */
-static void setFence(int32_t fence, void* fenceGenerator);
-
-
-/* Used to receive the surfaces and fences from egl. The egl buffers are thrown
- * away. The fences are sent to the requester via a callback */
-class Hwc2TestSurfaceManager {
-public:
-    /* Listens for a new frame, detaches the buffer and returns the fence
-     * through saved callback. */
-    class BufferListener : public ConsumerBase::FrameAvailableListener {
-    public:
-        BufferListener(sp<IGraphicBufferConsumer> consumer,
-                FenceCallback callback, void* callbackArgs)
-            : mConsumer(consumer),
-              mCallback(callback),
-              mCallbackArgs(callbackArgs) { }
-
-        void onFrameAvailable(const BufferItem& /*item*/)
-        {
-            BufferItem item;
-
-            if (mConsumer->acquireBuffer(&item, 0))
-                return;
-            if (mConsumer->detachBuffer(item.mSlot))
-                return;
-
-            mCallback(item.mFence->dup(), mCallbackArgs);
-        }
-
-    private:
-        sp<IGraphicBufferConsumer> mConsumer;
-        FenceCallback mCallback;
-        void* mCallbackArgs;
-    };
-
-    /* Creates a buffer listener that waits on a new frame from the buffer
-     * queue. */
-    void initialize(const Area& bufferArea, android_pixel_format_t format,
-            FenceCallback callback, void* callbackArgs)
-    {
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-
-        consumer->setDefaultBufferSize(bufferArea.width, bufferArea.height);
-        consumer->setDefaultBufferFormat(format);
-
-        mBufferItemConsumer = new BufferItemConsumer(consumer, 0);
-
-        mListener = new BufferListener(consumer, callback, callbackArgs);
-        mBufferItemConsumer->setFrameAvailableListener(mListener);
-
-        mSurface = new Surface(producer, true);
-    }
-
-    /* Used by Egl manager. The surface is never displayed. */
-    sp<Surface> getSurface() const
-    {
-        return mSurface;
-    }
-
-private:
-    sp<BufferItemConsumer> mBufferItemConsumer;
-    sp<BufferListener> mListener;
-    /* Used by Egl manager. The surface is never displayed */
-    sp<Surface> mSurface;
-};
-
-
-/* Used to generate valid fences. It is not possible to create a dummy sync
- * fence for testing. Egl can generate buffers along with a valid fence.
- * The buffer cannot be guaranteed to be the same format across all devices so
- * a CPU filled buffer is used instead. The Egl fence is used along with the
- * CPU filled buffer. */
-class Hwc2TestEglManager {
-public:
-    Hwc2TestEglManager()
-        : mEglDisplay(EGL_NO_DISPLAY),
-          mEglSurface(EGL_NO_SURFACE),
-          mEglContext(EGL_NO_CONTEXT) { }
-
-    ~Hwc2TestEglManager()
-    {
-        cleanup();
-    }
-
-    int initialize(sp<Surface> surface)
-    {
-        mSurface = surface;
-
-        mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-        if (mEglDisplay == EGL_NO_DISPLAY) return false;
-
-        EGLint major;
-        EGLint minor;
-        if (!eglInitialize(mEglDisplay, &major, &minor)) {
-            ALOGW("Could not initialize EGL");
-            return false;
-        }
-
-        /* We're going to use a 1x1 pbuffer surface later on
-         * The configuration distance doesn't really matter for what we're
-         * trying to do */
-        EGLint configAttrs[] = {
-                EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-                EGL_RED_SIZE, 8,
-                EGL_GREEN_SIZE, 8,
-                EGL_BLUE_SIZE, 8,
-                EGL_ALPHA_SIZE, 0,
-                EGL_DEPTH_SIZE, 24,
-                EGL_STENCIL_SIZE, 0,
-                EGL_NONE
-        };
-
-        EGLConfig configs[1];
-        EGLint configCnt;
-        if (!eglChooseConfig(mEglDisplay, configAttrs, configs, 1,
-                &configCnt)) {
-            ALOGW("Could not select EGL configuration");
-            eglReleaseThread();
-            eglTerminate(mEglDisplay);
-            return false;
-        }
-
-        if (configCnt <= 0) {
-            ALOGW("Could not find EGL configuration");
-            eglReleaseThread();
-            eglTerminate(mEglDisplay);
-            return false;
-        }
-
-        /* These objects are initialized below but the default "null" values are
-         * used to cleanup properly at any point in the initialization sequence */
-        EGLint attrs[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
-        mEglContext = eglCreateContext(mEglDisplay, configs[0], EGL_NO_CONTEXT,
-                attrs);
-        if (mEglContext == EGL_NO_CONTEXT) {
-            ALOGW("Could not create EGL context");
-            cleanup();
-            return false;
-        }
-
-        EGLint surfaceAttrs[] = { EGL_NONE };
-        mEglSurface = eglCreateWindowSurface(mEglDisplay, configs[0],
-                mSurface.get(), surfaceAttrs);
-        if (mEglSurface == EGL_NO_SURFACE) {
-            ALOGW("Could not create EGL surface");
-            cleanup();
-            return false;
-        }
-
-        if (!eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
-            ALOGW("Could not change current EGL context");
-            cleanup();
-            return false;
-        }
-
-        return true;
-    }
-
-    void makeCurrent() const
-    {
-        eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext);
-    }
-
-    void present() const
-    {
-        eglSwapBuffers(mEglDisplay, mEglSurface);
-    }
-
-private:
-    void cleanup()
-    {
-        if (mEglDisplay == EGL_NO_DISPLAY)
-            return;
-        if (mEglSurface != EGL_NO_SURFACE)
-            eglDestroySurface(mEglDisplay, mEglSurface);
-        if (mEglContext != EGL_NO_CONTEXT)
-            eglDestroyContext(mEglDisplay, mEglContext);
-
-        eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,
-                EGL_NO_CONTEXT);
-        eglReleaseThread();
-        eglTerminate(mEglDisplay);
-    }
-
-    sp<Surface> mSurface;
-    EGLDisplay mEglDisplay;
-    EGLSurface mEglSurface;
-    EGLContext mEglContext;
-};
-
-
-static const std::array<vec2, 4> triangles = {{
-    {  1.0f,  1.0f },
-    { -1.0f,  1.0f },
-    {  1.0f, -1.0f },
-    { -1.0f, -1.0f },
-}};
-
-class Hwc2TestFenceGenerator {
-public:
-
-    Hwc2TestFenceGenerator()
-    {
-        mSurfaceManager.initialize({1, 1}, HAL_PIXEL_FORMAT_RGBA_8888,
-                setFence, this);
-
-        if (!mEglManager.initialize(mSurfaceManager.getSurface()))
-            return;
-
-        mEglManager.makeCurrent();
-
-        glClearColor(0.0, 0.0, 0.0, 1.0);
-        glEnableVertexAttribArray(0);
-    }
-
-    ~Hwc2TestFenceGenerator()
-    {
-        if (mFence >= 0)
-            close(mFence);
-        mFence = -1;
-
-        mEglManager.makeCurrent();
-    }
-
-    /* It is not possible to simply generate a fence. The easiest way is to
-     * generate a buffer using egl and use the associated fence. The buffer
-     * cannot be guaranteed to be a certain format across all devices using this
-     * method. Instead the buffer is generated using the CPU */
-    int32_t get()
-    {
-        if (mFence >= 0) {
-            return dup(mFence);
-        }
-
-        std::unique_lock<std::mutex> lock(mMutex);
-
-        /* If the pending is still set to false and times out, we cannot recover.
-         * Set an error and return */
-        while (mPending != false) {
-            if (mCv.wait_for(lock, std::chrono::seconds(2)) == std::cv_status::timeout)
-                return -ETIME;
-        }
-
-        /* Generate a fence. The fence will be returned through the setFence
-         * callback */
-        mEglManager.makeCurrent();
-
-        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, triangles.data());
-        glClear(GL_COLOR_BUFFER_BIT);
-
-        mEglManager.present();
-
-        /* Wait for the setFence callback */
-        while (mPending != true) {
-            if (mCv.wait_for(lock, std::chrono::seconds(2)) == std::cv_status::timeout)
-                return -ETIME;
-        }
-
-        mPending = false;
-
-        return dup(mFence);
-    }
-
-    /* Callback that sets the fence */
-    void set(int32_t fence)
-    {
-        mFence = fence;
-        mPending = true;
-
-        mCv.notify_all();
-    }
-
-private:
-
-    Hwc2TestSurfaceManager mSurfaceManager;
-    Hwc2TestEglManager mEglManager;
-
-    std::mutex mMutex;
-    std::condition_variable mCv;
-
-    int32_t mFence = -1;
-    bool mPending = false;
-};
-
-
-static void setFence(int32_t fence, void* fenceGenerator)
-{
-    static_cast<Hwc2TestFenceGenerator*>(fenceGenerator)->set(fence);
-}
-
-
-/* Sets the pixel of a buffer given the location, format, stride and color.
- * Currently only supports RGBA_8888 */
-static void setColor(int32_t x, int32_t y,
-        android_pixel_format_t format, uint32_t stride, uint8_t* img, uint8_t r,
-        uint8_t g, uint8_t b, uint8_t a)
-{
-       switch (format) {
-       case HAL_PIXEL_FORMAT_RGBA_8888:
-           img[(y * stride + x) * 4 + 0] = r;
-           img[(y * stride + x) * 4 + 1] = g;
-           img[(y * stride + x) * 4 + 2] = b;
-           img[(y * stride + x) * 4 + 3] = a;
-           break;
-       default:
-           break;
-       }
-}
-
-Hwc2TestBuffer::Hwc2TestBuffer()
-    : mFenceGenerator(new Hwc2TestFenceGenerator()) { }
-
-Hwc2TestBuffer::~Hwc2TestBuffer() = default;
-
-/* When the buffer changes sizes, save the new size and invalidate the current
- * buffer */
-void Hwc2TestBuffer::updateBufferArea(const Area& bufferArea)
-{
-    if (mBufferArea.width == bufferArea.width
-            && mBufferArea.height == bufferArea.height)
-        return;
-
-    mBufferArea.width = bufferArea.width;
-    mBufferArea.height = bufferArea.height;
-
-    mValidBuffer = false;
-}
-
-/* Returns a valid buffer handle and fence. The handle is filled using the CPU
- * to ensure the correct format across all devices. The fence is created using
- * egl. */
-int Hwc2TestBuffer::get(buffer_handle_t* outHandle, int32_t* outFence)
-{
-    if (mBufferArea.width == -1 || mBufferArea.height == -1)
-        return -EINVAL;
-
-    /* If the current buffer is valid, the previous buffer can be reused.
-     * Otherwise, create new buffer */
-    if (!mValidBuffer) {
-        int ret = generateBuffer();
-        if (ret)
-            return ret;
-    }
-
-    *outFence = mFenceGenerator->get();
-    *outHandle = mHandle;
-
-    mValidBuffer = true;
-
-    return 0;
-}
-
-/* CPU fills a buffer to guarantee the correct buffer format across all
- * devices */
-int Hwc2TestBuffer::generateBuffer()
-{
-    /* Create new graphic buffer with correct dimensions */
-    mGraphicBuffer = new GraphicBuffer(mBufferArea.width, mBufferArea.height,
-            mFormat, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_HW_RENDER,
-            "hwc2_test_buffer");
-    int ret = mGraphicBuffer->initCheck();
-    if (ret) {
-        return ret;
-    }
-    if (!mGraphicBuffer->handle) {
-        return -EINVAL;
-    }
-
-    /* Locks the buffer for writing */
-    uint8_t* img;
-    mGraphicBuffer->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-
-    uint32_t stride = mGraphicBuffer->getStride();
-
-    /* Iterate from the top row of the buffer to the bottom row */
-    for (int32_t y = 0; y < mBufferArea.height; y++) {
-
-        /* Will be used as R, G and B values for pixel colors */
-        uint8_t max = 255;
-        uint8_t min = 0;
-
-        /* Divide the rows into 3 sections. The first section will contain
-         * the lighest colors. The last section will contain the darkest
-         * colors. */
-        if (y < mBufferArea.height * 1.0 / 3.0) {
-            min = 255 / 2;
-        } else if (y >= mBufferArea.height * 2.0 / 3.0) {
-            max = 255 / 2;
-        }
-
-        /* Divide the columns into 3 sections. The first section is red,
-         * the second is green and the third is blue */
-        int32_t x = 0;
-        for (; x < mBufferArea.width / 3; x++) {
-            setColor(x, y, mFormat, stride, img, max, min, min, 255);
-        }
-
-        for (; x < mBufferArea.width * 2 / 3; x++) {
-            setColor(x, y, mFormat, stride, img, min, max, min, 255);
-        }
-
-        for (; x < mBufferArea.width; x++) {
-            setColor(x, y, mFormat, stride, img, min, min, max, 255);
-        }
-    }
-
-    /* Unlock the buffer for reading */
-    mGraphicBuffer->unlock();
-
-    mHandle = mGraphicBuffer->handle;
-
-    return 0;
-}
-
-
-Hwc2TestClientTargetBuffer::Hwc2TestClientTargetBuffer()
-    : mFenceGenerator(new Hwc2TestFenceGenerator()) { }
-
-Hwc2TestClientTargetBuffer::~Hwc2TestClientTargetBuffer() { }
-
-/* Generates a client target buffer using the layers assigned for client
- * composition. Takes into account the individual layer properties such as
- * transform, blend mode, source crop, etc. */
-int Hwc2TestClientTargetBuffer::get(buffer_handle_t* outHandle,
-        int32_t* outFence, const Area& bufferArea,
-        const Hwc2TestLayers* testLayers,
-        const std::set<hwc2_layer_t>* clientLayers,
-        const std::set<hwc2_layer_t>* clearLayers)
-{
-    /* Create new graphic buffer with correct dimensions */
-    mGraphicBuffer = new GraphicBuffer(bufferArea.width, bufferArea.height,
-            mFormat, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_HW_RENDER,
-            "hwc2_test_buffer");
-    int ret = mGraphicBuffer->initCheck();
-    if (ret) {
-        return ret;
-    }
-    if (!mGraphicBuffer->handle) {
-        return -EINVAL;
-    }
-
-    uint8_t* img;
-    mGraphicBuffer->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
-
-    uint32_t stride = mGraphicBuffer->getStride();
-
-    float bWDiv3 = bufferArea.width / 3;
-    float bW2Div3 = bufferArea.width * 2 / 3;
-    float bHDiv3 = bufferArea.height / 3;
-    float bH2Div3 = bufferArea.height * 2 / 3;
-
-    /* Cycle through every pixel in the buffer and determine what color it
-     * should be. */
-    for (int32_t y = 0; y < bufferArea.height; y++) {
-        for (int32_t x = 0; x < bufferArea.width; x++) {
-
-            uint8_t r = 0, g = 0, b = 0;
-            float a = 0.0f;
-
-            /* Cycle through each client layer from back to front and
-             * update the pixel color. */
-            for (auto layer = clientLayers->rbegin();
-                    layer != clientLayers->rend(); ++layer) {
-
-                const hwc_rect_t df = testLayers->getDisplayFrame(*layer);
-
-                float dfL = df.left;
-                float dfT = df.top;
-                float dfR = df.right;
-                float dfB = df.bottom;
-
-                /* If the pixel location falls outside of the layer display
-                 * frame, skip the layer. */
-                if (x < dfL || x >= dfR || y < dfT || y >= dfB)
-                    continue;
-
-                /* If the device has requested the layer be clear, clear
-                 * the pixel and continue. */
-                if (clearLayers->count(*layer) != 0) {
-                    r = 0;
-                    g = 0;
-                    b = 0;
-                    a = 0.0f;
-                    continue;
-                }
-
-                float planeAlpha = testLayers->getPlaneAlpha(*layer);
-
-                /* If the layer is a solid color, fill the color and
-                 * continue. */
-                if (testLayers->getComposition(*layer)
-                        == HWC2_COMPOSITION_SOLID_COLOR) {
-                    const auto color = testLayers->getColor(*layer);
-                    r = color.r;
-                    g = color.g;
-                    b = color.b;
-                    a = color.a * planeAlpha;
-                    continue;
-                }
-
-                float xPos = x;
-                float yPos = y;
-
-                hwc_transform_t transform = testLayers->getTransform(*layer);
-
-                float dfW = dfR - dfL;
-                float dfH = dfB - dfT;
-
-                /* If a layer has a transform, find which location on the
-                 * layer will end up in the current pixel location. We
-                 * can calculate the color of the current pixel using that
-                 * location. */
-                if (transform > 0) {
-                    /* Change origin to be the center of the layer. */
-                    xPos = xPos - dfL - dfW / 2.0;
-                    yPos = yPos - dfT - dfH / 2.0;
-
-                    /* Flip Horizontal by reflecting across the y axis. */
-                    if (transform & HWC_TRANSFORM_FLIP_H)
-                        xPos = -xPos;
-
-                    /* Flip vertical by reflecting across the x axis. */
-                    if (transform & HWC_TRANSFORM_FLIP_V)
-                        yPos = -yPos;
-
-                    /* Rotate 90 by using a basic linear algebra rotation
-                     * and scaling the result so the display frame remains
-                     * the same. For example, a buffer of size 100x50 should
-                     * rotate 90 degress but remain the same dimension
-                     * (100x50) at the end of the transformation. */
-                    if (transform & HWC_TRANSFORM_ROT_90) {
-                        float tmp = xPos;
-                        xPos = -yPos * dfW / dfH;
-                        yPos = tmp * dfH / dfW;
-                    }
-
-                    /* Change origin back to the top left corner of the
-                     * layer. */
-                    xPos = xPos + dfL + dfW / 2.0;
-                    yPos = yPos + dfT + dfH / 2.0;
-                }
-
-                hwc_frect_t sc = testLayers->getSourceCrop(*layer);
-                float scL = sc.left, scT = sc.top;
-
-                float dfWDivScW = dfW / (sc.right - scL);
-                float dfHDivScH = dfH / (sc.bottom - scT);
-
-                float max = 255, min = 0;
-
-                /* Choose the pixel color. Similar to generateBuffer,
-                 * each layer will be divided into 3x3 colors. Because
-                 * both the source crop and display frame must be taken into
-                 * account, the formulas are more complicated.
-                 *
-                 * If the source crop and display frame were not taken into
-                 * account, we would simply divide the buffer into three
-                 * sections by height. Each section would get one color.
-                 * For example the formula for the first section would be:
-                 *
-                 * if (yPos < bufferArea.height / 3)
-                 *        //Select first section color
-                 *
-                 * However the pixel color is chosen based on the source
-                 * crop and displayed based on the display frame.
-                 *
-                 * If the display frame top was 0 and the source crop height
-                 * and display frame height were the same. The only factor
-                 * would be the source crop top. To calculate the new
-                 * section boundary, the section boundary would be moved up
-                 * by the height of the source crop top. The formula would
-                 * be:
-                 * if (yPos < (bufferArea.height / 3 - sourceCrop.top)
-                 *        //Select first section color
-                 *
-                 * If the display frame top could also vary but source crop
-                 * and display frame heights were the same, the formula
-                 * would be:
-                 * if (yPos < (bufferArea.height / 3 - sourceCrop.top
-                 *              + displayFrameTop)
-                 *        //Select first section color
-                 *
-                 * If the heights were not the same, the conversion between
-                 * the source crop and display frame dimensions must be
-                 * taken into account. The formula would be:
-                 * if (yPos < ((bufferArea.height / 3) - sourceCrop.top)
-                 *              * displayFrameHeight / sourceCropHeight
-                 *              + displayFrameTop)
-                 *        //Select first section color
-                 */
-                if (yPos < ((bHDiv3) - scT) * dfHDivScH + dfT) {
-                    min = 255 / 2;
-                } else if (yPos >= ((bH2Div3) - scT) * dfHDivScH + dfT) {
-                    max = 255 / 2;
-                }
-
-                uint8_t rCur = min, gCur = min, bCur = min;
-                float aCur = 1.0f;
-
-                /* This further divides the color sections from 3 to 3x3.
-                 * The math behind it follows the same logic as the previous
-                 * comment */
-                if (xPos < ((bWDiv3) - scL) * (dfWDivScW) + dfL) {
-                    rCur = max;
-                } else if (xPos < ((bW2Div3) - scL) * (dfWDivScW) + dfL) {
-                    gCur = max;
-                } else {
-                    bCur = max;
-                }
-
-
-                /* Blend the pixel color with the previous layers' pixel
-                 * colors using the plane alpha and blend mode. The final
-                 * pixel color is chosen using the plane alpha and blend
-                 * mode formulas found in hwcomposer2.h */
-                hwc2_blend_mode_t blendMode = testLayers->getBlendMode(*layer);
-
-                if (blendMode == HWC2_BLEND_MODE_PREMULTIPLIED) {
-                    rCur *= planeAlpha;
-                    gCur *= planeAlpha;
-                    bCur *= planeAlpha;
-                }
-
-                aCur *= planeAlpha;
-
-                if (blendMode == HWC2_BLEND_MODE_PREMULTIPLIED) {
-                    r = rCur + r * (1.0 - aCur);
-                    g = gCur + g * (1.0 - aCur);
-                    b = bCur + b * (1.0 - aCur);
-                    a = aCur + a * (1.0 - aCur);
-                } else if (blendMode == HWC2_BLEND_MODE_COVERAGE) {
-                    r = rCur * aCur + r * (1.0 - aCur);
-                    g = gCur * aCur + g * (1.0 - aCur);
-                    b = bCur * aCur + b * (1.0 - aCur);
-                    a = aCur * aCur + a * (1.0 - aCur);
-                } else {
-                    r = rCur;
-                    g = gCur;
-                    b = bCur;
-                    a = aCur;
-                }
-            }
-
-            /* Set the pixel color */
-            setColor(x, y, mFormat, stride, img, r, g, b, a * 255);
-        }
-    }
-
-    mGraphicBuffer->unlock();
-
-    *outFence = mFenceGenerator->get();
-    *outHandle = mGraphicBuffer->handle;
-
-    return 0;
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h b/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h
deleted file mode 100644
index b2b3a6696a..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestBuffer.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_BUFFER_H
-#define _HWC2_TEST_BUFFER_H
-
-#include <android-base/unique_fd.h>
-#include <set>
-
-#include <hardware/hwcomposer2.h>
-
-#include <ui/GraphicBuffer.h>
-
-#include "Hwc2TestProperties.h"
-
-class Hwc2TestFenceGenerator;
-class Hwc2TestLayers;
-
-class Hwc2TestBuffer {
-public:
-    Hwc2TestBuffer();
-    ~Hwc2TestBuffer();
-
-    void updateBufferArea(const Area& bufferArea);
-
-    int  get(buffer_handle_t* outHandle, int32_t* outFence);
-
-protected:
-    int generateBuffer();
-
-    android::sp<android::GraphicBuffer> mGraphicBuffer;
-
-    std::unique_ptr<Hwc2TestFenceGenerator> mFenceGenerator;
-
-    Area mBufferArea = {-1, -1};
-    const android_pixel_format_t mFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-
-    bool mValidBuffer = false;
-    buffer_handle_t mHandle = nullptr;
-};
-
-
-class Hwc2TestClientTargetBuffer {
-public:
-    Hwc2TestClientTargetBuffer();
-    ~Hwc2TestClientTargetBuffer();
-
-    int  get(buffer_handle_t* outHandle, int32_t* outFence,
-            const Area& bufferArea, const Hwc2TestLayers* testLayers,
-            const std::set<hwc2_layer_t>* clientLayers,
-            const std::set<hwc2_layer_t>* clearLayers);
-
-protected:
-    android::sp<android::GraphicBuffer> mGraphicBuffer;
-
-    std::unique_ptr<Hwc2TestFenceGenerator> mFenceGenerator;
-
-    const android_pixel_format_t mFormat = HAL_PIXEL_FORMAT_RGBA_8888;
-};
-
-#endif /* ifndef _HWC2_TEST_BUFFER_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp
deleted file mode 100644
index 69254921d4..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-
-#include <ui/Rect.h>
-
-#include "Hwc2TestClientTarget.h"
-
-int Hwc2TestClientTarget::getBuffer(const Hwc2TestLayers& testLayers,
-        const std::set<hwc2_layer_t>& clientLayers,
-        const std::set<hwc2_layer_t>& clearLayers, bool flipClientTarget,
-        const Area& displayArea, buffer_handle_t* outHandle,
-        int32_t* outAcquireFence)
-{
-    if (!flipClientTarget) {
-        bool needsClientTarget = false;
-
-        for (auto clientLayer : clientLayers) {
-            if (testLayers.getVisibleRegion(clientLayer).numRects > 0) {
-                needsClientTarget = true;
-                break;
-            }
-        }
-
-        if (!needsClientTarget) {
-           *outHandle = nullptr;
-           *outAcquireFence = -1;
-           return 0;
-        }
-    }
-
-    return mBuffer.get(outHandle, outAcquireFence, displayArea,
-            &testLayers, &clientLayers, &clearLayers);
-}
-
-
-Hwc2TestClientTargetSupport::Hwc2TestClientTargetSupport(
-        Hwc2TestCoverage coverage, const Area& displayArea)
-    : mBufferArea(coverage, displayArea),
-      mDataspace(coverage),
-      mSurfaceDamage(coverage)
-{
-    mBufferArea.setDependent(&mSurfaceDamage);
-}
-
-std::string Hwc2TestClientTargetSupport::dump() const
-{
-    std::stringstream dmp;
-
-    dmp << "client target: \n";
-
-    for (auto property : properties) {
-        dmp << property->dump();
-    }
-
-    return dmp.str();
-}
-
-void Hwc2TestClientTargetSupport::reset()
-{
-    for (auto property : properties) {
-        property->reset();
-    }
-}
-
-bool Hwc2TestClientTargetSupport::advance()
-{
-    for (auto property : properties) {
-        if (property->advance())
-            return true;
-    }
-    return false;
-}
-
-Area Hwc2TestClientTargetSupport::getBufferArea() const
-{
-    return mBufferArea.get();
-}
-
-android_dataspace_t Hwc2TestClientTargetSupport::getDataspace() const
-{
-    return mDataspace.get();
-}
-
-const hwc_region_t Hwc2TestClientTargetSupport::getSurfaceDamage() const
-{
-    return mSurfaceDamage.get();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h b/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h
deleted file mode 100644
index 3b47978bef..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestClientTarget.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_CLIENT_TARGET_H
-#define _HWC2_TEST_CLIENT_TARGET_H
-
-#include <set>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestProperties.h"
-#include "Hwc2TestLayers.h"
-
-/* Generates client target buffers from client composition layers */
-class Hwc2TestClientTarget {
-public:
-    int getBuffer(const Hwc2TestLayers& layers,
-            const std::set<hwc2_layer_t>& clientLayers,
-            const std::set<hwc2_layer_t>& clearLayers,
-            bool clearClientTarget, const Area& displayArea,
-            buffer_handle_t* outHandle, int32_t* outAcquireFence);
-
-private:
-    Hwc2TestClientTargetBuffer mBuffer;
-};
-
-/* Generates valid client targets to test which ones the device will support */
-class Hwc2TestClientTargetSupport {
-public:
-    Hwc2TestClientTargetSupport(Hwc2TestCoverage coverage,
-            const Area& displayArea);
-
-    std::string dump() const;
-
-    void reset();
-    bool advance();
-
-    Area getBufferArea() const;
-    android_dataspace_t getDataspace() const;
-    const hwc_region_t getSurfaceDamage() const;
-
-private:
-    std::array<Hwc2TestContainer*, 3> properties = {{
-        &mDataspace, &mSurfaceDamage, &mBufferArea
-    }};
-
-    Hwc2TestBufferArea mBufferArea;
-    Hwc2TestDataspace mDataspace;
-    Hwc2TestSurfaceDamage mSurfaceDamage;
-};
-
-#endif /* ifndef _HWC2_TEST_CLIENT_TARGET_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp
deleted file mode 100644
index 937fce28fb..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.cpp
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-
-#include "Hwc2TestLayer.h"
-
-Hwc2TestCoverage getCoverage(Hwc2TestPropertyName property,
-        Hwc2TestCoverage coverage, const std::unordered_map<Hwc2TestPropertyName,
-        Hwc2TestCoverage>& coverageExceptions) {
-    auto exception = coverageExceptions.find(property);
-    return (exception != coverageExceptions.end())? exception->second : coverage;
-}
-
-Hwc2TestLayer::Hwc2TestLayer(Hwc2TestCoverage coverage,
-        const Area& displayArea)
-    : Hwc2TestLayer(coverage, displayArea,
-            std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>()) { }
-
-Hwc2TestLayer::Hwc2TestLayer(Hwc2TestCoverage coverage,
-        const Area& displayArea, const std::unordered_map<Hwc2TestPropertyName,
-        Hwc2TestCoverage>& coverageExceptions)
-    : mBlendMode(getCoverage(Hwc2TestPropertyName::BlendMode, coverage,
-           coverageExceptions)),
-      mBufferArea(getCoverage(Hwc2TestPropertyName::BufferArea, coverage,
-           coverageExceptions), displayArea),
-      mColor(getCoverage(Hwc2TestPropertyName::Color, coverage,
-           coverageExceptions)),
-      mComposition(getCoverage(Hwc2TestPropertyName::Composition, coverage,
-           coverageExceptions)),
-      mDataspace(getCoverage(Hwc2TestPropertyName::Dataspace, coverage,
-           coverageExceptions)),
-      mDisplayFrame(getCoverage(Hwc2TestPropertyName::DisplayFrame, coverage,
-           coverageExceptions), displayArea),
-      mPlaneAlpha(getCoverage(Hwc2TestPropertyName::PlaneAlpha, coverage,
-           coverageExceptions)),
-      mSourceCrop(getCoverage(Hwc2TestPropertyName::SourceCrop, coverage,
-           coverageExceptions)),
-      mSurfaceDamage(getCoverage(Hwc2TestPropertyName::SurfaceDamage, coverage,
-           coverageExceptions)),
-      mTransform(getCoverage(Hwc2TestPropertyName::Transform, coverage,
-           coverageExceptions))
-{
-    mBufferArea.setDependent(&mBuffer);
-    mBufferArea.setDependent(&mSourceCrop);
-    mBufferArea.setDependent(&mSurfaceDamage);
-    mBlendMode.setDependent(&mColor);
-}
-
-std::string Hwc2TestLayer::dump() const
-{
-    std::stringstream dmp;
-
-    dmp << "layer: \n";
-
-    for (auto property : mProperties) {
-        dmp << property->dump();
-    }
-
-    dmp << mVisibleRegion.dump();
-    dmp << "\tz order: " << mZOrder << "\n";
-
-    return dmp.str();
-}
-
-int Hwc2TestLayer::getBuffer(buffer_handle_t* outHandle,
-        android::base::unique_fd* outAcquireFence)
-{
-    int32_t acquireFence;
-    int ret = mBuffer.get(outHandle, &acquireFence);
-    outAcquireFence->reset(acquireFence);
-    return ret;
-}
-
-int Hwc2TestLayer::getBuffer(buffer_handle_t* outHandle,
-        int32_t* outAcquireFence)
-{
-    return mBuffer.get(outHandle, outAcquireFence);
-}
-
-void Hwc2TestLayer::setZOrder(uint32_t zOrder)
-{
-    mZOrder = zOrder;
-}
-
-void Hwc2TestLayer::setVisibleRegion(const android::Region& region)
-{
-    return mVisibleRegion.set(region);
-}
-
-void Hwc2TestLayer::reset()
-{
-    mVisibleRegion.release();
-
-    for (auto property : mProperties) {
-        property->reset();
-    }
-}
-
-bool Hwc2TestLayer::advance()
-{
-    for (auto property : mProperties) {
-        if (property->isSupported(mComposition.get()))
-            if (property->advance())
-                return true;
-    }
-    return false;
-}
-
-hwc2_blend_mode_t Hwc2TestLayer::getBlendMode() const
-{
-    return mBlendMode.get();
-}
-
-Area Hwc2TestLayer::getBufferArea() const
-{
-    return mBufferArea.get();
-}
-
-hwc_color_t Hwc2TestLayer::getColor() const
-{
-    return mColor.get();
-}
-
-hwc2_composition_t Hwc2TestLayer::getComposition() const
-{
-    return mComposition.get();
-}
-
-/* The cursor position corresponds to {displayFrame.left, displayFrame.top} */
-hwc_rect_t Hwc2TestLayer::getCursorPosition() const
-{
-    return mDisplayFrame.get();
-}
-
-android_dataspace_t Hwc2TestLayer::getDataspace() const
-{
-    return mDataspace.get();
-}
-
-hwc_rect_t Hwc2TestLayer::getDisplayFrame() const
-{
-    return mDisplayFrame.get();
-}
-
-float Hwc2TestLayer::getPlaneAlpha() const
-{
-    return mPlaneAlpha.get();
-}
-
-hwc_frect_t Hwc2TestLayer::getSourceCrop() const
-{
-    return mSourceCrop.get();
-}
-
-hwc_region_t Hwc2TestLayer::getSurfaceDamage() const
-{
-    return mSurfaceDamage.get();
-}
-
-hwc_transform_t Hwc2TestLayer::getTransform() const
-{
-    return mTransform.get();
-}
-
-hwc_region_t Hwc2TestLayer::getVisibleRegion() const
-{
-    return mVisibleRegion.get();
-}
-
-uint32_t Hwc2TestLayer::getZOrder() const
-{
-    return mZOrder;
-}
-
-bool Hwc2TestLayer::advanceBlendMode()
-{
-    return mBlendMode.advance();
-}
-
-bool Hwc2TestLayer::advanceBufferArea()
-{
-    return mBufferArea.advance();
-}
-
-bool Hwc2TestLayer::advanceColor()
-{
-    return mColor.advance();
-}
-
-bool Hwc2TestLayer::advanceComposition()
-{
-    return mComposition.advance();
-}
-
-bool Hwc2TestLayer::advanceCursorPosition()
-{
-    return mDisplayFrame.advance();
-}
-
-bool Hwc2TestLayer::advanceDataspace()
-{
-    return mDataspace.advance();
-}
-
-bool Hwc2TestLayer::advanceDisplayFrame()
-{
-    return mDisplayFrame.advance();
-}
-
-bool Hwc2TestLayer::advancePlaneAlpha()
-{
-    return mPlaneAlpha.advance();
-}
-
-bool Hwc2TestLayer::advanceSourceCrop()
-{
-    return mSourceCrop.advance();
-}
-
-bool Hwc2TestLayer::advanceSurfaceDamage()
-{
-    return mSurfaceDamage.advance();
-}
-
-bool Hwc2TestLayer::advanceTransform()
-{
-    return mTransform.advance();
-}
-
-bool Hwc2TestLayer::advanceVisibleRegion()
-{
-    if (mPlaneAlpha.advance())
-        return true;
-    return mDisplayFrame.advance();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h b/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h
deleted file mode 100644
index 0e7dd228fb..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayer.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_LAYER_H
-#define _HWC2_TEST_LAYER_H
-
-#include <android-base/unique_fd.h>
-#include <unordered_map>
-
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestProperties.h"
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-class Hwc2TestLayer {
-public:
-    Hwc2TestLayer(Hwc2TestCoverage coverage, const Area& displayArea);
-
-    Hwc2TestLayer(Hwc2TestCoverage coverage, const Area& displayArea,
-            const std::unordered_map<Hwc2TestPropertyName,
-            Hwc2TestCoverage>& coverage_exceptions);
-
-    std::string dump() const;
-
-    int getBuffer(buffer_handle_t* outHandle,
-            android::base::unique_fd* outAcquireFence);
-    int getBuffer(buffer_handle_t* outHandle, int32_t* outAcquireFence);
-
-    void setZOrder(uint32_t zOrder);
-    void setVisibleRegion(const android::Region& region);
-
-    void reset();
-    bool advance();
-
-    hwc2_blend_mode_t      getBlendMode() const;
-    Area                   getBufferArea() const;
-    hwc_color_t            getColor() const;
-    hwc2_composition_t     getComposition() const;
-    hwc_rect_t             getCursorPosition() const;
-    android_dataspace_t    getDataspace() const;
-    hwc_rect_t             getDisplayFrame() const;
-    float                  getPlaneAlpha() const;
-    hwc_frect_t            getSourceCrop() const;
-    hwc_region_t           getSurfaceDamage() const;
-    hwc_transform_t        getTransform() const;
-    hwc_region_t           getVisibleRegion() const;
-    uint32_t               getZOrder() const;
-
-    bool advanceBlendMode();
-    bool advanceBufferArea();
-    bool advanceColor();
-    bool advanceComposition();
-    bool advanceCursorPosition();
-    bool advanceDataspace();
-    bool advanceDisplayFrame();
-    bool advancePlaneAlpha();
-    bool advanceSourceCrop();
-    bool advanceSurfaceDamage();
-    bool advanceTransform();
-    bool advanceVisibleRegion();
-
-private:
-    std::array<Hwc2TestContainer*, 10> mProperties = {{
-        &mTransform, &mColor, &mDataspace, &mPlaneAlpha, &mSourceCrop,
-        &mSurfaceDamage, &mBlendMode, &mBufferArea, &mDisplayFrame,
-        &mComposition
-    }};
-
-    Hwc2TestBuffer mBuffer;
-
-    Hwc2TestBlendMode mBlendMode;
-    Hwc2TestBufferArea mBufferArea;
-    Hwc2TestColor mColor;
-    Hwc2TestComposition mComposition;
-    Hwc2TestDataspace mDataspace;
-    Hwc2TestDisplayFrame mDisplayFrame;
-    Hwc2TestPlaneAlpha mPlaneAlpha;
-    Hwc2TestSourceCrop mSourceCrop;
-    Hwc2TestSurfaceDamage mSurfaceDamage;
-    Hwc2TestTransform mTransform;
-    Hwc2TestVisibleRegion mVisibleRegion;
-
-    uint32_t mZOrder = UINT32_MAX;
-};
-
-#endif /* ifndef _HWC2_TEST_LAYER_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp
deleted file mode 100644
index 495ef79609..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.cpp
+++ /dev/null
@@ -1,281 +0,0 @@
-/* * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-#include <gtest/gtest.h>
-
-#include "Hwc2TestLayers.h"
-
-Hwc2TestLayers::Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-        Hwc2TestCoverage coverage, const Area& displayArea)
-    : Hwc2TestLayers(layers, coverage, displayArea,
-            std::unordered_map<Hwc2TestPropertyName, Hwc2TestCoverage>()) { }
-
-Hwc2TestLayers::Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-        Hwc2TestCoverage coverage, const Area& displayArea,
-        const std::unordered_map<Hwc2TestPropertyName,
-        Hwc2TestCoverage>& coverageExceptions)
-    : mDisplayArea(displayArea)
-{
-    for (auto layer : layers) {
-        mTestLayers.emplace(std::piecewise_construct,
-                std::forward_as_tuple(layer),
-                std::forward_as_tuple(coverage, displayArea, coverageExceptions));
-    }
-
-    /* Iterate over the layers in order and assign z orders in the same order.
-     * This allows us to iterate over z orders in the same way when computing
-     * visible regions */
-    uint32_t nextZOrder = layers.size();
-
-    for (auto& testLayer : mTestLayers) {
-        testLayer.second.setZOrder(nextZOrder--);
-    }
-
-    setVisibleRegions();
-}
-
-std::string Hwc2TestLayers::dump() const
-{
-    std::stringstream dmp;
-    for (auto& testLayer : mTestLayers) {
-        dmp << testLayer.second.dump();
-    }
-    return dmp.str();
-}
-
-void Hwc2TestLayers::reset()
-{
-    for (auto& testLayer : mTestLayers) {
-        testLayer.second.reset();
-    }
-
-    setVisibleRegions();
-}
-
-bool Hwc2TestLayers::advance()
-{
-    auto itr = mTestLayers.begin();
-    bool optimized;
-
-    while (itr != mTestLayers.end()) {
-        if (itr->second.advance()) {
-            optimized = setVisibleRegions();
-            if (!mOptimize || optimized)
-                return true;
-            itr = mTestLayers.begin();
-        } else {
-            itr->second.reset();
-            ++itr;
-        }
-    }
-    return false;
-}
-
-bool Hwc2TestLayers::advanceVisibleRegions()
-{
-    auto itr = mTestLayers.begin();
-    bool optimized;
-
-    while (itr != mTestLayers.end()) {
-        if (itr->second.advanceVisibleRegion()) {
-            optimized = setVisibleRegions();
-            if (!mOptimize || optimized)
-                return true;
-            itr = mTestLayers.begin();
-        } else {
-            itr->second.reset();
-            ++itr;
-        }
-    }
-    return false;
-}
-
-/* Removes layouts that do not cover the entire display.
- * Also removes layouts where a layer is completely blocked from view.
- */
-bool Hwc2TestLayers::optimizeLayouts()
-{
-    mOptimize = true;
-
-    if (setVisibleRegions())
-        return true;
-    return advance();
-}
-
-bool Hwc2TestLayers::contains(hwc2_layer_t layer) const
-{
-    return mTestLayers.count(layer) != 0;
-}
-
-int Hwc2TestLayers::getBuffer(hwc2_layer_t layer, buffer_handle_t* outHandle,
-        int32_t* outAcquireFence)
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getBuffer(outHandle, outAcquireFence);
-}
-
-hwc2_blend_mode_t Hwc2TestLayers::getBlendMode(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getBlendMode();
-}
-
-Area Hwc2TestLayers::getBufferArea(hwc2_layer_t layer) const
-{
-    auto testLayer = mTestLayers.find(layer);
-    if (testLayer == mTestLayers.end())
-        [] () { GTEST_FAIL(); }();
-    return testLayer->second.getBufferArea();
-}
-
-hwc_color_t Hwc2TestLayers::getColor(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getColor();
-}
-
-hwc2_composition_t Hwc2TestLayers::getComposition(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getComposition();
-}
-
-hwc_rect_t Hwc2TestLayers::getCursorPosition(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getCursorPosition();
-}
-
-android_dataspace_t Hwc2TestLayers::getDataspace(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getDataspace();
-}
-
-hwc_rect_t Hwc2TestLayers::getDisplayFrame(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getDisplayFrame();
-}
-
-float Hwc2TestLayers::getPlaneAlpha(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getPlaneAlpha();
-}
-
-hwc_frect_t Hwc2TestLayers::getSourceCrop(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getSourceCrop();
-}
-
-hwc_region_t Hwc2TestLayers::getSurfaceDamage(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getSurfaceDamage();
-}
-
-hwc_transform_t Hwc2TestLayers::getTransform(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getTransform();
-}
-
-hwc_region_t Hwc2TestLayers::getVisibleRegion(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getVisibleRegion();
-}
-
-uint32_t Hwc2TestLayers::getZOrder(hwc2_layer_t layer) const
-{
-    if (mTestLayers.count(layer) == 0) {
-        []() { GTEST_FAIL(); }();
-    }
-    return mTestLayers.at(layer).getZOrder();
-}
-
-/* Sets the visible regions for a display. Returns false if the layers do not
- * cover the entire display or if a layer is not visible */
-bool Hwc2TestLayers::setVisibleRegions()
-{
-    /* The region of the display that is covered by layers above the current
-     * layer */
-    android::Region aboveOpaqueLayers;
-
-    bool optimized = true;
-
-    /* Iterate over test layers from max z order to min z order. */
-    for (auto& testLayer : mTestLayers) {
-        android::Region visibleRegion;
-
-        /* Set the visible region of this layer */
-        const hwc_rect_t displayFrame = testLayer.second.getDisplayFrame();
-
-        visibleRegion.set(android::Rect(displayFrame.left, displayFrame.top,
-                displayFrame.right, displayFrame.bottom));
-
-        /* Remove the area covered by opaque layers above this layer
-         * from this layer's visible region */
-        visibleRegion.subtractSelf(aboveOpaqueLayers);
-
-        testLayer.second.setVisibleRegion(visibleRegion);
-
-        /* If a layer is not visible, return false */
-        if (visibleRegion.isEmpty())
-            optimized = false;
-
-        /* If this layer is opaque, store the region it covers */
-        if (testLayer.second.getPlaneAlpha() == 1.0f)
-            aboveOpaqueLayers.orSelf(visibleRegion);
-    }
-
-    /* If the opaque region does not cover the entire display return false */
-    if (!aboveOpaqueLayers.isRect())
-        return false;
-
-    const auto rect = aboveOpaqueLayers.begin();
-    if (rect->left != 0 || rect->top != 0 || rect->right != mDisplayArea.width
-            || rect->bottom != mDisplayArea.height)
-        return false;
-
-    return optimized;
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h b/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h
deleted file mode 100644
index d95a91f485..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestLayers.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_LAYERS_H
-#define _HWC2_TEST_LAYERS_H
-
-#include <map>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestProperties.h"
-#include "Hwc2TestLayer.h"
-
-class Hwc2TestLayers {
-public:
-    Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestCoverage coverage, const Area& displayArea);
-
-    Hwc2TestLayers(const std::vector<hwc2_layer_t>& layers,
-            Hwc2TestCoverage coverage, const Area& displayArea,
-            const std::unordered_map<Hwc2TestPropertyName,
-            Hwc2TestCoverage>& coverageExceptions);
-
-    std::string dump() const;
-
-    void reset();
-
-    bool advance();
-    bool advanceVisibleRegions();
-
-    /* Test cases with multiple layers and property values can take quite some
-     * time to run. A significant amount of time can be spent on test cases
-     * where one layer is changing property values but is not visible. To
-     * decrease runtime, this function can be called. Removes layouts where a
-     * layer is completely blocked from view. It also removes layouts that do
-     * not cover the entire display.*/
-    bool optimizeLayouts();
-
-    bool contains(hwc2_layer_t layer) const;
-
-    int  getBuffer(hwc2_layer_t layer, buffer_handle_t* outHandle,
-            int32_t* outAcquireFence);
-
-    hwc2_blend_mode_t      getBlendMode(hwc2_layer_t layer) const;
-    Area                   getBufferArea(hwc2_layer_t layer) const;
-    hwc_color_t            getColor(hwc2_layer_t layer) const;
-    hwc2_composition_t     getComposition(hwc2_layer_t layer) const;
-    hwc_rect_t             getCursorPosition(hwc2_layer_t layer) const;
-    android_dataspace_t    getDataspace(hwc2_layer_t layer) const;
-    hwc_rect_t             getDisplayFrame(hwc2_layer_t layer) const;
-    android_pixel_format_t getFormat(hwc2_layer_t layer) const;
-    float                  getPlaneAlpha(hwc2_layer_t layer) const;
-    hwc_frect_t            getSourceCrop(hwc2_layer_t layer) const;
-    hwc_region_t           getSurfaceDamage(hwc2_layer_t layer) const;
-    hwc_transform_t        getTransform(hwc2_layer_t layer) const;
-    hwc_region_t           getVisibleRegion(hwc2_layer_t layer) const;
-    uint32_t               getZOrder(hwc2_layer_t layer) const;
-
-private:
-    bool setVisibleRegions();
-
-    std::map<hwc2_layer_t, Hwc2TestLayer> mTestLayers;
-
-    Area mDisplayArea;
-
-    bool mOptimize = false;
-};
-
-#endif /* ifndef _HWC2_TEST_LAYERS_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp
deleted file mode 100644
index b5522de3a5..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.cpp
+++ /dev/null
@@ -1,782 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-#include <cutils/log.h>
-#include <ui/Rect.h>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestProperties.h"
-
-Hwc2TestBufferArea::Hwc2TestBufferArea(Hwc2TestCoverage coverage,
-        const Area& displayArea)
-    : Hwc2TestProperty(mBufferAreas, mCompositionSupport),
-      mScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicScalars:
-            mDefaultScalars),
-      mDisplayArea(displayArea)
-{
-    update();
-}
-
-std::string Hwc2TestBufferArea::dump() const
-{
-    std::stringstream dmp;
-    const Area& curr = get();
-    dmp << "\tbuffer area: width " << curr.width << ", height " << curr.height
-            << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestBufferArea::setDependent(Hwc2TestBuffer* buffer)
-{
-    mBuffer = buffer;
-    if (buffer) {
-        buffer->updateBufferArea(get());
-    }
-}
-
-void Hwc2TestBufferArea::setDependent(Hwc2TestSourceCrop* sourceCrop)
-{
-    mSourceCrop = sourceCrop;
-    if (mSourceCrop) {
-        mSourceCrop->updateBufferArea(get());
-    }
-}
-
-void Hwc2TestBufferArea::setDependent(Hwc2TestSurfaceDamage* surfaceDamage)
-{
-    mSurfaceDamage = surfaceDamage;
-    if (mSurfaceDamage) {
-        mSurfaceDamage->updateBufferArea(get());
-    }
-}
-
-void Hwc2TestBufferArea::update()
-{
-    mBufferAreas.clear();
-
-    if (mDisplayArea.width == 0 && mDisplayArea.height == 0) {
-        mBufferAreas.push_back({0, 0});
-        return;
-    }
-
-    for (auto scalar : mScalars) {
-        mBufferAreas.push_back({static_cast<int32_t>(scalar * mDisplayArea.width),
-                static_cast<int32_t>(scalar * mDisplayArea.height)});
-    }
-
-    updateDependents();
-}
-
-void Hwc2TestBufferArea::updateDependents()
-{
-    const Area& curr = get();
-
-    if (mBuffer)
-        mBuffer->updateBufferArea(curr);
-    if (mSourceCrop)
-        mSourceCrop->updateBufferArea(curr);
-    if (mSurfaceDamage)
-        mSurfaceDamage->updateBufferArea(curr);
-}
-
-const std::vector<float> Hwc2TestBufferArea::mDefaultScalars = {
-    1.0f,
-};
-
-const std::vector<float> Hwc2TestBufferArea::mBasicScalars = {
-    1.0f, 0.5f,
-};
-
-const std::vector<float> Hwc2TestBufferArea::mCompleteScalars = {
-    1.0f, 0.75f, 0.5f
-};
-
-
-Hwc2TestBlendMode::Hwc2TestBlendMode(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompleteBlendModes, mBasicBlendModes,
-            mDefaultBlendModes, mCompositionSupport) { }
-
-std::string Hwc2TestBlendMode::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tblend mode: " << getBlendModeName(get()) << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestBlendMode::setDependent(Hwc2TestColor* color)
-{
-    mColor = color;
-    updateDependents();
-}
-
-void Hwc2TestBlendMode::updateDependents()
-{
-    if (mColor)
-        mColor->updateBlendMode(get());
-}
-
-const std::vector<hwc2_blend_mode_t> Hwc2TestBlendMode::mDefaultBlendModes = {
-    HWC2_BLEND_MODE_NONE,
-};
-
-const std::vector<hwc2_blend_mode_t> Hwc2TestBlendMode::mBasicBlendModes = {
-    HWC2_BLEND_MODE_NONE,
-    HWC2_BLEND_MODE_PREMULTIPLIED,
-};
-
-const std::vector<hwc2_blend_mode_t> Hwc2TestBlendMode::mCompleteBlendModes = {
-    HWC2_BLEND_MODE_NONE,
-    HWC2_BLEND_MODE_PREMULTIPLIED,
-    HWC2_BLEND_MODE_COVERAGE,
-};
-
-
-Hwc2TestColor::Hwc2TestColor(Hwc2TestCoverage coverage,
-        hwc2_blend_mode_t blendMode)
-    : Hwc2TestProperty(mColors, mCompositionSupport),
-      mBaseColors((coverage == Hwc2TestCoverage::Complete)? mCompleteBaseColors:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicBaseColors:
-            mDefaultBaseColors),
-      mBlendMode(blendMode)
-{
-    update();
-}
-
-std::string Hwc2TestColor::dump() const
-{
-    std::stringstream dmp;
-    const hwc_color_t& color = get();
-    dmp << "\tcolor: r " << std::to_string(color.r) << ", g "
-            << std::to_string(color.g) << ", b " << std::to_string(color.b)
-            << ", a " << std::to_string(color.a) << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestColor::updateBlendMode(hwc2_blend_mode_t blendMode)
-{
-    mBlendMode = blendMode;
-    update();
-}
-
-void Hwc2TestColor::update()
-{
-    if (mBlendMode != HWC2_BLEND_MODE_PREMULTIPLIED) {
-        mColors = mBaseColors;
-        return;
-    }
-
-    mColors.clear();
-
-    for (const hwc_color_t& baseColor : mBaseColors) {
-        if (baseColor.a >= baseColor.r && baseColor.a >= baseColor.g
-                && baseColor.a >= baseColor.b) {
-            mColors.push_back(baseColor);
-        }
-    }
-
-}
-
-const std::vector<hwc_color_t> Hwc2TestColor::mDefaultBaseColors = {
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-};
-
-const std::vector<hwc_color_t> Hwc2TestColor::mBasicBaseColors = {
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-    {        0,         0,         0,         0},
-};
-
-const std::vector<hwc_color_t> Hwc2TestColor::mCompleteBaseColors = {
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-    {UINT8_MAX, UINT8_MAX, UINT8_MAX,         0},
-    {UINT8_MAX, UINT8_MAX,         0, UINT8_MAX},
-    {UINT8_MAX, UINT8_MAX,         0,         0},
-    {UINT8_MAX,         0, UINT8_MAX, UINT8_MAX},
-    {UINT8_MAX,         0, UINT8_MAX,         0},
-    {UINT8_MAX,         0,         0, UINT8_MAX},
-    {UINT8_MAX,         0,         0,         0},
-    {        0, UINT8_MAX, UINT8_MAX, UINT8_MAX},
-    {        0, UINT8_MAX, UINT8_MAX,         0},
-    {        0, UINT8_MAX,         0, UINT8_MAX},
-    {        0, UINT8_MAX,         0,         0},
-    {        0,         0, UINT8_MAX, UINT8_MAX},
-    {        0,         0, UINT8_MAX,         0},
-    {        0,         0,         0, UINT8_MAX},
-    {        0,         0,         0,         0},
-};
-
-
-Hwc2TestComposition::Hwc2TestComposition(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompleteCompositions, mBasicCompositions,
-            mDefaultCompositions, mCompositionSupport) { }
-
-std::string Hwc2TestComposition::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tcomposition: " << getCompositionName(get()) << "\n";
-    return dmp.str();
-}
-
-const std::vector<hwc2_composition_t> Hwc2TestComposition::mDefaultCompositions = {
-    HWC2_COMPOSITION_DEVICE,
-};
-
-const std::vector<hwc2_composition_t> Hwc2TestComposition::mBasicCompositions = {
-    HWC2_COMPOSITION_CLIENT,
-    HWC2_COMPOSITION_DEVICE,
-};
-
-const std::vector<hwc2_composition_t> Hwc2TestComposition::mCompleteCompositions = {
-    HWC2_COMPOSITION_CLIENT,
-    HWC2_COMPOSITION_DEVICE,
-    HWC2_COMPOSITION_SOLID_COLOR,
-    HWC2_COMPOSITION_CURSOR,
-    HWC2_COMPOSITION_SIDEBAND,
-};
-
-
-Hwc2TestDataspace::Hwc2TestDataspace(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, completeDataspaces, basicDataspaces,
-            defaultDataspaces, mCompositionSupport) { }
-
-std::string Hwc2TestDataspace::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tdataspace: " << get() << "\n";
-    return dmp.str();
-}
-
-const std::vector<android_dataspace_t> Hwc2TestDataspace::defaultDataspaces = {
-    HAL_DATASPACE_UNKNOWN,
-};
-
-const std::vector<android_dataspace_t> Hwc2TestDataspace::basicDataspaces = {
-    HAL_DATASPACE_UNKNOWN,
-    HAL_DATASPACE_V0_SRGB,
-};
-
-const std::vector<android_dataspace_t> Hwc2TestDataspace::completeDataspaces = {
-    HAL_DATASPACE_UNKNOWN,
-    HAL_DATASPACE_ARBITRARY,
-    HAL_DATASPACE_STANDARD_SHIFT,
-    HAL_DATASPACE_STANDARD_MASK,
-    HAL_DATASPACE_STANDARD_UNSPECIFIED,
-    HAL_DATASPACE_STANDARD_BT709,
-    HAL_DATASPACE_STANDARD_BT601_625,
-    HAL_DATASPACE_STANDARD_BT601_625_UNADJUSTED,
-    HAL_DATASPACE_STANDARD_BT601_525,
-    HAL_DATASPACE_STANDARD_BT601_525_UNADJUSTED,
-    HAL_DATASPACE_STANDARD_BT2020,
-    HAL_DATASPACE_STANDARD_BT2020_CONSTANT_LUMINANCE,
-    HAL_DATASPACE_STANDARD_BT470M,
-    HAL_DATASPACE_STANDARD_FILM,
-    HAL_DATASPACE_TRANSFER_SHIFT,
-    HAL_DATASPACE_TRANSFER_MASK,
-    HAL_DATASPACE_TRANSFER_UNSPECIFIED,
-    HAL_DATASPACE_TRANSFER_LINEAR,
-    HAL_DATASPACE_TRANSFER_SRGB,
-    HAL_DATASPACE_TRANSFER_SMPTE_170M,
-    HAL_DATASPACE_TRANSFER_GAMMA2_2,
-    HAL_DATASPACE_TRANSFER_GAMMA2_8,
-    HAL_DATASPACE_TRANSFER_ST2084,
-    HAL_DATASPACE_TRANSFER_HLG,
-    HAL_DATASPACE_RANGE_SHIFT,
-    HAL_DATASPACE_RANGE_MASK,
-    HAL_DATASPACE_RANGE_UNSPECIFIED,
-    HAL_DATASPACE_RANGE_FULL,
-    HAL_DATASPACE_RANGE_LIMITED,
-    HAL_DATASPACE_SRGB_LINEAR,
-    HAL_DATASPACE_V0_SRGB_LINEAR,
-    HAL_DATASPACE_SRGB,
-    HAL_DATASPACE_V0_SRGB,
-    HAL_DATASPACE_JFIF,
-    HAL_DATASPACE_V0_JFIF,
-    HAL_DATASPACE_BT601_625,
-    HAL_DATASPACE_V0_BT601_625,
-    HAL_DATASPACE_BT601_525,
-    HAL_DATASPACE_V0_BT601_525,
-    HAL_DATASPACE_BT709,
-    HAL_DATASPACE_V0_BT709,
-    HAL_DATASPACE_DEPTH,
-};
-
-
-Hwc2TestDisplayDimension::Hwc2TestDisplayDimension(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(
-            (coverage == Hwc2TestCoverage::Complete)? mCompleteDisplayDimensions:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicDisplayDimensions:
-            mDefaultDisplayDimensions, mCompositionSupport) { }
-
-std::string Hwc2TestDisplayDimension::dump() const
-{
-    std::stringstream dmp;
-    const UnsignedArea& curr = get();
-    dmp << "\tdisplay dimension: " << curr.width<< " x " << curr.height<< "\n";
-    return dmp.str();
-}
-
-void Hwc2TestDisplayDimension::setDependent(Hwc2TestBuffer* buffer)
-{
-    mBuffer = buffer;
-    updateDependents();
-}
-
-void Hwc2TestDisplayDimension::updateDependents()
-{
-    const UnsignedArea& curr = get();
-
-    if (mBuffer)
-        mBuffer->updateBufferArea({static_cast<int32_t>(curr.width),
-                static_cast<int32_t>(curr.height)});
-}
-
-const std::vector<UnsignedArea>
-        Hwc2TestDisplayDimension::mDefaultDisplayDimensions = {
-    {1920, 1080},
-};
-
-const std::vector<UnsignedArea>
-        Hwc2TestDisplayDimension::mBasicDisplayDimensions = {
-    {640, 480},
-    {1280, 720},
-    {1920, 1080},
-    {1920, 1200},
-};
-
-const std::vector<UnsignedArea>
-        Hwc2TestDisplayDimension::mCompleteDisplayDimensions = {
-    {320, 240},
-    {480, 320},
-    {640, 480},
-    {1280, 720},
-    {1920, 1080},
-    {1920, 1200},
-    {2560, 1440},
-    {2560, 1600},
-    {3840, 2160},
-    {4096, 2160},
-};
-
-
-Hwc2TestDisplayFrame::Hwc2TestDisplayFrame(Hwc2TestCoverage coverage,
-        const Area& displayArea)
-    : Hwc2TestProperty(mDisplayFrames, mCompositionSupport),
-      mFrectScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteFrectScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicFrectScalars:
-            mDefaultFrectScalars),
-      mDisplayArea(displayArea)
-{
-    update();
-}
-
-std::string Hwc2TestDisplayFrame::dump() const
-{
-    std::stringstream dmp;
-    const hwc_rect_t& displayFrame = get();
-    dmp << "\tdisplay frame: left " << displayFrame.left << ", top "
-            << displayFrame.top << ", right " << displayFrame.right
-            << ", bottom " << displayFrame.bottom << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestDisplayFrame::update()
-{
-    mDisplayFrames.clear();
-
-    if (mDisplayArea.width == 0 && mDisplayArea.height == 0) {
-        mDisplayFrames.push_back({0, 0, 0, 0});
-        return;
-    }
-
-    for (const auto& frectScalar : mFrectScalars) {
-        mDisplayFrames.push_back({
-                static_cast<int>(frectScalar.left * mDisplayArea.width),
-                static_cast<int>(frectScalar.top * mDisplayArea.height),
-                static_cast<int>(frectScalar.right * mDisplayArea.width),
-                static_cast<int>(frectScalar.bottom * mDisplayArea.height)});
-    }
-}
-
-const std::vector<hwc_frect_t> Hwc2TestDisplayFrame::mDefaultFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestDisplayFrame::mBasicFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.0, 1.0, 0.05},
-    {0.0, 0.95, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestDisplayFrame::mCompleteFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.05, 1.0, 0.95},
-    {0.0, 0.05, 1.0, 1.0},
-    {0.0, 0.0, 1.0, 0.05},
-    {0.0, 0.95, 1.0, 1.0},
-    {0.25, 0.0, 0.75, 0.35},
-    {0.25, 0.25, 0.75, 0.75},
-};
-
-
-Hwc2TestPlaneAlpha::Hwc2TestPlaneAlpha(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompletePlaneAlphas, mBasicPlaneAlphas,
-            mDefaultPlaneAlphas, mCompositionSupport) { }
-
-std::string Hwc2TestPlaneAlpha::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\tplane alpha: " << get() << "\n";
-    return dmp.str();
-}
-
-const std::vector<float> Hwc2TestPlaneAlpha::mDefaultPlaneAlphas = {
-    1.0f,
-};
-
-const std::vector<float> Hwc2TestPlaneAlpha::mBasicPlaneAlphas = {
-    1.0f, 0.0f,
-};
-
-const std::vector<float> Hwc2TestPlaneAlpha::mCompletePlaneAlphas = {
-    1.0f, 0.75f, 0.5f, 0.25f, 0.0f,
-};
-
-
-Hwc2TestSourceCrop::Hwc2TestSourceCrop(Hwc2TestCoverage coverage,
-        const Area& bufferArea)
-    : Hwc2TestProperty(mSourceCrops, mCompositionSupport),
-      mFrectScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteFrectScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicFrectScalars:
-            mDefaultFrectScalars),
-      mBufferArea(bufferArea)
-{
-    update();
-}
-
-std::string Hwc2TestSourceCrop::dump() const
-{
-    std::stringstream dmp;
-    const hwc_frect_t& sourceCrop = get();
-    dmp << "\tsource crop: left " << sourceCrop.left << ", top "
-            << sourceCrop.top << ", right " << sourceCrop.right << ", bottom "
-            << sourceCrop.bottom << "\n";
-    return dmp.str();
-}
-
-void Hwc2TestSourceCrop::updateBufferArea(const Area& bufferArea)
-{
-    mBufferArea = bufferArea;
-    update();
-}
-
-void Hwc2TestSourceCrop::update()
-{
-    mSourceCrops.clear();
-
-    if (mBufferArea.width == 0 && mBufferArea.height == 0) {
-        mSourceCrops.push_back({0, 0, 0, 0});
-        return;
-    }
-
-    for (const auto& frectScalar : mFrectScalars) {
-        mSourceCrops.push_back({
-                frectScalar.left * mBufferArea.width,
-                frectScalar.top * mBufferArea.height,
-                frectScalar.right * mBufferArea.width,
-                frectScalar.bottom * mBufferArea.height});
-    }
-}
-
-const std::vector<hwc_frect_t> Hwc2TestSourceCrop::mDefaultFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestSourceCrop::mBasicFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.0, 0.5, 0.5},
-    {0.5, 0.5, 1.0, 1.0},
-};
-
-const std::vector<hwc_frect_t> Hwc2TestSourceCrop::mCompleteFrectScalars = {
-    {0.0, 0.0, 1.0, 1.0},
-    {0.0, 0.0, 0.5, 0.5},
-    {0.5, 0.5, 1.0, 1.0},
-    {0.0, 0.0, 0.25, 0.25},
-    {0.25, 0.25, 0.75, 0.75},
-};
-
-
-Hwc2TestSurfaceDamage::Hwc2TestSurfaceDamage(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(mSurfaceDamages, mCompositionSupport),
-      mRegionScalars((coverage == Hwc2TestCoverage::Complete)? mCompleteRegionScalars:
-            (coverage == Hwc2TestCoverage::Basic)? mBasicRegionScalars:
-            mDefaultRegionScalars)
-{
-    update();
-}
-
-Hwc2TestSurfaceDamage::~Hwc2TestSurfaceDamage()
-{
-    freeSurfaceDamages();
-}
-
-std::string Hwc2TestSurfaceDamage::dump() const
-{
-    std::stringstream dmp;
-
-    const hwc_region_t& curr = get();
-    dmp << "\tsurface damage: region count " << curr.numRects << "\n";
-    for (size_t i = 0; i < curr.numRects; i++) {
-        const hwc_rect_t& rect = curr.rects[i];
-        dmp << "\t\trect: left " << rect.left << ", top " << rect.top
-                << ", right " << rect.right << ", bottom " << rect.bottom << "\n";
-    }
-
-    return dmp.str();
-}
-
-void Hwc2TestSurfaceDamage::updateBufferArea(const Area& bufferArea)
-{
-    mBufferArea = bufferArea;
-    update();
-}
-
-void Hwc2TestSurfaceDamage::update()
-{
-    freeSurfaceDamages();
-
-    if (mBufferArea.width == 0 && mBufferArea.height == 0) {
-        mSurfaceDamages.push_back({0, nullptr});
-        return;
-    }
-
-    hwc_region_t damage;
-
-    for (const auto& regionScalar : mRegionScalars) {
-        damage.numRects = regionScalar.size();
-
-        if (damage.numRects > 0) {
-            hwc_rect_t* rects = new hwc_rect_t[damage.numRects];
-            if (!rects) {
-                ALOGW("failed to allocate new hwc_rect_t array");
-                continue;
-            }
-
-            for (size_t i = 0; i < damage.numRects; i++) {
-                rects[i].left = regionScalar[i].left * mBufferArea.width;
-                rects[i].top = regionScalar[i].top * mBufferArea.height;
-                rects[i].right = regionScalar[i].right * mBufferArea.width;
-                rects[i].bottom = regionScalar[i].bottom * mBufferArea.height;
-            }
-
-            damage.rects = static_cast<hwc_rect_t const*>(rects);
-        } else {
-            damage.rects = nullptr;
-        }
-
-        mSurfaceDamages.push_back(damage);
-    }
-}
-
-void Hwc2TestSurfaceDamage::freeSurfaceDamages()
-{
-    for (const auto& surfaceDamage : mSurfaceDamages) {
-        if (surfaceDamage.numRects > 0 && surfaceDamage.rects)
-            delete[] surfaceDamage.rects;
-    }
-    mSurfaceDamages.clear();
-}
-
-const std::vector<std::vector<hwc_frect_t>> Hwc2TestSurfaceDamage::mDefaultRegionScalars = {
-    {{}},
-};
-
-const std::vector<std::vector<hwc_frect_t>> Hwc2TestSurfaceDamage::mBasicRegionScalars = {
-    {{}},
-    {{0.0, 0.0, 1.0, 1.0}},
-};
-
-const std::vector<std::vector<hwc_frect_t>> Hwc2TestSurfaceDamage::mCompleteRegionScalars = {
-    {{}},
-    {{0.0, 0.0, 1.0, 1.0}},
-    {{0.0, 0.0, 0.5, 0.5}, {0.5, 0.5, 1.0, 1.0}},
-};
-
-
-Hwc2TestTransform::Hwc2TestTransform(Hwc2TestCoverage coverage)
-    : Hwc2TestProperty(coverage, mCompleteTransforms, mBasicTransforms,
-            mDefaultTransforms, mCompositionSupport) { }
-
-std::string Hwc2TestTransform::dump() const
-{
-    std::stringstream dmp;
-    dmp << "\ttransform: " << getTransformName(get()) << "\n";
-    return dmp.str();
-}
-
-const std::vector<hwc_transform_t> Hwc2TestTransform::mDefaultTransforms = {
-    static_cast<hwc_transform_t>(0),
-};
-
-const std::vector<hwc_transform_t> Hwc2TestTransform::mBasicTransforms = {
-    static_cast<hwc_transform_t>(0),
-    HWC_TRANSFORM_FLIP_H,
-    HWC_TRANSFORM_FLIP_V,
-    HWC_TRANSFORM_ROT_90,
-};
-
-const std::vector<hwc_transform_t> Hwc2TestTransform::mCompleteTransforms = {
-    static_cast<hwc_transform_t>(0),
-    HWC_TRANSFORM_FLIP_H,
-    HWC_TRANSFORM_FLIP_V,
-    HWC_TRANSFORM_ROT_90,
-    HWC_TRANSFORM_ROT_180,
-    HWC_TRANSFORM_ROT_270,
-    HWC_TRANSFORM_FLIP_H_ROT_90,
-    HWC_TRANSFORM_FLIP_V_ROT_90,
-};
-
-
-Hwc2TestVisibleRegion::~Hwc2TestVisibleRegion()
-{
-    release();
-}
-
-std::string Hwc2TestVisibleRegion::dump() const
-{
-    std::stringstream dmp;
-
-    const hwc_region_t& curr = get();
-    dmp << "\tvisible region: region count " << curr.numRects << "\n";
-    for (size_t i = 0; i < curr.numRects; i++) {
-        const hwc_rect_t& rect = curr.rects[i];
-        dmp << "\t\trect: left " << rect.left << ", top " << rect.top
-                << ", right " << rect.right << ", bottom " << rect.bottom << "\n";
-    }
-
-    return dmp.str();
-}
-
-void Hwc2TestVisibleRegion::set(const android::Region& visibleRegion)
-{
-    release();
-
-    size_t size = 0;
-    const android::Rect* rects = visibleRegion.getArray(&size);
-
-    mVisibleRegion.numRects = size;
-    mVisibleRegion.rects = nullptr;
-
-    if (size > 0) {
-        hwc_rect_t* hwcRects = new hwc_rect_t[size];
-        for (size_t i = 0; i < size; i++) {
-            hwcRects[i].left = rects[i].left;
-            hwcRects[i].top = rects[i].top;
-            hwcRects[i].right = rects[i].right;
-            hwcRects[i].bottom = rects[i].bottom;
-        }
-        mVisibleRegion.rects = hwcRects;
-    }
-}
-
-hwc_region_t Hwc2TestVisibleRegion::get() const
-{
-    return mVisibleRegion;
-}
-
-void Hwc2TestVisibleRegion::release()
-{
-    if (mVisibleRegion.numRects > 0 && mVisibleRegion.rects)
-        delete[] mVisibleRegion.rects;
-    mVisibleRegion.rects = nullptr;
-    mVisibleRegion.numRects = 0;
-}
-
-/* Identifies which layer properties are supported by each composition type.
- * hwc2_composition_t values range from:
- *  HWC2_COMPOSITION_INVALID = 0,
- *  HWC2_COMPOSITION_CLIENT = 1,
- *  HWC2_COMPOSITION_DEVICE = 2,
- *  HWC2_COMPOSITION_SOLID_COLOR = 3,
- *  HWC2_COMPOSITION_CURSOR = 4,
- *  HWC2_COMPOSITION_SIDEBAND = 5,
- *
- * Each property array can be indexed by a hwc2_composition_t value.
- * By using an array instead of a more complex data structure, runtimes for
- * some test cases showed a noticeable improvement.
- */
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestBufferArea::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestBlendMode::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestColor::mCompositionSupport = {{
-    false,   false,   false,   true,    false,   false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestComposition::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestDataspace::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestDisplayDimension::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestDisplayFrame::mCompositionSupport = {{
-    false,   true,    true,    true,    false,   true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestPlaneAlpha::mCompositionSupport = {{
-    false,   true,    true,    true,    true,    true,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestSourceCrop::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestSurfaceDamage::mCompositionSupport = {{
-    false,   false,   true,    false,   true,    false,
-}};
-
-/*  INVALID  CLIENT   DEVICE   COLOR    CURSOR   SIDEBAND */
-const std::array<bool, 6> Hwc2TestTransform::mCompositionSupport = {{
-    false,   true,    true,    false,   true,    true,
-}};
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h b/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h
deleted file mode 100644
index c2029aba04..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestProperties.h
+++ /dev/null
@@ -1,384 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_PROPERTIES_H
-#define _HWC2_TEST_PROPERTIES_H
-
-#include <array>
-#include <vector>
-
-#include <ui/Region.h>
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-enum class Hwc2TestCoverage {
-    Default = 0,
-    Basic,
-    Complete,
-};
-
-enum class Hwc2TestPropertyName {
-    BlendMode = 1,
-    BufferArea,
-    Color,
-    Composition,
-    CursorPosition,
-    Dataspace,
-    DisplayFrame,
-    PlaneAlpha,
-    SourceCrop,
-    SurfaceDamage,
-    Transform,
-};
-
-typedef struct {
-    int32_t width;
-    int32_t height;
-} Area;
-
-
-typedef struct {
-    uint32_t width;
-    uint32_t height;
-} UnsignedArea;
-
-
-class Hwc2TestContainer {
-public:
-    virtual ~Hwc2TestContainer() = default;
-
-    /* Resets the container */
-    virtual void reset() = 0;
-
-    /* Attempts to advance to the next valid value. Returns true if one can be
-     * found */
-    virtual bool advance() = 0;
-
-    virtual std::string dump() const = 0;
-
-    /* Returns true if the container supports the given composition type */
-    virtual bool isSupported(hwc2_composition_t composition) = 0;
-};
-
-
-template <class T>
-class Hwc2TestProperty : public Hwc2TestContainer {
-public:
-    Hwc2TestProperty(Hwc2TestCoverage coverage,
-            const std::vector<T>& completeList, const std::vector<T>& basicList,
-            const std::vector<T>& defaultList,
-            const std::array<bool, 6>& compositionSupport)
-        : Hwc2TestProperty((coverage == Hwc2TestCoverage::Complete)? completeList:
-                (coverage == Hwc2TestCoverage::Basic)? basicList : defaultList,
-                compositionSupport) { }
-
-    Hwc2TestProperty(const std::vector<T>& list,
-            const std::array<bool, 6>& compositionSupport)
-        : mList(list),
-          mCompositionSupport(compositionSupport) { }
-
-    void reset() override
-    {
-        mListIdx = 0;
-    }
-
-    bool advance() override
-    {
-        if (mListIdx + 1 < mList.size()) {
-            mListIdx++;
-            updateDependents();
-            return true;
-        }
-        reset();
-        updateDependents();
-        return false;
-    }
-
-    T get() const
-    {
-        return mList.at(mListIdx);
-    }
-
-    virtual bool isSupported(hwc2_composition_t composition)
-    {
-        return mCompositionSupport.at(composition);
-    }
-
-protected:
-    /* If a derived class has dependents, override this function */
-    virtual void updateDependents() { }
-
-    const std::vector<T>& mList;
-    size_t mListIdx = 0;
-
-    const std::array<bool, 6>& mCompositionSupport;
-};
-
-class Hwc2TestBuffer;
-class Hwc2TestSourceCrop;
-class Hwc2TestSurfaceDamage;
-
-class Hwc2TestBufferArea : public Hwc2TestProperty<Area> {
-public:
-    Hwc2TestBufferArea(Hwc2TestCoverage coverage, const Area& displayArea);
-
-    std::string dump() const override;
-
-    void setDependent(Hwc2TestBuffer* buffer);
-    void setDependent(Hwc2TestSourceCrop* sourceCrop);
-    void setDependent(Hwc2TestSurfaceDamage* surfaceDamage);
-
-protected:
-    void update();
-    void updateDependents() override;
-
-    const std::vector<float>& mScalars;
-    static const std::vector<float> mDefaultScalars;
-    static const std::vector<float> mBasicScalars;
-    static const std::vector<float> mCompleteScalars;
-
-    Area mDisplayArea;
-
-    Hwc2TestBuffer* mBuffer = nullptr;
-    Hwc2TestSourceCrop* mSourceCrop = nullptr;
-    Hwc2TestSurfaceDamage* mSurfaceDamage = nullptr;
-
-    std::vector<Area> mBufferAreas;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestColor;
-
-class Hwc2TestBlendMode : public Hwc2TestProperty<hwc2_blend_mode_t> {
-public:
-    Hwc2TestBlendMode(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-    void setDependent(Hwc2TestColor* color);
-
-protected:
-    void updateDependents() override;
-
-    Hwc2TestColor* mColor = nullptr;
-
-    static const std::vector<hwc2_blend_mode_t> mDefaultBlendModes;
-    static const std::vector<hwc2_blend_mode_t> mBasicBlendModes;
-    static const std::vector<hwc2_blend_mode_t> mCompleteBlendModes;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestColor : public Hwc2TestProperty<hwc_color_t> {
-public:
-    Hwc2TestColor(Hwc2TestCoverage coverage,
-            hwc2_blend_mode_t blendMode = HWC2_BLEND_MODE_NONE);
-
-    std::string dump() const override;
-
-    void updateBlendMode(hwc2_blend_mode_t blendMode);
-
-protected:
-    void update();
-
-    std::vector<hwc_color_t> mBaseColors;
-    static const std::vector<hwc_color_t> mDefaultBaseColors;
-    static const std::vector<hwc_color_t> mBasicBaseColors;
-    static const std::vector<hwc_color_t> mCompleteBaseColors;
-
-    hwc2_blend_mode_t mBlendMode;
-
-    std::vector<hwc_color_t> mColors;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestComposition : public Hwc2TestProperty<hwc2_composition_t> {
-public:
-    Hwc2TestComposition(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<hwc2_composition_t> mDefaultCompositions;
-    static const std::vector<hwc2_composition_t> mBasicCompositions;
-    static const std::vector<hwc2_composition_t> mCompleteCompositions;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestDataspace : public Hwc2TestProperty<android_dataspace_t> {
-public:
-    Hwc2TestDataspace(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<android_dataspace_t> defaultDataspaces;
-    static const std::vector<android_dataspace_t> basicDataspaces;
-    static const std::vector<android_dataspace_t> completeDataspaces;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestDisplayDimension : public Hwc2TestProperty<UnsignedArea> {
-public:
-    Hwc2TestDisplayDimension(Hwc2TestCoverage coverage);
-
-    std::string dump() const;
-
-    void setDependent(Hwc2TestBuffer* buffer);
-
-private:
-    void updateDependents();
-
-    Hwc2TestBuffer* mBuffer;
-
-    static const std::vector<UnsignedArea> mDefaultDisplayDimensions;
-    static const std::vector<UnsignedArea> mBasicDisplayDimensions;
-    static const std::vector<UnsignedArea> mCompleteDisplayDimensions;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestDisplayFrame : public Hwc2TestProperty<hwc_rect_t> {
-public:
-    Hwc2TestDisplayFrame(Hwc2TestCoverage coverage, const Area& displayArea);
-
-    std::string dump() const override;
-
-protected:
-    void update();
-
-    const std::vector<hwc_frect_t>& mFrectScalars;
-    const static std::vector<hwc_frect_t> mDefaultFrectScalars;
-    const static std::vector<hwc_frect_t> mBasicFrectScalars;
-    const static std::vector<hwc_frect_t> mCompleteFrectScalars;
-
-    Area mDisplayArea;
-
-    std::vector<hwc_rect_t> mDisplayFrames;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestPlaneAlpha : public Hwc2TestProperty<float> {
-public:
-    Hwc2TestPlaneAlpha(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<float> mDefaultPlaneAlphas;
-    static const std::vector<float> mBasicPlaneAlphas;
-    static const std::vector<float> mCompletePlaneAlphas;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestSourceCrop : public Hwc2TestProperty<hwc_frect_t> {
-public:
-    Hwc2TestSourceCrop(Hwc2TestCoverage coverage, const Area& bufferArea = {0, 0});
-
-    std::string dump() const override;
-
-    void updateBufferArea(const Area& bufferArea);
-
-protected:
-    void update();
-
-    const std::vector<hwc_frect_t>& mFrectScalars;
-    const static std::vector<hwc_frect_t> mDefaultFrectScalars;
-    const static std::vector<hwc_frect_t> mBasicFrectScalars;
-    const static std::vector<hwc_frect_t> mCompleteFrectScalars;
-
-    Area mBufferArea;
-
-    std::vector<hwc_frect_t> mSourceCrops;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestSurfaceDamage : public Hwc2TestProperty<hwc_region_t> {
-public:
-    Hwc2TestSurfaceDamage(Hwc2TestCoverage coverage);
-    ~Hwc2TestSurfaceDamage();
-
-    std::string dump() const override;
-
-    void updateBufferArea(const Area& bufferArea);
-
-protected:
-    void update();
-    void freeSurfaceDamages();
-
-    const std::vector<std::vector<hwc_frect_t>> &mRegionScalars;
-    const static std::vector<std::vector<hwc_frect_t>> mDefaultRegionScalars;
-    const static std::vector<std::vector<hwc_frect_t>> mBasicRegionScalars;
-    const static std::vector<std::vector<hwc_frect_t>> mCompleteRegionScalars;
-
-    Area mBufferArea = {0, 0};
-
-    std::vector<hwc_region_t> mSurfaceDamages;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestTransform : public Hwc2TestProperty<hwc_transform_t> {
-public:
-    Hwc2TestTransform(Hwc2TestCoverage coverage);
-
-    std::string dump() const override;
-
-protected:
-    static const std::vector<hwc_transform_t> mDefaultTransforms;
-    static const std::vector<hwc_transform_t> mBasicTransforms;
-    static const std::vector<hwc_transform_t> mCompleteTransforms;
-
-    static const std::array<bool, 6> mCompositionSupport;
-};
-
-
-class Hwc2TestVisibleRegion {
-public:
-    ~Hwc2TestVisibleRegion();
-
-    std::string dump() const;
-
-    void set(const android::Region& visibleRegion);
-    hwc_region_t get() const;
-    void release();
-
-protected:
-    hwc_region_t mVisibleRegion = {0, nullptr};
-};
-
-#endif /* ifndef _HWC2_TEST_PROPERTIES_H */
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp b/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp
deleted file mode 100644
index d0fbc0b5ad..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-
-#include "Hwc2TestVirtualDisplay.h"
-
-Hwc2TestVirtualDisplay::Hwc2TestVirtualDisplay(
-        Hwc2TestCoverage coverage)
-    : mDisplayDimension(coverage)
-{
-    mDisplayDimension.setDependent(&mBuffer);
-}
-
-std::string Hwc2TestVirtualDisplay::dump() const
-{
-    std::stringstream dmp;
-
-    dmp << "virtual display: \n";
-
-    mDisplayDimension.dump();
-
-    return dmp.str();
-}
-
-int Hwc2TestVirtualDisplay::getBuffer(buffer_handle_t* outHandle,
-        android::base::unique_fd* outAcquireFence)
-{
-    int32_t acquireFence;
-    int ret = mBuffer.get(outHandle, &acquireFence);
-    outAcquireFence->reset(acquireFence);
-    return ret;
-}
-
-void Hwc2TestVirtualDisplay::reset()
-{
-    return mDisplayDimension.reset();
-}
-
-bool Hwc2TestVirtualDisplay::advance()
-{
-    return mDisplayDimension.advance();
-}
-
-UnsignedArea Hwc2TestVirtualDisplay::getDisplayDimension() const
-{
-    return mDisplayDimension.get();
-}
diff --git a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h b/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h
deleted file mode 100644
index 09420ef629..0000000000
--- a/services/surfaceflinger/tests/hwc2/Hwc2TestVirtualDisplay.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HWC2_TEST_VIRTUAL_DISPLAY_H
-#define _HWC2_TEST_VIRTUAL_DISPLAY_H
-
-#include "Hwc2TestBuffer.h"
-#include "Hwc2TestProperties.h"
-
-#define HWC2_INCLUDE_STRINGIFICATION
-#define HWC2_USE_CPP11
-#include <hardware/hwcomposer2.h>
-#undef HWC2_INCLUDE_STRINGIFICATION
-#undef HWC2_USE_CPP11
-
-class Hwc2TestVirtualDisplay {
-public:
-    Hwc2TestVirtualDisplay(Hwc2TestCoverage coverage);
-
-    std::string dump() const;
-
-    int getBuffer(buffer_handle_t* outHandle,
-            android::base::unique_fd* outAcquireFence);
-
-    void reset();
-    bool advance();
-
-    UnsignedArea getDisplayDimension() const;
-
-private:
-    Hwc2TestBuffer mBuffer;
-
-    Hwc2TestDisplayDimension mDisplayDimension;
-};
-
-#endif /* ifndef _HWC2_TEST_VIRTUAL_DISPLAY_H */
diff --git a/services/surfaceflinger/tests/vsync/Android.mk b/services/surfaceflinger/tests/vsync/Android.mk
deleted file mode 100644
index 8e41617f7b..0000000000
--- a/services/surfaceflinger/tests/vsync/Android.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-	vsync.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-	libcutils \
-	libutils \
-	libbinder \
-    libui \
-    libgui
-
-LOCAL_MODULE:= test-vsync-events
-
-LOCAL_MODULE_TAGS := tests
-
-LOCAL_CFLAGS := -Werror
-
-include $(BUILD_EXECUTABLE)
diff --git a/services/surfaceflinger/tests/vsync/vsync.cpp b/services/surfaceflinger/tests/vsync/vsync.cpp
deleted file mode 100644
index a1b45e6adb..0000000000
--- a/services/surfaceflinger/tests/vsync/vsync.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android/looper.h>
-#include <gui/DisplayEventReceiver.h>
-#include <utils/Looper.h>
-
-using namespace android;
-
-int receiver(int /*fd*/, int /*events*/, void* data)
-{
-    DisplayEventReceiver* q = (DisplayEventReceiver*)data;
-
-    ssize_t n;
-    DisplayEventReceiver::Event buffer[1];
-
-    static nsecs_t oldTimeStamp = 0;
-
-    while ((n = q->getEvents(buffer, 1)) > 0) {
-        for (int i=0 ; i<n ; i++) {
-            if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) {
-                printf("event vsync: count=%d\t", buffer[i].vsync.count);
-            }
-            if (oldTimeStamp) {
-                float t = float(buffer[i].header.timestamp - oldTimeStamp) / s2ns(1);
-                printf("%f ms (%f Hz)\n", t*1000, 1.0/t);
-            }
-            oldTimeStamp = buffer[i].header.timestamp;
-        }
-    }
-    if (n<0) {
-        printf("error reading events (%s)\n", strerror(-n));
-    }
-    return 1;
-}
-
-int main(int /*argc*/, char** /*argv*/)
-{
-    DisplayEventReceiver myDisplayEvent;
-
-
-    sp<Looper> loop = new Looper(false);
-    loop->addFd(myDisplayEvent.getFd(), 0, ALOOPER_EVENT_INPUT, receiver,
-            &myDisplayEvent);
-
-    myDisplayEvent.setVsyncRate(1);
-
-    do {
-        //printf("about to poll...\n");
-        int32_t ret = loop->pollOnce(-1);
-        switch (ret) {
-            case ALOOPER_POLL_WAKE:
-                //("ALOOPER_POLL_WAKE\n");
-                break;
-            case ALOOPER_POLL_CALLBACK:
-                //("ALOOPER_POLL_CALLBACK\n");
-                break;
-            case ALOOPER_POLL_TIMEOUT:
-                printf("ALOOPER_POLL_TIMEOUT\n");
-                break;
-            case ALOOPER_POLL_ERROR:
-                printf("ALOOPER_POLL_TIMEOUT\n");
-                break;
-            default:
-                printf("ugh? poll returned %d\n", ret);
-                break;
-        }
-    } while (1);
-
-    return 0;
-}
diff --git a/services/surfaceflinger/tests/waitforvsync/Android.mk b/services/surfaceflinger/tests/waitforvsync/Android.mk
deleted file mode 100644
index 932d2be133..0000000000
--- a/services/surfaceflinger/tests/waitforvsync/Android.mk
+++ /dev/null
@@ -1,16 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-	waitforvsync.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-	libcutils \
-
-LOCAL_MODULE:= test-waitforvsync
-
-LOCAL_MODULE_TAGS := tests
-
-LOCAL_CFLAGS := -Werror
-
-include $(BUILD_EXECUTABLE)
diff --git a/services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp b/services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp
deleted file mode 100644
index 65eaae58b7..0000000000
--- a/services/surfaceflinger/tests/waitforvsync/waitforvsync.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <linux/fb.h>
-#include <errno.h>
-#include <string.h>
-#include <stdio.h>
-#include <unistd.h>
-
-#ifndef FBIO_WAITFORVSYNC
-#define FBIO_WAITFORVSYNC   _IOW('F', 0x20, __u32)
-#endif
-
-int main(int /*argc*/, char** /*argv*/) {
-    int fd = open("/dev/graphics/fb0", O_RDWR);
-    if (fd >= 0) {
-        do {
-            uint32_t crt = 0;
-           int err = ioctl(fd, FBIO_WAITFORVSYNC, &crt);
-           if (err < 0) {
-               printf("FBIO_WAITFORVSYNC error: %s\n", strerror(errno));
-               break;
-           }
-        } while(1);
-        close(fd);
-    }
-    return 0;
-}
-- 
2.17.0

