From 5d2cce65f9e320ae9c39fb28c82942d00c191aa1 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 17 Sep 2018 01:35:09 +0300
Subject: [PATCH 26/49] libui: reset to lineage-15.1

Change-Id: Iacf08590eed5975551f1a506dc33e45c17b3e8fa
---
 libs/nativewindow/AHardwareBuffer.cpp       |   2 +-
 libs/ui/Android.bp                          |  27 +---
 libs/ui/DebugUtils.cpp                      | 113 ++++----------
 libs/ui/Fence.cpp                           |  18 ++-
 libs/ui/Gralloc2.cpp                        | 149 ++----------------
 libs/ui/GraphicBuffer.cpp                   | 207 +++++++++++++------------
 libs/ui/GraphicBufferAllocator.cpp          | 105 ++++++-------
 libs/ui/GraphicBufferMapper.cpp             | 225 ++++++++++++++++------------
 libs/ui/Region.cpp                          |  11 --
 libs/ui/include/ui/DebugUtils.h             |  11 +-
 libs/ui/include/ui/Fence.h                  |  12 +-
 libs/ui/include/ui/FenceTime.h              |   4 +
 libs/ui/include/ui/Gralloc2.h               |  28 ++--
 libs/ui/include/ui/GraphicBuffer.h          |  21 ++-
 libs/ui/include/ui/GraphicBufferAllocator.h |  36 +++--
 libs/ui/include/ui/GraphicBufferMapper.h    |  26 +---
 libs/ui/include/ui/PixelFormat.h            |   9 ++
 libs/ui/include/ui/Rect.h                   |   3 -
 libs/ui/include/ui/Region.h                 |  24 +++
 19 files changed, 453 insertions(+), 578 deletions(-)

diff --git a/libs/nativewindow/AHardwareBuffer.cpp b/libs/nativewindow/AHardwareBuffer.cpp
index 203816284..cf4d9d9ac 100644
--- a/libs/nativewindow/AHardwareBuffer.cpp
+++ b/libs/nativewindow/AHardwareBuffer.cpp
@@ -127,7 +127,7 @@ int AHardwareBuffer_lock(AHardwareBuffer* buffer, uint64_t usage,
     } else {
         bounds.set(Rect(rect->left, rect->top, rect->right, rect->bottom));
     }
-    return gBuffer->lockAsync(usage, usage, bounds, outVirtualAddress, fence);
+    return gBuffer->lockAsync(usage, bounds, outVirtualAddress, fence);
 }
 
 int AHardwareBuffer_unlock(AHardwareBuffer* buffer, int32_t* fence) {
diff --git a/libs/ui/Android.bp b/libs/ui/Android.bp
index 25c353a51..1b02b4f7b 100644
--- a/libs/ui/Android.bp
+++ b/libs/ui/Android.bp
@@ -20,12 +20,11 @@ cc_library_shared {
     },
 
     clang: true,
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
+    cflags: ["-DEGL_NEEDS_HANDLE"],
     cppflags: [
         "-Weverything",
+        "-Wno-unused-variable",
+        "-Wno-unused-function",
 
         // The static constructors and destructors in this library have not been noted to
         // introduce significant overheads
@@ -55,7 +54,7 @@ cc_library_shared {
     },
 
     sanitize: {
-        integer_overflow: true,
+        //misc_undefined: ["integer"],
     },
 
     srcs: [
@@ -64,7 +63,7 @@ cc_library_shared {
         "Fence.cpp",
         "FenceTime.cpp",
         "FrameStats.cpp",
-        "Gralloc2.cpp",
+        "FramebufferNativeWindow.cpp",
         "GraphicBuffer.cpp",
         "GraphicBufferAllocator.cpp",
         "GraphicBufferMapper.cpp",
@@ -109,23 +108,21 @@ cc_library_shared {
     ],
 
     header_libs: [
-        "libbase_headers",
         "libnativebase_headers",
         "libhardware_headers",
-        "libui_headers",
         "libpdx_headers",
     ],
 
+    export_include_dirs: ["include"],
+
     export_static_lib_headers: [
         "libarect",
         "libmath",
     ],
 
     export_header_lib_headers: [
-        "libbase_headers",
         "libnativebase_headers",
         "libhardware_headers",
-        "libui_headers",
     ],
 }
 
@@ -133,14 +130,4 @@ cc_library_headers {
     name: "libui_headers",
     export_include_dirs: ["include"],
     vendor_available: true,
-    target: {
-        vendor: {
-            override_export_include_dirs: ["include_vndk"],
-        },
-    },
 }
-
-subdirs = [
-    "tests",
-    "tools",
-]
diff --git a/libs/ui/DebugUtils.cpp b/libs/ui/DebugUtils.cpp
index 61df02d41..d5676cc2b 100644
--- a/libs/ui/DebugUtils.cpp
+++ b/libs/ui/DebugUtils.cpp
@@ -16,15 +16,10 @@
 
 #include <ui/DebugUtils.h>
 #include <ui/PixelFormat.h>
-#include <ui/Rect.h>
 
 #include <android-base/stringprintf.h>
 #include <string>
 
-using android::base::StringPrintf;
-using android::ui::ColorMode;
-using android::ui::RenderIntent;
-
 std::string decodeStandard(android_dataspace dataspace) {
     const uint32_t dataspaceSelect = (dataspace & HAL_DATASPACE_STANDARD_MASK);
     switch (dataspaceSelect) {
@@ -76,7 +71,7 @@ std::string decodeStandard(android_dataspace dataspace) {
                 case HAL_DATASPACE_SRGB:
                     return std::string("(deprecated) sRGB");
 
-                case HAL_DATASPACE_BT709:
+                case HAL_DATASPACE_V0_BT709:
                     return std::string("(deprecated) BT709");
 
                 case HAL_DATASPACE_ARBITRARY:
@@ -86,7 +81,7 @@ std::string decodeStandard(android_dataspace dataspace) {
                 // Fallthrough
                 default:
                     return android::base::StringPrintf("Unknown deprecated dataspace code %d",
-                                                       dataspace);
+                                                       dataspaceSelect);
             }
     }
 
@@ -100,7 +95,7 @@ std::string decodeTransfer(android_dataspace dataspace) {
             case HAL_DATASPACE_JFIF:
             case HAL_DATASPACE_BT601_625:
             case HAL_DATASPACE_BT601_525:
-            case HAL_DATASPACE_BT709:
+            case HAL_DATASPACE_V0_BT709:
                 return std::string("SMPTE_170M");
 
             case HAL_DATASPACE_SRGB_LINEAR:
@@ -161,8 +156,8 @@ std::string decodeRange(android_dataspace dataspace) {
 
             case HAL_DATASPACE_BT601_625:
             case HAL_DATASPACE_BT601_525:
-            case HAL_DATASPACE_BT709:
-                return std::string("Limited range");
+            case HAL_DATASPACE_V0_BT709:
+                return std::string("Limited range)");
 
             case HAL_DATASPACE_ARBITRARY:
             case HAL_DATASPACE_UNKNOWN:
@@ -192,85 +187,49 @@ std::string decodeRange(android_dataspace dataspace) {
 
 std::string dataspaceDetails(android_dataspace dataspace) {
     if (dataspace == 0) {
-        return "Default";
+        return "Default (0)";
     }
     return android::base::StringPrintf("%s %s %s", decodeStandard(dataspace).c_str(),
                                        decodeTransfer(dataspace).c_str(),
                                        decodeRange(dataspace).c_str());
 }
 
-std::string decodeColorMode(ColorMode colorMode) {
+std::string decodeColorMode(android_color_mode colorMode) {
     switch (colorMode) {
-        case ColorMode::NATIVE:
-            return std::string("ColorMode::NATIVE");
-
-        case ColorMode::STANDARD_BT601_625:
-            return std::string("ColorMode::BT601_625");
-
-        case ColorMode::STANDARD_BT601_625_UNADJUSTED:
-            return std::string("ColorMode::BT601_625_UNADJUSTED");
+        case HAL_COLOR_MODE_NATIVE:
+            return std::string("HAL_COLOR_MODE_NATIVE");
 
-        case ColorMode::STANDARD_BT601_525:
-            return std::string("ColorMode::BT601_525");
+        case HAL_COLOR_MODE_STANDARD_BT601_625:
+            return std::string("HAL_COLOR_MODE_BT601_625");
 
-        case ColorMode::STANDARD_BT601_525_UNADJUSTED:
-            return std::string("ColorMode::BT601_525_UNADJUSTED");
+        case HAL_COLOR_MODE_STANDARD_BT601_625_UNADJUSTED:
+            return std::string("HAL_COLOR_MODE_BT601_625_UNADJUSTED");
 
-        case ColorMode::STANDARD_BT709:
-            return std::string("ColorMode::BT709");
+        case HAL_COLOR_MODE_STANDARD_BT601_525:
+            return std::string("HAL_COLOR_MODE_BT601_525");
 
-        case ColorMode::DCI_P3:
-            return std::string("ColorMode::DCI_P3");
+        case HAL_COLOR_MODE_STANDARD_BT601_525_UNADJUSTED:
+            return std::string("HAL_COLOR_MODE_BT601_525_UNADJUSTED");
 
-        case ColorMode::SRGB:
-            return std::string("ColorMode::SRGB");
+        case HAL_COLOR_MODE_STANDARD_BT709:
+            return std::string("HAL_COLOR_MODE_BT709");
 
-        case ColorMode::ADOBE_RGB:
-            return std::string("ColorMode::ADOBE_RGB");
+        case HAL_COLOR_MODE_DCI_P3:
+            return std::string("HAL_COLOR_MODE_DCI_P3");
 
-        case ColorMode::DISPLAY_P3:
-            return std::string("ColorMode::DISPLAY_P3");
+        case HAL_COLOR_MODE_SRGB:
+            return std::string("HAL_COLOR_MODE_SRGB");
 
-        case ColorMode::BT2020:
-            return std::string("ColorMode::BT2020");
+        case HAL_COLOR_MODE_ADOBE_RGB:
+            return std::string("HAL_COLOR_MODE_ADOBE_RGB");
 
-        case ColorMode::BT2100_PQ:
-            return std::string("ColorMode::BT2100_PQ");
-
-        case ColorMode::BT2100_HLG:
-            return std::string("ColorMode::BT2100_HLG");
+        case HAL_COLOR_MODE_DISPLAY_P3:
+            return std::string("HAL_COLOR_MODE_DISPLAY_P3");
     }
 
     return android::base::StringPrintf("Unknown color mode %d", colorMode);
 }
 
-std::string decodeColorTransform(android_color_transform colorTransform) {
-    switch (colorTransform) {
-        case HAL_COLOR_TRANSFORM_IDENTITY:
-            return std::string("Identity");
-
-        case HAL_COLOR_TRANSFORM_ARBITRARY_MATRIX:
-            return std::string("Arbitrary matrix");
-
-        case HAL_COLOR_TRANSFORM_VALUE_INVERSE:
-            return std::string("Inverse value");
-
-        case HAL_COLOR_TRANSFORM_GRAYSCALE:
-            return std::string("Grayscale");
-
-        case HAL_COLOR_TRANSFORM_CORRECT_PROTANOPIA:
-            return std::string("Correct protanopia");
-
-        case HAL_COLOR_TRANSFORM_CORRECT_DEUTERANOPIA:
-            return std::string("Correct deuteranopia");
-
-        case HAL_COLOR_TRANSFORM_CORRECT_TRITANOPIA:
-            return std::string("Correct tritanopia");
-    }
-
-    return android::base::StringPrintf("Unknown color transform %d", colorTransform);
-}
-
 // Converts a PixelFormat to a human-readable string.  Max 11 chars.
 // (Could use a table of prefab String8 objects.)
 std::string decodePixelFormat(android::PixelFormat format) {
@@ -303,21 +262,3 @@ std::string decodePixelFormat(android::PixelFormat format) {
             return android::base::StringPrintf("Unknown %#08x", format);
     }
 }
-
-std::string decodeRenderIntent(RenderIntent renderIntent) {
-    switch(renderIntent) {
-      case RenderIntent::COLORIMETRIC:
-          return std::string("RenderIntent::COLORIMETRIC");
-      case RenderIntent::ENHANCE:
-          return std::string("RenderIntent::ENHANCE");
-      case RenderIntent::TONE_MAP_COLORIMETRIC:
-          return std::string("RenderIntent::TONE_MAP_COLORIMETRIC");
-      case RenderIntent::TONE_MAP_ENHANCE:
-          return std::string("RenderIntent::TONE_MAP_ENHANCE");
-    }
-    return std::string("Unknown RenderIntent");
-}
-
-std::string to_string(const android::Rect& rect) {
-    return StringPrintf("(%4d,%4d,%4d,%4d)", rect.left, rect.top, rect.right, rect.bottom);
-}
diff --git a/libs/ui/Fence.cpp b/libs/ui/Fence.cpp
index ff53aa8f2..b67f4d932 100644
--- a/libs/ui/Fence.cpp
+++ b/libs/ui/Fence.cpp
@@ -37,12 +37,18 @@ namespace android {
 
 const sp<Fence> Fence::NO_FENCE = sp<Fence>(new Fence);
 
+Fence::Fence() :
+    mFenceFd(-1) {
+}
+
 Fence::Fence(int fenceFd) :
     mFenceFd(fenceFd) {
 }
 
-Fence::Fence(base::unique_fd fenceFd) :
-    mFenceFd(std::move(fenceFd)) {
+Fence::~Fence() {
+    if (mFenceFd != -1) {
+        close(mFenceFd);
+    }
 }
 
 status_t Fence::wait(int timeout) {
@@ -62,7 +68,7 @@ status_t Fence::waitForever(const char* logname) {
     int warningTimeout = 3000;
     int err = sync_wait(mFenceFd, warningTimeout);
     if (err < 0 && errno == ETIME) {
-        ALOGE("%s: fence %d didn't signal in %u ms", logname, mFenceFd.get(),
+        ALOGE("%s: fence %d didn't signal in %u ms", logname, mFenceFd,
                 warningTimeout);
         err = sync_wait(mFenceFd, TIMEOUT_NEVER);
     }
@@ -88,7 +94,7 @@ sp<Fence> Fence::merge(const char* name, const sp<Fence>& f1,
     if (result == -1) {
         status_t err = -errno;
         ALOGE("merge: sync_merge(\"%s\", %d, %d) returned an error: %s (%d)",
-                name, f1->mFenceFd.get(), f2->mFenceFd.get(),
+                name, f1->mFenceFd, f2->mFenceFd,
                 strerror(-err), err);
         return NO_FENCE;
     }
@@ -111,7 +117,7 @@ nsecs_t Fence::getSignalTime() const {
 
     struct sync_fence_info_data* finfo = sync_fence_info(mFenceFd);
     if (finfo == NULL) {
-        ALOGE("sync_fence_info returned NULL for fd %d", mFenceFd.get());
+        ALOGE("sync_fence_info returned NULL for fd %d", mFenceFd);
         return SIGNAL_TIME_INVALID;
     }
     if (finfo->status != 1) {
@@ -175,7 +181,7 @@ status_t Fence::unflatten(void const*& buffer, size_t& size, int const*& fds, si
     }
 
     if (numFds) {
-        mFenceFd.reset(*fds++);
+        mFenceFd = *fds++;
         count--;
     }
 
diff --git a/libs/ui/Gralloc2.cpp b/libs/ui/Gralloc2.cpp
index 918251f9d..d252fb077 100644
--- a/libs/ui/Gralloc2.cpp
+++ b/libs/ui/Gralloc2.cpp
@@ -20,7 +20,6 @@
 #include <hwbinder/IPCThreadState.h>
 #include <ui/Gralloc2.h>
 
-#include <inttypes.h>
 #include <log/log.h>
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wzero-length-array"
@@ -31,110 +30,35 @@ namespace android {
 
 namespace Gralloc2 {
 
-namespace {
-
 static constexpr Error kTransactionError = Error::NO_RESOURCES;
 
-uint64_t getValid10UsageBits() {
-    static const uint64_t valid10UsageBits = []() -> uint64_t {
-        using hardware::graphics::common::V1_0::BufferUsage;
-        uint64_t bits = 0;
-        for (const auto bit : hardware::hidl_enum_iterator<BufferUsage>()) {
-            bits = bits | bit;
-        }
-        // TODO(b/72323293, b/72703005): Remove these additional bits
-        bits = bits | (1 << 10) | (1 << 13);
-
-#ifdef ADDNL_GRALLOC_10_USAGE_BITS
-        uint64_t addnl_bits = static_cast<uint64_t>(ADDNL_GRALLOC_10_USAGE_BITS);
-        ALOGI("Adding additional valid usage bits: 0x%" PRIx64, addnl_bits);
-        bits = bits | addnl_bits;
-#endif
-
-        return bits;
-    }();
-    return valid10UsageBits;
-}
-
-uint64_t getValid11UsageBits() {
-    static const uint64_t valid11UsageBits = []() -> uint64_t {
-        using hardware::graphics::common::V1_1::BufferUsage;
-        uint64_t bits = 0;
-        for (const auto bit : hardware::hidl_enum_iterator<BufferUsage>()) {
-            bits = bits | bit;
-        }
-        return bits;
-    }();
-    return valid11UsageBits;
-}
-
-}  // anonymous namespace
-
 void Mapper::preload() {
     android::hardware::preloadPassthroughService<hardware::graphics::mapper::V2_0::IMapper>();
 }
 
 Mapper::Mapper()
 {
-    mMapper = hardware::graphics::mapper::V2_0::IMapper::getService();
-    if (mMapper == nullptr) {
-        LOG_ALWAYS_FATAL("gralloc-mapper is missing");
-    }
-    if (mMapper->isRemote()) {
+    mMapper = IMapper::getService();
+    if (mMapper != nullptr && mMapper->isRemote()) {
         LOG_ALWAYS_FATAL("gralloc-mapper must be in passthrough mode");
     }
-
-    // IMapper 2.1 is optional
-    mMapperV2_1 = IMapper::castFrom(mMapper);
-}
-
-Gralloc2::Error Mapper::validateBufferDescriptorInfo(
-        const IMapper::BufferDescriptorInfo& descriptorInfo) const {
-    uint64_t validUsageBits = getValid10UsageBits();
-    if (mMapperV2_1 != nullptr) {
-        validUsageBits = validUsageBits | getValid11UsageBits();
-    }
-
-    if (descriptorInfo.usage & ~validUsageBits) {
-        ALOGE("buffer descriptor contains invalid usage bits 0x%" PRIx64,
-              descriptorInfo.usage & ~validUsageBits);
-        return Error::BAD_VALUE;
-    }
-    return Error::NONE;
 }
 
 Error Mapper::createDescriptor(
         const IMapper::BufferDescriptorInfo& descriptorInfo,
         BufferDescriptor* outDescriptor) const
 {
-    Error error = validateBufferDescriptorInfo(descriptorInfo);
-    if (error != Error::NONE) {
-        return error;
-    }
+    Error error;
+    auto ret = mMapper->createDescriptor(descriptorInfo,
+            [&](const auto& tmpError, const auto& tmpDescriptor)
+            {
+                error = tmpError;
+                if (error != Error::NONE) {
+                    return;
+                }
 
-    auto hidl_cb = [&](const auto& tmpError, const auto& tmpDescriptor)
-                   {
-                       error = tmpError;
-                       if (error != Error::NONE) {
-                           return;
-                       }
-
-                       *outDescriptor = tmpDescriptor;
-                   };
-
-    hardware::Return<void> ret;
-    if (mMapperV2_1 != nullptr) {
-        ret = mMapperV2_1->createDescriptor_2_1(descriptorInfo, hidl_cb);
-    } else {
-        const hardware::graphics::mapper::V2_0::IMapper::BufferDescriptorInfo info = {
-            descriptorInfo.width,
-            descriptorInfo.height,
-            descriptorInfo.layerCount,
-            static_cast<hardware::graphics::common::V1_0::PixelFormat>(descriptorInfo.format),
-            descriptorInfo.usage,
-        };
-        ret = mMapper->createDescriptor(info, hidl_cb);
-    }
+                *outDescriptor = tmpDescriptor;
+            });
 
     return (ret.isOk()) ? error : kTransactionError;
 }
@@ -167,50 +91,6 @@ void Mapper::freeBuffer(buffer_handle_t bufferHandle) const
             buffer, error);
 }
 
-Error Mapper::validateBufferSize(buffer_handle_t bufferHandle,
-        const IMapper::BufferDescriptorInfo& descriptorInfo,
-        uint32_t stride) const
-{
-    if (mMapperV2_1 == nullptr) {
-        return Error::NONE;
-    }
-
-    auto buffer = const_cast<native_handle_t*>(bufferHandle);
-    auto ret = mMapperV2_1->validateBufferSize(buffer, descriptorInfo, stride);
-
-    return (ret.isOk()) ? static_cast<Error>(ret) : kTransactionError;
-}
-
-void Mapper::getTransportSize(buffer_handle_t bufferHandle,
-        uint32_t* outNumFds, uint32_t* outNumInts) const
-{
-    *outNumFds = uint32_t(bufferHandle->numFds);
-    *outNumInts = uint32_t(bufferHandle->numInts);
-
-    if (mMapperV2_1 == nullptr) {
-        return;
-    }
-
-    Error error;
-    auto buffer = const_cast<native_handle_t*>(bufferHandle);
-    auto ret = mMapperV2_1->getTransportSize(buffer,
-            [&](const auto& tmpError, const auto& tmpNumFds, const auto& tmpNumInts) {
-                error = tmpError;
-                if (error != Error::NONE) {
-                    return;
-                }
-
-                *outNumFds = tmpNumFds;
-                *outNumInts = tmpNumInts;
-            });
-
-    if (!ret.isOk()) {
-        error = kTransactionError;
-    }
-    ALOGE_IF(error != Error::NONE, "getTransportSize(%p) failed with %d",
-            buffer, error);
-}
-
 Error Mapper::lock(buffer_handle_t bufferHandle, uint64_t usage,
         const IMapper::Rect& accessRegion,
         int acquireFence, void** outData) const
@@ -322,9 +202,8 @@ int Mapper::unlock(buffer_handle_t bufferHandle) const
 Allocator::Allocator(const Mapper& mapper)
     : mMapper(mapper)
 {
-    mAllocator = IAllocator::getService();
-    if (mAllocator == nullptr) {
-        LOG_ALWAYS_FATAL("gralloc-alloc is missing");
+    if (mMapper.valid()) {
+        mAllocator = IAllocator::getService();
     }
 }
 
diff --git a/libs/ui/GraphicBuffer.cpp b/libs/ui/GraphicBuffer.cpp
index ee3ea97c6..f69198670 100644
--- a/libs/ui/GraphicBuffer.cpp
+++ b/libs/ui/GraphicBuffer.cpp
@@ -52,7 +52,6 @@ GraphicBuffer::GraphicBuffer()
     height =
     stride =
     format =
-    usage_deprecated = 0;
     usage  = 0;
     layerCount = 0;
     handle = NULL;
@@ -61,16 +60,18 @@ GraphicBuffer::GraphicBuffer()
 // deprecated
 GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
         PixelFormat inFormat, uint32_t inUsage, std::string requestorName)
-    : GraphicBuffer(inWidth, inHeight, inFormat, 1, static_cast<uint64_t>(inUsage), requestorName)
+    : GraphicBuffer(inWidth, inHeight, inFormat, 1, inUsage,
+            requestorName)
 {
 }
 
 GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inLayerCount, uint64_t usage, std::string requestorName)
+        PixelFormat inFormat, uint32_t inLayerCount, uint32_t usage,
+        std::string requestorName)
     : GraphicBuffer()
 {
     mInitCheck = initWithSize(inWidth, inHeight, inFormat, inLayerCount,
-            usage, std::move(requestorName));
+            usage);
 }
 
 // deprecated
@@ -78,15 +79,44 @@ GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
         PixelFormat inFormat, uint32_t inLayerCount, uint32_t inUsage,
         uint32_t inStride, native_handle_t* inHandle, bool keepOwnership)
     : GraphicBuffer(inHandle, keepOwnership ? TAKE_HANDLE : WRAP_HANDLE,
-            inWidth, inHeight, inFormat, inLayerCount, static_cast<uint64_t>(inUsage),
+            inWidth, inHeight, inFormat, inLayerCount, inUsage,
             inStride)
 {
 }
 
+GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
+        PixelFormat inFormat, uint32_t inUsage, uint32_t inStride,
+        native_handle_t* inHandle, bool keepOwnership)
+    : BASE(), mOwner(keepOwnership ? ownHandle : ownNone),
+      mBufferMapper(GraphicBufferMapper::get()),
+      mInitCheck(NO_ERROR), mId(getUniqueId())
+{
+    width  = static_cast<int>(inWidth);
+    height = static_cast<int>(inHeight);
+    stride = static_cast<int>(inStride);
+    format = inFormat;
+    usage  = static_cast<int>(inUsage);
+    handle = inHandle;
+}
+
+GraphicBuffer::GraphicBuffer(ANativeWindowBuffer* buffer, bool keepOwnership)
+    : BASE(), mOwner(keepOwnership ? ownHandle : ownNone),
+      mBufferMapper(GraphicBufferMapper::get()),
+      mInitCheck(NO_ERROR), mId(getUniqueId())
+{
+    width  = buffer->width;
+    height = buffer->height;
+    stride = buffer->stride;
+    format = buffer->format;
+    layerCount = buffer->layerCount;
+    usage  = buffer->usage;
+    handle = buffer->handle;
+}
+
 GraphicBuffer::GraphicBuffer(const native_handle_t* handle,
         HandleWrapMethod method, uint32_t width, uint32_t height,
         PixelFormat format, uint32_t layerCount,
-        uint64_t usage,
+        uint32_t usage,
         uint32_t stride)
     : GraphicBuffer()
 {
@@ -104,12 +134,17 @@ GraphicBuffer::~GraphicBuffer()
 void GraphicBuffer::free_handle()
 {
     if (mOwner == ownHandle) {
-        mBufferMapper.freeBuffer(handle);
+        mBufferMapper.unregisterBuffer(handle);
+        native_handle_close(handle);
+        native_handle_delete(const_cast<native_handle*>(handle));
     } else if (mOwner == ownData) {
         GraphicBufferAllocator& allocator(GraphicBufferAllocator::get());
         allocator.free(handle);
     }
+
+#ifndef EGL_NEEDS_HANDLE
     handle = NULL;
+#endif
 }
 
 status_t GraphicBuffer::initCheck() const {
@@ -129,7 +164,7 @@ ANativeWindowBuffer* GraphicBuffer::getNativeBuffer() const
 }
 
 status_t GraphicBuffer::reallocate(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inLayerCount, uint64_t inUsage)
+        PixelFormat inFormat, uint32_t inLayerCount, uint32_t inUsage)
 {
     if (mOwner != ownData)
         return INVALID_OPERATION;
@@ -139,7 +174,7 @@ status_t GraphicBuffer::reallocate(uint32_t inWidth, uint32_t inHeight,
             static_cast<int>(inHeight) == height &&
             inFormat == format &&
             inLayerCount == layerCount &&
-            inUsage == usage)
+            static_cast<int>(inUsage) == usage)
         return NO_ERROR;
 
     if (handle) {
@@ -147,38 +182,33 @@ status_t GraphicBuffer::reallocate(uint32_t inWidth, uint32_t inHeight,
         allocator.free(handle);
         handle = 0;
     }
-    return initWithSize(inWidth, inHeight, inFormat, inLayerCount, inUsage, "[Reallocation]");
+    return initWithSize(inWidth, inHeight, inFormat, inLayerCount,
+            inUsage);
 }
 
 bool GraphicBuffer::needsReallocation(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inLayerCount, uint64_t inUsage)
+        PixelFormat inFormat, uint32_t inLayerCount, uint32_t inUsage)
 {
     if (static_cast<int>(inWidth) != width) return true;
     if (static_cast<int>(inHeight) != height) return true;
     if (inFormat != format) return true;
     if (inLayerCount != layerCount) return true;
-    if ((usage & inUsage) != inUsage) return true;
+    if ((static_cast<uint32_t>(usage) & inUsage) != inUsage) return true;
     return false;
 }
 
 status_t GraphicBuffer::initWithSize(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inLayerCount, uint64_t inUsage,
-        std::string requestorName)
+        PixelFormat inFormat, uint32_t inLayerCount, uint32_t inUsage)
 {
     GraphicBufferAllocator& allocator = GraphicBufferAllocator::get();
     uint32_t outStride = 0;
-    status_t err = allocator.allocate(inWidth, inHeight, inFormat, inLayerCount,
-            inUsage, &handle, &outStride, mId,
-            std::move(requestorName));
+    status_t err = allocator.alloc(inWidth, inHeight, inFormat, inUsage, &handle, &outStride);
     if (err == NO_ERROR) {
-        mBufferMapper.getTransportSize(handle, &mTransportNumFds, &mTransportNumInts);
-
         width = static_cast<int>(inWidth);
         height = static_cast<int>(inHeight);
         format = inFormat;
         layerCount = inLayerCount;
-        usage = inUsage;
-        usage_deprecated = int(usage);
+        usage = static_cast<int>(inUsage);
         stride = static_cast<int>(outStride);
     }
     return err;
@@ -186,41 +216,47 @@ status_t GraphicBuffer::initWithSize(uint32_t inWidth, uint32_t inHeight,
 
 status_t GraphicBuffer::initWithHandle(const native_handle_t* handle,
         HandleWrapMethod method, uint32_t width, uint32_t height,
-        PixelFormat format, uint32_t layerCount, uint64_t usage,
+        PixelFormat format, uint32_t layerCount, uint32_t usage,
         uint32_t stride)
 {
+    native_handle_t* clone = nullptr;
+
+    if (method == CLONE_HANDLE) {
+        clone = native_handle_clone(handle);
+        if (!clone) {
+            return NO_MEMORY;
+        }
+
+        handle = clone;
+        method = TAKE_UNREGISTERED_HANDLE;
+    }
+
     ANativeWindowBuffer::width  = static_cast<int>(width);
     ANativeWindowBuffer::height = static_cast<int>(height);
     ANativeWindowBuffer::stride = static_cast<int>(stride);
     ANativeWindowBuffer::format = format;
-    ANativeWindowBuffer::usage  = usage;
-    ANativeWindowBuffer::usage_deprecated = int(usage);
+    ANativeWindowBuffer::usage  = static_cast<int>(usage);
 
     ANativeWindowBuffer::layerCount = layerCount;
+    ANativeWindowBuffer::handle = handle;
 
     mOwner = (method == WRAP_HANDLE) ? ownNone : ownHandle;
 
-    if (method == TAKE_UNREGISTERED_HANDLE || method == CLONE_HANDLE) {
-        buffer_handle_t importedHandle;
-        status_t err = mBufferMapper.importBuffer(handle, width, height,
-                layerCount, format, usage, stride, &importedHandle);
+    if (method == TAKE_UNREGISTERED_HANDLE) {
+        status_t err = mBufferMapper.importBuffer(handle);
         if (err != NO_ERROR) {
+            // clean up cloned handle
+            if (clone) {
+                native_handle_close(clone);
+                native_handle_delete(clone);
+            }
+
             initWithHandle(nullptr, WRAP_HANDLE, 0, 0, 0, 0, 0, 0);
 
             return err;
         }
-
-        if (method == TAKE_UNREGISTERED_HANDLE) {
-            native_handle_close(handle);
-            native_handle_delete(const_cast<native_handle_t*>(handle));
-        }
-
-        handle = importedHandle;
-        mBufferMapper.getTransportSize(handle, &mTransportNumFds, &mTransportNumInts);
     }
 
-    ANativeWindowBuffer::handle = handle;
-
     return NO_ERROR;
 }
 
@@ -278,14 +314,15 @@ status_t GraphicBuffer::lockAsync(uint32_t inUsage, void** vaddr, int fenceFd)
     return res;
 }
 
+/*
 status_t GraphicBuffer::lockAsync(uint32_t inUsage, const Rect& rect,
         void** vaddr, int fenceFd)
 {
     return lockAsync(inUsage, inUsage, rect, vaddr, fenceFd);
 }
+*/
 
-status_t GraphicBuffer::lockAsync(uint64_t inProducerUsage,
-        uint64_t inConsumerUsage, const Rect& rect, void** vaddr, int fenceFd)
+status_t GraphicBuffer::lockAsync(uint32_t inUsage, const Rect& rect, void** vaddr, int fenceFd)
 {
     if (rect.left < 0 || rect.right  > width ||
         rect.top  < 0 || rect.bottom > height) {
@@ -294,8 +331,7 @@ status_t GraphicBuffer::lockAsync(uint64_t inProducerUsage,
                 width, height);
         return BAD_VALUE;
     }
-    status_t res = getBufferMapper().lockAsync(handle, inProducerUsage,
-            inConsumerUsage, rect, vaddr, fenceFd);
+    status_t res = getBufferMapper().lockAsync(handle, inUsage, rect, vaddr, fenceFd);
     return res;
 }
 
@@ -317,7 +353,8 @@ status_t GraphicBuffer::lockAsyncYCbCr(uint32_t inUsage, const Rect& rect,
                 width, height);
         return BAD_VALUE;
     }
-    status_t res = getBufferMapper().lockAsyncYCbCr(handle, inUsage, rect, ycbcr, fenceFd);
+    status_t res = getBufferMapper().lockAsyncYCbCr(handle, inUsage, rect,
+            ycbcr, fenceFd);
     return res;
 }
 
@@ -328,11 +365,11 @@ status_t GraphicBuffer::unlockAsync(int *fenceFd)
 }
 
 size_t GraphicBuffer::getFlattenedSize() const {
-    return static_cast<size_t>(13 + (handle ? mTransportNumInts : 0)) * sizeof(int);
+    return static_cast<size_t>(12 + (handle ? handle->numInts : 0)) * sizeof(int);
 }
 
 size_t GraphicBuffer::getFdCount() const {
-    return static_cast<size_t>(handle ? mTransportNumFds : 0);
+    return static_cast<size_t>(handle ? handle->numFds : 0);
 }
 
 status_t GraphicBuffer::flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const {
@@ -343,33 +380,33 @@ status_t GraphicBuffer::flatten(void*& buffer, size_t& size, int*& fds, size_t&
     if (count < fdCountNeeded) return NO_MEMORY;
 
     int32_t* buf = static_cast<int32_t*>(buffer);
-    buf[0] = 'GB01';
+    buf[0] = 'GBFR';
     buf[1] = width;
     buf[2] = height;
     buf[3] = stride;
     buf[4] = format;
     buf[5] = static_cast<int32_t>(layerCount);
-    buf[6] = int(usage); // low 32-bits
+    buf[6] = usage;
     buf[7] = static_cast<int32_t>(mId >> 32);
     buf[8] = static_cast<int32_t>(mId & 0xFFFFFFFFull);
     buf[9] = static_cast<int32_t>(mGenerationNumber);
     buf[10] = 0;
     buf[11] = 0;
-    buf[12] = int(usage >> 32); // high 32-bits
 
     if (handle) {
-        buf[10] = int32_t(mTransportNumFds);
-        buf[11] = int32_t(mTransportNumInts);
-        memcpy(fds, handle->data, static_cast<size_t>(mTransportNumFds) * sizeof(int));
-        memcpy(buf + 13, handle->data + handle->numFds,
-                static_cast<size_t>(mTransportNumInts) * sizeof(int));
+        buf[10] = handle->numFds;
+        buf[11] = handle->numInts;
+        memcpy(fds, handle->data,
+                static_cast<size_t>(handle->numFds) * sizeof(int));
+        memcpy(&buf[12], handle->data + handle->numFds,
+                static_cast<size_t>(handle->numInts) * sizeof(int));
     }
 
     buffer = static_cast<void*>(static_cast<uint8_t*>(buffer) + sizeNeeded);
     size -= sizeNeeded;
     if (handle) {
-        fds += mTransportNumFds;
-        count -= static_cast<size_t>(mTransportNumFds);
+        fds += handle->numFds;
+        count -= static_cast<size_t>(handle->numFds);
     }
 
     return NO_ERROR;
@@ -377,21 +414,10 @@ status_t GraphicBuffer::flatten(void*& buffer, size_t& size, int*& fds, size_t&
 
 status_t GraphicBuffer::unflatten(
         void const*& buffer, size_t& size, int const*& fds, size_t& count) {
+    if (size < 12 * sizeof(int)) return NO_MEMORY;
 
     int const* buf = static_cast<int const*>(buffer);
-
-    // NOTE: it turns out that some media code generates a flattened GraphicBuffer manually!!!!!
-    // see H2BGraphicBufferProducer.cpp
-    uint32_t flattenWordCount = 0;
-    if (buf[0] == 'GB01') {
-        // new version with 64-bits usage bits
-        flattenWordCount = 13;
-    } else if (buf[0] == 'GBFR') {
-        // old version, when usage bits were 32-bits
-        flattenWordCount = 12;
-    } else {
-        return BAD_TYPE;
-    }
+    if (buf[0] != 'GBFR') return BAD_TYPE;
 
     const size_t numFds  = static_cast<size_t>(buf[10]);
     const size_t numInts = static_cast<size_t>(buf[11]);
@@ -401,16 +427,15 @@ status_t GraphicBuffer::unflatten(
     // chosen to be high enough to not cause issues and low enough to prevent
     // overflow problems.
     const size_t maxNumber = 4096;
-    if (numFds >= maxNumber || numInts >= (maxNumber - flattenWordCount)) {
-        width = height = stride = format = usage_deprecated = 0;
-        layerCount = 0;
-        usage = 0;
+    if (numFds >= maxNumber || numInts >= (maxNumber - 12)) {
+        width = height = stride = format = layerCount = usage = 0;
         handle = NULL;
-        ALOGE("unflatten: numFds or numInts is too large: %zd, %zd", numFds, numInts);
+        ALOGE("unflatten: numFds or numInts is too large: %zd, %zd",
+                numFds, numInts);
         return BAD_VALUE;
     }
 
-    const size_t sizeNeeded = (flattenWordCount + numInts) * sizeof(int);
+    const size_t sizeNeeded = (12 + numInts) * sizeof(int);
     if (size < sizeNeeded) return NO_MEMORY;
 
     size_t fdCountNeeded = numFds;
@@ -427,29 +452,20 @@ status_t GraphicBuffer::unflatten(
         stride = buf[3];
         format = buf[4];
         layerCount = static_cast<uintptr_t>(buf[5]);
-        usage_deprecated = buf[6];
-        if (flattenWordCount == 13) {
-            usage = (uint64_t(buf[12]) << 32) | uint32_t(buf[6]);
-        } else {
-            usage = uint64_t(usage_deprecated);
-        }
+        usage  = buf[6];
         native_handle* h = native_handle_create(
                 static_cast<int>(numFds), static_cast<int>(numInts));
         if (!h) {
-            width = height = stride = format = usage_deprecated = 0;
-            layerCount = 0;
-            usage = 0;
+            width = height = stride = format = layerCount = usage = 0;
             handle = NULL;
             ALOGE("unflatten: native_handle_create failed");
             return NO_MEMORY;
         }
         memcpy(h->data, fds, numFds * sizeof(int));
-        memcpy(h->data + numFds, buf + flattenWordCount, numInts * sizeof(int));
+        memcpy(h->data + numFds, &buf[12], numInts * sizeof(int));
         handle = h;
     } else {
-        width = height = stride = format = usage_deprecated = 0;
-        layerCount = 0;
-        usage = 0;
+        width = height = stride = format = layerCount = usage = 0;
         handle = NULL;
     }
 
@@ -461,22 +477,15 @@ status_t GraphicBuffer::unflatten(
     mOwner = ownHandle;
 
     if (handle != 0) {
-        buffer_handle_t importedHandle;
-        status_t err = mBufferMapper.importBuffer(handle, uint32_t(width), uint32_t(height),
-                uint32_t(layerCount), format, usage, uint32_t(stride), &importedHandle);
+        status_t err = mBufferMapper.importBuffer(handle);
         if (err != NO_ERROR) {
-            width = height = stride = format = usage_deprecated = 0;
-            layerCount = 0;
-            usage = 0;
+            width = height = stride = format = layerCount = usage = 0;
+            native_handle_delete(const_cast<native_handle*>(handle));
             handle = NULL;
-            ALOGE("unflatten: registerBuffer failed: %s (%d)", strerror(-err), err);
+            ALOGE("unflatten: registerBuffer failed: %s (%d)",
+                    strerror(-err), err);
             return err;
         }
-
-        native_handle_close(handle);
-        native_handle_delete(const_cast<native_handle_t*>(handle));
-        handle = importedHandle;
-        mBufferMapper.getTransportSize(handle, &mTransportNumFds, &mTransportNumInts);
     }
 
     buffer = static_cast<void const*>(static_cast<uint8_t const*>(buffer) + sizeNeeded);
diff --git a/libs/ui/GraphicBufferAllocator.cpp b/libs/ui/GraphicBufferAllocator.cpp
index eaba1ed1a..20c7ec40c 100644
--- a/libs/ui/GraphicBufferAllocator.cpp
+++ b/libs/ui/GraphicBufferAllocator.cpp
@@ -29,7 +29,6 @@
 #include <utils/String8.h>
 #include <utils/Trace.h>
 
-#include <ui/Gralloc2.h>
 #include <ui/GraphicBufferMapper.h>
 
 namespace android {
@@ -42,13 +41,20 @@ KeyedVector<buffer_handle_t,
     GraphicBufferAllocator::alloc_rec_t> GraphicBufferAllocator::sAllocList;
 
 GraphicBufferAllocator::GraphicBufferAllocator()
-  : mMapper(GraphicBufferMapper::getInstance()),
-    mAllocator(std::make_unique<Gralloc2::Allocator>(
-                mMapper.getGrallocMapper()))
+    : mAllocDev(0)
 {
+    hw_module_t const* module;
+    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
+    ALOGE_IF(err, "FATAL: can't find the %s module", GRALLOC_HARDWARE_MODULE_ID);
+    if (err == 0) {
+        gralloc_open(module, &mAllocDev);
+    }
 }
 
-GraphicBufferAllocator::~GraphicBufferAllocator() {}
+GraphicBufferAllocator::~GraphicBufferAllocator()
+{
+    gralloc_close(mAllocDev);
+}
 
 void GraphicBufferAllocator::dump(String8& result) const
 {
@@ -59,30 +65,12 @@ void GraphicBufferAllocator::dump(String8& result) const
     char buffer[SIZE];
     snprintf(buffer, SIZE, "Allocated buffers:\n");
     result.append(buffer);
-    const size_t c = list.size();
-    for (size_t i=0 ; i<c ; i++) {
-        const alloc_rec_t& rec(list.valueAt(i));
-        if (rec.size) {
-            snprintf(buffer, SIZE, "%10p: %7.2f KiB | %4u (%4u) x %4u | %4u | %8X | 0x%" PRIx64
-                    " | %s\n",
-                    list.keyAt(i), rec.size/1024.0,
-                    rec.width, rec.stride, rec.height, rec.layerCount, rec.format,
-                    rec.usage, rec.requestorName.c_str());
-        } else {
-            snprintf(buffer, SIZE, "%10p: unknown     | %4u (%4u) x %4u | %4u | %8X | 0x%" PRIx64
-                    " | %s\n",
-                    list.keyAt(i),
-                    rec.width, rec.stride, rec.height, rec.layerCount, rec.format,
-                    rec.usage, rec.requestorName.c_str());
-        }
-        result.append(buffer);
-        total += rec.size;
-    }
     snprintf(buffer, SIZE, "Total allocated (estimate): %.2f KB\n", total/1024.0);
     result.append(buffer);
-
-    std::string deviceDump = mAllocator->dumpDebugInfo();
-    result.append(deviceDump.c_str(), deviceDump.size());
+    if (mAllocDev->common.version >= 1 && mAllocDev->dump) {
+        mAllocDev->dump(mAllocDev, buffer, SIZE);
+        result.append(buffer);
+    }
 }
 
 void GraphicBufferAllocator::dumpToSystemLog()
@@ -92,10 +80,9 @@ void GraphicBufferAllocator::dumpToSystemLog()
     ALOGD("%s", s.string());
 }
 
-status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,
-        PixelFormat format, uint32_t layerCount, uint64_t usage,
-        buffer_handle_t* handle, uint32_t* stride,
-        uint64_t /*graphicBufferId*/, std::string requestorName)
+status_t GraphicBufferAllocator::alloc(uint32_t width, uint32_t height,
+        PixelFormat format, uint32_t usage, buffer_handle_t* handle,
+        uint32_t* stride)
 {
     ATRACE_CALL();
 
@@ -104,19 +91,22 @@ status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,
     if (!width || !height)
         width = height = 1;
 
-    // Ensure that layerCount is valid.
-    if (layerCount < 1)
-        layerCount = 1;
+    // we have a h/w allocator and h/w buffer is requested
+    status_t err;
+
+    // Filter out any usage bits that should not be passed to the gralloc module
+    usage &= GRALLOC_USAGE_ALLOC_MASK;
 
-    Gralloc2::IMapper::BufferDescriptorInfo info = {};
-    info.width = width;
-    info.height = height;
-    info.layerCount = layerCount;
-    info.format = static_cast<Gralloc2::PixelFormat>(format);
-    info.usage = usage;
+    int outStride = 0;
+    err = mAllocDev->alloc(mAllocDev, static_cast<int>(width),
+            static_cast<int>(height), format, static_cast<int>(usage), handle,
+            &outStride);
+    *stride = static_cast<uint32_t>(outStride);
 
-    Gralloc2::Error error = mAllocator->allocate(info, stride, handle);
-    if (error == Gralloc2::Error::NONE) {
+    ALOGW_IF(err, "alloc(%u, %u, %d, %08x, ...) failed %d (%s)",
+            width, height, format, usage, err, strerror(-err));
+
+    if (err == NO_ERROR) {
         Mutex::Autolock _l(sLock);
         KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
         uint32_t bpp = bytesPerPixel(format);
@@ -125,36 +115,33 @@ status_t GraphicBufferAllocator::allocate(uint32_t width, uint32_t height,
         rec.height = height;
         rec.stride = *stride;
         rec.format = format;
-        rec.layerCount = layerCount;
         rec.usage = usage;
         rec.size = static_cast<size_t>(height * (*stride) * bpp);
-        rec.requestorName = std::move(requestorName);
         list.add(*handle, rec);
-
-        return NO_ERROR;
-    } else {
-        ALOGE("Failed to allocate (%u x %u) layerCount %u format %d "
-                "usage %" PRIx64 ": %d",
-                width, height, layerCount, format, usage,
-                error);
-        return NO_MEMORY;
     }
+
+    return err;
 }
 
 status_t GraphicBufferAllocator::free(buffer_handle_t handle)
 {
     ATRACE_CALL();
+    status_t err;
 
-    // We allocated a buffer from the allocator and imported it into the
-    // mapper to get the handle.  We just need to free the handle now.
-    mMapper.freeBuffer(handle);
+    err = mAllocDev->free(mAllocDev, handle);
 
-    Mutex::Autolock _l(sLock);
-    KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
-    list.removeItem(handle);
+    ALOGW_IF(err, "free(...) failed %d (%s)", err, strerror(-err));
+    if (err == NO_ERROR) {
+        Mutex::Autolock _l(sLock);
+        KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
+        list.removeItem(handle);
+    }
 
-    return NO_ERROR;
+    return err;
 }
 
 // ---------------------------------------------------------------------------
 }; // namespace android
+
+__strong_alias(_ZN7android22GraphicBufferAllocator5allocEjjiiPPK13native_handlePi,
+        _ZN7android22GraphicBufferAllocator5allocEjjijPPK13native_handlePj);
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index 2d8e5824b..0f458a62a 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -16,7 +16,6 @@
 
 #define LOG_TAG "GraphicBufferMapper"
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
-//#define LOG_NDEBUG 0
 
 #include <ui/GraphicBufferMapper.h>
 
@@ -32,156 +31,198 @@
 #include <utils/Log.h>
 #include <utils/Trace.h>
 
-#include <ui/Gralloc2.h>
 #include <ui/GraphicBuffer.h>
+#include <ui/GraphicBufferMapper.h>
+#include <ui/Rect.h>
+
+//#include <system/graphics.h>
+//#include <ui/Gralloc2.h>
+
+
+#include <hardware/gralloc.h>
 
-#include <system/graphics.h>
 
 namespace android {
 // ---------------------------------------------------------------------------
 
 ANDROID_SINGLETON_STATIC_INSTANCE( GraphicBufferMapper )
 
-void GraphicBufferMapper::preloadHal() {
-    Gralloc2::Mapper::preload();
-}
-
 GraphicBufferMapper::GraphicBufferMapper()
-  : mMapper(std::make_unique<const Gralloc2::Mapper>())
+    : mAllocMod(0)
 {
+    hw_module_t const* module;
+    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
+    ALOGE_IF(err, "FATAL: can't find the %s module", GRALLOC_HARDWARE_MODULE_ID);
+    if (err == 0) {
+        mAllocMod = reinterpret_cast<gralloc_module_t const *>(module);
+    }
 }
 
-status_t GraphicBufferMapper::importBuffer(buffer_handle_t rawHandle,
-        uint32_t width, uint32_t height, uint32_t layerCount,
-        PixelFormat format, uint64_t usage, uint32_t stride,
-        buffer_handle_t* outHandle)
+status_t GraphicBufferMapper::importBuffer(buffer_handle_t handle)
 {
     ATRACE_CALL();
+    status_t err;
 
-    buffer_handle_t bufferHandle;
-    Gralloc2::Error error = mMapper->importBuffer(
-            hardware::hidl_handle(rawHandle), &bufferHandle);
-    if (error != Gralloc2::Error::NONE) {
-        ALOGW("importBuffer(%p) failed: %d", rawHandle, error);
-        return static_cast<status_t>(error);
-    }
+    err = mAllocMod->registerBuffer(mAllocMod, handle);
+
+    ALOGW_IF(err, "registerBuffer(%p) failed %d (%s)",
+            handle, err, strerror(-err));
+    return err;
+}
 
-    Gralloc2::IMapper::BufferDescriptorInfo info = {};
-    info.width = width;
-    info.height = height;
-    info.layerCount = layerCount;
-    info.format = static_cast<Gralloc2::PixelFormat>(format);
-    info.usage = usage;
-
-    error = mMapper->validateBufferSize(bufferHandle, info, stride);
-    if (error != Gralloc2::Error::NONE) {
-        ALOGE("validateBufferSize(%p) failed: %d", rawHandle, error);
-        freeBuffer(bufferHandle);
-        return static_cast<status_t>(error);
+/*
+status_t GraphicBufferMapper::freeBuffer(buffer_handle_t handle)
+{
+    ATRACE_CALL();
+    gralloc1_error_t error;
+    if (mMapper->valid()) {
+        mMapper->freeBuffer(handle);
+        error = GRALLOC1_ERROR_NONE;
+    } else {
+        error = mDevice->release(handle);
+        if (!mDevice->hasCapability(GRALLOC1_CAPABILITY_RELEASE_IMPLY_DELETE)) {
+            native_handle_close(handle);
+            native_handle_delete(const_cast<native_handle_t*>(handle));
+        }
     }
 
-    *outHandle = bufferHandle;
+    ALOGW_IF(error != GRALLOC1_ERROR_NONE, "freeBuffer(%p): failed %d",
+            handle, error);
 
-    return NO_ERROR;
+    return error;
 }
-
-void GraphicBufferMapper::getTransportSize(buffer_handle_t handle,
-            uint32_t* outTransportNumFds, uint32_t* outTransportNumInts)
+*/
+/*
+status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
+        uint32_t usage, const Rect& bounds, void** vaddr, int fenceFd)
 {
-    mMapper->getTransportSize(handle, outTransportNumFds, outTransportNumInts);
+    return lockAsync(handle, usage, usage, bounds, vaddr, fenceFd);
 }
-
-status_t GraphicBufferMapper::freeBuffer(buffer_handle_t handle)
+*/
+status_t GraphicBufferMapper::unregisterBuffer(buffer_handle_t handle)
 {
     ATRACE_CALL();
+    status_t err;
 
-    mMapper->freeBuffer(handle);
-
-    return NO_ERROR;
-}
+    err = mAllocMod->unregisterBuffer(mAllocMod, handle);
 
-static inline Gralloc2::IMapper::Rect asGralloc2Rect(const Rect& rect) {
-    Gralloc2::IMapper::Rect outRect{};
-    outRect.left = rect.left;
-    outRect.top = rect.top;
-    outRect.width = rect.width();
-    outRect.height = rect.height();
-    return outRect;
+    ALOGW_IF(err, "unregisterBuffer(%p) failed %d (%s)",
+            handle, err, strerror(-err));
+    return err;
 }
 
-status_t GraphicBufferMapper::lock(buffer_handle_t handle, uint32_t usage,
-        const Rect& bounds, void** vaddr)
+status_t GraphicBufferMapper::lock(buffer_handle_t handle,
+        uint32_t usage, const Rect& bounds, void** vaddr)
 {
-    return lockAsync(handle, usage, bounds, vaddr, -1);
-}
+    ATRACE_CALL();
+    status_t err;
 
-status_t GraphicBufferMapper::lockYCbCr(buffer_handle_t handle, uint32_t usage,
-        const Rect& bounds, android_ycbcr *ycbcr)
-{
-    return lockAsyncYCbCr(handle, usage, bounds, ycbcr, -1);
+    err = mAllocMod->lock(mAllocMod, handle, static_cast<int>(usage),
+            bounds.left, bounds.top, bounds.width(), bounds.height(),
+            vaddr);
+
+    ALOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
-status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
+status_t GraphicBufferMapper::lockYCbCr(buffer_handle_t handle,
+        uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr)
 {
-    int32_t fenceFd = -1;
-    status_t error = unlockAsync(handle, &fenceFd);
-    if (error == NO_ERROR && fenceFd >= 0) {
-        sync_wait(fenceFd, -1);
-        close(fenceFd);
+    ATRACE_CALL();
+    status_t err;
+
+    if (mAllocMod->lock_ycbcr == NULL) {
+        return -EINVAL; // do not log failure
     }
-    return error;
+
+    err = mAllocMod->lock_ycbcr(mAllocMod, handle, static_cast<int>(usage),
+            bounds.left, bounds.top, bounds.width(), bounds.height(),
+            ycbcr);
+
+    ALOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
-status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
-        uint32_t usage, const Rect& bounds, void** vaddr, int fenceFd)
+status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
 {
-    return lockAsync(handle, usage, usage, bounds, vaddr, fenceFd);
+    ATRACE_CALL();
+    status_t err;
+
+    err = mAllocMod->unlock(mAllocMod, handle);
+
+    ALOGW_IF(err, "unlock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
-        uint64_t producerUsage, uint64_t consumerUsage, const Rect& bounds,
+        uint32_t usage, const Rect& bounds,
         void** vaddr, int fenceFd)
 {
     ATRACE_CALL();
+    status_t err;
+
+    if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3) {
+        err = mAllocMod->lockAsync(mAllocMod, handle, static_cast<int>(usage),
+                bounds.left, bounds.top, bounds.width(), bounds.height(),
+                vaddr, fenceFd);
+    } else {
+        if (fenceFd >= 0) {
+            sync_wait(fenceFd, -1);
+            close(fenceFd);
+        }
+        err = mAllocMod->lock(mAllocMod, handle, static_cast<int>(usage),
+                bounds.left, bounds.top, bounds.width(), bounds.height(),
+                vaddr);
+    }
 
-    const uint64_t usage = static_cast<uint64_t>(
-            android_convertGralloc1To0Usage(producerUsage, consumerUsage));
-    Gralloc2::Error error = mMapper->lock(handle, usage,
-            asGralloc2Rect(bounds), fenceFd, vaddr);
-
-    ALOGW_IF(error != Gralloc2::Error::NONE, "lock(%p, ...) failed: %d",
-            handle, error);
-
-    return static_cast<status_t>(error);
+    ALOGW_IF(err, "lockAsync(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 status_t GraphicBufferMapper::lockAsyncYCbCr(buffer_handle_t handle,
         uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr, int fenceFd)
 {
     ATRACE_CALL();
-
-    Gralloc2::YCbCrLayout layout;
-    Gralloc2::Error error = mMapper->lock(handle, usage,
-            asGralloc2Rect(bounds), fenceFd, &layout);
-    if (error == Gralloc2::Error::NONE) {
-        ycbcr->y = layout.y;
-        ycbcr->cb = layout.cb;
-        ycbcr->cr = layout.cr;
-        ycbcr->ystride = static_cast<size_t>(layout.yStride);
-        ycbcr->cstride = static_cast<size_t>(layout.cStride);
-        ycbcr->chroma_step = static_cast<size_t>(layout.chromaStep);
+    status_t err;
+
+    if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3
+            && mAllocMod->lockAsync_ycbcr != NULL) {
+        err = mAllocMod->lockAsync_ycbcr(mAllocMod, handle,
+                static_cast<int>(usage), bounds.left, bounds.top,
+                bounds.width(), bounds.height(), ycbcr, fenceFd);
+    } else if (mAllocMod->lock_ycbcr != NULL) {
+        if (fenceFd >= 0) {
+            sync_wait(fenceFd, -1);
+            close(fenceFd);
+        }
+        err = mAllocMod->lock_ycbcr(mAllocMod, handle, static_cast<int>(usage),
+                bounds.left, bounds.top, bounds.width(), bounds.height(),
+                ycbcr);
+    } else {
+        if (fenceFd >= 0) {
+            close(fenceFd);
+        }
+        return -EINVAL; // do not log failure
     }
 
-    return static_cast<status_t>(error);
+    ALOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 status_t GraphicBufferMapper::unlockAsync(buffer_handle_t handle, int *fenceFd)
 {
     ATRACE_CALL();
+    status_t err;
 
-    *fenceFd = mMapper->unlock(handle);
+    if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3) {
+        err = mAllocMod->unlockAsync(mAllocMod, handle, fenceFd);
+    } else {
+        *fenceFd = -1;
+        err = mAllocMod->unlock(mAllocMod, handle);
+    }
 
-    return NO_ERROR;
+    ALOGW_IF(err, "unlockAsync(...) failed %d (%s)", err, strerror(-err));
+    return err;
 }
 
 // ---------------------------------------------------------------------------
diff --git a/libs/ui/Region.cpp b/libs/ui/Region.cpp
index fe4ae6c41..b53c56362 100644
--- a/libs/ui/Region.cpp
+++ b/libs/ui/Region.cpp
@@ -513,12 +513,6 @@ void Region::rasterizer::flushSpan()
 
 bool Region::validate(const Region& reg, const char* name, bool silent)
 {
-    if (reg.mStorage.isEmpty()) {
-        ALOGE_IF(!silent, "%s: mStorage is empty, which is never valid", name);
-        // return immediately as the code below assumes mStorage is non-empty
-        return false;
-    }
-
     bool result = true;
     const_iterator cur = reg.begin();
     const_iterator const tail = reg.end();
@@ -838,11 +832,6 @@ Region::const_iterator Region::begin() const {
 }
 
 Region::const_iterator Region::end() const {
-    // Workaround for b/77643177
-    // mStorage should never be empty, but somehow it is and it's causing
-    // an abort in ubsan
-    if (mStorage.isEmpty()) return mStorage.array();
-
     size_t numRects = isRect() ? 1 : mStorage.size() - 1;
     return mStorage.array() + numRects;
 }
diff --git a/libs/ui/include/ui/DebugUtils.h b/libs/ui/include/ui/DebugUtils.h
index 92b2bfb28..30f4a59fe 100644
--- a/libs/ui/include/ui/DebugUtils.h
+++ b/libs/ui/include/ui/DebugUtils.h
@@ -16,21 +16,14 @@
 
 #pragma once
 
-#include <ui/GraphicTypes.h>
+#include <system/graphics.h>
 #include <ui/PixelFormat.h>
 
 #include <string>
 
-namespace android {
-class Rect;
-}
-
 std::string decodeStandard(android_dataspace dataspace);
 std::string decodeTransfer(android_dataspace dataspace);
 std::string decodeRange(android_dataspace dataspace);
 std::string dataspaceDetails(android_dataspace dataspace);
-std::string decodeColorMode(android::ui::ColorMode colormode);
-std::string decodeColorTransform(android_color_transform colorTransform);
+std::string decodeColorMode(android_color_mode colormode);
 std::string decodePixelFormat(android::PixelFormat format);
-std::string decodeRenderIntent(android::ui::RenderIntent renderIntent);
-std::string to_string(const android::Rect& rect);
diff --git a/libs/ui/include/ui/Fence.h b/libs/ui/include/ui/Fence.h
index ec67fa972..88290bd62 100644
--- a/libs/ui/include/ui/Fence.h
+++ b/libs/ui/include/ui/Fence.h
@@ -19,7 +19,6 @@
 
 #include <stdint.h>
 
-#include <android-base/unique_fd.h>
 #include <utils/Flattenable.h>
 #include <utils/RefBase.h>
 #include <utils/Timers.h>
@@ -33,7 +32,11 @@ class String8;
 // ===========================================================================
 
 class Fence
+#ifdef STE_HARDWARE
+    : public LightRefBase<Fence>, public Flattenable
+#else
     : public LightRefBase<Fence>, public Flattenable<Fence>
+#endif
 {
 public:
     static const sp<Fence> NO_FENCE;
@@ -50,13 +53,12 @@ public:
     // Construct a new Fence object with an invalid file descriptor.  This
     // should be done when the Fence object will be set up by unflattening
     // serialized data.
-    Fence() = default;
+    Fence();
 
     // Construct a new Fence object to manage a given fence file descriptor.
     // When the new Fence object is destructed the file descriptor will be
     // closed.
     explicit Fence(int fenceFd);
-    explicit Fence(base::unique_fd fenceFd);
 
     // Not copyable or movable.
     Fence(const Fence& rhs) = delete;
@@ -138,9 +140,9 @@ public:
 private:
     // Only allow instantiation using ref counting.
     friend class LightRefBase<Fence>;
-    ~Fence() = default;
+    ~Fence();
 
-    base::unique_fd mFenceFd;
+    int mFenceFd;
 };
 
 }; // namespace android
diff --git a/libs/ui/include/ui/FenceTime.h b/libs/ui/include/ui/FenceTime.h
index 871fcf2df..83e13cc26 100644
--- a/libs/ui/include/ui/FenceTime.h
+++ b/libs/ui/include/ui/FenceTime.h
@@ -42,7 +42,11 @@ public:
     // consistent for all steps of the flattening process.
     //
     // Not thread safe.
+#ifdef STE_HARDWARE
+    struct Snapshot : public Flattenable {
+#else
     struct Snapshot : public Flattenable<Snapshot> {
+#endif
         enum class State {
             EMPTY,
             FENCE,
diff --git a/libs/ui/include/ui/Gralloc2.h b/libs/ui/include/ui/Gralloc2.h
index 5a8dbda5d..66c8188c0 100644
--- a/libs/ui/include/ui/Gralloc2.h
+++ b/libs/ui/include/ui/Gralloc2.h
@@ -20,9 +20,7 @@
 #include <string>
 
 #include <android/hardware/graphics/allocator/2.0/IAllocator.h>
-#include <android/hardware/graphics/common/1.1/types.h>
 #include <android/hardware/graphics/mapper/2.0/IMapper.h>
-#include <android/hardware/graphics/mapper/2.1/IMapper.h>
 #include <utils/StrongPointer.h>
 
 namespace android {
@@ -30,11 +28,11 @@ namespace android {
 namespace Gralloc2 {
 
 using hardware::graphics::allocator::V2_0::IAllocator;
-using hardware::graphics::common::V1_1::BufferUsage;
-using hardware::graphics::common::V1_1::PixelFormat;
-using hardware::graphics::mapper::V2_1::IMapper;
+using hardware::graphics::common::V1_0::BufferUsage;
+using hardware::graphics::common::V1_0::PixelFormat;
 using hardware::graphics::mapper::V2_0::BufferDescriptor;
 using hardware::graphics::mapper::V2_0::Error;
+using hardware::graphics::mapper::V2_0::IMapper;
 using hardware::graphics::mapper::V2_0::YCbCrLayout;
 
 // A wrapper to IMapper
@@ -44,6 +42,9 @@ public:
 
     Mapper();
 
+    // this will be removed and Mapper will be always valid
+    bool valid() const { return (mMapper != nullptr); }
+
     Error createDescriptor(
             const IMapper::BufferDescriptorInfo& descriptorInfo,
             BufferDescriptor* outDescriptor) const;
@@ -57,13 +58,6 @@ public:
 
     void freeBuffer(buffer_handle_t bufferHandle) const;
 
-    Error validateBufferSize(buffer_handle_t bufferHandle,
-            const IMapper::BufferDescriptorInfo& descriptorInfo,
-            uint32_t stride) const;
-
-    void getTransportSize(buffer_handle_t bufferHandle,
-            uint32_t* outNumFds, uint32_t* outNumInts) const;
-
     // The ownership of acquireFence is always transferred to the callee, even
     // on errors.
     Error lock(buffer_handle_t bufferHandle, uint64_t usage,
@@ -81,12 +75,7 @@ public:
     int unlock(buffer_handle_t bufferHandle) const;
 
 private:
-    // Determines whether the passed info is compatible with the mapper.
-    Error validateBufferDescriptorInfo(
-            const IMapper::BufferDescriptorInfo& descriptorInfo) const;
-
-    sp<hardware::graphics::mapper::V2_0::IMapper> mMapper;
-    sp<IMapper> mMapperV2_1;
+    sp<IMapper> mMapper;
 };
 
 // A wrapper to IAllocator
@@ -96,6 +85,9 @@ public:
     // time.
     Allocator(const Mapper& mapper);
 
+    // this will be removed and Allocator will be always valid
+    bool valid() const { return (mAllocator != nullptr); }
+
     std::string dumpDebugInfo() const;
 
     /*
diff --git a/libs/ui/include/ui/GraphicBuffer.h b/libs/ui/include/ui/GraphicBuffer.h
index 422ba5609..004934727 100644
--- a/libs/ui/include/ui/GraphicBuffer.h
+++ b/libs/ui/include/ui/GraphicBuffer.h
@@ -42,10 +42,18 @@ class GraphicBufferMapper;
 // ===========================================================================
 
 class GraphicBuffer
-    : public ANativeObjectBase<ANativeWindowBuffer, GraphicBuffer, RefBase>,
+    : public ANativeObjectBase< ANativeWindowBuffer, GraphicBuffer,
+#ifdef STE_HARDWARE
+    LightRefBase<GraphicBuffer> >,
+      public Flattenable
+#else
+    RefBase >,
       public Flattenable<GraphicBuffer>
+#endif
 {
+#ifndef STE_HARDWARE
     friend class Flattenable<GraphicBuffer>;
+#endif
 public:
 
     enum {
@@ -85,6 +93,10 @@ public:
             uint32_t inLayerCount, uint32_t inUsage,
             std::string requestorName = "<Unknown>");
 
+    GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat,
+            uint32_t inUsage, uint32_t inStride, native_handle_t* inHandle,
+            bool keepOwnership);
+
     // Create a GraphicBuffer from an existing handle.
     enum HandleWrapMethod : uint8_t {
         // Wrap and use the handle directly.  It assumes the handle has been
@@ -130,6 +142,9 @@ public:
     GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat,
             uint32_t inUsage, std::string requestorName = "<Unknown>");
 
+    // create a buffer from an existing ANativeWindowBuffer
+    GraphicBuffer(ANativeWindowBuffer* buffer, bool keepOwnership);
+
     // return status
     status_t initCheck() const;
 
@@ -166,8 +181,10 @@ public:
     status_t lockAsync(uint32_t inUsage, void** vaddr, int fenceFd);
     status_t lockAsync(uint32_t inUsage, const Rect& rect, void** vaddr,
             int fenceFd);
+/*
     status_t lockAsync(uint64_t inProducerUsage, uint64_t inConsumerUsage,
             const Rect& rect, void** vaddr, int fenceFd);
+*/
     status_t lockAsyncYCbCr(uint32_t inUsage, android_ycbcr *ycbcr,
             int fenceFd);
     status_t lockAsyncYCbCr(uint32_t inUsage, const Rect& rect,
@@ -218,7 +235,7 @@ private:
 
     status_t initWithSize(uint32_t inWidth, uint32_t inHeight,
             PixelFormat inFormat, uint32_t inLayerCount,
-            uint64_t inUsage, std::string requestorName);
+            uint32_t inUsage);
 
     status_t initWithHandle(const native_handle_t* handle,
             HandleWrapMethod method, uint32_t width, uint32_t height,
diff --git a/libs/ui/include/ui/GraphicBufferAllocator.h b/libs/ui/include/ui/GraphicBufferAllocator.h
index 414969089..279b93a33 100644
--- a/libs/ui/include/ui/GraphicBufferAllocator.h
+++ b/libs/ui/include/ui/GraphicBufferAllocator.h
@@ -32,11 +32,10 @@
 #include <utils/Mutex.h>
 #include <utils/Singleton.h>
 
-namespace android {
+#include <hardware/gralloc.h>
 
-namespace Gralloc2 {
-class Allocator;
-}
+namespace android {
+// ---------------------------------------------------------------------------
 
 class GraphicBufferMapper;
 class String8;
@@ -44,12 +43,29 @@ class String8;
 class GraphicBufferAllocator : public Singleton<GraphicBufferAllocator>
 {
 public:
+    enum {
+        USAGE_SW_READ_NEVER     = GRALLOC_USAGE_SW_READ_NEVER,
+        USAGE_SW_READ_RARELY    = GRALLOC_USAGE_SW_READ_RARELY,
+        USAGE_SW_READ_OFTEN     = GRALLOC_USAGE_SW_READ_OFTEN,
+        USAGE_SW_READ_MASK      = GRALLOC_USAGE_SW_READ_MASK,
+
+        USAGE_SW_WRITE_NEVER    = GRALLOC_USAGE_SW_WRITE_NEVER,
+        USAGE_SW_WRITE_RARELY   = GRALLOC_USAGE_SW_WRITE_RARELY,
+        USAGE_SW_WRITE_OFTEN    = GRALLOC_USAGE_SW_WRITE_OFTEN,
+        USAGE_SW_WRITE_MASK     = GRALLOC_USAGE_SW_WRITE_MASK,
+
+        USAGE_SOFTWARE_MASK     = USAGE_SW_READ_MASK|USAGE_SW_WRITE_MASK,
+
+        USAGE_HW_TEXTURE        = GRALLOC_USAGE_HW_TEXTURE,
+        USAGE_HW_RENDER         = GRALLOC_USAGE_HW_RENDER,
+        USAGE_HW_2D             = GRALLOC_USAGE_HW_2D,
+        USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK
+    };
+
     static inline GraphicBufferAllocator& get() { return getInstance(); }
 
-    status_t allocate(uint32_t w, uint32_t h, PixelFormat format,
-            uint32_t layerCount, uint64_t usage,
-            buffer_handle_t* handle, uint32_t* stride, uint64_t graphicBufferId,
-            std::string requestorName);
+    status_t alloc(uint32_t w, uint32_t h, PixelFormat format, uint32_t usage,
+            buffer_handle_t* handle, uint32_t* stride);
 
     status_t free(buffer_handle_t handle);
 
@@ -65,7 +81,6 @@ private:
         uint32_t layerCount;
         uint32_t usage;
         size_t size;
-        std::string requestorName;
     };
 
     static Mutex sLock;
@@ -75,8 +90,7 @@ private:
     GraphicBufferAllocator();
     ~GraphicBufferAllocator();
 
-    GraphicBufferMapper& mMapper;
-    const std::unique_ptr<const Gralloc2::Allocator> mAllocator;
+    alloc_device_t  *mAllocDev;
 };
 
 // ---------------------------------------------------------------------------
diff --git a/libs/ui/include/ui/GraphicBufferMapper.h b/libs/ui/include/ui/GraphicBufferMapper.h
index 7cf003dcb..78eb9c645 100644
--- a/libs/ui/include/ui/GraphicBufferMapper.h
+++ b/libs/ui/include/ui/GraphicBufferMapper.h
@@ -22,7 +22,6 @@
 
 #include <memory>
 
-#include <ui/PixelFormat.h>
 #include <utils/Singleton.h>
 
 
@@ -30,34 +29,26 @@
 // when/if we get rid of gralloc, we should provide aliases or fix call sites.
 #include <hardware/gralloc.h>
 
+struct gralloc_module_t;
 
 namespace android {
 
 // ---------------------------------------------------------------------------
 
-namespace Gralloc2 {
-class Mapper;
-}
-
 class Rect;
 
 class GraphicBufferMapper : public Singleton<GraphicBufferMapper>
 {
 public:
-    static void preloadHal();
     static inline GraphicBufferMapper& get() { return getInstance(); }
 
     // The imported outHandle must be freed with freeBuffer when no longer
     // needed. rawHandle is owned by the caller.
-    status_t importBuffer(buffer_handle_t rawHandle,
-            uint32_t width, uint32_t height, uint32_t layerCount,
-            PixelFormat format, uint64_t usage, uint32_t stride,
-            buffer_handle_t* outHandle);
+    status_t importBuffer(buffer_handle_t handle);
 
-    status_t freeBuffer(buffer_handle_t handle);
+    status_t unregisterBuffer(buffer_handle_t handle);
 
-    void getTransportSize(buffer_handle_t handle,
-            uint32_t* outTransportNumFds, uint32_t* outTransportNumInts);
+    status_t freeBuffer(buffer_handle_t handle);
 
     status_t lock(buffer_handle_t handle,
             uint32_t usage, const Rect& bounds, void** vaddr);
@@ -80,17 +71,10 @@ public:
 
     status_t unlockAsync(buffer_handle_t handle, int *fenceFd);
 
-    const Gralloc2::Mapper& getGrallocMapper() const
-    {
-        return *mMapper;
-    }
-
 private:
     friend class Singleton<GraphicBufferMapper>;
-
     GraphicBufferMapper();
-
-    const std::unique_ptr<const Gralloc2::Mapper> mMapper;
+    gralloc_module_t const *mAllocMod;
 };
 
 // ---------------------------------------------------------------------------
diff --git a/libs/ui/include/ui/PixelFormat.h b/libs/ui/include/ui/PixelFormat.h
index 02773d92f..d4680b1a7 100644
--- a/libs/ui/include/ui/PixelFormat.h
+++ b/libs/ui/include/ui/PixelFormat.h
@@ -62,6 +62,15 @@ enum {
     PIXEL_FORMAT_RGBA_4444    = 7,                             // 16-bit ARGB
     PIXEL_FORMAT_RGBA_FP16    = HAL_PIXEL_FORMAT_RGBA_FP16,    // 64-bit RGBA
     PIXEL_FORMAT_RGBA_1010102 = HAL_PIXEL_FORMAT_RGBA_1010102, // 32-bit RGBA
+
+#ifdef STE_HARDWARE
+    // Added Support for YUV42XMBN,
+    // Required for Copybit CC acceleration
+    PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
+    PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
+    PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
+#endif
+
 };
 
 typedef int32_t PixelFormat;
diff --git a/libs/ui/include/ui/Rect.h b/libs/ui/include/ui/Rect.h
index 0bec0b7f7..c099a026a 100644
--- a/libs/ui/include/ui/Rect.h
+++ b/libs/ui/include/ui/Rect.h
@@ -95,18 +95,15 @@ public:
     }
 
     // rectangle's width
-    __attribute__((no_sanitize("signed-integer-overflow")))
     inline int32_t getWidth() const {
         return right - left;
     }
 
     // rectangle's height
-    __attribute__((no_sanitize("signed-integer-overflow")))
     inline int32_t getHeight() const {
         return bottom - top;
     }
 
-    __attribute__((no_sanitize("signed-integer-overflow")))
     inline Rect getBounds() const {
         return Rect(right - left, bottom - top);
     }
diff --git a/libs/ui/include/ui/Region.h b/libs/ui/include/ui/Region.h
index 778845295..44e96fc81 100644
--- a/libs/ui/include/ui/Region.h
+++ b/libs/ui/include/ui/Region.h
@@ -25,6 +25,10 @@
 #include <ui/Rect.h>
 #include <utils/Flattenable.h>
 
+#ifdef STE_HARDWARE
+#include <hardware/copybit.h>
+#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -211,6 +215,26 @@ Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
 // ---------------------------------------------------------------------------
+#ifdef STE_HARDWARE
+struct region_iterator : public copybit_region_t {
+    region_iterator(const Region& region)
+        : b(region.begin()), e(region.end()) {
+        this->next = iterate;
+    }
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
+        region_iterator const* me = static_cast<region_iterator const*>(self);
+        if (me->b != me->e) {
+            *reinterpret_cast<Rect*>(rect) = *me->b++;
+            return 1;
+        }
+        return 0;
+    }
+    mutable Region::const_iterator b;
+    Region::const_iterator const e;
+};
+#endif
+// ---------------------------------------------------------------------------
 }; // namespace android
 
 #endif // ANDROID_UI_REGION_H
-- 
2.11.0

