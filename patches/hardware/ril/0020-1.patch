From 74cae48055160f772ab7b3197e2f5d59dc5c3caf Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Tue, 18 Sep 2018 17:48:07 +0300
Subject: [PATCH 20/21] 1

Change-Id: I6024ee1b7c616805f5dff89dc9e97cdb3fa0d6d4
---
 libril/ril.cpp         | 109 +++++++++++++++++++++++++-----------
 libril/ril_service.cpp | 147 +++++++++++++++++++++++--------------------------
 2 files changed, 148 insertions(+), 108 deletions(-)

diff --git a/libril/ril.cpp b/libril/ril.cpp
index 8934578..0fae22a 100644
--- a/libril/ril.cpp
+++ b/libril/ril.cpp
@@ -191,10 +191,23 @@ static UnsolResponseInfo s_unsolResponses[] = {
 #include "ril_unsol_commands.h"
 };
 
+static CommandInfo s_commands_v[] = {
+#include <telephony/ril_commands_vendor.h>
+};
+
+static UnsolResponseInfo s_unsolResponses_v[] = {
+#include <telephony/ril_unsol_commands_vendor.h>
+};
+
 char * RIL_getServiceName() {
     return ril_service_name;
 }
 
+extern "C"
+void RIL_setServiceName(const char * s) {
+    strncpy(ril_service_name, s, MAX_SERVICE_NAME_LENGTH);
+}
+
 RequestInfo *
 addRequestToList(int serial, int slotId, int request) {
     RequestInfo *pRI;
@@ -225,6 +238,18 @@ addRequestToList(int serial, int slotId, int request) {
 #endif
 #endif
 
+    CommandInfo *pCI = NULL;
+    if (request > RIL_OEM_REQUEST_BASE) {
+        int index = request - RIL_OEM_REQUEST_BASE;
+        RLOGD("processCommandBuffer: samsung request=%d, index=%d",
+                request, index);
+        if (index < (int32_t)NUM_ELEMS(s_commands_v))
+            pCI = &(s_commands_v[index]);
+    } else {
+        if (request < (int32_t)NUM_ELEMS(s_commands))
+            pCI = &(s_commands[request]);
+    }
+
     pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));
     if (pRI == NULL) {
         RLOGE("Memory allocation failed for request %s", requestToString(request));
@@ -232,7 +257,7 @@ addRequestToList(int serial, int slotId, int request) {
     }
 
     pRI->token = serial;
-    pRI->pCI = &(s_commands[request]);
+    pRI->pCI = pCI;
     pRI->socket_id = socket_id;
 
     ret = pthread_mutex_lock(pendingRequestsMutexHook);
@@ -285,13 +310,6 @@ static void resendLastNITZTimeData(RIL_SOCKET_ID socket_id) {
         int responseType = (s_callbacks.version >= 13)
                            ? RESPONSE_UNSOLICITED_ACK_EXP
                            : RESPONSE_UNSOLICITED;
-        // acquire read lock for the service before calling nitzTimeReceivedInd() since it reads
-        // nitzTimeReceived in ril_service
-        pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(
-                (int) socket_id);
-        int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
-
         int ret = radio::nitzTimeReceivedInd(
             (int)socket_id, responseType, 0,
             RIL_E_SUCCESS, s_lastNITZTimeData, s_lastNITZTimeDataSize);
@@ -299,9 +317,6 @@ static void resendLastNITZTimeData(RIL_SOCKET_ID socket_id) {
             free(s_lastNITZTimeData);
             s_lastNITZTimeData = NULL;
         }
-
-        rwlockRet = pthread_rwlock_unlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
     }
 }
 
@@ -453,21 +468,30 @@ RIL_register (const RIL_RadioFunctions *callbacks) {
         assert(i == s_commands[i].requestNumber);
     }
 
+    for (int i = 0; i < (int)NUM_ELEMS(s_commands_v); i++) {
+        assert(i + RIL_OEM_REQUEST_BASE == s_commands[i].requestNumber);
+    }
+
     for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses); i++) {
         assert(i + RIL_UNSOL_RESPONSE_BASE
                 == s_unsolResponses[i].requestNumber);
     }
 
+    for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses_v); i++) {
+        assert(i + SAMSUNG_UNSOL_RESPONSE_BASE
+                == s_unsolResponses[i].requestNumber);
+    }
+
     radio::registerService(&s_callbacks, s_commands);
     RLOGI("RILHIDL called registerService");
 
 }
 
 extern "C" void
-RIL_register_socket (const RIL_RadioFunctions *(*Init)(const struct RIL_Env *, int, char **),
+RIL_register_socket (RIL_RadioFunctions *(*Init)(const struct RIL_Env *, int, char **),
         RIL_SOCKET_TYPE socketType, int argc, char **argv) {
 
-    const RIL_RadioFunctions* UimFuncs = NULL;
+    RIL_RadioFunctions* UimFuncs = NULL;
 
     if(Init) {
         UimFuncs = Init(&RilSapSocket::uimRilEnv, argc, argv);
@@ -737,7 +761,8 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     int ret;
     bool shouldScheduleTimeout = false;
     RIL_SOCKET_ID soc_id = RIL_SOCKET_1;
-
+    UnsolResponseInfo *pRI = NULL;
+    int32_t pRI_elements;
 #if defined(ANDROID_MULTI_SIM)
     soc_id = socket_id;
 #endif
@@ -750,9 +775,40 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     }
 
     unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;
+    pRI = s_unsolResponses;
+    pRI_elements = (int32_t)NUM_ELEMS(s_unsolResponses);
+
+    /* Hack to include Samsung responses */
+    if (unsolResponse > SAMSUNG_UNSOL_RESPONSE_BASE) {
+        pRI = s_unsolResponses_v;
+        pRI_elements = (int32_t)NUM_ELEMS(s_unsolResponses_v);
+
+        /*
+         * Some of the vendor response codes cannot be found by calculating their index anymore,
+         * because they have an even higher offset and are not ordered in the array.
+         * Example: RIL_UNSOL_SNDMGR_WB_AMR_REPORT = 20017, but it's at index 33 in the vendor
+         * response array.
+         * Thus, look through all the vendor URIs (Unsol Response Info) and pick the correct index.
+         * This has a cost of O(N).
+         */
+        int pRI_index;
+        for (pRI_index = 0; pRI_index < pRI_elements; pRI_index++) {
+            if (pRI[pRI_index].requestNumber == unsolResponse) {
+                unsolResponseIndex = pRI_index;
+            }
+        }
+
+        RLOGD("SAMSUNG: unsolResponse=%d, unsolResponseIndex=%d", unsolResponse, unsolResponseIndex);
+    }
 
-    if ((unsolResponseIndex < 0)
-        || (unsolResponseIndex >= (int32_t)NUM_ELEMS(s_unsolResponses))) {
+    if (unsolResponseIndex >= 0 && unsolResponseIndex < pRI_elements) {
+        pRI = &pRI[unsolResponseIndex];
+    } else {
+        RLOGE("could not map unsolResponse=%d to %s response array (index=%d)", unsolResponse,
+                pRI == s_unsolResponses ? "AOSP" : "Samsung", unsolResponseIndex);
+    }
+
+    if (pRI == NULL || pRI->responseFunction == NULL) {
         RLOGE("unsupported unsolicited response code %d", unsolResponse);
         return;
     }
@@ -760,7 +816,7 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     // Grab a wake lock if needed for this reponse,
     // as we exit we'll either release it immediately
     // or set a timer to release it later.
-    switch (s_unsolResponses[unsolResponseIndex].wakeType) {
+    switch (pRI->wakeType) {
         case WAKE_PARTIAL:
             grabPartialWakeLock();
             shouldScheduleTimeout = true;
@@ -777,27 +833,18 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
 
     int responseType;
     if (s_callbacks.version >= 13
-                && s_unsolResponses[unsolResponseIndex].wakeType == WAKE_PARTIAL) {
+                && pRI->wakeType == WAKE_PARTIAL) {
         responseType = RESPONSE_UNSOLICITED_ACK_EXP;
     } else {
         responseType = RESPONSE_UNSOLICITED;
     }
 
     pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock((int) soc_id);
-    int rwlockRet;
-
-    if (unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
-        // get a write lock in caes of NITZ since setNitzTimeReceived() is called
-        rwlockRet = pthread_rwlock_wrlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
-        radio::setNitzTimeReceived((int) soc_id, android::elapsedRealtime());
-    } else {
-        rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
-        assert(rwlockRet == 0);
-    }
+    int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
+    assert(rwlockRet == 0);
 
-    if (s_unsolResponses[unsolResponseIndex].responseFunction) {
-        ret = s_unsolResponses[unsolResponseIndex].responseFunction(
+    if (pRI->responseFunction) {
+        ret = pRI->responseFunction(
                 (int) soc_id, responseType, 0, RIL_E_SUCCESS, const_cast<void*>(data),
                 datalen);
     }
diff --git a/libril/ril_service.cpp b/libril/ril_service.cpp
index e2d7e32..decf8d0 100644
--- a/libril/ril_service.cpp
+++ b/libril/ril_service.cpp
@@ -61,12 +61,6 @@ using android::sp;
 #define CALL_ONSTATEREQUEST(a) s_vendorFunctions->onStateRequest()
 #endif
 
-#ifdef OEM_HOOK_DISABLED
-constexpr bool kOemHookEnabled = false;
-#else
-constexpr bool kOemHookEnabled = true;
-#endif
-
 RIL_RadioFunctions *s_vendorFunctions = NULL;
 static CommandInfo *s_commands;
 
@@ -96,14 +90,12 @@ struct OemHookImpl;
 #if (SIM_COUNT >= 2)
 sp<RadioImpl> radioService[SIM_COUNT];
 sp<OemHookImpl> oemHookService[SIM_COUNT];
-int64_t nitzTimeReceived[SIM_COUNT];
 // counter used for synchronization. It is incremented every time response callbacks are updated.
 volatile int32_t mCounterRadio[SIM_COUNT];
 volatile int32_t mCounterOemHook[SIM_COUNT];
 #else
 sp<RadioImpl> radioService[1];
 sp<OemHookImpl> oemHookService[1];
-int64_t nitzTimeReceived[1];
 // counter used for synchronization. It is incremented every time response callbacks are updated.
 volatile int32_t mCounterRadio[1];
 volatile int32_t mCounterOemHook[1];
@@ -531,9 +523,9 @@ void sendErrorResponse(RequestInfo *pRI, RIL_Errno err) {
  * request with error RIL_E_NO_MEMORY.
  * Returns true on success, and false on failure.
  */
-bool copyHidlStringToRil(char **dest, const hidl_string &src, RequestInfo *pRI, bool allowEmpty) {
+bool copyHidlStringToRil(char **dest, const hidl_string &src, RequestInfo *pRI) {
     size_t len = src.size();
-    if (len == 0 && !allowEmpty) {
+    if (len == 0) {
         *dest = NULL;
         return true;
     }
@@ -547,10 +539,6 @@ bool copyHidlStringToRil(char **dest, const hidl_string &src, RequestInfo *pRI,
     return true;
 }
 
-bool copyHidlStringToRil(char **dest, const hidl_string &src, RequestInfo *pRI) {
-    return copyHidlStringToRil(dest, src, pRI, false);
-}
-
 hidl_string convertCharPtrToHidlString(const char *ptr) {
     hidl_string ret;
     if (ptr != NULL) {
@@ -586,7 +574,7 @@ bool dispatchString(int serial, int slotId, int request, const char * str) {
     return true;
 }
 
-bool dispatchStrings(int serial, int slotId, int request, bool allowEmpty, int countStrings, ...) {
+bool dispatchStrings(int serial, int slotId, int request, int countStrings, ...) {
     RequestInfo *pRI = android::addRequestToList(serial, slotId, request);
     if (pRI == NULL) {
         return false;
@@ -603,7 +591,7 @@ bool dispatchStrings(int serial, int slotId, int request, bool allowEmpty, int c
     va_start(ap, countStrings);
     for (int i = 0; i < countStrings; i++) {
         const char* str = va_arg(ap, const char *);
-        if (!copyHidlStringToRil(&pStrings[i], hidl_string(str), pRI, allowEmpty)) {
+        if (!copyHidlStringToRil(&pStrings[i], hidl_string(str), pRI)) {
             va_end(ap);
             for (int j = 0; j < i; j++) {
                 memsetAndFreeStrings(1, pStrings[j]);
@@ -856,7 +844,7 @@ Return<void> RadioImpl::supplyIccPinForApp(int32_t serial, const hidl_string& pi
 #if VDBG
     RLOGD("supplyIccPinForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PIN, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PIN,
             2, pin.c_str(), aid.c_str());
     return Void();
 }
@@ -866,7 +854,7 @@ Return<void> RadioImpl::supplyIccPukForApp(int32_t serial, const hidl_string& pu
 #if VDBG
     RLOGD("supplyIccPukForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PUK, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PUK,
             3, puk.c_str(), pin.c_str(), aid.c_str());
     return Void();
 }
@@ -876,7 +864,7 @@ Return<void> RadioImpl::supplyIccPin2ForApp(int32_t serial, const hidl_string& p
 #if VDBG
     RLOGD("supplyIccPin2ForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PIN2, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PIN2,
             2, pin2.c_str(), aid.c_str());
     return Void();
 }
@@ -886,7 +874,7 @@ Return<void> RadioImpl::supplyIccPuk2ForApp(int32_t serial, const hidl_string& p
 #if VDBG
     RLOGD("supplyIccPuk2ForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PUK2, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_SIM_PUK2,
             3, puk2.c_str(), pin2.c_str(), aid.c_str());
     return Void();
 }
@@ -896,7 +884,7 @@ Return<void> RadioImpl::changeIccPinForApp(int32_t serial, const hidl_string& ol
 #if VDBG
     RLOGD("changeIccPinForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_SIM_PIN, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_SIM_PIN,
             3, oldPin.c_str(), newPin.c_str(), aid.c_str());
     return Void();
 }
@@ -906,7 +894,7 @@ Return<void> RadioImpl::changeIccPin2ForApp(int32_t serial, const hidl_string& o
 #if VDBG
     RLOGD("changeIccPin2ForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_SIM_PIN2, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_SIM_PIN2,
             3, oldPin2.c_str(), newPin2.c_str(), aid.c_str());
     return Void();
 }
@@ -916,7 +904,7 @@ Return<void> RadioImpl::supplyNetworkDepersonalization(int32_t serial,
 #if VDBG
     RLOGD("supplyNetworkDepersonalization: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION,
             1, netPin.c_str());
     return Void();
 }
@@ -975,7 +963,7 @@ Return<void> RadioImpl::getImsiForApp(int32_t serial, const hidl_string& aid) {
 #if VDBG
     RLOGD("getImsiForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_GET_IMSI, false,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_GET_IMSI,
             1, aid.c_str());
     return Void();
 }
@@ -1086,7 +1074,7 @@ Return<void> RadioImpl::sendSms(int32_t serial, const GsmSmsMessage& message) {
 #if VDBG
     RLOGD("sendSms: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS, false,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS,
             2, message.smscPdu.c_str(), message.pdu.c_str());
     return Void();
 }
@@ -1095,7 +1083,7 @@ Return<void> RadioImpl::sendSMSExpectMore(int32_t serial, const GsmSmsMessage& m
 #if VDBG
     RLOGD("sendSMSExpectMore: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS_EXPECT_MORE, false,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_SEND_SMS_EXPECT_MORE,
             2, message.smscPdu.c_str(), message.pdu.c_str());
     return Void();
 }
@@ -1129,7 +1117,7 @@ Return<void> RadioImpl::setupDataCall(int32_t serial, RadioTechnology radioTechn
     if (s_vendorFunctions->version >= 4 && s_vendorFunctions->version <= 14) {
         const hidl_string &protocol =
                 (isRoaming ? dataProfileInfo.roamingProtocol : dataProfileInfo.protocol);
-        dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 7,
+        dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, 7,
             std::to_string((int) radioTechnology + 2).c_str(),
             std::to_string((int) dataProfileInfo.profileId).c_str(),
             dataProfileInfo.apn.c_str(),
@@ -1147,7 +1135,7 @@ Return<void> RadioImpl::setupDataCall(int32_t serial, RadioTechnology radioTechn
             }
             return Void();
         }
-        dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, true, 15,
+        dispatchStrings(serial, mSlotId, RIL_REQUEST_SETUP_DATA_CALL, 15,
             std::to_string((int) radioTechnology + 2).c_str(),
             std::to_string((int) dataProfileInfo.profileId).c_str(),
             dataProfileInfo.apn.c_str(),
@@ -1306,7 +1294,7 @@ Return<void> RadioImpl::deactivateDataCall(int32_t serial,
 #if VDBG
     RLOGD("deactivateDataCall: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_DEACTIVATE_DATA_CALL, false,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_DEACTIVATE_DATA_CALL,
             2, (std::to_string(cid)).c_str(), reasonRadioShutDown ? "1" : "0");
     return Void();
 }
@@ -1317,7 +1305,7 @@ Return<void> RadioImpl::getFacilityLockForApp(int32_t serial, const hidl_string&
 #if VDBG
     RLOGD("getFacilityLockForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_QUERY_FACILITY_LOCK, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_QUERY_FACILITY_LOCK,
             4, facility.c_str(), password.c_str(),
             (std::to_string(serviceClass)).c_str(), appId.c_str());
     return Void();
@@ -1329,7 +1317,7 @@ Return<void> RadioImpl::setFacilityLockForApp(int32_t serial, const hidl_string&
 #if VDBG
     RLOGD("setFacilityLockForApp: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_SET_FACILITY_LOCK, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_SET_FACILITY_LOCK,
             5, facility.c_str(), lockState ? "1" : "0", password.c_str(),
             (std::to_string(serviceClass)).c_str(), appId.c_str() );
     return Void();
@@ -1341,7 +1329,7 @@ Return<void> RadioImpl::setBarringPassword(int32_t serial, const hidl_string& fa
 #if VDBG
     RLOGD("setBarringPassword: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_BARRING_PASSWORD, true,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_CHANGE_BARRING_PASSWORD,
             3, facility.c_str(), oldPassword.c_str(), newPassword.c_str());
     return Void();
 }
@@ -1735,7 +1723,7 @@ Return<void> RadioImpl::sendBurstDtmf(int32_t serial, const hidl_string& dtmf, i
 #if VDBG
     RLOGD("sendBurstDtmf: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_CDMA_BURST_DTMF, false,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_CDMA_BURST_DTMF,
             3, dtmf.c_str(), (std::to_string(on)).c_str(),
             (std::to_string(off)).c_str());
     return Void();
@@ -2004,7 +1992,7 @@ Return<void> RadioImpl::acknowledgeIncomingGsmSmsWithPdu(int32_t serial, bool su
 #if VDBG
     RLOGD("acknowledgeIncomingGsmSmsWithPdu: serial %d", serial);
 #endif
-    dispatchStrings(serial, mSlotId, RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, false,
+    dispatchStrings(serial, mSlotId, RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU,
             2, success ? "1" : "0", ackPdu.c_str());
     return Void();
 }
@@ -2056,8 +2044,19 @@ Return<void> RadioImpl::setInitialAttachApn(int32_t serial, const DataProfileInf
     if (s_vendorFunctions->version <= 14) {
         RIL_InitialAttachApn iaa = {};
 
-        if (!copyHidlStringToRil(&iaa.apn, dataProfileInfo.apn, pRI, true)) {
-            return Void();
+        if (dataProfileInfo.apn.size() == 0) {
+            iaa.apn = (char *) calloc(1, sizeof(char));
+            if (iaa.apn == NULL) {
+                RLOGE("Memory allocation failed for request %s",
+                        requestToString(pRI->pCI->requestNumber));
+                sendErrorResponse(pRI, RIL_E_NO_MEMORY);
+                return Void();
+            }
+            iaa.apn[0] = '\0';
+        } else {
+            if (!copyHidlStringToRil(&iaa.apn, dataProfileInfo.apn, pRI)) {
+                return Void();
+            }
         }
 
         const hidl_string &protocol =
@@ -2083,8 +2082,19 @@ Return<void> RadioImpl::setInitialAttachApn(int32_t serial, const DataProfileInf
     } else {
         RIL_InitialAttachApn_v15 iaa = {};
 
-        if (!copyHidlStringToRil(&iaa.apn, dataProfileInfo.apn, pRI, true)) {
-            return Void();
+        if (dataProfileInfo.apn.size() == 0) {
+            iaa.apn = (char *) calloc(1, sizeof(char));
+            if (iaa.apn == NULL) {
+                RLOGE("Memory allocation failed for request %s",
+                        requestToString(pRI->pCI->requestNumber));
+                sendErrorResponse(pRI, RIL_E_NO_MEMORY);
+                return Void();
+            }
+            iaa.apn[0] = '\0';
+        } else {
+            if (!copyHidlStringToRil(&iaa.apn, dataProfileInfo.apn, pRI)) {
+                return Void();
+            }
         }
 
         if (!copyHidlStringToRil(&iaa.protocol, dataProfileInfo.protocol, pRI)) {
@@ -2513,21 +2523,20 @@ Return<void> RadioImpl::setDataProfile(int32_t serial, const hidl_vec<DataProfil
         for (size_t i = 0; i < num; i++) {
             dataProfilePtrs[i] = &dataProfiles[i];
 
-            success = copyHidlStringToRil(&dataProfiles[i].apn, profiles[i].apn, pRI, true);
+            success = copyHidlStringToRil(&dataProfiles[i].apn, profiles[i].apn, pRI);
 
             const hidl_string &protocol =
                     (isRoaming ? profiles[i].roamingProtocol : profiles[i].protocol);
 
-            if (success && !copyHidlStringToRil(&dataProfiles[i].protocol, protocol, pRI, true)) {
+            if (success && !copyHidlStringToRil(&dataProfiles[i].protocol, protocol, pRI)) {
                 success = false;
             }
 
-            if (success && !copyHidlStringToRil(&dataProfiles[i].user, profiles[i].user, pRI,
-                    true)) {
+            if (success && !copyHidlStringToRil(&dataProfiles[i].user, profiles[i].user, pRI)) {
                 success = false;
             }
             if (success && !copyHidlStringToRil(&dataProfiles[i].password, profiles[i].password,
-                    pRI, true)) {
+                    pRI)) {
                 success = false;
             }
 
@@ -2577,25 +2586,24 @@ Return<void> RadioImpl::setDataProfile(int32_t serial, const hidl_vec<DataProfil
         for (size_t i = 0; i < num; i++) {
             dataProfilePtrs[i] = &dataProfiles[i];
 
-            success = copyHidlStringToRil(&dataProfiles[i].apn, profiles[i].apn, pRI, true);
+            success = copyHidlStringToRil(&dataProfiles[i].apn, profiles[i].apn, pRI);
             if (success && !copyHidlStringToRil(&dataProfiles[i].protocol, profiles[i].protocol,
                     pRI)) {
                 success = false;
             }
             if (success && !copyHidlStringToRil(&dataProfiles[i].roamingProtocol,
-                    profiles[i].roamingProtocol, pRI, true)) {
+                    profiles[i].roamingProtocol, pRI)) {
                 success = false;
             }
-            if (success && !copyHidlStringToRil(&dataProfiles[i].user, profiles[i].user, pRI,
-                    true)) {
+            if (success && !copyHidlStringToRil(&dataProfiles[i].user, profiles[i].user, pRI)) {
                 success = false;
             }
             if (success && !copyHidlStringToRil(&dataProfiles[i].password, profiles[i].password,
-                    pRI, true)) {
+                    pRI)) {
                 success = false;
             }
             if (success && !copyHidlStringToRil(&dataProfiles[i].mvnoMatchData,
-                    profiles[i].mvnoMatchData, pRI, true)) {
+                    profiles[i].mvnoMatchData, pRI)) {
                 success = false;
             }
 
@@ -2858,9 +2866,9 @@ Return<void> RadioImpl::setCarrierInfoForImsiEncryption(int32_t serial,
         memsetAndFreeStrings(2, imsiEncryption.mnc, imsiEncryption.mcc);
         return Void();
     }
-    imsiEncryption.carrierKeyLength = data.carrierKey.size();
-    imsiEncryption.carrierKey = new uint8_t[imsiEncryption.carrierKeyLength];
-    memcpy(imsiEncryption.carrierKey, data.carrierKey.data(), imsiEncryption.carrierKeyLength);
+    int32_t lSize = data.carrierKey.size();
+    imsiEncryption.carrierKey = new uint8_t[lSize];
+    memcpy(imsiEncryption.carrierKey, data.carrierKey.data(), lSize);
     imsiEncryption.expirationTime = data.expirationTime;
     CALL_ONREQUEST(pRI->pCI->requestNumber, &imsiEncryption,
             sizeof(RIL_CarrierInfoForImsiEncryption), pRI, mSlotId);
@@ -6812,8 +6820,6 @@ int radio::sendRequestRawResponse(int slotId,
    RLOGD("sendRequestRawResponse: serial %d", serial);
 #endif
 
-    if (!kOemHookEnabled) return 0;
-
     if (oemHookService[slotId]->mOemHookResponse != NULL) {
         RadioResponseInfo responseInfo = {};
         populateResponseInfo(responseInfo, serial, responseType, e);
@@ -6843,8 +6849,6 @@ int radio::sendRequestStringsResponse(int slotId,
     RLOGD("sendRequestStringsResponse: serial %d", serial);
 #endif
 
-    if (!kOemHookEnabled) return 0;
-
     if (oemHookService[slotId]->mOemHookResponse != NULL) {
         RadioResponseInfo responseInfo = {};
         populateResponseInfo(responseInfo, serial, responseType, e);
@@ -7203,7 +7207,7 @@ int radio::nitzTimeReceivedInd(int slotId,
             return 0;
         }
         hidl_string nitzTime;
-        //int64_t timeReceived = android::elapsedRealtime();
+        int64_t timeReceived = android::elapsedRealtime();
         char *resp = strndup((char *) response, responseLen);
         char *tmp = resp;
 
@@ -7223,11 +7227,10 @@ int radio::nitzTimeReceivedInd(int slotId,
         free(resp);
 #if VDBG
         RLOGD("nitzTimeReceivedInd: nitzTime %s receivedTime %" PRId64, nitzTime.c_str(),
-                nitzTimeReceived[slotId]);
+                timeReceived);
 #endif
         Return<void> retStatus = radioService[slotId]->mRadioIndication->nitzTimeReceived(
-                convertIntToRadioIndicationType(indicationType), nitzTime,
-                nitzTimeReceived[slotId]);
+                convertIntToRadioIndicationType(indicationType), nitzTime, timeReceived);
         radioService[slotId]->checkReturnStatus(retStatus);
     } else {
         RLOGE("nitzTimeReceivedInd: radioService[%d]->mRadioIndication == NULL", slotId);
@@ -8796,7 +8799,7 @@ int radio::networkScanResultInd(int slotId,
 
         V1_1::NetworkScanResult result;
         result.status = (V1_1::ScanStatus) networkScanResult->status;
-        result.error = (RadioError) networkScanResult->error;
+        result.error = (RadioError) e;
         convertRilCellInfoListToHal(
                 networkScanResult->network_infos,
                 networkScanResult->network_infos_length * sizeof(RIL_CellInfo_v12),
@@ -8867,8 +8870,6 @@ int radio::keepaliveStatusInd(int slotId,
 int radio::oemHookRawInd(int slotId,
                          int indicationType, int token, RIL_Errno e, void *response,
                          size_t responseLen) {
-    if (!kOemHookEnabled) return 0;
-
     if (oemHookService[slotId] != NULL && oemHookService[slotId]->mOemHookIndication != NULL) {
         if (response == NULL || responseLen == 0) {
             RLOGE("oemHookRawInd: invalid response");
@@ -8910,9 +8911,6 @@ void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands
     simCount = SIM_COUNT;
     #endif
 
-    s_vendorFunctions = callbacks;
-    s_commands = commands;
-
     configureRpcThreadpool(1, true /* callerWillJoin */);
     for (int i = 0; i < simCount; i++) {
         pthread_rwlock_t *radioServiceRwlockPtr = getRadioServiceRwlock(i);
@@ -8921,19 +8919,19 @@ void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands
 
         radioService[i] = new RadioImpl;
         radioService[i]->mSlotId = i;
+        oemHookService[i] = new OemHookImpl;
+        oemHookService[i]->mSlotId = i;
         RLOGD("registerService: starting android::hardware::radio::V1_1::IRadio %s",
                 serviceNames[i]);
         android::status_t status = radioService[i]->registerAsService(serviceNames[i]);
-
-        if (kOemHookEnabled) {
-            oemHookService[i] = new OemHookImpl;
-            oemHookService[i]->mSlotId = i;
-            status = oemHookService[i]->registerAsService(serviceNames[i]);
-        }
+        status = oemHookService[i]->registerAsService(serviceNames[i]);
 
         ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
         assert(ret == 0);
     }
+
+    s_vendorFunctions = callbacks;
+    s_commands = commands;
 }
 
 void rilc_thread_pool() {
@@ -8955,8 +8953,3 @@ pthread_rwlock_t * radio::getRadioServiceRwlock(int slotId) {
 
     return radioServiceRwlockPtr;
 }
-
-// should acquire write lock for the corresponding service before calling this
-void radio::setNitzTimeReceived(int slotId, long timeReceived) {
-    nitzTimeReceived[slotId] = timeReceived;
-}
-- 
2.11.0

