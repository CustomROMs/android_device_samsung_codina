From 0265de9744a083cc2ac065b01a21b22d2481807b Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 3 Sep 2018 03:03:11 +0300
Subject: [PATCH 1/8] Revert "graphics: make mapper default impl a header
 library"

This reverts commit 821c4c4a9d717f79f9bef75e9f7b2a915bb1c165.

Change-Id: I96656f983fff7428c044b400518003c57ed41ed8
---
 .../2.0/utils/passthrough/Android.bp          |   4 +-
 .../allocator-passthrough/2.0/Gralloc0Hal.h   |   4 +-
 .../allocator-passthrough/2.0/Gralloc1Hal.h   |   4 +-
 graphics/mapper/2.0/default/Android.bp        |  13 +-
 .../mapper/2.0/default/Gralloc0Mapper.cpp     | 156 ++++++++
 graphics/mapper/2.0/default/Gralloc0Mapper.h  |  56 +++
 .../mapper/2.0/default/Gralloc1Mapper.cpp     | 273 ++++++++++++++
 graphics/mapper/2.0/default/Gralloc1Mapper.h  |  76 ++++
 .../2.0 => default}/GrallocBufferDescriptor.h |  14 +-
 graphics/mapper/2.0/default/GrallocMapper.cpp | 321 +++++++++++++++++
 graphics/mapper/2.0/default/GrallocMapper.h   |  96 +++++
 graphics/mapper/2.0/default/passthrough.cpp   |  24 --
 .../mapper/2.0/utils/passthrough/Android.bp   |  43 ---
 .../mapper-passthrough/2.0/Gralloc0Hal.h      | 214 -----------
 .../mapper-passthrough/2.0/Gralloc1Hal.h      | 338 ------------------
 .../mapper-passthrough/2.0/GrallocLoader.h    | 161 ---------
 16 files changed, 1001 insertions(+), 796 deletions(-)
 create mode 100644 graphics/mapper/2.0/default/Gralloc0Mapper.cpp
 create mode 100644 graphics/mapper/2.0/default/Gralloc0Mapper.h
 create mode 100644 graphics/mapper/2.0/default/Gralloc1Mapper.cpp
 create mode 100644 graphics/mapper/2.0/default/Gralloc1Mapper.h
 rename graphics/mapper/2.0/{utils/passthrough/include/mapper-passthrough/2.0 => default}/GrallocBufferDescriptor.h (84%)
 create mode 100644 graphics/mapper/2.0/default/GrallocMapper.cpp
 create mode 100644 graphics/mapper/2.0/default/GrallocMapper.h
 delete mode 100644 graphics/mapper/2.0/default/passthrough.cpp
 delete mode 100644 graphics/mapper/2.0/utils/passthrough/Android.bp
 delete mode 100644 graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc0Hal.h
 delete mode 100644 graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc1Hal.h
 delete mode 100644 graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/GrallocLoader.h

diff --git a/graphics/allocator/2.0/utils/passthrough/Android.bp b/graphics/allocator/2.0/utils/passthrough/Android.bp
index 95b92cfb5..ff9280add 100644
--- a/graphics/allocator/2.0/utils/passthrough/Android.bp
+++ b/graphics/allocator/2.0/utils/passthrough/Android.bp
@@ -14,11 +14,11 @@ cc_library_headers {
     ],
     header_libs: [
         "android.hardware.graphics.allocator@2.0-hal",
-        "android.hardware.graphics.mapper@2.0-passthrough_headers",
+        "libgrallocmapperincludes",
     ],
     export_header_lib_headers: [
         "android.hardware.graphics.allocator@2.0-hal",
-        "android.hardware.graphics.mapper@2.0-passthrough_headers",
+        "libgrallocmapperincludes",
     ],
     export_include_dirs: ["include"],
 }
diff --git a/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc0Hal.h b/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc0Hal.h
index 6c179be72..2665b4003 100644
--- a/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc0Hal.h
+++ b/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc0Hal.h
@@ -22,10 +22,10 @@
 
 #include <cstring>  // for strerror
 
+#include <GrallocBufferDescriptor.h>
 #include <allocator-hal/2.0/AllocatorHal.h>
 #include <hardware/gralloc.h>
 #include <log/log.h>
-#include <mapper-passthrough/2.0/GrallocBufferDescriptor.h>
 
 namespace android {
 namespace hardware {
@@ -38,7 +38,7 @@ namespace detail {
 
 using mapper::V2_0::BufferDescriptor;
 using mapper::V2_0::Error;
-using mapper::V2_0::passthrough::grallocDecodeBufferDescriptor;
+using mapper::V2_0::implementation::grallocDecodeBufferDescriptor;
 
 // Gralloc0HalImpl implements V2_*::hal::AllocatorHal on top of gralloc0
 template <typename Hal>
diff --git a/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc1Hal.h b/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc1Hal.h
index 53b5c14de..3979f0d76 100644
--- a/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc1Hal.h
+++ b/graphics/allocator/2.0/utils/passthrough/include/allocator-passthrough/2.0/Gralloc1Hal.h
@@ -22,10 +22,10 @@
 
 #include <cstring>  // for strerror
 
+#include <GrallocBufferDescriptor.h>
 #include <allocator-hal/2.0/AllocatorHal.h>
 #include <hardware/gralloc1.h>
 #include <log/log.h>
-#include <mapper-passthrough/2.0/GrallocBufferDescriptor.h>
 
 namespace android {
 namespace hardware {
@@ -39,7 +39,7 @@ namespace detail {
 using common::V1_0::BufferUsage;
 using mapper::V2_0::BufferDescriptor;
 using mapper::V2_0::Error;
-using mapper::V2_0::passthrough::grallocDecodeBufferDescriptor;
+using mapper::V2_0::implementation::grallocDecodeBufferDescriptor;
 
 // Gralloc1HalImpl implements V2_*::hal::AllocatorHal on top of gralloc1
 template <typename Hal>
diff --git a/graphics/mapper/2.0/default/Android.bp b/graphics/mapper/2.0/default/Android.bp
index 8874799d1..677d96611 100644
--- a/graphics/mapper/2.0/default/Android.bp
+++ b/graphics/mapper/2.0/default/Android.bp
@@ -18,10 +18,8 @@ cc_library_shared {
     defaults: ["hidl_defaults"],
     vendor: true,
     relative_install_path: "hw",
-    srcs: ["passthrough.cpp"],
-    header_libs: [
-        "android.hardware.graphics.mapper@2.0-passthrough"
-    ],
+    srcs: ["GrallocMapper.cpp", "Gralloc0Mapper.cpp", "Gralloc1Mapper.cpp"],
+    cppflags: ["-Wall", "-Wextra"],
     shared_libs: [
         "android.hardware.graphics.mapper@2.0",
         "libbase",
@@ -33,5 +31,10 @@ cc_library_shared {
         "libsync",
         "libutils",
     ],
-    cflags: ["-DLOG_TAG=\"MapperHal\""],
+}
+
+cc_library_headers {
+    name: "libgrallocmapperincludes",
+    vendor: true,
+    export_include_dirs: ["."],
 }
diff --git a/graphics/mapper/2.0/default/Gralloc0Mapper.cpp b/graphics/mapper/2.0/default/Gralloc0Mapper.cpp
new file mode 100644
index 000000000..28f50161c
--- /dev/null
+++ b/graphics/mapper/2.0/default/Gralloc0Mapper.cpp
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ * * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "Gralloc0Mapper"
+
+#include "Gralloc0Mapper.h"
+
+#include <log/log.h>
+
+namespace android {
+namespace hardware {
+namespace graphics {
+namespace mapper {
+namespace V2_0 {
+namespace implementation {
+
+Gralloc0Mapper::Gralloc0Mapper(const hw_module_t* module)
+    : mModule(reinterpret_cast<const gralloc_module_t*>(module)),
+      mMinor(module->module_api_version & 0xff) {
+    mCapabilities.highUsageBits = false;
+    mCapabilities.layeredBuffers = false;
+    mCapabilities.unregisterImplyDelete = false;
+}
+
+Error Gralloc0Mapper::registerBuffer(buffer_handle_t bufferHandle) {
+    int result = mModule->registerBuffer(mModule, bufferHandle);
+    return result ? Error::BAD_BUFFER : Error::NONE;
+}
+
+void Gralloc0Mapper::unregisterBuffer(buffer_handle_t bufferHandle) {
+    mModule->unregisterBuffer(mModule, bufferHandle);
+}
+
+Error Gralloc0Mapper::lockBuffer(buffer_handle_t bufferHandle,
+                                 uint64_t cpuUsage,
+                                 const IMapper::Rect& accessRegion, int fenceFd,
+                                 void** outData) {
+    int result;
+    void* data = nullptr;
+    if (mMinor >= 3 && mModule->lockAsync) {
+        // Dup fenceFd as it is going to be owned by gralloc.  Note that it is
+        // gralloc's responsibility to close it, even on locking errors.
+        if (fenceFd >= 0) {
+            fenceFd = dup(fenceFd);
+            if (fenceFd < 0) {
+                return Error::NO_RESOURCES;
+            }
+        }
+
+        result = mModule->lockAsync(mModule, bufferHandle, cpuUsage,
+                                    accessRegion.left, accessRegion.top,
+                                    accessRegion.width, accessRegion.height,
+                                    &data, fenceFd);
+    } else {
+        waitFenceFd(fenceFd, "Gralloc0Mapper::lock");
+
+        result = mModule->lock(mModule, bufferHandle, cpuUsage,
+                               accessRegion.left, accessRegion.top,
+                               accessRegion.width, accessRegion.height, &data);
+    }
+
+    if (result) {
+        return Error::BAD_VALUE;
+    } else {
+        *outData = data;
+        return Error::NONE;
+    }
+}
+
+Error Gralloc0Mapper::lockBuffer(buffer_handle_t bufferHandle,
+                                 uint64_t cpuUsage,
+                                 const IMapper::Rect& accessRegion, int fenceFd,
+                                 YCbCrLayout* outLayout) {
+    int result;
+    android_ycbcr ycbcr = {};
+    if (mMinor >= 3 && mModule->lockAsync_ycbcr) {
+        // Dup fenceFd as it is going to be owned by gralloc.  Note that it is
+        // gralloc's responsibility to close it, even on locking errors.
+        if (fenceFd >= 0) {
+            fenceFd = dup(fenceFd);
+            if (fenceFd < 0) {
+                return Error::NO_RESOURCES;
+            }
+        }
+
+        result = mModule->lockAsync_ycbcr(mModule, bufferHandle, cpuUsage,
+                                          accessRegion.left, accessRegion.top,
+                                          accessRegion.width,
+                                          accessRegion.height, &ycbcr, fenceFd);
+    } else {
+        waitFenceFd(fenceFd, "Gralloc0Mapper::lockYCbCr");
+
+        if (mModule->lock_ycbcr) {
+            result = mModule->lock_ycbcr(mModule, bufferHandle, cpuUsage,
+                                         accessRegion.left, accessRegion.top,
+                                         accessRegion.width,
+                                         accessRegion.height, &ycbcr);
+        } else {
+            result = -EINVAL;
+        }
+    }
+
+    if (result) {
+        return Error::BAD_VALUE;
+    } else {
+        outLayout->y = ycbcr.y;
+        outLayout->cb = ycbcr.cb;
+        outLayout->cr = ycbcr.cr;
+        outLayout->yStride = ycbcr.ystride;
+        outLayout->cStride = ycbcr.cstride;
+        outLayout->chromaStep = ycbcr.chroma_step;
+        return Error::NONE;
+    }
+}
+
+Error Gralloc0Mapper::unlockBuffer(buffer_handle_t bufferHandle,
+                                   int* outFenceFd) {
+    int result;
+    int fenceFd = -1;
+    if (mMinor >= 3 && mModule->unlockAsync) {
+        result = mModule->unlockAsync(mModule, bufferHandle, &fenceFd);
+    } else {
+        result = mModule->unlock(mModule, bufferHandle);
+    }
+
+    if (result) {
+        // we always own the fenceFd even when unlock failed
+        if (fenceFd >= 0) {
+            close(fenceFd);
+        }
+
+        return Error::BAD_VALUE;
+    } else {
+        *outFenceFd = fenceFd;
+        return Error::NONE;
+    }
+}
+
+}  // namespace implementation
+}  // namespace V2_0
+}  // namespace mapper
+}  // namespace graphics
+}  // namespace hardware
+}  // namespace android
diff --git a/graphics/mapper/2.0/default/Gralloc0Mapper.h b/graphics/mapper/2.0/default/Gralloc0Mapper.h
new file mode 100644
index 000000000..e792a6970
--- /dev/null
+++ b/graphics/mapper/2.0/default/Gralloc0Mapper.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ * * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC0MAPPER_H
+#define ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC0MAPPER_H
+
+#include "GrallocMapper.h"
+
+#include <hardware/gralloc.h>
+
+namespace android {
+namespace hardware {
+namespace graphics {
+namespace mapper {
+namespace V2_0 {
+namespace implementation {
+
+class Gralloc0Mapper : public GrallocMapper {
+   public:
+    Gralloc0Mapper(const hw_module_t* module);
+
+   private:
+    Error registerBuffer(buffer_handle_t bufferHandle) override;
+    void unregisterBuffer(buffer_handle_t bufferHandle) override;
+    Error lockBuffer(buffer_handle_t bufferHandle, uint64_t cpuUsage,
+                     const IMapper::Rect& accessRegion, int fenceFd,
+                     void** outData) override;
+    Error lockBuffer(buffer_handle_t bufferHandle, uint64_t cpuUsage,
+                     const IMapper::Rect& accessRegion, int fenceFd,
+                     YCbCrLayout* outLayout) override;
+    Error unlockBuffer(buffer_handle_t bufferHandle, int* outFenceFd) override;
+
+    const gralloc_module_t* mModule;
+    uint8_t mMinor;
+};
+
+}  // namespace implementation
+}  // namespace V2_0
+}  // namespace mapper
+}  // namespace graphics
+}  // namespace hardware
+}  // namespace android
+
+#endif  // ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC0MAPPER_H
diff --git a/graphics/mapper/2.0/default/Gralloc1Mapper.cpp b/graphics/mapper/2.0/default/Gralloc1Mapper.cpp
new file mode 100644
index 000000000..c1e5adcd6
--- /dev/null
+++ b/graphics/mapper/2.0/default/Gralloc1Mapper.cpp
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ * * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "Gralloc1Mapper"
+
+#include "Gralloc1Mapper.h"
+
+#include <vector>
+
+#include <log/log.h>
+
+namespace android {
+namespace hardware {
+namespace graphics {
+namespace mapper {
+namespace V2_0 {
+namespace implementation {
+
+using android::hardware::graphics::common::V1_0::BufferUsage;
+
+Gralloc1Mapper::Gralloc1Mapper(const hw_module_t* module)
+    : mDevice(nullptr), mDispatch() {
+    int result = gralloc1_open(module, &mDevice);
+    if (result) {
+        LOG_ALWAYS_FATAL("failed to open gralloc1 device: %s",
+                         strerror(-result));
+    }
+
+    initCapabilities();
+    initDispatch();
+}
+
+Gralloc1Mapper::~Gralloc1Mapper() {
+    gralloc1_close(mDevice);
+}
+
+void Gralloc1Mapper::initCapabilities() {
+    mCapabilities.highUsageBits = true;
+    mCapabilities.layeredBuffers = false;
+    mCapabilities.unregisterImplyDelete = false;
+
+    uint32_t count = 0;
+    mDevice->getCapabilities(mDevice, &count, nullptr);
+
+    std::vector<int32_t> capabilities(count);
+    mDevice->getCapabilities(mDevice, &count, capabilities.data());
+    capabilities.resize(count);
+
+    for (auto capability : capabilities) {
+        switch (capability) {
+            case GRALLOC1_CAPABILITY_LAYERED_BUFFERS:
+                mCapabilities.layeredBuffers = true;
+                break;
+            case GRALLOC1_CAPABILITY_RELEASE_IMPLY_DELETE:
+                mCapabilities.unregisterImplyDelete = true;
+                break;
+        }
+    }
+}
+
+template <typename T>
+void Gralloc1Mapper::initDispatch(gralloc1_function_descriptor_t desc,
+                                  T* outPfn) {
+    auto pfn = mDevice->getFunction(mDevice, desc);
+    if (!pfn) {
+        LOG_ALWAYS_FATAL("failed to get gralloc1 function %d", desc);
+    }
+
+    *outPfn = reinterpret_cast<T>(pfn);
+}
+
+void Gralloc1Mapper::initDispatch() {
+    initDispatch(GRALLOC1_FUNCTION_RETAIN, &mDispatch.retain);
+    initDispatch(GRALLOC1_FUNCTION_RELEASE, &mDispatch.release);
+    initDispatch(GRALLOC1_FUNCTION_GET_NUM_FLEX_PLANES,
+                 &mDispatch.getNumFlexPlanes);
+    initDispatch(GRALLOC1_FUNCTION_LOCK, &mDispatch.lock);
+    initDispatch(GRALLOC1_FUNCTION_LOCK_FLEX, &mDispatch.lockFlex);
+    initDispatch(GRALLOC1_FUNCTION_UNLOCK, &mDispatch.unlock);
+}
+
+Error Gralloc1Mapper::toError(int32_t error) {
+    switch (error) {
+        case GRALLOC1_ERROR_NONE:
+            return Error::NONE;
+        case GRALLOC1_ERROR_BAD_DESCRIPTOR:
+            return Error::BAD_DESCRIPTOR;
+        case GRALLOC1_ERROR_BAD_HANDLE:
+            return Error::BAD_BUFFER;
+        case GRALLOC1_ERROR_BAD_VALUE:
+            return Error::BAD_VALUE;
+        case GRALLOC1_ERROR_NOT_SHARED:
+            return Error::NONE;  // this is fine
+        case GRALLOC1_ERROR_NO_RESOURCES:
+            return Error::NO_RESOURCES;
+        case GRALLOC1_ERROR_UNDEFINED:
+        case GRALLOC1_ERROR_UNSUPPORTED:
+        default:
+            return Error::UNSUPPORTED;
+    }
+}
+
+bool Gralloc1Mapper::toYCbCrLayout(const android_flex_layout& flex,
+                                   YCbCrLayout* outLayout) {
+    // must be YCbCr
+    if (flex.format != FLEX_FORMAT_YCbCr || flex.num_planes < 3) {
+        return false;
+    }
+
+    for (int i = 0; i < 3; i++) {
+        const auto& plane = flex.planes[i];
+        // must have 8-bit depth
+        if (plane.bits_per_component != 8 || plane.bits_used != 8) {
+            return false;
+        }
+
+        if (plane.component == FLEX_COMPONENT_Y) {
+            // Y must not be interleaved
+            if (plane.h_increment != 1) {
+                return false;
+            }
+        } else {
+            // Cb and Cr can be interleaved
+            if (plane.h_increment != 1 && plane.h_increment != 2) {
+                return false;
+            }
+        }
+
+        if (!plane.v_increment) {
+            return false;
+        }
+    }
+
+    if (flex.planes[0].component != FLEX_COMPONENT_Y ||
+        flex.planes[1].component != FLEX_COMPONENT_Cb ||
+        flex.planes[2].component != FLEX_COMPONENT_Cr) {
+        return false;
+    }
+
+    const auto& y = flex.planes[0];
+    const auto& cb = flex.planes[1];
+    const auto& cr = flex.planes[2];
+
+    if (cb.h_increment != cr.h_increment || cb.v_increment != cr.v_increment) {
+        return false;
+    }
+
+    outLayout->y = y.top_left;
+    outLayout->cb = cb.top_left;
+    outLayout->cr = cr.top_left;
+    outLayout->yStride = y.v_increment;
+    outLayout->cStride = cb.v_increment;
+    outLayout->chromaStep = cb.h_increment;
+
+    return true;
+}
+
+gralloc1_rect_t Gralloc1Mapper::asGralloc1Rect(const IMapper::Rect& rect) {
+    return gralloc1_rect_t{rect.left, rect.top, rect.width, rect.height};
+}
+
+Error Gralloc1Mapper::registerBuffer(buffer_handle_t bufferHandle) {
+    return toError(mDispatch.retain(mDevice, bufferHandle));
+}
+
+void Gralloc1Mapper::unregisterBuffer(buffer_handle_t bufferHandle) {
+    mDispatch.release(mDevice, bufferHandle);
+}
+
+Error Gralloc1Mapper::lockBuffer(buffer_handle_t bufferHandle,
+                                 uint64_t cpuUsage,
+                                 const IMapper::Rect& accessRegion, int fenceFd,
+                                 void** outData) {
+    // Dup fenceFd as it is going to be owned by gralloc.  Note that it is
+    // gralloc's responsibility to close it, even on locking errors.
+    if (fenceFd >= 0) {
+        fenceFd = dup(fenceFd);
+        if (fenceFd < 0) {
+            return Error::NO_RESOURCES;
+        }
+    }
+
+    const uint64_t consumerUsage =
+        cpuUsage & ~static_cast<uint64_t>(BufferUsage::CPU_WRITE_MASK);
+    const auto accessRect = asGralloc1Rect(accessRegion);
+    void* data = nullptr;
+    int32_t error = mDispatch.lock(mDevice, bufferHandle, cpuUsage,
+                                   consumerUsage, &accessRect, &data, fenceFd);
+
+    if (error == GRALLOC1_ERROR_NONE) {
+        *outData = data;
+    }
+
+    return toError(error);
+}
+
+Error Gralloc1Mapper::lockBuffer(buffer_handle_t bufferHandle,
+                                 uint64_t cpuUsage,
+                                 const IMapper::Rect& accessRegion, int fenceFd,
+                                 YCbCrLayout* outLayout) {
+    // prepare flex layout
+    android_flex_layout flex = {};
+    int32_t error =
+        mDispatch.getNumFlexPlanes(mDevice, bufferHandle, &flex.num_planes);
+    if (error != GRALLOC1_ERROR_NONE) {
+        return toError(error);
+    }
+    std::vector<android_flex_plane_t> flexPlanes(flex.num_planes);
+    flex.planes = flexPlanes.data();
+
+    // Dup fenceFd as it is going to be owned by gralloc.  Note that it is
+    // gralloc's responsibility to close it, even on locking errors.
+    if (fenceFd >= 0) {
+        fenceFd = dup(fenceFd);
+        if (fenceFd < 0) {
+            return Error::NO_RESOURCES;
+        }
+    }
+
+    const uint64_t consumerUsage =
+        cpuUsage & ~static_cast<uint64_t>(BufferUsage::CPU_WRITE_MASK);
+    const auto accessRect = asGralloc1Rect(accessRegion);
+    error = mDispatch.lockFlex(mDevice, bufferHandle, cpuUsage, consumerUsage,
+                               &accessRect, &flex, fenceFd);
+    if (error == GRALLOC1_ERROR_NONE && !toYCbCrLayout(flex, outLayout)) {
+        ALOGD("unable to convert android_flex_layout to YCbCrLayout");
+
+        // undo the lock
+        fenceFd = -1;
+        mDispatch.unlock(mDevice, bufferHandle, &fenceFd);
+        if (fenceFd >= 0) {
+            close(fenceFd);
+        }
+
+        error = GRALLOC1_ERROR_BAD_HANDLE;
+    }
+
+    return toError(error);
+}
+
+Error Gralloc1Mapper::unlockBuffer(buffer_handle_t bufferHandle,
+                                   int* outFenceFd) {
+    int fenceFd = -1;
+    int32_t error = mDispatch.unlock(mDevice, bufferHandle, &fenceFd);
+
+    if (error == GRALLOC1_ERROR_NONE) {
+        *outFenceFd = fenceFd;
+    } else if (fenceFd >= 0) {
+        // we always own the fenceFd even when unlock failed
+        close(fenceFd);
+    }
+
+    return toError(error);
+}
+
+}  // namespace implementation
+}  // namespace V2_0
+}  // namespace mapper
+}  // namespace graphics
+}  // namespace hardware
+}  // namespace android
diff --git a/graphics/mapper/2.0/default/Gralloc1Mapper.h b/graphics/mapper/2.0/default/Gralloc1Mapper.h
new file mode 100644
index 000000000..452afdf82
--- /dev/null
+++ b/graphics/mapper/2.0/default/Gralloc1Mapper.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ * * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC1MAPPER_H
+#define ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC1MAPPER_H
+
+#include "GrallocMapper.h"
+
+#include <hardware/gralloc1.h>
+
+namespace android {
+namespace hardware {
+namespace graphics {
+namespace mapper {
+namespace V2_0 {
+namespace implementation {
+
+class Gralloc1Mapper : public GrallocMapper {
+   public:
+    Gralloc1Mapper(const hw_module_t* module);
+    ~Gralloc1Mapper();
+
+   private:
+    void initCapabilities();
+
+    template <typename T>
+    void initDispatch(gralloc1_function_descriptor_t desc, T* outPfn);
+    void initDispatch();
+
+    static Error toError(int32_t error);
+    static bool toYCbCrLayout(const android_flex_layout& flex,
+                              YCbCrLayout* outLayout);
+    static gralloc1_rect_t asGralloc1Rect(const IMapper::Rect& rect);
+
+    Error registerBuffer(buffer_handle_t bufferHandle) override;
+    void unregisterBuffer(buffer_handle_t bufferHandle) override;
+    Error lockBuffer(buffer_handle_t bufferHandle, uint64_t cpuUsage,
+                     const IMapper::Rect& accessRegion, int fenceFd,
+                     void** outData) override;
+    Error lockBuffer(buffer_handle_t bufferHandle, uint64_t cpuUsage,
+                     const IMapper::Rect& accessRegion, int fenceFd,
+                     YCbCrLayout* outLayout) override;
+    Error unlockBuffer(buffer_handle_t bufferHandle, int* outFenceFd) override;
+
+    gralloc1_device_t* mDevice;
+
+    struct {
+        GRALLOC1_PFN_RETAIN retain;
+        GRALLOC1_PFN_RELEASE release;
+        GRALLOC1_PFN_GET_NUM_FLEX_PLANES getNumFlexPlanes;
+        GRALLOC1_PFN_LOCK lock;
+        GRALLOC1_PFN_LOCK_FLEX lockFlex;
+        GRALLOC1_PFN_UNLOCK unlock;
+    } mDispatch;
+};
+
+}  // namespace implementation
+}  // namespace V2_0
+}  // namespace mapper
+}  // namespace graphics
+}  // namespace hardware
+}  // namespace android
+
+#endif  // ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC1MAPPER_H
diff --git a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/GrallocBufferDescriptor.h b/graphics/mapper/2.0/default/GrallocBufferDescriptor.h
similarity index 84%
rename from graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/GrallocBufferDescriptor.h
rename to graphics/mapper/2.0/default/GrallocBufferDescriptor.h
index 4c477e12a..9b5ab0456 100644
--- a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/GrallocBufferDescriptor.h
+++ b/graphics/mapper/2.0/default/GrallocBufferDescriptor.h
@@ -14,7 +14,8 @@
  * limitations under the License.
  */
 
-#pragma once
+#ifndef ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOCBUFFERDESCRIPTOR_H
+#define ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOCBUFFERDESCRIPTOR_H
 
 #include <android/hardware/graphics/mapper/2.0/IMapper.h>
 
@@ -23,7 +24,7 @@ namespace hardware {
 namespace graphics {
 namespace mapper {
 namespace V2_0 {
-namespace passthrough {
+namespace implementation {
 
 using android::hardware::graphics::common::V1_0::PixelFormat;
 
@@ -49,8 +50,9 @@ inline BufferDescriptor grallocEncodeBufferDescriptor(
     return descriptor;
 }
 
-inline bool grallocDecodeBufferDescriptor(const BufferDescriptor& descriptor,
-                                          IMapper::BufferDescriptorInfo* outDescriptorInfo) {
+inline bool grallocDecodeBufferDescriptor(
+    const BufferDescriptor& descriptor,
+    IMapper::BufferDescriptorInfo* outDescriptorInfo) {
     if (descriptor.size() != grallocBufferDescriptorSize ||
         descriptor[0] != grallocBufferDescriptorMagicVersion) {
         return false;
@@ -67,9 +69,11 @@ inline bool grallocDecodeBufferDescriptor(const BufferDescriptor& descriptor,
     return true;
 }
 
-}  // namespace passthrough
+}  // namespace implementation
 }  // namespace V2_0
 }  // namespace mapper
 }  // namespace graphics
 }  // namespace hardware
 }  // namespace android
+
+#endif  // ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOCBUFFERDESCRIPTOR_H
diff --git a/graphics/mapper/2.0/default/GrallocMapper.cpp b/graphics/mapper/2.0/default/GrallocMapper.cpp
new file mode 100644
index 000000000..d16143da4
--- /dev/null
+++ b/graphics/mapper/2.0/default/GrallocMapper.cpp
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ * * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "GrallocMapperPassthrough"
+
+#include "GrallocMapper.h"
+
+#include "Gralloc0Mapper.h"
+#include "Gralloc1Mapper.h"
+#include "GrallocBufferDescriptor.h"
+
+#include <inttypes.h>
+
+#include <log/log.h>
+#include <sync/sync.h>
+
+namespace android {
+namespace hardware {
+namespace graphics {
+namespace mapper {
+namespace V2_0 {
+namespace implementation {
+
+using android::hardware::graphics::common::V1_0::BufferUsage;
+using android::hardware::graphics::common::V1_0::PixelFormat;
+
+namespace {
+
+class RegisteredHandlePool {
+   public:
+    bool add(buffer_handle_t bufferHandle) {
+        std::lock_guard<std::mutex> lock(mMutex);
+        return mHandles.insert(bufferHandle).second;
+    }
+
+    native_handle_t* pop(void* buffer) {
+        auto bufferHandle = static_cast<native_handle_t*>(buffer);
+
+        std::lock_guard<std::mutex> lock(mMutex);
+        return mHandles.erase(bufferHandle) == 1 ? bufferHandle : nullptr;
+    }
+
+    buffer_handle_t get(const void* buffer) {
+        auto bufferHandle = static_cast<buffer_handle_t>(buffer);
+
+        std::lock_guard<std::mutex> lock(mMutex);
+        return mHandles.count(bufferHandle) == 1 ? bufferHandle : nullptr;
+    }
+
+   private:
+    std::mutex mMutex;
+    std::unordered_set<buffer_handle_t> mHandles;
+};
+
+// GraphicBufferMapper is expected to be valid (and leaked) during process
+// termination.  We need to make sure IMapper, and in turn, gRegisteredHandles
+// are valid as well.  Create the registered handle pool on the heap, and let
+// it leak for simplicity.
+//
+// However, there is no way to make sure gralloc0/gralloc1 are valid.  Any use
+// of static/global object in gralloc0/gralloc1 that may have been destructed
+// is potentially broken.
+RegisteredHandlePool* gRegisteredHandles = new RegisteredHandlePool;
+
+}  // anonymous namespace
+
+bool GrallocMapper::validateDescriptorInfo(
+    const BufferDescriptorInfo& descriptorInfo) const {
+    const uint64_t validUsageBits =
+        BufferUsage::CPU_READ_MASK | BufferUsage::CPU_WRITE_MASK |
+        BufferUsage::GPU_TEXTURE | BufferUsage::GPU_RENDER_TARGET |
+        BufferUsage::COMPOSER_OVERLAY | BufferUsage::COMPOSER_CLIENT_TARGET |
+        BufferUsage::PROTECTED | BufferUsage::COMPOSER_CURSOR |
+        BufferUsage::VIDEO_ENCODER | BufferUsage::CAMERA_OUTPUT |
+        BufferUsage::CAMERA_INPUT | BufferUsage::RENDERSCRIPT |
+        BufferUsage::VIDEO_DECODER | BufferUsage::SENSOR_DIRECT_DATA |
+        BufferUsage::GPU_DATA_BUFFER | BufferUsage::VENDOR_MASK |
+        (mCapabilities.highUsageBits ? BufferUsage::VENDOR_MASK_HI
+                                     : static_cast<BufferUsage>(0));
+
+    if (!descriptorInfo.width || !descriptorInfo.height ||
+        !descriptorInfo.layerCount) {
+        return false;
+    }
+
+    if (!mCapabilities.layeredBuffers && descriptorInfo.layerCount > 1) {
+        return false;
+    }
+
+    if (descriptorInfo.format == static_cast<PixelFormat>(0)) {
+        return false;
+    }
+
+    if (descriptorInfo.usage & ~validUsageBits) {
+        // could not fail as gralloc may use the reserved bits...
+        ALOGW("buffer descriptor with invalid usage bits 0x%" PRIx64,
+              descriptorInfo.usage & ~validUsageBits);
+    }
+
+    return true;
+}
+
+Return<void> GrallocMapper::createDescriptor(
+    const BufferDescriptorInfo& descriptorInfo, createDescriptor_cb hidl_cb) {
+    if (validateDescriptorInfo(descriptorInfo)) {
+        hidl_cb(Error::NONE, grallocEncodeBufferDescriptor(descriptorInfo));
+    } else {
+        hidl_cb(Error::BAD_VALUE, BufferDescriptor());
+    }
+
+    return Void();
+}
+
+Return<void> GrallocMapper::importBuffer(const hidl_handle& rawHandle,
+                                         importBuffer_cb hidl_cb) {
+    // because of passthrough HALs, we must not generate an error when
+    // rawHandle has been imported
+
+    if (!rawHandle.getNativeHandle()) {
+        hidl_cb(Error::BAD_BUFFER, nullptr);
+        return Void();
+    }
+
+    native_handle_t* bufferHandle =
+        native_handle_clone(rawHandle.getNativeHandle());
+    if (!bufferHandle) {
+        hidl_cb(Error::NO_RESOURCES, nullptr);
+        return Void();
+    }
+
+    Error error = registerBuffer(bufferHandle);
+    if (error != Error::NONE) {
+        native_handle_close(bufferHandle);
+        native_handle_delete(bufferHandle);
+
+        hidl_cb(error, nullptr);
+        return Void();
+    }
+
+    // The newly cloned handle is already registered?  This can only happen
+    // when a handle previously registered was native_handle_delete'd instead
+    // of freeBuffer'd.
+    if (!gRegisteredHandles->add(bufferHandle)) {
+        ALOGE("handle %p has already been imported; potential fd leaking",
+              bufferHandle);
+        unregisterBuffer(bufferHandle);
+        if (!mCapabilities.unregisterImplyDelete) {
+            native_handle_close(bufferHandle);
+            native_handle_delete(bufferHandle);
+        }
+
+        hidl_cb(Error::NO_RESOURCES, nullptr);
+        return Void();
+    }
+
+    hidl_cb(Error::NONE, bufferHandle);
+    return Void();
+}
+
+Return<Error> GrallocMapper::freeBuffer(void* buffer) {
+    native_handle_t* bufferHandle = gRegisteredHandles->pop(buffer);
+    if (!bufferHandle) {
+        return Error::BAD_BUFFER;
+    }
+
+    unregisterBuffer(bufferHandle);
+    if (!mCapabilities.unregisterImplyDelete) {
+        native_handle_close(bufferHandle);
+        native_handle_delete(bufferHandle);
+    }
+
+    return Error::NONE;
+}
+
+void GrallocMapper::waitFenceFd(int fenceFd, const char* logname) {
+    if (fenceFd < 0) {
+        return;
+    }
+
+    const int warningTimeout = 3500;
+    const int error = sync_wait(fenceFd, warningTimeout);
+    if (error < 0 && errno == ETIME) {
+        ALOGE("%s: fence %d didn't signal in %u ms", logname, fenceFd,
+              warningTimeout);
+        sync_wait(fenceFd, -1);
+    }
+}
+
+bool GrallocMapper::getFenceFd(const hidl_handle& fenceHandle,
+                               int* outFenceFd) {
+    auto handle = fenceHandle.getNativeHandle();
+    if (handle && handle->numFds > 1) {
+        ALOGE("invalid fence handle with %d fds", handle->numFds);
+        return false;
+    }
+
+    *outFenceFd = (handle && handle->numFds == 1) ? handle->data[0] : -1;
+    return true;
+}
+
+hidl_handle GrallocMapper::getFenceHandle(int fenceFd, char* handleStorage) {
+    native_handle_t* handle = nullptr;
+    if (fenceFd >= 0) {
+        handle = native_handle_init(handleStorage, 1, 0);
+        handle->data[0] = fenceFd;
+    }
+
+    return hidl_handle(handle);
+}
+
+Return<void> GrallocMapper::lock(void* buffer, uint64_t cpuUsage,
+                                 const IMapper::Rect& accessRegion,
+                                 const hidl_handle& acquireFence,
+                                 lock_cb hidl_cb) {
+    buffer_handle_t bufferHandle = gRegisteredHandles->get(buffer);
+    if (!bufferHandle) {
+        hidl_cb(Error::BAD_BUFFER, nullptr);
+        return Void();
+    }
+
+    int fenceFd;
+    if (!getFenceFd(acquireFence, &fenceFd)) {
+        hidl_cb(Error::BAD_VALUE, nullptr);
+        return Void();
+    }
+
+    void* data = nullptr;
+    Error error =
+        lockBuffer(bufferHandle, cpuUsage, accessRegion, fenceFd, &data);
+
+    hidl_cb(error, data);
+    return Void();
+}
+
+Return<void> GrallocMapper::lockYCbCr(void* buffer, uint64_t cpuUsage,
+                                      const IMapper::Rect& accessRegion,
+                                      const hidl_handle& acquireFence,
+                                      lockYCbCr_cb hidl_cb) {
+    YCbCrLayout layout = {};
+
+    buffer_handle_t bufferHandle = gRegisteredHandles->get(buffer);
+    if (!bufferHandle) {
+        hidl_cb(Error::BAD_BUFFER, layout);
+        return Void();
+    }
+
+    int fenceFd;
+    if (!getFenceFd(acquireFence, &fenceFd)) {
+        hidl_cb(Error::BAD_VALUE, layout);
+        return Void();
+    }
+
+    Error error =
+        lockBuffer(bufferHandle, cpuUsage, accessRegion, fenceFd, &layout);
+
+    hidl_cb(error, layout);
+    return Void();
+}
+
+Return<void> GrallocMapper::unlock(void* buffer, unlock_cb hidl_cb) {
+    buffer_handle_t bufferHandle = gRegisteredHandles->get(buffer);
+    if (!bufferHandle) {
+        hidl_cb(Error::BAD_BUFFER, nullptr);
+        return Void();
+    }
+
+    int fenceFd;
+    Error error = unlockBuffer(bufferHandle, &fenceFd);
+    if (error == Error::NONE) {
+        NATIVE_HANDLE_DECLARE_STORAGE(fenceStorage, 1, 0);
+
+        hidl_cb(error, getFenceHandle(fenceFd, fenceStorage));
+
+        if (fenceFd >= 0) {
+            close(fenceFd);
+        }
+    } else {
+        hidl_cb(error, nullptr);
+    }
+
+    return Void();
+}
+
+IMapper* HIDL_FETCH_IMapper(const char* /* name */) {
+    const hw_module_t* module = nullptr;
+    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
+    if (err) {
+        ALOGE("failed to get gralloc module");
+        return nullptr;
+    }
+
+    uint8_t major = (module->module_api_version >> 8) & 0xff;
+    switch (major) {
+        case 1:
+            return new Gralloc1Mapper(module);
+        case 0:
+            return new Gralloc0Mapper(module);
+        default:
+            ALOGE("unknown gralloc module major version %d", major);
+            return nullptr;
+    }
+}
+
+} // namespace implementation
+} // namespace V2_0
+} // namespace mapper
+} // namespace graphics
+} // namespace hardware
+} // namespace android
diff --git a/graphics/mapper/2.0/default/GrallocMapper.h b/graphics/mapper/2.0/default/GrallocMapper.h
new file mode 100644
index 000000000..e876fe449
--- /dev/null
+++ b/graphics/mapper/2.0/default/GrallocMapper.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC_MAPPER_H
+#define ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC_MAPPER_H
+
+#include <android/hardware/graphics/mapper/2.0/IMapper.h>
+#include <cutils/native_handle.h>
+
+#include <mutex>
+#include <unordered_set>
+
+namespace android {
+namespace hardware {
+namespace graphics {
+namespace mapper {
+namespace V2_0 {
+namespace implementation {
+
+class GrallocMapper : public IMapper {
+   public:
+    // IMapper interface
+    Return<void> createDescriptor(const BufferDescriptorInfo& descriptorInfo,
+                                  createDescriptor_cb hidl_cb) override;
+    Return<void> importBuffer(const hidl_handle& rawHandle,
+                              importBuffer_cb hidl_cb) override;
+    Return<Error> freeBuffer(void* buffer) override;
+    Return<void> lock(void* buffer, uint64_t cpuUsage,
+                      const IMapper::Rect& accessRegion,
+                      const hidl_handle& acquireFence,
+                      lock_cb hidl_cb) override;
+    Return<void> lockYCbCr(void* buffer, uint64_t cpuUsage,
+                           const IMapper::Rect& accessRegion,
+                           const hidl_handle& acquireFence,
+                           lockYCbCr_cb hidl_cb) override;
+    Return<void> unlock(void* buffer, unlock_cb hidl_cb) override;
+
+   protected:
+    static void waitFenceFd(int fenceFd, const char* logname);
+
+    struct {
+        bool highUsageBits;
+        bool layeredBuffers;
+        bool unregisterImplyDelete;
+    } mCapabilities = {};
+
+   private:
+    virtual bool validateDescriptorInfo(
+        const BufferDescriptorInfo& descriptorInfo) const;
+
+    // Register a buffer.  The handle is already cloned by the caller.
+    virtual Error registerBuffer(buffer_handle_t bufferHandle) = 0;
+
+    // Unregister a buffer.  The handle is closed and deleted by the
+    // callee if and only if mCapabilities.unregisterImplyDelete is set.
+    virtual void unregisterBuffer(buffer_handle_t bufferHandle) = 0;
+
+    // Lock a buffer.  The fence is owned by the caller.
+    virtual Error lockBuffer(buffer_handle_t bufferHandle, uint64_t cpuUsage,
+                             const IMapper::Rect& accessRegion, int fenceFd,
+                             void** outData) = 0;
+    virtual Error lockBuffer(buffer_handle_t bufferHandle, uint64_t cpuUsage,
+                             const IMapper::Rect& accessRegion, int fenceFd,
+                             YCbCrLayout* outLayout) = 0;
+
+    // Unlock a buffer.  The returned fence is owned by the caller.
+    virtual Error unlockBuffer(buffer_handle_t bufferHandle,
+                               int* outFenceFd) = 0;
+
+    static bool getFenceFd(const hidl_handle& fenceHandle, int* outFenceFd);
+    static hidl_handle getFenceHandle(int fenceFd, char* handleStorage);
+};
+
+extern "C" IMapper* HIDL_FETCH_IMapper(const char* name);
+
+} // namespace implementation
+} // namespace V2_0
+} // namespace mapper
+} // namespace graphics
+} // namespace hardware
+} // namespace android
+
+#endif // ANDROID_HARDWARE_GRAPHICS_MAPPER_V2_0_GRALLOC_MAPPER_H
diff --git a/graphics/mapper/2.0/default/passthrough.cpp b/graphics/mapper/2.0/default/passthrough.cpp
deleted file mode 100644
index e18b88fb8..000000000
--- a/graphics/mapper/2.0/default/passthrough.cpp
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright 2016 The Android Open Source Project
- * * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <android/hardware/graphics/mapper/2.0/IMapper.h>
-#include <mapper-passthrough/2.0/GrallocLoader.h>
-
-using android::hardware::graphics::mapper::V2_0::IMapper;
-using android::hardware::graphics::mapper::V2_0::passthrough::GrallocLoader;
-
-extern "C" IMapper* HIDL_FETCH_IMapper(const char* /*name*/) {
-    return GrallocLoader::load();
-}
diff --git a/graphics/mapper/2.0/utils/passthrough/Android.bp b/graphics/mapper/2.0/utils/passthrough/Android.bp
deleted file mode 100644
index 4f700c867..000000000
--- a/graphics/mapper/2.0/utils/passthrough/Android.bp
+++ /dev/null
@@ -1,43 +0,0 @@
-//
-// Copyright (C) 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_library_headers {
-    name: "android.hardware.graphics.mapper@2.0-passthrough",
-    defaults: ["hidl_defaults"],
-    vendor: true,
-    shared_libs: [
-        "android.hardware.graphics.mapper@2.0",
-        "libhardware",
-        "libsync",
-    ],
-    export_shared_lib_headers: [
-        "android.hardware.graphics.mapper@2.0",
-        "libhardware",
-        "libsync",
-    ],
-    header_libs: [
-        "android.hardware.graphics.mapper@2.0-hal",
-    ],
-    export_header_lib_headers: [
-        "android.hardware.graphics.mapper@2.0-hal",
-    ],
-    export_include_dirs: ["include"],
-}
-
-cc_library_headers {
-    name: "android.hardware.graphics.mapper@2.0-passthrough_headers",
-    vendor: true,
-    export_include_dirs: ["include"],
-}
diff --git a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc0Hal.h b/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc0Hal.h
deleted file mode 100644
index 7369ac759..000000000
--- a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc0Hal.h
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Copyright 2016 The Android Open Source Project
- * * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#ifndef LOG_TAG
-#warning "Gralloc0Hal.h included without LOG_TAG"
-#endif
-
-#include <inttypes.h>
-
-#include <hardware/gralloc.h>
-#include <log/log.h>
-#include <mapper-hal/2.0/MapperHal.h>
-#include <mapper-passthrough/2.0/GrallocBufferDescriptor.h>
-#include <sync/sync.h>
-
-namespace android {
-namespace hardware {
-namespace graphics {
-namespace mapper {
-namespace V2_0 {
-namespace passthrough {
-
-namespace detail {
-
-using common::V1_0::BufferUsage;
-
-// Gralloc0HalImpl implements V2_*::hal::MapperHal on top of gralloc0
-template <typename Hal>
-class Gralloc0HalImpl : public Hal {
-   public:
-    bool initWithModule(const hw_module_t* module) {
-        mModule = reinterpret_cast<const gralloc_module_t*>(module);
-        mMinor = module->module_api_version & 0xff;
-        return true;
-    }
-
-    Error createDescriptor(const IMapper::BufferDescriptorInfo& descriptorInfo,
-                           BufferDescriptor* outDescriptor) override {
-        if (!descriptorInfo.width || !descriptorInfo.height || !descriptorInfo.layerCount) {
-            return Error::BAD_VALUE;
-        }
-
-        if (descriptorInfo.layerCount != 1) {
-            return Error::UNSUPPORTED;
-        }
-
-        if (descriptorInfo.format == static_cast<PixelFormat>(0)) {
-            return Error::BAD_VALUE;
-        }
-
-        const uint64_t validUsageBits = getValidBufferUsageMask();
-        if (descriptorInfo.usage & ~validUsageBits) {
-            ALOGW("buffer descriptor with invalid usage bits 0x%" PRIx64,
-                  descriptorInfo.usage & ~validUsageBits);
-        }
-
-        *outDescriptor = grallocEncodeBufferDescriptor(descriptorInfo);
-
-        return Error::NONE;
-    }
-
-    Error importBuffer(const native_handle_t* rawHandle,
-                       native_handle_t** outBufferHandle) override {
-        native_handle_t* bufferHandle = native_handle_clone(rawHandle);
-        if (!bufferHandle) {
-            return Error::NO_RESOURCES;
-        }
-
-        if (mModule->registerBuffer(mModule, bufferHandle)) {
-            native_handle_close(bufferHandle);
-            native_handle_delete(bufferHandle);
-            return Error::BAD_BUFFER;
-        }
-
-        *outBufferHandle = bufferHandle;
-
-        return Error::NONE;
-    }
-
-    Error freeBuffer(native_handle_t* bufferHandle) override {
-        if (mModule->unregisterBuffer(mModule, bufferHandle)) {
-            return Error::BAD_BUFFER;
-        }
-
-        native_handle_close(bufferHandle);
-        native_handle_delete(bufferHandle);
-        return Error::NONE;
-    }
-
-    Error lock(const native_handle_t* bufferHandle, uint64_t cpuUsage,
-               const IMapper::Rect& accessRegion, base::unique_fd fenceFd,
-               void** outData) override {
-        int result;
-        void* data = nullptr;
-        if (mMinor >= 3 && mModule->lockAsync) {
-            result = mModule->lockAsync(mModule, bufferHandle, cpuUsage, accessRegion.left,
-                                        accessRegion.top, accessRegion.width, accessRegion.height,
-                                        &data, fenceFd.release());
-        } else {
-            waitFenceFd(fenceFd, "Gralloc0Hal::lock");
-
-            result =
-                mModule->lock(mModule, bufferHandle, cpuUsage, accessRegion.left, accessRegion.top,
-                              accessRegion.width, accessRegion.height, &data);
-        }
-
-        if (result) {
-            return Error::BAD_VALUE;
-        }
-
-        *outData = data;
-        return Error::NONE;
-    }
-
-    Error lockYCbCr(const native_handle_t* bufferHandle, uint64_t cpuUsage,
-                    const IMapper::Rect& accessRegion, base::unique_fd fenceFd,
-                    YCbCrLayout* outLayout) override {
-        int result;
-        android_ycbcr ycbcr = {};
-        if (mMinor >= 3 && mModule->lockAsync_ycbcr) {
-            result = mModule->lockAsync_ycbcr(mModule, bufferHandle, cpuUsage, accessRegion.left,
-                                              accessRegion.top, accessRegion.width,
-                                              accessRegion.height, &ycbcr, fenceFd.release());
-        } else {
-            waitFenceFd(fenceFd, "Gralloc0Hal::lockYCbCr");
-
-            if (mModule->lock_ycbcr) {
-                result = mModule->lock_ycbcr(mModule, bufferHandle, cpuUsage, accessRegion.left,
-                                             accessRegion.top, accessRegion.width,
-                                             accessRegion.height, &ycbcr);
-            } else {
-                result = -EINVAL;
-            }
-        }
-
-        if (result) {
-            return Error::BAD_VALUE;
-        }
-
-        outLayout->y = ycbcr.y;
-        outLayout->cb = ycbcr.cb;
-        outLayout->cr = ycbcr.cr;
-        outLayout->yStride = ycbcr.ystride;
-        outLayout->cStride = ycbcr.cstride;
-        outLayout->chromaStep = ycbcr.chroma_step;
-        return Error::NONE;
-    }
-
-    Error unlock(const native_handle_t* bufferHandle, base::unique_fd* outFenceFd) override {
-        int result;
-        int fenceFd = -1;
-        if (mMinor >= 3 && mModule->unlockAsync) {
-            result = mModule->unlockAsync(mModule, bufferHandle, &fenceFd);
-        } else {
-            result = mModule->unlock(mModule, bufferHandle);
-        }
-
-        // we always own the fenceFd even when unlock failed
-        outFenceFd->reset(fenceFd);
-        return result ? Error::BAD_VALUE : Error::NONE;
-    }
-
-   protected:
-    virtual uint64_t getValidBufferUsageMask() const {
-        return BufferUsage::CPU_READ_MASK | BufferUsage::CPU_WRITE_MASK | BufferUsage::GPU_TEXTURE |
-               BufferUsage::GPU_RENDER_TARGET | BufferUsage::COMPOSER_OVERLAY |
-               BufferUsage::COMPOSER_CLIENT_TARGET | BufferUsage::PROTECTED |
-               BufferUsage::COMPOSER_CURSOR | BufferUsage::VIDEO_ENCODER |
-               BufferUsage::CAMERA_OUTPUT | BufferUsage::CAMERA_INPUT | BufferUsage::RENDERSCRIPT |
-               BufferUsage::VIDEO_DECODER | BufferUsage::SENSOR_DIRECT_DATA |
-               BufferUsage::GPU_DATA_BUFFER | BufferUsage::VENDOR_MASK;
-    }
-
-    static void waitFenceFd(const base::unique_fd& fenceFd, const char* logname) {
-        if (fenceFd < 0) {
-            return;
-        }
-
-        const int warningTimeout = 3500;
-        const int error = sync_wait(fenceFd, warningTimeout);
-        if (error < 0 && errno == ETIME) {
-            ALOGE("%s: fence %d didn't signal in %u ms", logname, fenceFd.get(), warningTimeout);
-            sync_wait(fenceFd, -1);
-        }
-    }
-
-    const gralloc_module_t* mModule = nullptr;
-    uint8_t mMinor = 0;
-};
-
-}  // namespace detail
-
-using Gralloc0Hal = detail::Gralloc0HalImpl<hal::MapperHal>;
-
-}  // namespace passthrough
-}  // namespace V2_0
-}  // namespace mapper
-}  // namespace graphics
-}  // namespace hardware
-}  // namespace android
diff --git a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc1Hal.h b/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc1Hal.h
deleted file mode 100644
index d9beb4f67..000000000
--- a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/Gralloc1Hal.h
+++ /dev/null
@@ -1,338 +0,0 @@
-/*
- * Copyright 2016 The Android Open Source Project
- * * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#ifndef LOG_TAG
-#warning "Gralloc1Hal.h included without LOG_TAG"
-#endif
-
-#include <inttypes.h>
-
-#include <vector>
-
-#include <hardware/gralloc1.h>
-#include <log/log.h>
-#include <mapper-hal/2.0/MapperHal.h>
-#include <mapper-passthrough/2.0/GrallocBufferDescriptor.h>
-
-namespace android {
-namespace hardware {
-namespace graphics {
-namespace mapper {
-namespace V2_0 {
-namespace passthrough {
-
-namespace detail {
-
-using common::V1_0::BufferUsage;
-
-// Gralloc1HalImpl implements V2_*::hal::MapperHal on top of gralloc1
-template <typename Hal>
-class Gralloc1HalImpl : public Hal {
-   public:
-    ~Gralloc1HalImpl() {
-        if (mDevice) {
-            gralloc1_close(mDevice);
-        }
-    }
-
-    bool initWithModule(const hw_module_t* module) {
-        int result = gralloc1_open(module, &mDevice);
-        if (result) {
-            ALOGE("failed to open gralloc1 device: %s", strerror(-result));
-            mDevice = nullptr;
-            return false;
-        }
-
-        initCapabilities();
-
-        if (!initDispatch()) {
-            gralloc1_close(mDevice);
-            mDevice = nullptr;
-            return false;
-        }
-
-        return true;
-    }
-
-    Error createDescriptor(const IMapper::BufferDescriptorInfo& descriptorInfo,
-                           BufferDescriptor* outDescriptor) override {
-        if (!descriptorInfo.width || !descriptorInfo.height || !descriptorInfo.layerCount) {
-            return Error::BAD_VALUE;
-        }
-
-        if (!mCapabilities.layeredBuffers && descriptorInfo.layerCount != 1) {
-            return Error::UNSUPPORTED;
-        }
-
-        if (descriptorInfo.format == static_cast<PixelFormat>(0)) {
-            return Error::BAD_VALUE;
-        }
-
-        const uint64_t validUsageBits = getValidBufferUsageMask();
-        if (descriptorInfo.usage & ~validUsageBits) {
-            ALOGW("buffer descriptor with invalid usage bits 0x%" PRIx64,
-                  descriptorInfo.usage & ~validUsageBits);
-        }
-
-        *outDescriptor = grallocEncodeBufferDescriptor(descriptorInfo);
-
-        return Error::NONE;
-    }
-
-    Error importBuffer(const native_handle_t* rawHandle,
-                       native_handle_t** outBufferHandle) override {
-        native_handle_t* bufferHandle = native_handle_clone(rawHandle);
-        if (!bufferHandle) {
-            return Error::NO_RESOURCES;
-        }
-
-        int32_t error = mDispatch.retain(mDevice, bufferHandle);
-        if (error != GRALLOC1_ERROR_NONE) {
-            native_handle_close(bufferHandle);
-            native_handle_delete(bufferHandle);
-            return toError(error);
-        }
-
-        *outBufferHandle = bufferHandle;
-
-        return Error::NONE;
-    }
-
-    Error freeBuffer(native_handle_t* bufferHandle) override {
-        int32_t error = mDispatch.release(mDevice, bufferHandle);
-        if (error == GRALLOC1_ERROR_NONE && !mCapabilities.releaseImplyDelete) {
-            native_handle_close(bufferHandle);
-            native_handle_delete(bufferHandle);
-        }
-        return toError(error);
-    }
-
-    Error lock(const native_handle_t* bufferHandle, uint64_t cpuUsage,
-               const IMapper::Rect& accessRegion, base::unique_fd fenceFd,
-               void** outData) override {
-        const uint64_t consumerUsage =
-            cpuUsage & ~static_cast<uint64_t>(BufferUsage::CPU_WRITE_MASK);
-        const auto accessRect = asGralloc1Rect(accessRegion);
-        void* data = nullptr;
-        int32_t error = mDispatch.lock(mDevice, bufferHandle, cpuUsage, consumerUsage, &accessRect,
-                                       &data, fenceFd.release());
-        if (error == GRALLOC1_ERROR_NONE) {
-            *outData = data;
-        }
-
-        return toError(error);
-    }
-
-    Error lockYCbCr(const native_handle_t* bufferHandle, uint64_t cpuUsage,
-                    const IMapper::Rect& accessRegion, base::unique_fd fenceFd,
-                    YCbCrLayout* outLayout) override {
-        // prepare flex layout
-        android_flex_layout flex = {};
-        int32_t error = mDispatch.getNumFlexPlanes(mDevice, bufferHandle, &flex.num_planes);
-        if (error != GRALLOC1_ERROR_NONE) {
-            return toError(error);
-        }
-        std::vector<android_flex_plane_t> flexPlanes(flex.num_planes);
-        flex.planes = flexPlanes.data();
-
-        const uint64_t consumerUsage =
-            cpuUsage & ~static_cast<uint64_t>(BufferUsage::CPU_WRITE_MASK);
-        const auto accessRect = asGralloc1Rect(accessRegion);
-        error = mDispatch.lockFlex(mDevice, bufferHandle, cpuUsage, consumerUsage, &accessRect,
-                                   &flex, fenceFd.release());
-        if (error == GRALLOC1_ERROR_NONE && !toYCbCrLayout(flex, outLayout)) {
-            ALOGD("unable to convert android_flex_layout to YCbCrLayout");
-            // undo the lock
-            unlock(bufferHandle, &fenceFd);
-            error = GRALLOC1_ERROR_BAD_HANDLE;
-        }
-
-        return toError(error);
-    }
-
-    Error unlock(const native_handle_t* bufferHandle, base::unique_fd* outFenceFd) override {
-        int fenceFd = -1;
-        int32_t error = mDispatch.unlock(mDevice, bufferHandle, &fenceFd);
-
-        // we always own the fenceFd even when unlock failed
-        outFenceFd->reset(fenceFd);
-        return toError(error);
-    }
-
-   protected:
-    virtual void initCapabilities() {
-        uint32_t count = 0;
-        mDevice->getCapabilities(mDevice, &count, nullptr);
-
-        std::vector<int32_t> capabilities(count);
-        mDevice->getCapabilities(mDevice, &count, capabilities.data());
-        capabilities.resize(count);
-
-        for (auto capability : capabilities) {
-            switch (capability) {
-                case GRALLOC1_CAPABILITY_LAYERED_BUFFERS:
-                    mCapabilities.layeredBuffers = true;
-                    break;
-                case GRALLOC1_CAPABILITY_RELEASE_IMPLY_DELETE:
-                    mCapabilities.releaseImplyDelete = true;
-                    break;
-            }
-        }
-    }
-
-    template <typename T>
-    bool initDispatch(gralloc1_function_descriptor_t desc, T* outPfn) {
-        auto pfn = mDevice->getFunction(mDevice, desc);
-        if (pfn) {
-            *outPfn = reinterpret_cast<T>(pfn);
-            return true;
-        } else {
-            ALOGE("failed to get gralloc1 function %d", desc);
-            return false;
-        }
-    }
-
-    virtual bool initDispatch() {
-        if (!initDispatch(GRALLOC1_FUNCTION_RETAIN, &mDispatch.retain) ||
-            !initDispatch(GRALLOC1_FUNCTION_RELEASE, &mDispatch.release) ||
-            !initDispatch(GRALLOC1_FUNCTION_GET_NUM_FLEX_PLANES, &mDispatch.getNumFlexPlanes) ||
-            !initDispatch(GRALLOC1_FUNCTION_LOCK, &mDispatch.lock) ||
-            !initDispatch(GRALLOC1_FUNCTION_LOCK_FLEX, &mDispatch.lockFlex) ||
-            !initDispatch(GRALLOC1_FUNCTION_UNLOCK, &mDispatch.unlock)) {
-            return false;
-        }
-
-        return true;
-    }
-
-    virtual uint64_t getValidBufferUsageMask() const {
-        return BufferUsage::CPU_READ_MASK | BufferUsage::CPU_WRITE_MASK | BufferUsage::GPU_TEXTURE |
-               BufferUsage::GPU_RENDER_TARGET | BufferUsage::COMPOSER_OVERLAY |
-               BufferUsage::COMPOSER_CLIENT_TARGET | BufferUsage::PROTECTED |
-               BufferUsage::COMPOSER_CURSOR | BufferUsage::VIDEO_ENCODER |
-               BufferUsage::CAMERA_OUTPUT | BufferUsage::CAMERA_INPUT | BufferUsage::RENDERSCRIPT |
-               BufferUsage::VIDEO_DECODER | BufferUsage::SENSOR_DIRECT_DATA |
-               BufferUsage::GPU_DATA_BUFFER | BufferUsage::VENDOR_MASK |
-               BufferUsage::VENDOR_MASK_HI;
-    }
-
-    static Error toError(int32_t error) {
-        switch (error) {
-            case GRALLOC1_ERROR_NONE:
-                return Error::NONE;
-            case GRALLOC1_ERROR_BAD_DESCRIPTOR:
-                return Error::BAD_DESCRIPTOR;
-            case GRALLOC1_ERROR_BAD_HANDLE:
-                return Error::BAD_BUFFER;
-            case GRALLOC1_ERROR_BAD_VALUE:
-                return Error::BAD_VALUE;
-            case GRALLOC1_ERROR_NOT_SHARED:
-                return Error::NONE;  // this is fine
-            case GRALLOC1_ERROR_NO_RESOURCES:
-                return Error::NO_RESOURCES;
-            case GRALLOC1_ERROR_UNDEFINED:
-            case GRALLOC1_ERROR_UNSUPPORTED:
-            default:
-                return Error::UNSUPPORTED;
-        }
-    }
-
-    static bool toYCbCrLayout(const android_flex_layout& flex, YCbCrLayout* outLayout) {
-        // must be YCbCr
-        if (flex.format != FLEX_FORMAT_YCbCr || flex.num_planes < 3) {
-            return false;
-        }
-
-        for (int i = 0; i < 3; i++) {
-            const auto& plane = flex.planes[i];
-            // must have 8-bit depth
-            if (plane.bits_per_component != 8 || plane.bits_used != 8) {
-                return false;
-            }
-
-            if (plane.component == FLEX_COMPONENT_Y) {
-                // Y must not be interleaved
-                if (plane.h_increment != 1) {
-                    return false;
-                }
-            } else {
-                // Cb and Cr can be interleaved
-                if (plane.h_increment != 1 && plane.h_increment != 2) {
-                    return false;
-                }
-            }
-
-            if (!plane.v_increment) {
-                return false;
-            }
-        }
-
-        if (flex.planes[0].component != FLEX_COMPONENT_Y ||
-            flex.planes[1].component != FLEX_COMPONENT_Cb ||
-            flex.planes[2].component != FLEX_COMPONENT_Cr) {
-            return false;
-        }
-
-        const auto& y = flex.planes[0];
-        const auto& cb = flex.planes[1];
-        const auto& cr = flex.planes[2];
-
-        if (cb.h_increment != cr.h_increment || cb.v_increment != cr.v_increment) {
-            return false;
-        }
-
-        outLayout->y = y.top_left;
-        outLayout->cb = cb.top_left;
-        outLayout->cr = cr.top_left;
-        outLayout->yStride = y.v_increment;
-        outLayout->cStride = cb.v_increment;
-        outLayout->chromaStep = cb.h_increment;
-
-        return true;
-    }
-
-    static gralloc1_rect_t asGralloc1Rect(const IMapper::Rect& rect) {
-        return gralloc1_rect_t{rect.left, rect.top, rect.width, rect.height};
-    }
-
-    gralloc1_device_t* mDevice = nullptr;
-
-    struct {
-        bool layeredBuffers;
-        bool releaseImplyDelete;
-    } mCapabilities = {};
-
-    struct {
-        GRALLOC1_PFN_RETAIN retain;
-        GRALLOC1_PFN_RELEASE release;
-        GRALLOC1_PFN_GET_NUM_FLEX_PLANES getNumFlexPlanes;
-        GRALLOC1_PFN_LOCK lock;
-        GRALLOC1_PFN_LOCK_FLEX lockFlex;
-        GRALLOC1_PFN_UNLOCK unlock;
-    } mDispatch = {};
-};
-
-}  // namespace detail
-
-using Gralloc1Hal = detail::Gralloc1HalImpl<hal::MapperHal>;
-
-}  // namespace passthrough
-}  // namespace V2_0
-}  // namespace mapper
-}  // namespace graphics
-}  // namespace hardware
-}  // namespace android
diff --git a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/GrallocLoader.h b/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/GrallocLoader.h
deleted file mode 100644
index e8b1b4b83..000000000
--- a/graphics/mapper/2.0/utils/passthrough/include/mapper-passthrough/2.0/GrallocLoader.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#ifndef LOG_TAG
-#warning "GrallocLoader.h included without LOG_TAG"
-#endif
-
-#include <memory>
-#include <mutex>
-#include <unordered_set>
-
-#include <hardware/gralloc.h>
-#include <hardware/hardware.h>
-#include <log/log.h>
-#include <mapper-hal/2.0/Mapper.h>
-#include <mapper-passthrough/2.0/Gralloc0Hal.h>
-#include <mapper-passthrough/2.0/Gralloc1Hal.h>
-
-namespace android {
-namespace hardware {
-namespace graphics {
-namespace mapper {
-namespace V2_0 {
-namespace passthrough {
-
-class GrallocImportedBufferPool {
-   public:
-    static GrallocImportedBufferPool& getInstance() {
-        // GraphicBufferMapper in framework is expected to be valid (and
-        // leaked) during process termination.  We need to make sure IMapper,
-        // and in turn, GrallocImportedBufferPool is valid as well.  Create
-        // imported buffer pool on the heap (and let it leak) for the purpose.
-        // Besides, all IMapper instances must share the same pool.  Make it a
-        // singleton.
-        //
-        // However, there is no way to make sure gralloc0/gralloc1 are valid
-        // during process termination.  Any use of static/global object in
-        // gralloc0/gralloc1 that may be destructed during process termination
-        // is potentially broken.
-        static GrallocImportedBufferPool* singleton = new GrallocImportedBufferPool;
-        return *singleton;
-    }
-
-    void* add(native_handle_t* bufferHandle) {
-        std::lock_guard<std::mutex> lock(mMutex);
-        return mBufferHandles.insert(bufferHandle).second ? bufferHandle : nullptr;
-    }
-
-    native_handle_t* remove(void* buffer) {
-        auto bufferHandle = static_cast<native_handle_t*>(buffer);
-
-        std::lock_guard<std::mutex> lock(mMutex);
-        return mBufferHandles.erase(bufferHandle) == 1 ? bufferHandle : nullptr;
-    }
-
-    const native_handle_t* get(void* buffer) {
-        auto bufferHandle = static_cast<const native_handle_t*>(buffer);
-
-        std::lock_guard<std::mutex> lock(mMutex);
-        return mBufferHandles.count(bufferHandle) == 1 ? bufferHandle : nullptr;
-    }
-
-   private:
-    std::mutex mMutex;
-    std::unordered_set<const native_handle_t*> mBufferHandles;
-};
-
-// Inherit from V2_*::hal::Mapper and override imported buffer management functions
-template <typename T>
-class GrallocMapper : public T {
-   protected:
-    void* addImportedBuffer(native_handle_t* bufferHandle) override {
-        return GrallocImportedBufferPool::getInstance().add(bufferHandle);
-    }
-
-    native_handle_t* removeImportedBuffer(void* buffer) override {
-        return GrallocImportedBufferPool::getInstance().remove(buffer);
-    }
-
-    const native_handle_t* getImportedBuffer(void* buffer) const override {
-        return GrallocImportedBufferPool::getInstance().get(buffer);
-    }
-};
-
-class GrallocLoader {
-   public:
-    static IMapper* load() {
-        const hw_module_t* module = loadModule();
-        if (!module) {
-            return nullptr;
-        }
-        auto hal = createHal(module);
-        if (!hal) {
-            return nullptr;
-        }
-        return createMapper(std::move(hal));
-    }
-
-    // load the gralloc module
-    static const hw_module_t* loadModule() {
-        const hw_module_t* module;
-        int error = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
-        if (error) {
-            ALOGE("failed to get gralloc module");
-            return nullptr;
-        }
-
-        return module;
-    }
-
-    // return the major api version of the module
-    static int getModuleMajorApiVersion(const hw_module_t* module) {
-        return (module->module_api_version >> 8) & 0xff;
-    }
-
-    // create a MapperHal instance
-    static std::unique_ptr<hal::MapperHal> createHal(const hw_module_t* module) {
-        int major = getModuleMajorApiVersion(module);
-        switch (major) {
-            case 1: {
-                auto hal = std::make_unique<Gralloc1Hal>();
-                return hal->initWithModule(module) ? std::move(hal) : nullptr;
-            }
-            case 0: {
-                auto hal = std::make_unique<Gralloc0Hal>();
-                return hal->initWithModule(module) ? std::move(hal) : nullptr;
-            }
-            default:
-                ALOGE("unknown gralloc module major version %d", major);
-                return nullptr;
-        }
-    }
-
-    // create an IAllocator instance
-    static IMapper* createMapper(std::unique_ptr<hal::MapperHal> hal) {
-        auto mapper = std::make_unique<GrallocMapper<hal::Mapper>>();
-        return mapper->init(std::move(hal)) ? mapper.release() : nullptr;
-    }
-};
-
-}  // namespace passthrough
-}  // namespace V2_0
-}  // namespace mapper
-}  // namespace graphics
-}  // namespace hardware
-}  // namespace android
-- 
2.17.0

