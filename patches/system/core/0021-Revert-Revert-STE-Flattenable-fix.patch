From 099eed2059e2f181fbc6da993f76dc7f5123dbc3 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Thu, 13 Sep 2018 22:28:37 +0300
Subject: [PATCH 21/31] Revert "Revert "STE Flattenable fix""

This reverts commit 8ae5b5e0fc8c2323aa1ca02c26d4e008baf82cc1.

Change-Id: I551bd9d46334f3cf12f5184b1eafb08a24118b37
---
 libutils/Android.bp                  |  5 +++--
 libutils/Flattenable.cpp             | 24 ++++++++++++++++++++++++
 libutils/include/utils/Flattenable.h | 32 ++++++++++++++++++++++++++++++++
 3 files changed, 59 insertions(+), 2 deletions(-)
 create mode 100644 libutils/Flattenable.cpp

diff --git a/libutils/Android.bp b/libutils/Android.bp
index a4fc4b4ce..91eedf7db 100644
--- a/libutils/Android.bp
+++ b/libutils/Android.bp
@@ -55,6 +55,7 @@ cc_defaults {
     cflags: [
         "-Wall",
         "-Werror",
+        "-DSTE_HARDWARE",
     ],
     include_dirs: ["external/safe-iop/include"],
     header_libs: [
@@ -83,7 +84,6 @@ cc_defaults {
                 "libdl",
                 "libvndksupport",
             ],
-
             sanitize: {
                 misc_undefined: ["integer"],
             },
@@ -112,7 +112,7 @@ cc_defaults {
                 "-Wno-unused-private-field",
             ],
 
-            enabled: true,
+            enabled: false,
         },
     },
 }
@@ -141,6 +141,7 @@ cc_library {
         "Unicode.cpp",
         "VectorImpl.cpp",
         "misc.cpp",
+        "Flattenable.cpp",
     ],
 
     target: {
diff --git a/libutils/Flattenable.cpp b/libutils/Flattenable.cpp
new file mode 100644
index 000000000..1f2ffaa28
--- /dev/null
+++ b/libutils/Flattenable.cpp
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <utils/Flattenable.h>
+
+namespace android {
+
+Flattenable::~Flattenable() {
+}
+
+}; // namespace android
diff --git a/libutils/include/utils/Flattenable.h b/libutils/include/utils/Flattenable.h
index 675e211e0..54ca29733 100644
--- a/libutils/include/utils/Flattenable.h
+++ b/libutils/include/utils/Flattenable.h
@@ -17,6 +17,12 @@
 #ifndef ANDROID_UTILS_FLATTENABLE_H
 #define ANDROID_UTILS_FLATTENABLE_H
 
+#pragma GCC diagnostic ignored "-Wdeprecated"
+#pragma GCC diagnostic ignored "-Wold-style-cast"
+#pragma GCC diagnostic ignored "-Wunused-parameter"
+#pragma GCC diagnostic ignored "-Winconsistent-missing-destructor-override"
+#pragma GCC diagnostic ignored "-Wweak-vtables"
+#pragma GCC diagnostic ignored "-Wcast-qual"
 
 #include <stdint.h>
 #include <string.h>
@@ -63,8 +69,10 @@ public:
     // write a POD structure
     template<typename T>
     static void write(void*& buffer, size_t& size, const T& value) {
+/*
         static_assert(std::is_trivially_copyable<T>::value,
                       "Cannot flatten a non-trivially-copyable type");
+*/
         memcpy(buffer, &value, sizeof(T));
         advance(buffer, size, sizeof(T));
     }
@@ -72,8 +80,10 @@ public:
     // read a POD structure
     template<typename T>
     static void read(void const*& buffer, size_t& size, T& value) {
+/*
         static_assert(std::is_trivially_copyable<T>::value,
                       "Cannot unflatten a non-trivially-copyable type");
+*/
         memcpy(&value, buffer, sizeof(T));
         advance(buffer, size, sizeof(T));
     }
@@ -86,21 +96,35 @@ public:
  * Flattenable objects must implement this protocol.
  */
 
+#ifndef STE_HARDWARE
 template <typename T>
+#endif
 class Flattenable {
 public:
     // size in bytes of the flattened object
+#ifdef STE_HARDWARE
+    virtual size_t getFlattenedSize() const = 0;
+#else
     inline size_t getFlattenedSize() const;
+#endif
 
     // number of file descriptors to flatten
+#ifdef STE_HARDWARE
+    virtual size_t getFdCount() const = 0;
+#else
     inline size_t getFdCount() const;
+#endif
 
     // flattens the object into buffer.
     // size should be at least of getFlattenedSize()
     // file descriptors are written in the fds[] array but ownership is
     // not transfered (ie: they must be dupped by the caller of
     // flatten() if needed).
+#ifdef STE_HARDWARE
+    virtual status_t flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const = 0;
+#else
     inline status_t flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const;
+#endif
 
     // unflattens the object from buffer.
     // size should be equal to the value of getFlattenedSize() when the
@@ -109,6 +133,13 @@ public:
     // don't need to be dupped(). ie: the caller of unflatten doesn't
     // keep ownership. If a fd is not retained by unflatten() it must be
     // explicitly closed.
+#ifdef STE_HARDWARE
+    virtual status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count) = 0;
+
+protected:
+    virtual ~Flattenable() = 0;
+};
+#else
     inline status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count);
 };
 
@@ -130,6 +161,7 @@ inline status_t Flattenable<T>::unflatten(
         void const*& buffer, size_t& size, int const*& fds, size_t& count) {
     return static_cast<T*>(this)->T::unflatten(buffer, size, fds, count);
 }
+#endif
 
 /*
  * LightFlattenable is a protocol allowing object to serialize themselves out
-- 
2.11.0

