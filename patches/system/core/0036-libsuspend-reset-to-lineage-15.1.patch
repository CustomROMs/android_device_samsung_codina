From 6cd151ba2c67387e79c1d457497c9e932701bcc7 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 27 Aug 2018 01:17:16 +0300
Subject: [PATCH 36/44] libsuspend: reset to lineage-15.1

Change-Id: Ib0aa440cc647e703eb2a52ce34eebca9da89aca1
---
 libsuspend/Android.bp                    |   4 +-
 libsuspend/autosuspend.c                 |  57 +++---
 libsuspend/autosuspend_ops.h             |   6 +-
 libsuspend/autosuspend_wakeup_count.c    | 215 +++++++++++++++++++++++
 libsuspend/include/suspend/autosuspend.h |  13 +-
 5 files changed, 241 insertions(+), 54 deletions(-)
 create mode 100644 libsuspend/autosuspend_wakeup_count.c

diff --git a/libsuspend/Android.bp b/libsuspend/Android.bp
index 5e08f780e..274b9997b 100644
--- a/libsuspend/Android.bp
+++ b/libsuspend/Android.bp
@@ -9,17 +9,17 @@ cc_library {
 
     srcs: [
         "autosuspend.c",
-        "autosuspend_wakeup_count.cpp",
         "autosuspend_earlysuspend.c",
+        "autosuspend_wakeup_count.c",
     ],
     export_include_dirs: ["include"],
     local_include_dirs: ["include"],
     shared_libs: [
-        "libbase",
         "liblog",
         "libcutils",
     ],
     cflags: [
+        "-Werror",
         // "-DLOG_NDEBUG=0",
     ],
 }
diff --git a/libsuspend/autosuspend.c b/libsuspend/autosuspend.c
index c5f14a6f6..342d0d8fc 100644
--- a/libsuspend/autosuspend.c
+++ b/libsuspend/autosuspend.c
@@ -24,11 +24,13 @@
 
 #include "autosuspend_ops.h"
 
-static struct autosuspend_ops* autosuspend_ops = NULL;
+static struct autosuspend_ops *autosuspend_ops;
 static bool autosuspend_enabled;
+static bool autosuspend_inited;
 
-static int autosuspend_init(void) {
-    if (autosuspend_ops != NULL) {
+static int autosuspend_init(void)
+{
+    if (autosuspend_inited) {
         return 0;
     }
 
@@ -38,16 +40,24 @@ static int autosuspend_init(void) {
     }
 
     autosuspend_ops = autosuspend_wakeup_count_init();
-    if (autosuspend_ops == NULL) {
-        ALOGE("failed to initialize autosuspend");
+    if (autosuspend_ops) {
+        goto out;
+    }
+
+    if (!autosuspend_ops) {
+        ALOGE("failed to initialize autosuspend\n");
         return -1;
     }
 
-    ALOGV("autosuspend initialized");
+out:
+    autosuspend_inited = true;
+
+    ALOGV("autosuspend initialized\n");
     return 0;
 }
 
-int autosuspend_enable(void) {
+int autosuspend_enable(void)
+{
     int ret;
 
     ret = autosuspend_init();
@@ -55,7 +65,7 @@ int autosuspend_enable(void) {
         return ret;
     }
 
-    ALOGV("autosuspend_enable");
+    ALOGV("autosuspend_enable\n");
 
     if (autosuspend_enabled) {
         return 0;
@@ -70,7 +80,8 @@ int autosuspend_enable(void) {
     return 0;
 }
 
-int autosuspend_disable(void) {
+int autosuspend_disable(void)
+{
     int ret;
 
     ret = autosuspend_init();
@@ -78,7 +89,7 @@ int autosuspend_disable(void) {
         return ret;
     }
 
-    ALOGV("autosuspend_disable");
+    ALOGV("autosuspend_disable\n");
 
     if (!autosuspend_enabled) {
         return 0;
@@ -92,29 +103,3 @@ int autosuspend_disable(void) {
     autosuspend_enabled = false;
     return 0;
 }
-
-int autosuspend_force_suspend(int timeout_ms) {
-    int ret;
-
-    ret = autosuspend_init();
-    if (ret) {
-        return ret;
-    }
-
-    ALOGV("autosuspend_force_suspend");
-
-    return autosuspend_ops->force_suspend(timeout_ms);
-}
-
-void autosuspend_set_wakeup_callback(void (*func)(bool success)) {
-    int ret;
-
-    ret = autosuspend_init();
-    if (ret) {
-        return;
-    }
-
-    ALOGV("set_wakeup_callback");
-
-    autosuspend_ops->set_wakeup_callback(func);
-}
diff --git a/libsuspend/autosuspend_ops.h b/libsuspend/autosuspend_ops.h
index b0024c8bb..698e25be8 100644
--- a/libsuspend/autosuspend_ops.h
+++ b/libsuspend/autosuspend_ops.h
@@ -20,12 +20,10 @@
 struct autosuspend_ops {
     int (*enable)(void);
     int (*disable)(void);
-    int (*force_suspend)(int timeout_ms);
-    void (*set_wakeup_callback)(void (*func)(bool success));
 };
 
-__BEGIN_DECLS
+struct autosuspend_ops *autosuspend_autosleep_init(void);
+struct autosuspend_ops *autosuspend_earlysuspend_init(void);
 struct autosuspend_ops *autosuspend_wakeup_count_init(void);
-__END_DECLS
 
 #endif
diff --git a/libsuspend/autosuspend_wakeup_count.c b/libsuspend/autosuspend_wakeup_count.c
new file mode 100644
index 000000000..2da204ae0
--- /dev/null
+++ b/libsuspend/autosuspend_wakeup_count.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "libsuspend"
+//#define LOG_NDEBUG 0
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <log/log.h>
+
+#include "autosuspend_ops.h"
+
+#define SYS_POWER_STATE "/sys/power/state"
+#define SYS_POWER_WAKEUP_COUNT "/sys/power/wakeup_count"
+
+#define BASE_SLEEP_TIME 100000
+
+static int state_fd;
+static int wakeup_count_fd;
+static pthread_t suspend_thread;
+static sem_t suspend_lockout;
+static const char *sleep_state = "mem";
+static void (*wakeup_func)(bool success) = NULL;
+static int sleep_time = BASE_SLEEP_TIME;
+
+static void update_sleep_time(bool success) {
+    if (success) {
+        sleep_time = BASE_SLEEP_TIME;
+        return;
+    }
+    // double sleep time after each failure up to one minute
+    sleep_time = MIN(sleep_time * 2, 60000000);
+}
+
+static void *suspend_thread_func(void *arg __attribute__((unused)))
+{
+    char buf[80];
+    char wakeup_count[20];
+    int wakeup_count_len;
+    int ret;
+    bool success = true;
+
+    while (1) {
+        update_sleep_time(success);
+        usleep(sleep_time);
+        success = false;
+        ALOGV("%s: read wakeup_count\n", __func__);
+        lseek(wakeup_count_fd, 0, SEEK_SET);
+        wakeup_count_len = TEMP_FAILURE_RETRY(read(wakeup_count_fd, wakeup_count,
+                sizeof(wakeup_count)));
+        if (wakeup_count_len < 0) {
+            strerror_r(errno, buf, sizeof(buf));
+            ALOGE("Error reading from %s: %s\n", SYS_POWER_WAKEUP_COUNT, buf);
+            wakeup_count_len = 0;
+            continue;
+        }
+        if (!wakeup_count_len) {
+            ALOGE("Empty wakeup count\n");
+            continue;
+        }
+
+        ALOGV("%s: wait\n", __func__);
+        ret = sem_wait(&suspend_lockout);
+        if (ret < 0) {
+            strerror_r(errno, buf, sizeof(buf));
+            ALOGE("Error waiting on semaphore: %s\n", buf);
+            continue;
+        }
+
+        ALOGV("%s: write %*s to wakeup_count\n", __func__, wakeup_count_len, wakeup_count);
+        ret = TEMP_FAILURE_RETRY(write(wakeup_count_fd, wakeup_count, wakeup_count_len));
+        if (ret < 0) {
+            strerror_r(errno, buf, sizeof(buf));
+            ALOGE("Error writing to %s: %s\n", SYS_POWER_WAKEUP_COUNT, buf);
+        } else {
+            ALOGV("%s: write %s to %s\n", __func__, sleep_state, SYS_POWER_STATE);
+            ret = TEMP_FAILURE_RETRY(write(state_fd, sleep_state, strlen(sleep_state)));
+            if (ret >= 0) {
+                success = true;
+            }
+            void (*func)(bool success) = wakeup_func;
+            if (func != NULL) {
+                (*func)(success);
+            }
+        }
+
+        ALOGV("%s: release sem\n", __func__);
+        ret = sem_post(&suspend_lockout);
+        if (ret < 0) {
+            strerror_r(errno, buf, sizeof(buf));
+            ALOGE("Error releasing semaphore: %s\n", buf);
+        }
+    }
+    return NULL;
+}
+
+static int autosuspend_wakeup_count_enable(void)
+{
+    char buf[80];
+    int ret;
+
+    ALOGV("autosuspend_wakeup_count_enable\n");
+
+    ret = sem_post(&suspend_lockout);
+
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        ALOGE("Error changing semaphore: %s\n", buf);
+    }
+
+    ALOGV("autosuspend_wakeup_count_enable done\n");
+
+    return ret;
+}
+
+static int autosuspend_wakeup_count_disable(void)
+{
+    char buf[80];
+    int ret;
+
+    ALOGV("autosuspend_wakeup_count_disable\n");
+
+    ret = sem_wait(&suspend_lockout);
+
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        ALOGE("Error changing semaphore: %s\n", buf);
+    }
+
+    ALOGV("autosuspend_wakeup_count_disable done\n");
+
+    return ret;
+}
+
+void set_wakeup_callback(void (*func)(bool success))
+{
+    if (wakeup_func != NULL) {
+        ALOGE("Duplicate wakeup callback applied, keeping original");
+        return;
+    }
+    wakeup_func = func;
+}
+
+struct autosuspend_ops autosuspend_wakeup_count_ops = {
+        .enable = autosuspend_wakeup_count_enable,
+        .disable = autosuspend_wakeup_count_disable,
+};
+
+struct autosuspend_ops *autosuspend_wakeup_count_init(void)
+{
+    int ret;
+    char buf[80];
+
+    state_fd = TEMP_FAILURE_RETRY(open(SYS_POWER_STATE, O_RDWR));
+    if (state_fd < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        ALOGE("Error opening %s: %s\n", SYS_POWER_STATE, buf);
+        goto err_open_state;
+    }
+
+    wakeup_count_fd = TEMP_FAILURE_RETRY(open(SYS_POWER_WAKEUP_COUNT, O_RDWR));
+    if (wakeup_count_fd < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        ALOGE("Error opening %s: %s\n", SYS_POWER_WAKEUP_COUNT, buf);
+        goto err_open_wakeup_count;
+    }
+
+    ret = sem_init(&suspend_lockout, 0, 0);
+    if (ret < 0) {
+        strerror_r(errno, buf, sizeof(buf));
+        ALOGE("Error creating semaphore: %s\n", buf);
+        goto err_sem_init;
+    }
+    ret = pthread_create(&suspend_thread, NULL, suspend_thread_func, NULL);
+    if (ret) {
+        strerror_r(ret, buf, sizeof(buf));
+        ALOGE("Error creating thread: %s\n", buf);
+        goto err_pthread_create;
+    }
+
+    ALOGI("Selected wakeup count\n");
+    return &autosuspend_wakeup_count_ops;
+
+err_pthread_create:
+    sem_destroy(&suspend_lockout);
+err_sem_init:
+    close(wakeup_count_fd);
+err_open_wakeup_count:
+    close(state_fd);
+err_open_state:
+    return NULL;
+}
diff --git a/libsuspend/include/suspend/autosuspend.h b/libsuspend/include/suspend/autosuspend.h
index 21f4d61bf..59188a804 100644
--- a/libsuspend/include/suspend/autosuspend.h
+++ b/libsuspend/include/suspend/autosuspend.h
@@ -44,17 +44,6 @@ int autosuspend_enable(void);
  */
 int autosuspend_disable(void);
 
-/*
- * force_suspend
- *
- * Forces suspend to happen.  timeout_ms is used to give system a chance to suspend gracefully.
- * When timeout expires, suspend will be forced via mem --> /sys/power/state.  timeout_ms of 0
- * will force suspend immediately.
- *
- * Returns 0 if system suspended, -1 if suspend did not occur.
- */
-int autosuspend_force_suspend(int timeout_ms);
-
 /*
  * set_wakeup_callback
  *
@@ -62,7 +51,7 @@ int autosuspend_force_suspend(int timeout_ms);
  * success is true if the suspend was sucessful and false if the suspend
  * aborted due to some reason.
  */
-void autosuspend_set_wakeup_callback(void (*func)(bool success));
+void set_wakeup_callback(void (*func)(bool success));
 
 __END_DECLS
 
-- 
2.17.0

