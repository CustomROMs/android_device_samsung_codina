From 72199e982e2403f0e40e931da55659e75e14a3d7 Mon Sep 17 00:00:00 2001
From: Tom Marshall <tdm.code@gmail.com>
Date: Wed, 23 Aug 2017 22:11:03 +0000
Subject: [PATCH 07/44] adb: Look for executables in alternate places

 * Restore global variable recovery_mode.  This is set based on the
   commandline parameter --banner.

 * Use /sbin for path to 'sh' and 'bu' when in recovery mode.

 * Honor persist.sys.adb.shell when not in recovery mode.

Change-Id: I02ac651397021097fe865436c982e2b720d7917f
---
 adb/adb.h                         |  4 ++++
 adb/daemon/main.cpp               |  4 ++++
 adb/daemon/shell_service.cpp      | 24 ++++++++++++++++++++++--
 adb/daemon/shell_service_test.cpp |  2 ++
 adb/services.cpp                  | 15 ++++++++++++---
 5 files changed, 44 insertions(+), 5 deletions(-)

diff --git a/adb/adb.h b/adb/adb.h
index c8841661d..8bc1925f4 100644
--- a/adb/adb.h
+++ b/adb/adb.h
@@ -195,6 +195,10 @@ int local_connect_arbitrary_ports(int console_port, int adb_port, std::string* e
 
 ConnectionState connection_state(atransport* t);
 
+#if !ADB_HOST
+extern int recovery_mode;
+#endif
+
 extern const char* adb_device_banner;
 
 #define CHUNK_SIZE (64 * 1024)
diff --git a/adb/daemon/main.cpp b/adb/daemon/main.cpp
index c02cafab7..37bc0c75b 100644
--- a/adb/daemon/main.cpp
+++ b/adb/daemon/main.cpp
@@ -237,6 +237,8 @@ int adbd_main(int server_port) {
     return 0;
 }
 
+int recovery_mode = 0;
+
 int main(int argc, char** argv) {
     // Set M_DECAY_TIME so that our allocations aren't immediately purged on free.
     mallopt(M_DECAY_TIME, 1);
@@ -271,6 +273,8 @@ int main(int argc, char** argv) {
         }
     }
 
+    recovery_mode = (strcmp(adb_device_banner, "recovery") == 0);
+
     close_stdin();
 
     adb_trace_init(argv);
diff --git a/adb/daemon/shell_service.cpp b/adb/daemon/shell_service.cpp
index 56d647a7b..820f3913c 100644
--- a/adb/daemon/shell_service.cpp
+++ b/adb/daemon/shell_service.cpp
@@ -86,6 +86,7 @@
 #include <pty.h>
 #include <pwd.h>
 #include <sys/select.h>
+#include <sys/stat.h>
 #include <termios.h>
 
 #include <memory>
@@ -107,8 +108,26 @@
 #include "adb_utils.h"
 #include "security_log_tags.h"
 
+#include "cutils/properties.h"
+
 namespace {
 
+static std::string get_sh_path()
+{
+    if (recovery_mode) {
+        return "/sbin/sh";
+    }
+
+    char propbuf[PROPERTY_VALUE_MAX];
+    struct stat st;
+
+    property_get("persist.sys.adb.shell", propbuf, "");
+    if (propbuf[0] && stat(propbuf, &st) == 0) {
+        return propbuf;
+    }
+    return _PATH_BSHELL;
+}
+
 // Reads from |fd| until close or failure.
 std::string ReadAll(int fd) {
     char buffer[512];
@@ -366,9 +385,10 @@ bool Subprocess::ForkAndExec(std::string* error) {
             // Spawn a login shell if we don't have a command.
             execle(_PATH_BSHELL, "-" _PATH_BSHELL, nullptr, cenv.data());
         } else {
-            execle(_PATH_BSHELL, _PATH_BSHELL, "-c", command_.c_str(), nullptr, cenv.data());
+            execle(sh_path.c_str(), sh_path.c_str(), "-c", command_.c_str(), nullptr, cenv.data());
         }
-        WriteFdExactly(child_error_sfd, "exec '" _PATH_BSHELL "' failed: ");
+        std::string errmsg = "exec '" + sh_path + "' failed: ";
+        WriteFdExactly(child_error_sfd, errmsg.c_str());
         WriteFdExactly(child_error_sfd, strerror(errno));
         child_error_sfd.reset(-1);
         _Exit(1);
diff --git a/adb/daemon/shell_service_test.cpp b/adb/daemon/shell_service_test.cpp
index 4e27822d1..8287cd725 100644
--- a/adb/daemon/shell_service_test.cpp
+++ b/adb/daemon/shell_service_test.cpp
@@ -29,6 +29,8 @@
 #include "adb_io.h"
 #include "sysdeps.h"
 
+int recovery_mode = 0;
+
 class ShellServiceTest : public ::testing::Test {
   public:
     static void SetUpTestCase() {
diff --git a/adb/services.cpp b/adb/services.cpp
index a757d9066..0001b006a 100644
--- a/adb/services.cpp
+++ b/adb/services.cpp
@@ -268,6 +268,13 @@ static int create_service_thread(const char* service_name, void (*func)(int, voi
     return s[0];
 }
 
+#if !ADB_HOST
+static const char* bu_path()
+{
+    return (recovery_mode ? "/sbin/bu" : "/system/bin/bu");
+}
+#endif
+
 int service_to_fd(const char* name, atransport* transport) {
     int ret = -1;
 
@@ -304,12 +311,14 @@ int service_to_fd(const char* name, atransport* transport) {
     } else if(!strncmp(name, "unroot:", 7)) {
         ret = create_service_thread("unroot", restart_unroot_service, nullptr);
     } else if(!strncmp(name, "backup:", 7)) {
-        ret = StartSubprocess(android::base::StringPrintf("/system/bin/bu backup %s",
+        ret = StartSubprocess(android::base::StringPrintf("%s backup %s",
+                                                          bu_path(),
                                                           (name + 7)).c_str(),
                               nullptr, SubprocessType::kRaw, SubprocessProtocol::kNone);
     } else if(!strncmp(name, "restore:", 8)) {
-        ret = StartSubprocess("/system/bin/bu restore", nullptr, SubprocessType::kRaw,
-                              SubprocessProtocol::kNone);
+        ret = StartSubprocess(android::base::StringPrintf("%s restore",
+                                                         bu_path()).c_str(),
+                              nullptr, SubprocessType::kRaw, SubprocessProtocol::kNone);
     } else if(!strncmp(name, "tcpip:", 6)) {
         int port;
         if (sscanf(name + 6, "%d", &port) != 1) {
-- 
2.17.0

